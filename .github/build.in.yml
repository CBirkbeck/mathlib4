### NB: This is the master file for autogenerating
### NB: `.github/workflows/{bors, build_fork, build}.yml`.
### NB: If you need to edit any of those files, you should edit this file instead,
### NB: and regenerate those files by manually running
### NB: .github/workflows/mk_build_yml.sh

env:
  # Disable Lake's automatic fetching of cloud builds.
  # Lake's cache is currently incompatible with Mathlib's `lake exe cache`.
  # This is because Mathlib's Cache assumes all build aritfacts present in the build directory
  # are valid by-products of the Mathlib build. Build artifacts fetched from Lake's cache do
  # not necessarily satisfy this property.
  LAKE_NO_CACHE: true

concurrency:
  # label each workflow run; only the latest with each label will run
  # workflows on master get more expressive labels
  group: ${{ github.workflow }}-${{ github.ref }}.${{(github.ref == 'refs/heads/master' && github.run_id) || ''}}
  # cancel any running workflow with the same label
  cancel-in-progress: true

jobs:
  style_lint:
    if: github.repository MAIN_OR_FORK 'leanprover-community/mathlib4'
    name: Lint styleJOB_NAME
    runs-on: STYLE_LINT_RUNNER
    steps:
      - name: cleanup
        run: |
          find . -name . -o -prune -exec rm -rf -- {} +

      - uses: actions/checkout@v4

      # Run the case checker action
      - name: Check Case Sensitivity
        uses: credfeto/action-case-checker@v1.3.0

      - name: Look for ignored files
        uses: credfeto/action-no-ignored-files@v1.2.0

      - name: "Check for Lean files with the executable bit set"
        shell: bash
        run: |
          executable_files="$(find . -name '*.lean' -type f \( -perm -u=x -o -perm -g=x -o -perm -o=x \))"
          if [[ -n "$executable_files" ]]
          then
            echo "ERROR: The following Lean files have the executable bit set."
            echo "$executable_files"
            exit 1
          fi

      - name: install Python
        if: ${{ 'STYLE_LINT_RUNNER' == 'ubuntu-latest' }}
        uses: actions/setup-python@v5
        with:
          python-version: 3.8

      - name: install elan
        run: |
          set -o pipefail
          curl -sSfL https://github.com/leanprover/elan/releases/download/v3.1.1/elan-x86_64-unknown-linux-gnu.tar.gz | tar xz
          ./elan-init -y --default-toolchain none
          echo "$HOME/.elan/bin" >> "${GITHUB_PATH}"

      - name: "run style linters"
        run: |
          lake exe lint-style

      - name: Install bibtool
        if: ${{ 'STYLE_LINT_RUNNER' == 'ubuntu-latest' }}
        run: |
          sudo apt-get update
          sudo apt-get install -y bibtool

      - name: lint references.bib
        run: |
          ./scripts/lint-bib.sh

  build:
    if: github.repository MAIN_OR_FORK 'leanprover-community/mathlib4'
    name: BuildJOB_NAME
    runs-on: RUNS_ON
    defaults:
      run:
        shell: bwrap --ro-bind $(pwd)/pr-branch $(pwd)/pr-branch --tmpfs $(pwd)/pr-branch/.lake --dev-bind / / bash -euxo pipefail {0}
    env:
      # Command to execute `cache` from the master branch
      CACHE_CMD: ../master-branch/.lake/build/bin/cache

    steps:
      - name: Install bubblewrap
        # This step needs network access, so we reset the shell (also, `bwrap` is not yet installed)
        shell: bash -euxo pipefail {0}
        run: |
          sudo apt-get update
          sudo apt-get install -y bubblewrap

      - name: cleanup
        run: |
          find . -name . -o -prune -exec rm -rf -- {} +
          # Delete all but the 5 most recent toolchains.
          # Make sure to delete both the `~/.elan/toolchains/X` directory and the `~/.elan/update-hashes/X` file.
          # Skip symbolic links (`-type d`), the current directory (`! -name .`), and `nightly` and `stable`.
          if cd ~/.elan/toolchains && find . -maxdepth 1 -type d ! -name . -print0 | xargs -0 ls -1td | grep -v 'nightly$' | grep -v 'stable$' | tail -n +6 | xargs -I {} sh -c 'echo {} && rm -rf "{}" && rm "../update-hashes/{}"'; then
              : # Do nothing on success
          else
              : # Do nothing on failure, but suppress errors
          fi

      # The Hoskinson runners may not have jq installed, so do that now.
      - name: 'Setup jq'
        uses: dcarbone/install-jq-action@v2.1.0

      - name: install elan
        # This step needs network access, so we reset the shell
        shell: bash -euxo pipefail {0}
        run: |
          set -o pipefail
          curl -sSfL https://github.com/leanprover/elan/releases/download/v3.1.1/elan-x86_64-unknown-linux-gnu.tar.gz | tar xz
          ./elan-init -y --default-toolchain none
          echo "$HOME/.elan/bin" >> "${GITHUB_PATH}"

      # Checkout the master branch into a subdirectory
      - name: Checkout master branch
        uses: actions/checkout@v4
        with:
          ref: master
          path: master-branch

      - name: print lean and lake versions (master)
        run: |
          cd master-branch
          lean --version
          lake --version

      - name: build cache
        shell: bash -euxo pipefail {0}
        run: |
          cd master-branch
          lake build cache

      # Checkout the PR branch into a subdirectory
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          path: pr-branch

      - name: If using a lean-pr-release toolchain, reinstall
        # This step needs network access, so we reset the shell
        shell: bash -euxo pipefail {0}
        run: |
          cd pr-branch
          if [[ $(cat lean-toolchain) =~ ^leanprover/lean4-pr-releases:pr-release-[0-9]+$ ]]; then
            printf 'Uninstalling transient toolchain %s\n' "$(cat lean-toolchain)"
            elan toolchain uninstall "$(cat lean-toolchain)"
            elan toolchain install "$(cat lean-toolchain)"
          fi

      - name: get cache
        # This step needs network access, so we reset the shell
        shell: bash -euxo pipefail {0}
        id: get
        run: |
          cd pr-branch
          rm -rf .lake/build/lib/Mathlib/
          # Define the bwrap command with the necessary options
          # Fail quickly if the cache is completely cold, by checking for Mathlib.Init
          $CACHE_CMD get Mathlib.Init
          # WARNING: Here we run `lake` outside the sandbox
          lake build --no-build Mathlib.Init && $CACHE_CMD get || echo "No cache for 'Mathlib.Init' available"

      - name: print lean and lake versions (pr)
        run: |
          cd pr-branch
          lean --version
          lake --version

      - name: update {Mathlib, Tactic, Counterexamples, Archive}.lean
        id: mk_all
        run: |
          cd pr-branch
          if ! lake exe mk_all --check
          then
            echo "Not all lean files are in the import all files"
            echo "mk_all=false" >> "${GITHUB_OUTPUT}"
          else
            echo "mk_all=true" >> "${GITHUB_OUTPUT}"
          fi

      - name: build mathlib
        id: build
        uses: liskin/gh-problem-matcher-wrap@v3
        with:
          linters: gcc
          run: |
            cd pr-branch
            bash -o pipefail -c "env LEAN_ABORT_ON_PANIC=1 lake build --wfail -KCI"

      - name: print the sizes of the oleans
        run: |
          cd pr-branch
          du .lake/build/lib/Mathlib || echo "This code should be unreachable"

      - name: upload mathlib cache
        # This step needs network access, so we reset the shell
        shell: bash -euxo pipefail {0}
        # We only upload the cache if the build started (whether succeeding, failing, or cancelled)
        # but not if any earlier step failed or was cancelled.
        # See discussion at https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Some.20files.20not.20found.20in.20the.20cache/near/407183836
        if: ${{ always() && steps.get.outcome == 'success' }}
        run: |
          cd pr-branch
          # TODO: this is not doing anything currently, and needs to be integrated with put-unpacked
          # $CACHE_CMD commit || true
          # run this in CI if it gets an incorrect lake hash for existing cache files somehow
          # $CACHE_CMD put!
          # do not try to upload files just downloaded
          #
          # IMPORTANT: use `lake exe cache` from master-branch here: $CACHE_CMD
          $CACHE_CMD put-unpacked
        env:
          MATHLIB_CACHE_SAS: ${{ secrets.MATHLIB_CACHE_SAS }}
          MATHLIB_CACHE_S3_TOKEN: ${{ secrets.MATHLIB_CACHE_S3_TOKEN }}

      - name: check the cache
        # This step needs network access, so we reset the shell
        shell: bash -euxo pipefail {0}
        run: |
          cd pr-branch
          # Because the `lean-pr-testing-NNNN` branches use toolchains that are "updated in place"
          # the cache mechanism is unreliable, so we don't test it if we are on such a branch.
          if [[ ! $(cat lean-toolchain) =~ ^leanprover/lean4-pr-releases:pr-release-[0-9]+$ ]]; then
            $CACHE_CMD clean!
            rm -rf .lake/build/lib/Mathlib
            $CACHE_CMD get || (sleep 1; $CACHE_CMD get)
            # WARNING: Here we run `lake` outside the sandbox
            lake build --no-build
          fi

      - name: get archive cache
        # This step needs network access, so we reset the shell
        shell: bash -euxo pipefail {0}
        id: archive
        run: |
          cd pr-branch
          # Note: we should not be including `Archive` and `Counterexamples` in the cache.
          # We do this for now for the sake of not rebuilding them in every CI run
          # even when they are not touched.
          # Since `Archive` and `Counterexamples` files have very simple dependencies,
          # it should be possible to determine whether they need to be built without actually
          # storing and transferring oleans over the network.
          # Hopefully a future re-implementation of `cache` will obviate the present need for this hack.
          $CACHE_CMD get Archive.lean

      - name: build archive
        id: archive
        run: |
          cd pr-branch
          bash -o pipefail -c "env LEAN_ABORT_ON_PANIC=1 lake build Archive"

      - name: upload archive cache
        # This step needs network access, so we reset the shell
        shell: bash -euxo pipefail {0}
        run:
          cd pr-branch
          # IMPORTANT: use `lake exe cache` from master-branch here: $CACHE_CMD
          $CACHE_CMD put Archive.lean
        env:
          MATHLIB_CACHE_SAS: ${{ secrets.MATHLIB_CACHE_SAS }}
          MATHLIB_CACHE_S3_TOKEN: ${{ secrets.MATHLIB_CACHE_S3_TOKEN }}

      - name: get counterexamples cache
        # This step needs network access, so we reset the shell
        shell: bash -euxo pipefail {0}
        id: counterexamples
        run: |
          cd pr-branch
          $CACHE_CMD get Counterexamples.lean

      - name: build counterexamples
        id: counterexamples
        run: |
          cd pr-branch
          bash -o pipefail -c "env LEAN_ABORT_ON_PANIC=1 lake build Counterexamples"

      - name: upload counterexamples cache
        run:
          cd pr-branch
          # IMPORTANT: use `lake exe cache` from master-branch here: $CACHE_CMD
          $CACHE_CMD put Counterexamples.lean
        env:
          MATHLIB_CACHE_SAS: ${{ secrets.MATHLIB_CACHE_SAS }}
          MATHLIB_CACHE_S3_TOKEN: ${{ secrets.MATHLIB_CACHE_S3_TOKEN }}

      - name: Check {Mathlib, Tactic, Counterexamples, Archive}.lean
        run: |
          cd pr-branch
          if [ ${{ steps.mk_all.outputs.mk_all }} == "false" ]
          then
            echo "Please run 'lake exe mk_all' to regenerate the import all files"
            exit 1
          fi

      - name: check for noisy stdout lines
        id: noisy
        run: |
          cd pr-branch
          buildMsgs="$(
            ##  we exploit `lake`s replay feature: since the cache is present, running
            ##  `lake build` will reproduce all the outputs without having to recompute
            lake build Mathlib Archive Counterexamples |
            ##  we filter out the output lines that begin with `✔ [xx/yy]`, where xx, yy
            ##  are either numbers or ?, and the "Build completed successfully." message.
            ##  We keep the rest, which are actual outputs of the files
            awk '!($0 ~ "^\\s*✔ \\[[?0-9]*/[?0-9]*\\]" || $0 == "Build completed successfully."){ print $0 }')"
          if [ -n "${buildMsgs}" ]
          then
            printf $'%s\n' "${buildMsgs}"
            exit 1
          fi

      - name: check declarations in db files
        run: |
          cd pr-branch
          python3 scripts/yaml_check.py docs/100.yaml docs/1000.yaml docs/overview.yaml docs/undergrad.yaml
          lake exe check-yaml

      - name: generate our import graph
        run: |
          cd pr-branch
          lake exe graph

      - name: upload the import graph
        uses: actions/upload-artifact@v4
        with:
          name: import-graph
          path: pr-branch/import_graph.dot
          ## the default is 90, but we build often, so unless there's a reason
          ## to care about old copies in the future, just say 7 days for now
          retention-days: 7

      - name: clean up the import graph file
        run: rm pr-branch/import_graph.dot

      - name: build everything
        # make sure everything is available for test/import_all.lean
        run: |
          cd pr-branch
          lake build Batteries Qq Aesop ProofWidgets Plausible

      - name: test mathlib
        id: test
        uses: liskin/gh-problem-matcher-wrap@v3
        with:
          linters: gcc
          run: |
            cd pr-branch
            lake --iofail test

      - name: check for unused imports
        id: shake
        uses: liskin/gh-problem-matcher-wrap@v3
        with:
          linters: gcc
          run: |
            cd pr-branch
            env LEAN_ABORT_ON_PANIC=1 lake exe shake --gh-style

      - name: lint mathlib
        if: ${{ always() && steps.build.outcome == 'success' || steps.build.outcome == 'failure' }}
        id: lint
        uses: liskin/gh-problem-matcher-wrap@v3
        with:
          linters: gcc
          run: |
            cd pr-branch
            env LEAN_ABORT_ON_PANIC=1 lake exe runLinter Mathlib

      # We no longer run `lean4checker` in regular CI, as it is quite expensive for little benefit.
      # Instead we run it in a cron job on master: see `lean4checker.yml`.
      # Output is posted to the zulip topic
      # https://leanprover.zulipchat.com/#narrow/stream/345428-mathlib-reviewers/topic/lean4checker

      - name: Post comments for lean-pr-testing-NNNN and batteries-pr-testing-NNNN branches
        if: always()
        env:
          TOKEN: ${{ secrets.LEAN_PR_TESTING }}
          GITHUB_CONTEXT: ${{ toJson(github) }}
          WORKFLOW_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          BUILD_OUTCOME: ${{ steps.build.outcome }}
          NOISY_OUTCOME: ${{ steps.noisy.outcome }}
          ARCHIVE_OUTCOME: ${{ steps.archive.outcome }}
          COUNTEREXAMPLES_OUTCOME: ${{ steps.counterexamples.outcome }}
          LINT_OUTCOME: ${{ steps.lint.outcome }}
          TEST_OUTCOME: ${{ steps.test.outcome }}
        # This step needs network access, so we reset the shell
        shell: bash -euxo pipefail {0}
        run: |
          cd master-branch
          # Run these scripts from the master branch, the only use the env vars above, not the repo contents
          scripts/lean-pr-testing-comments.sh lean
          scripts/lean-pr-testing-comments.sh batteries

      - name: clone lean4checker, but don't run it
        if: ${{ (always() && steps.build.outcome == 'success' || steps.build.outcome == 'failure') && contains(github.event.pull_request.changed_files, 'lean-toolchain') }}
        # This step needs network access, so we reset the shell
        shell: bash -euxo pipefail {0}
        run: |
          cd pr-branch
          git clone https://github.com/leanprover/lean4checker

      - name: build lean4checker, but don't run it
        if: ${{ (always() && steps.build.outcome == 'success' || steps.build.outcome == 'failure') && contains(github.event.pull_request.changed_files, 'lean-toolchain') }}
        run: |
          cd pr-branch/lean4checker
          # Read lean-toolchain file and checkout appropriate branch
          TOOLCHAIN=$(cat ../lean-toolchain)
          if [[ "$TOOLCHAIN" =~ ^leanprover/lean4:v ]]; then
            VERSION=${TOOLCHAIN#leanprover/lean4:}
            git checkout "$VERSION"
          else
            git checkout master
          fi
          # Build lean4checker using the same toolchain
          cp ../lean-toolchain .
          lake build

  final:
    name: Post-CI jobJOB_NAME
    if: github.repository MAIN_OR_FORK 'leanprover-community/mathlib4'
    needs: [style_lint, build]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - id: PR
        uses: 8BitJonny/gh-get-current-pr@3.0.0
        # TODO: this may not work properly if the same commit is pushed to multiple branches:
        # https://github.com/8BitJonny/gh-get-current-pr/issues/8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          # Only return if PR is still open
          filterOutClosed: true

      - id: remove_labels
        name: Remove "awaiting-CI"
        # we use curl rather than octokit/request-action so that the job won't fail
        # (and send an annoying email) if the labels don't exist
        run: |
          curl --request DELETE \
            --url https://api.github.com/repos/${{ github.repository }}/issues/${{ steps.PR.outputs.number }}/labels/awaiting-CI \
            --header 'authorization: Bearer ${{ secrets.GITHUB_TOKEN }}'

      - if: contains(steps.PR.outputs.pr_labels, 'auto-merge-after-CI')
        name: If `auto-merge-after-CI` is present, add a `bors merge` comment.
        uses: GrantBirki/comment@v2
        with:
          token: ${{ secrets.AUTO_MERGE_TOKEN }}
          issue-number: ${{ steps.PR.outputs.number }}
          body: |
            As this PR is labelled `auto-merge-after-CI`, we are now sending it to bors:

            bors merge
