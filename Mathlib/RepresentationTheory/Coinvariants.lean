/-
Copyright (c) 2025 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston
-/
import Mathlib.Algebra.Homology.ShortComplex.ModuleCat
import Mathlib.RepresentationTheory.Rep

/-!
# Coinvariants a group representation

Given a commutative ring `k` and a monoid `G`, this file introduces the coinvariants of a
`k`-linear `G`-representation `(V, ρ)`.

We first define `Representation.augmentationSubmodule`, the submodule of `V` generated by elements
of the form `ρ g x - x` for `x : V`, `g : G`. Then the coinvariants of `(V, ρ)` are the quotient of
`V` by this submodule. We show that the functor sending a representation to its coinvariants is
left adjoint to the functor equipping a module with the trivial representation.

-/

universe u v

namespace Representation

variable {k G V W : Type*} [CommRing k] [Monoid G] [AddCommGroup V] [Module k V]
  [AddCommGroup W] [Module k W] (ρ : Representation k G V)

/-- The submodule of a representation generated by elements of the form `ρ g x - x`. -/
abbrev augmentationSubmodule : Submodule k V :=
  Submodule.span k (Set.range fun (x : G × V) => ρ x.1 x.2 - x.2)

variable {ρ}

lemma mem_augmentationSubmodule_of_eq (g : G) (x : V) (a : V) (h : ρ g x - x = a) :
    a ∈ augmentationSubmodule ρ :=
  Submodule.subset_span ⟨(g, x), h⟩

variable (ρ)

/-- The coinvariants of a representation, `V ⧸ ⟨{ρ g x - x | g ∈ G, x ∈ V}⟩`. -/
abbrev coinvariants := V ⧸ augmentationSubmodule ρ

/-- The quotient map from a representation to its coinvariants as a linear map. -/
abbrev coinvariantsMkQ := Submodule.mkQ (augmentationSubmodule ρ)

/-- A `G`-invariant linear map induces a linear map out of the coinvariants of a
`G`-representation. -/
def coinvariantsLift (f : V →ₗ[k] W) (h : ∀ (x : G), f ∘ₗ ρ x = f) :
    ρ.coinvariants →ₗ[k] W :=
  Submodule.liftQ _ f <| Submodule.span_le.2 fun x ⟨⟨g, y⟩, hy⟩ => by
    simpa only [← hy, SetLike.mem_coe, LinearMap.mem_ker, map_sub, sub_eq_zero, LinearMap.coe_comp,
      Function.comp_apply] using LinearMap.ext_iff.1 (h g) y

@[simp]
theorem coinvariantsLift_comp_mkQ (f : V →ₗ[k] W) (h : ∀ (x : G), f ∘ₗ ρ x = f) :
  coinvariantsLift ρ f h ∘ₗ (augmentationSubmodule ρ).mkQ = f := rfl

@[simp]
theorem coinvariantsLift_mk (f : V →ₗ[k] W) (h : ∀ (x : G), f ∘ₗ ρ x = f) (x : V) :
  coinvariantsLift ρ f h (Submodule.Quotient.mk x) = f x := rfl

section

variable {k G V : Type*} [CommRing k] [Group G] [AddCommGroup V] [Module k V]
variable (ρ : Representation k G V) (S : Subgroup G) [S.Normal]

lemma le_comap_augmentationSubmodule (g : G) :
    augmentationSubmodule (ρ.comp S.subtype) ≤
      (augmentationSubmodule <| ρ.comp S.subtype).comap (ρ g) :=
  Submodule.span_le.2 fun _ ⟨⟨s, x⟩, hs⟩ => by
    simpa [← hs] using mem_augmentationSubmodule_of_eq
      ⟨g * s * g⁻¹, Subgroup.Normal.conj_mem ‹_› s.1 s.2 g⟩ (ρ g x) _ <| by simp

/-- Given a normal subgroup `S ≤ G`, a `G`-representation `ρ` restricts to a `G`-representation on
the augmentation submodule of `ρ|_S`. -/
noncomputable abbrev toAugmentationSubmodule :
    Representation k G (augmentationSubmodule <| ρ.comp S.subtype) :=
  subrepresentation ρ (augmentationSubmodule <| ρ.comp S.subtype)
    fun g => le_comap_augmentationSubmodule ρ S g

/-- Given a normal subgroup `S ≤ G`, a `G`-representation `ρ` induces a `G`-representation on the
coinvariants of `ρ|_S`. -/
noncomputable abbrev toCoinvariants :
    Representation k G (coinvariants <| ρ.comp S.subtype) :=
  quotient ρ (augmentationSubmodule <| ρ.comp S.subtype)
    fun g => le_comap_augmentationSubmodule ρ S g

instance : IsTrivial ((toCoinvariants ρ S).comp S.subtype) where
  out g := Submodule.linearMap_qext _ <| by
    ext x
    simpa [Submodule.Quotient.eq] using mem_augmentationSubmodule_of_eq g x _ rfl

/-- Given a normal subgroup `S ≤ G`, a `G`-representation `ρ` induces a `G ⧸ S`-representation on
the coinvariants of `ρ|_S`. -/
noncomputable abbrev quotientToCoinvariants :
    Representation k (G ⧸ S) (coinvariants (ρ.comp S.subtype)) :=
  ofQuotient (toCoinvariants ρ S) S

end
end Representation

namespace Rep

variable {k G : Type u} [CommRing k] [Monoid G]
  {A B C : Rep k G} {n : ℕ}

open Representation CategoryTheory

/-- The linear map underlying a `G`-representation morphism `A ⟶ B`, where `B` has the trivial
representation, factors through `A_G`. -/
noncomputable abbrev coinvariantsLift [B.ρ.IsTrivial] (f : A ⟶ B) :
    coinvariants A.ρ →ₗ[k] B :=
  Representation.coinvariantsLift _ f.hom.hom fun _ => by
    ext
    have := hom_comm_apply f
    simp_all

/-- A `G`-representation morphism `A ⟶ B` induces a linear map `A_G →ₗ[k] B_G`. -/
noncomputable abbrev coinvariantsMap (f : A ⟶ B) :
    coinvariants A.ρ →ₗ[k] coinvariants B.ρ :=
  Representation.coinvariantsLift _ (Submodule.mkQ _ ∘ₗ f.hom.hom) fun g => LinearMap.ext fun x =>
    (Submodule.Quotient.eq _).2 <| mem_augmentationSubmodule_of_eq g (f.hom x) _ <| by
      simpa using (hom_comm_apply f g x).symm

@[simp]
theorem coinvariantsMap_comp_mkQ (f : A ⟶ B) :
    coinvariantsMap f ∘ₗ coinvariantsMkQ A.ρ = coinvariantsMkQ B.ρ ∘ₗ f.hom.hom := rfl

@[simp]
theorem coinvariantsMap_mk (f : A ⟶ B) (x : A) :
    coinvariantsMap f (Submodule.Quotient.mk x) = Submodule.Quotient.mk (f.hom x) := rfl

@[simp]
theorem coinvariantsMap_id (A : Rep k G) :
    coinvariantsMap (𝟙 A) = LinearMap.id := by
  ext; rfl

@[simp]
theorem coinvariantsMap_comp (f : A ⟶ B) (g : B ⟶ C) :
    coinvariantsMap (f ≫ g) = coinvariantsMap g ∘ₗ coinvariantsMap f := by
  ext; rfl

noncomputable section

variable {k G : Type u} [CommRing k] [Group G] (A : Rep k G) (S : Subgroup G) [S.Normal]

/-- Given a normal subgroup `S ≤ G`, a `G`-representation `ρ` restricts to a `G`-representation on
the augmentation submodule of `ρ|_S`. -/
abbrev toAugmentationSubmodule : Rep k G := Rep.of (A.ρ.toAugmentationSubmodule S)

/-- Given a normal subgroup `S ≤ G`, a `G`-representation `ρ` induces a `G`-representation on the
coinvariants of `ρ|_S`. -/
abbrev toCoinvariants : Rep k G := Rep.of (A.ρ.toCoinvariants S)

/-- Given a normal subgroup `S ≤ G`, a `G`-representation `A` induces a short exact sequence of
`G`-representations `0 ⟶ I(S)A ⟶ A ⟶ A_S ⟶ 0` where `I(S)A` is the submodule of `A`
generated by elements of the form `ρ(s)(x) - x` for `s : S, x : A`. -/
@[simps X₁ X₂ X₃ f g]
def coinvariantsShortComplex : ShortComplex (Rep k G) where
  X₁ := toAugmentationSubmodule A S
  X₂ := A
  X₃ := toCoinvariants A S
  f := subtype ..
  g := mkQ ..
  zero := by ext x; exact (Submodule.Quotient.mk_eq_zero _).2 x.2

lemma coinvariantsShortComplex_shortExact : (coinvariantsShortComplex A S).ShortExact where
  exact := (forget₂ _ (ModuleCat k)).reflects_exact_of_faithful _ <|
    (ShortComplex.moduleCat_exact_iff _).2
      fun x hx => ⟨(⟨x, (Submodule.Quotient.mk_eq_zero _).1 hx⟩ :
      Representation.augmentationSubmodule <| A.ρ.comp S.subtype), rfl⟩
  mono_f := (Rep.mono_iff_injective _).2 fun _ _ h => Subtype.ext h
  epi_g := (Rep.epi_iff_surjective _).2 <| Submodule.mkQ_surjective _

/-- Given a normal subgroup `S ≤ G`, a `G`-representation `ρ` induces a `G ⧸ S`-representation on
the coinvariants of `ρ|_S`. -/
abbrev quotientToCoinvariants : Rep k (G ⧸ S) := ofQuotient (toCoinvariants A S) S

end

variable (k G)

/-- The functor sending a representation to its coinvariants. -/
@[simps]
noncomputable def coinvariantsFunctor : Rep k G ⥤ ModuleCat k where
  obj A := ModuleCat.of k (A.ρ.coinvariants)
  map f := ModuleCat.ofHom (coinvariantsMap f)

instance : (coinvariantsFunctor k G).Additive where
  map_add := ModuleCat.hom_ext <| LinearMap.ext fun x => Quotient.inductionOn' x (fun _ => rfl)

/-- The adjunction between the functor sending a representation to its coinvariants and the functor
equipping a module with the trivial representation. -/
noncomputable def coinvariantsAdjunction : coinvariantsFunctor k G ⊣ trivialFunctor G :=
  Adjunction.mkOfHomEquiv {
    homEquiv := fun X Y => {
      toFun := fun f => {
        hom := ModuleCat.ofHom (f.hom ∘ₗ X.ρ.augmentationSubmodule.mkQ)
        comm := fun g => by
          ext x
          exact congr(f.hom $((Submodule.Quotient.eq <| X.ρ.augmentationSubmodule).2
            (X.ρ.mem_augmentationSubmodule_of_eq g x _ rfl))) }
      invFun := fun f => ModuleCat.ofHom (coinvariantsLift f)
      left_inv := fun _ => ModuleCat.hom_ext <| Submodule.linearMap_qext _ rfl
      right_inv := fun _ => Action.Hom.ext <| rfl }
    homEquiv_naturality_left_symm := fun _ _ => ModuleCat.hom_ext <| Submodule.linearMap_qext _ rfl
    homEquiv_naturality_right := by intros; rfl }

instance : (coinvariantsFunctor k G).PreservesZeroMorphisms where
  map_zero _ _ := ModuleCat.hom_ext <| Submodule.linearMap_qext _ rfl

instance : Limits.PreservesColimits (coinvariantsFunctor k G) :=
  (coinvariantsAdjunction k G).leftAdjoint_preservesColimits

end Rep
