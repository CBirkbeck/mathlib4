/-
Copyright (c) 2025 Amelia Livingston. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston
-/
import Mathlib.RepresentationTheory.Rep

/-!
# Coinvariants a group representation

Given a commutative ring `k` and a monoid `G`, this file introduces the coinvariants of a
`k`-linear `G`-representation `(V, ρ)`.

We first define `Representation.augmentationSubmodule`, the submodule of `V` generated by elements
of the form `ρ g x - x` for `x : V`, `g : G`. Then the coinvariants of `(V, ρ)` are the quotient of
`V` by this submodule.

## Main definitions

* `Representation.coinvariants ρ`: the coinvariants of a representation `ρ`.
* `Representation.coinvariantsFinsuppLEquiv ρ α`: given a type `α`, this is the `k`-linear
equivalence between `(α →₀ V)_G` and `α →₀ V_G`.
* `Representation.coinvariantsTprodLeftRegularLEquiv ρ`: the `k`-linear equivalence between
`(V ⊗ k[G])_G` and `V` sending `⟦v ⊗ single g r⟧ ↦ r • ρ(g⁻¹)(v)`.
* `Rep.coinvariantsAdjunction k G`: the adjunction between the functor sending a representation to
its coinvariants and the functor equipping a module with the trivial representation.
* `Rep.coinvariantsTensor k G`: the functor sending representations `A, B` to `(A ⊗[k] B)_G`. This
is naturally isomorphic to the functor sending `A, B` to `A ⊗[k[G]] B`, where we give `A` the
`k[G]ᵐᵒᵖ`-module structure defined by `g • a := A.ρ g⁻¹ a`.
* `Rep.coinvariantsTensorFreeLEquiv A α`: given a representation `A` and a type `α`, this is the
`k`-linear equivalence between `(A ⊗ (α →₀ k[G]))_G` and `α →₀ A` sending
`⟦a ⊗ single x (single g r)⟧ ↦ single x (r • ρ(g⁻¹)(a))`. This is useful for group homology.

-/

universe u v

namespace Representation

section

variable {k G V W : Type*} [CommRing k] [Monoid G] [AddCommGroup V] [Module k V]
  [AddCommGroup W] [Module k W] (ρ : Representation k G V) (τ : Representation k G W)

/-- The submodule of a representation generated by elements of the form `ρ g x - x`. -/
def augmentationSubmodule : Submodule k V :=
  Submodule.span k (Set.range fun (x : G × V) => ρ x.1 x.2 - x.2)

variable {ρ}

lemma mem_augmentationSubmodule_of_eq (g : G) (x : V) (a : V) (h : ρ g x - x = a) :
    a ∈ augmentationSubmodule ρ :=
  Submodule.subset_span ⟨(g, x), h⟩

variable (ρ)

@[simp]
theorem augmentationSubmodule_eq_bot_of_isTrivial [ρ.IsTrivial] :
    augmentationSubmodule ρ = ⊥ := by
  rw [augmentationSubmodule, Submodule.span_eq_bot]
  rintro x ⟨⟨g, y⟩, rfl⟩
  simp

/-- The coinvariants of a representation, `V ⧸ ⟨{ρ g x - x | g ∈ G, x ∈ V}⟩`. -/
def coinvariants := V ⧸ augmentationSubmodule ρ

instance : AddCommGroup (coinvariants ρ) := by unfold coinvariants; infer_instance

instance : Module k (coinvariants ρ) := by unfold coinvariants; infer_instance

/-- The quotient map from a representation to its coinvariants as a linear map. -/
def coinvariantsMk : V →ₗ[k] coinvariants ρ := Submodule.mkQ (augmentationSubmodule ρ)

theorem coinvariantsMk_eq_iff {x y : V} :
    coinvariantsMk ρ x = coinvariantsMk ρ y ↔ x - y ∈ ρ.augmentationSubmodule :=
  Submodule.Quotient.eq _

@[simp]
lemma coinvariantsMk_ρ_apply (g : G) (x : V) :
    coinvariantsMk ρ (ρ g x) = coinvariantsMk ρ x :=
  (coinvariantsMk_eq_iff _).2 <| mem_augmentationSubmodule_of_eq g x _ rfl

@[elab_as_elim]
theorem coinvariants.induction_on {C : coinvariants ρ → Prop} (x : coinvariants ρ)
    (h : ∀ v : V, C (coinvariantsMk ρ v)) : C x :=
  Submodule.Quotient.induction_on _ x h

/-- A `G`-invariant linear map induces a linear map out of the coinvariants of a
`G`-representation. -/
def coinvariantsLift (f : V →ₗ[k] W) (h : ∀ (x : G), f ∘ₗ ρ x = f) :
    ρ.coinvariants →ₗ[k] W :=
  Submodule.liftQ _ f <| Submodule.span_le.2 fun x ⟨⟨g, y⟩, hy⟩ => by
    simpa only [← hy, SetLike.mem_coe, LinearMap.mem_ker, map_sub, sub_eq_zero, LinearMap.coe_comp,
      Function.comp_apply] using LinearMap.ext_iff.1 (h g) y

variable {ρ}

@[simp]
theorem coinvariantsLift_comp_mk (f : V →ₗ[k] W) (h : ∀ (x : G), f ∘ₗ ρ x = f) :
  coinvariantsLift ρ f h ∘ₗ coinvariantsMk ρ = f := rfl

@[simp]
theorem coinvariantsLift_mk (f : V →ₗ[k] W) (h : ∀ (x : G), f ∘ₗ ρ x = f) (x : V) :
  coinvariantsLift ρ f h (coinvariantsMk _ x) = f x := rfl

@[ext]
lemma coinvariants_hom_ext {f g : coinvariants ρ →ₗ[k] W}
    (H : f ∘ₗ coinvariantsMk ρ = g ∘ₗ coinvariantsMk ρ) : f = g :=
  Submodule.linearMap_qext _ H

variable (ρ)

noncomputable def coinvariantsMap (f : V →ₗ[k] W) (hf : ∀ g, f ∘ₗ ρ g = τ g ∘ₗ f) :
    coinvariants ρ →ₗ[k] coinvariants τ :=
  coinvariantsLift _ (coinvariantsMk _ ∘ₗ f) fun g => LinearMap.ext fun x =>
    (coinvariantsMk_eq_iff _).2 <| mem_augmentationSubmodule_of_eq (ρ := τ) g (f x) _ <| by
      simpa using congr($((hf g).symm) x)

variable {ρ τ}

@[simp]
lemma coinvariantsMap_comp_mk {f : V →ₗ[k] W} {hf : ∀ g, f ∘ₗ ρ g = τ g ∘ₗ f} :
    coinvariantsMap ρ τ f hf ∘ₗ coinvariantsMk ρ = coinvariantsMk τ ∘ₗ f := rfl

@[simp]
lemma coinvariantsMap_mk (f : V →ₗ[k] W) (hf : ∀ g, f ∘ₗ ρ g = τ g ∘ₗ f) (x : V) :
    coinvariantsMap ρ τ f hf (coinvariantsMk _ x) = coinvariantsMk _ (f x) := rfl

end
section Finsupp

open Finsupp

variable {k G V : Type*} [CommRing k] [Group G] [AddCommGroup V] [Module k V]
  (ρ : Representation k G V) (α : Type*)

/-- Given a `G`-representation `(V, ρ)` and a type `α`, this is the map `(α →₀ V)_G →ₗ (α →₀ V_G)`
sending `⟦single a v⟧ ↦ single a ⟦v⟧`. -/
noncomputable def coinvariantsToFinsupp :
    coinvariants (ρ.finsupp α) →ₗ[k] α →₀ coinvariants ρ :=
  coinvariantsLift _ (mapRange.linearMap (coinvariantsMk _)) <| fun g => by ext; simp

variable {ρ α}

@[simp]
lemma coinvariantsToFinsupp_mk_single (x : α) (a : V) :
    coinvariantsToFinsupp ρ α (coinvariantsMk _ (single x a)) =
      single x (coinvariantsMk _ a) := by
  simp [coinvariantsToFinsupp]

variable (ρ α) in
/-- Given a `G`-representation `(V, ρ)` and a type `α`, this is the map `(α →₀ V_G) →ₗ (α →₀ V)_G`
sending `single a ⟦v⟧ ↦ ⟦single a v⟧`. -/
noncomputable def finsuppToCoinvariants :
    (α →₀ coinvariants ρ) →ₗ[k] coinvariants (ρ.finsupp α) :=
  lsum (R := k) k fun a => coinvariantsLift _ (coinvariantsMk _ ∘ₗ lsingle a) fun g =>
    LinearMap.ext fun x => (coinvariantsMk_eq_iff _).2 <|
    mem_augmentationSubmodule_of_eq g (single a x) _ <| by simp

@[simp]
lemma finsuppToCoinvariants_single_mk (a : α) (x : V) :
    finsuppToCoinvariants ρ α (single a <| coinvariantsMk _ x) =
      coinvariantsMk _ (single a x) := by
  simp [finsuppToCoinvariants]

variable (ρ α) in
/-- Given a `G`-representation `(V, ρ)` and a type `α`, this is the linear equivalence
`(α →₀ V)_G ≃ₗ (α →₀ V_G)` sending `⟦single a v⟧ ↦ single a ⟦v⟧`. -/
@[simps! symm_apply]
noncomputable def coinvariantsFinsuppLEquiv :
    coinvariants (ρ.finsupp α) ≃ₗ[k] α →₀ coinvariants ρ :=
  LinearEquiv.ofLinear (coinvariantsToFinsupp ρ α) (finsuppToCoinvariants ρ α)
    (by ext; simp) (by ext; simp)

@[simp]
lemma coinvariantsFinsuppLEquiv_apply (x) :
    coinvariantsFinsuppLEquiv ρ α x = coinvariantsToFinsupp ρ α x := by rfl

end Finsupp

section TensorProduct

open TensorProduct

variable {k G V W : Type*} [CommRing k] [Group G] [AddCommGroup V] [Module k V]
  [AddCommGroup W] [Module k W] (ρ : Representation k G V) (τ : Representation k G W)

@[simp]
lemma coinvariantsMk_inv_tmul (x : V) (y : W) (g : G) :
    coinvariantsMk (ρ.tprod τ) (ρ g⁻¹ x ⊗ₜ[k] y) = coinvariantsMk (ρ.tprod τ) (x ⊗ₜ[k] τ g y) :=
  (coinvariantsMk_eq_iff _).2 <| mem_augmentationSubmodule_of_eq g⁻¹ (x ⊗ₜ[k] τ g y) _ <| by simp

@[simp]
lemma coinvariantsMk_tmul_inv (x : V) (y : W) (g : G) :
    coinvariantsMk (ρ.tprod τ) (x ⊗ₜ[k] τ g⁻¹ y) = coinvariantsMk (ρ.tprod τ) (ρ g x ⊗ₜ[k] y) :=
  (coinvariantsMk_eq_iff _).2 <| mem_augmentationSubmodule_of_eq g⁻¹ (ρ g x ⊗ₜ[k] y) _ <| by simp

/-- Given a `k`-linear `G`-representation `V, ρ`, this is the map `(V ⊗ k[G])_G →ₗ[k] V` sending
`⟦v ⊗ single g r⟧ ↦ r • ρ(g⁻¹)(v)`. -/
noncomputable def ofCoinvariantsTprodLeftRegular :
    coinvariants (ρ.tprod (leftRegular k G)) →ₗ[k] V :=
  coinvariantsLift _ (TensorProduct.lift (Finsupp.linearCombination _ fun g => ρ g⁻¹) ∘ₗ
    (TensorProduct.comm _ _ _).toLinearMap) fun _ => by ext; simp

@[simp]
lemma ofCoinvariantsTprodLeftRegular_mk_tmul_single (x : V) (g : G) (r : k) :
    ofCoinvariantsTprodLeftRegular ρ (coinvariantsMk _ (x ⊗ₜ Finsupp.single g r)) = r • ρ g⁻¹ x :=
  congr($(Finsupp.linearCombination_single k (v := fun g => ρ g⁻¹) r g) x)

/-- Given a `k`-linear `G`-representation `(V, ρ)`, this is the linear equivalence
`(V ⊗ k[G])_G ≃ₗ[k] V` sending `⟦v ⊗ single g r⟧ ↦ r • ρ(g⁻¹)(v)`. -/
@[simps! symm_apply]
noncomputable def coinvariantsTprodLeftRegularLEquiv :
    coinvariants (ρ.tprod (leftRegular k G)) ≃ₗ[k] V :=
  LinearEquiv.ofLinear (ofCoinvariantsTprodLeftRegular ρ)
    (coinvariantsMk _ ∘ₗ (mk k V (G →₀ k)).flip (Finsupp.single 1 1)) (by ext; simp) <| by
      ext x g
      exact (coinvariantsMk_eq_iff _).2 <|
      mem_augmentationSubmodule_of_eq g⁻¹ (x ⊗ₜ Finsupp.single g 1) _ <| by
        simp [smul_tmul', smul_tmul]

@[simp]
lemma coinvariantsTprodLeftRegularLEquiv_apply (x) :
    coinvariantsTprodLeftRegularLEquiv ρ x = ofCoinvariantsTprodLeftRegular ρ x := by
  rfl

end TensorProduct

end Representation

namespace Rep

open CategoryTheory

section

variable {k G : Type u} [CommRing k] [Monoid G] {A B C : Rep k G} {n : ℕ}

open Representation

/-- The linear map underlying a `G`-representation morphism `A ⟶ B`, where `B` has the trivial
representation, factors through `A_G`. -/
noncomputable abbrev coinvariantsLift [B.ρ.IsTrivial] (f : A ⟶ B) :
    coinvariants A.ρ →ₗ[k] B :=
  Representation.coinvariantsLift _ f.hom.hom fun _ => by
    ext
    have := hom_comm_apply f
    simp_all

/-- A `G`-representation morphism `A ⟶ B` induces a linear map `A_G →ₗ[k] B_G`. -/
noncomputable abbrev coinvariantsMap (f : A ⟶ B) :
    coinvariants A.ρ →ₗ[k] coinvariants B.ρ :=
  Representation.coinvariantsMap _ _ f.hom.hom fun _ => ModuleCat.hom_ext_iff.1 (f.comm _)

@[simp]
theorem coinvariantsMap_id (A : Rep k G) :
    coinvariantsMap (𝟙 A) = LinearMap.id := by
  ext; rfl

@[simp]
theorem coinvariantsMap_comp (f : A ⟶ B) (g : B ⟶ C) :
    coinvariantsMap (f ≫ g) = coinvariantsMap g ∘ₗ coinvariantsMap f := by
  ext; rfl

variable (k G)

/-- The functor sending a representation to its coinvariants. -/
@[simps obj map]
noncomputable def coinvariantsFunctor : Rep k G ⥤ ModuleCat k where
  obj A := ModuleCat.of k (A.ρ.coinvariants)
  map f := ModuleCat.ofHom (coinvariantsMap f)

variable {k G} in
@[ext]
lemma coinvariantsFunctor_hom_ext {M : ModuleCat k} {f g : (coinvariantsFunctor k G).obj A ⟶ M}
    (hfg : f.hom ∘ₗ coinvariantsMk _ = g.hom ∘ₗ coinvariantsMk _) :
    f = g := ModuleCat.hom_ext <| coinvariants_hom_ext hfg

instance : (coinvariantsFunctor k G).Additive where
  map_add := by intros; ext; rfl

/-- The adjunction between the functor sending a representation to its coinvariants and the functor
equipping a module with the trivial representation. -/
@[simps! unit_app_hom_hom counit_app_hom]
noncomputable def coinvariantsAdjunction : coinvariantsFunctor k G ⊣ trivialFunctor G :=
  Adjunction.mkOfHomEquiv {
    homEquiv X Y := {
      toFun f := {
        hom := ModuleCat.ofHom (f.hom ∘ₗ X.ρ.coinvariantsMk)
        comm g := by
          ext x
          exact congr(f.hom $((coinvariantsMk_eq_iff _).2
            (X.ρ.mem_augmentationSubmodule_of_eq g x _ rfl))) }
      invFun f := ModuleCat.ofHom (coinvariantsLift f)
      left_inv _ := by ext; rfl
      right_inv _ := rfl }
    homEquiv_naturality_left_symm _ _ := by ext; rfl
    homEquiv_naturality_right := by intros; rfl }

instance : (coinvariantsFunctor k G).PreservesZeroMorphisms where
  map_zero _ _ := by ext; rfl

instance : Limits.PreservesColimits (coinvariantsFunctor k G) :=
  (coinvariantsAdjunction k G).leftAdjoint_preservesColimits

open MonoidalCategory ModuleCat.MonoidalCategory in
/-- The functor sending `A, B` to `(A ⊗[k] B)_G`. This is naturally isomorphic to the functor
sending `A, B` to `A ⊗[k[G]] B`, where we give `A` the `k[G]ᵐᵒᵖ`-module structure defined by
`g • a := A.ρ g⁻¹ a`. -/
@[simps]
noncomputable def coinvariantsTensor : Rep k G ⥤ Rep k G ⥤ ModuleCat k where
  obj A := MonoidalCategory.tensorLeft A ⋙ coinvariantsFunctor k G
  map f := {
    app A := ModuleCat.ofHom (coinvariantsMap (f ⊗ 𝟙 A))
    naturality _ _ _ := coinvariantsFunctor_hom_ext <| TensorProduct.ext' fun _ _ => by rfl }
  map_id _ := NatTrans.ext <| funext fun _ => by simp
  map_comp _ _ := NatTrans.ext <| funext fun _ => by simp

variable {k G} (A B)

noncomputable abbrev coinvariantsTensorMk :
    A →ₗ[k] B →ₗ[k] ((coinvariantsTensor k G).obj A).obj B :=
  (TensorProduct.mk k A B).compr₂ (coinvariantsMk _)

variable {A B}

lemma coinvariantsTensorMk_apply (a : A) (b : B) :
  coinvariantsTensorMk A B a b = coinvariantsMk _ (a ⊗ₜ[k] b) := rfl

@[ext]
lemma coinvariantsTensor_hom_ext {M : ModuleCat k}
    {f g : ((coinvariantsTensor k G).obj A).obj B ⟶ M}
    (hfg : (coinvariantsTensorMk A B).compr₂ f.hom = (coinvariantsTensorMk A B).compr₂ g.hom) :
    f = g := coinvariantsFunctor_hom_ext <| TensorProduct.ext <| hfg

instance (A : Rep k G) : ((coinvariantsTensor k G).obj A).Additive := by
  unfold coinvariantsTensor
  infer_instance

end

section Finsupp

variable {k G : Type u} [CommRing k] [Group G] (A : Rep k G) (α : Type u) [DecidableEq α]

open MonoidalCategory Finsupp Representation

/-- Given a `k`-linear `G`-representation `(A, ρ)` and a type `α`, this is the map
`(A ⊗ (α →₀ k[G]))_G →ₗ[k] (α →₀ A)` sending
`⟦a ⊗ single x (single g r)⟧ ↦ single x (r • ρ(g⁻¹)(a)).` -/
noncomputable def coinvariantsTensorFreeToFinsupp :
    (A ⊗ free k G α).ρ.coinvariants →ₗ[k] (α →₀ A) :=
  (coinvariantsFinsuppLEquiv _ α ≪≫ₗ lcongr (Equiv.refl α)
    (coinvariantsTprodLeftRegularLEquiv A.ρ)).toLinearMap ∘ₗ coinvariantsMap (finsuppTensorRight A
      (leftRegular k G) α).hom

variable {A α}

@[simp]
lemma coinvariantsTensorFreeToFinsupp_mk_tmul_single (x : A) (i : α) (g : G) (r : k) :
    DFunLike.coe (F := (A.ρ.tprod (Representation.free k G α)).coinvariants →ₗ[k] α →₀ A.V)
      (coinvariantsTensorFreeToFinsupp A α) (coinvariantsMk _ (x ⊗ₜ single i (single g r))) =
      single i (r • A.ρ g⁻¹ x) := by
  simp [ModuleCat.MonoidalCategory.instMonoidalCategoryStruct_tensorObj,
    ModuleCat.MonoidalCategory.tensorObj, coinvariantsTensorFreeToFinsupp,
    coinvariantsMap, finsuppTensorRight, TensorProduct.finsuppRight]

variable (A α)

/-- Given a `k`-linear `G`-representation `(A, ρ)` and a type `α`, this is the map
`(α →₀ A) →ₗ[k] (A ⊗ (α →₀ k[G]))_G` sending `single x a ↦ ⟦a ⊗ₜ single x 1⟧.` -/
noncomputable def finsuppToCoinvariantsTensorFree :
    (α →₀ A) →ₗ[k] coinvariants (A ⊗ (free k G α)).ρ :=
  coinvariantsMap ((finsuppTensorRight A (leftRegular k G) α)).inv ∘ₗ
    (coinvariantsFinsuppLEquiv _ α ≪≫ₗ
    lcongr (Equiv.refl α) (coinvariantsTprodLeftRegularLEquiv A.ρ)).symm.toLinearMap

variable {A α}

@[simp]
lemma finsuppToCoinvariantsTensorFree_single (i : α) (x : A) :
    DFunLike.coe (F := (α →₀ A.V) →ₗ[k] (A.ρ.tprod (Representation.free k G α)).coinvariants)
      (finsuppToCoinvariantsTensorFree A α) (single i x) =
      coinvariantsMk _ (x ⊗ₜ single i (single (1 : G) (1 : k))) := by
  simp [finsuppToCoinvariantsTensorFree, coinvariantsMap, ModuleCat.MonoidalCategory.tensorObj,
    ModuleCat.MonoidalCategory.instMonoidalCategoryStruct_tensorObj]

variable (A α)

/-- Given a `k`-linear `G`-representation `(A, ρ)` and a type `α`, this is the linear equivalence
`(A ⊗ (α →₀ k[G]))_G ≃ₗ[k] (α →₀ A)` sending
`⟦a ⊗ single x (single g r)⟧ ↦ single x (r • ρ(g⁻¹)(a)).` -/
@[simps! symm_apply]
noncomputable abbrev coinvariantsTensorFreeLEquiv :
    coinvariants (A ⊗ free k G α).ρ ≃ₗ[k] (α →₀ A) :=
  LinearEquiv.ofLinear (coinvariantsTensorFreeToFinsupp A α) (finsuppToCoinvariantsTensorFree A α)
    (lhom_ext fun i x => by
      simp [finsuppToCoinvariantsTensorFree_single i x,
        coinvariantsTensorFreeToFinsupp_mk_tmul_single x i 1 1]) <|
    coinvariants_hom_ext <| TensorProduct.ext <| LinearMap.ext fun a => lhom_ext' fun i =>
      lhom_ext fun g r => by
        simp [coinvariantsTensorFreeToFinsupp_mk_tmul_single a i g r,
          finsuppToCoinvariantsTensorFree_single (A := A) i, TensorProduct.smul_tmul]

@[simp]
lemma coinvariantsTensorFreeLEquiv_apply (x) :
    DFunLike.coe (F := (A.ρ.tprod (Representation.free k G α)).coinvariants →ₗ[k] α →₀ A)
      (A.coinvariantsTensorFreeToFinsupp α) x = coinvariantsTensorFreeToFinsupp A α x := by
  rfl

end Finsupp
end Rep
