/-
Copyright (c) 2018 Chris Hughes. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Chris Hughes, Abhimanyu Pallavi Sudhir, Jean Lo, Calle S√∂nne, S√©bastien Gou√´zel,
  R√©my Degenne, David Loeffler
-/
import Mathlib.Analysis.SpecialFunctions.Pow.Real

#align_import analysis.special_functions.pow.nnreal from "leanprover-community/mathlib"@"4fa54b337f7d52805480306db1b1439c741848c8"

/-!
# Power function on `‚Ñù‚â•0` and `‚Ñù‚â•0‚àû`

We construct the power functions `x ^ y` where
* `x` is a nonnegative real number and `y` is a real number;
* `x` is a number from `[0, +‚àû]` (a.k.a. `‚Ñù‚â•0‚àû`) and `y` is a real number.

We also prove basic properties of these functions.
-/

local macro_rules | `($x ^ $y) => `(HPow.hPow $x $y) -- Porting note: See issue lean4#2220

noncomputable section

open Classical Real NNReal ENNReal BigOperators ComplexConjugate

open Finset Set

namespace NNReal

/-- The nonnegative real power function `x^y`, defined for `x : ‚Ñù‚â•0` and `y : ‚Ñù ` as the
restriction of the real power function. For `x > 0`, it is equal to `exp (y log x)`. For `x = 0`,
one sets `0 ^ 0 = 1` and `0 ^ y = 0` for `y ‚â† 0`. -/
noncomputable def rpow (x : ‚Ñù‚â•0) (y : ‚Ñù) : ‚Ñù‚â•0 :=
  ‚ü®(x : ‚Ñù) ^ y, Real.rpow_nonneg_of_nonneg x.2 y‚ü©
#align nnreal.rpow NNReal.rpow

noncomputable instance : Pow ‚Ñù‚â•0 ‚Ñù :=
  ‚ü®rpow‚ü©

@[simp]
theorem rpow_eq_pow (x : ‚Ñù‚â•0) (y : ‚Ñù) : rpow x y = x ^ y :=
  rfl
#align nnreal.rpow_eq_pow NNReal.rpow_eq_pow

@[simp, norm_cast]
theorem coe_rpow (x : ‚Ñù‚â•0) (y : ‚Ñù) : ((x ^ y : ‚Ñù‚â•0) : ‚Ñù) = (x : ‚Ñù) ^ y :=
  rfl
#align nnreal.coe_rpow NNReal.coe_rpow

@[simp]
theorem rpow_zero (x : ‚Ñù‚â•0) : x ^ (0 : ‚Ñù) = 1 :=
  NNReal.eq <| Real.rpow_zero _
#align nnreal.rpow_zero NNReal.rpow_zero

@[simp]
theorem rpow_eq_zero_iff {x : ‚Ñù‚â•0} {y : ‚Ñù} : x ^ y = 0 ‚Üî x = 0 ‚àß y ‚â† 0 := by
  rw [‚Üê NNReal.coe_eq, coe_rpow, ‚Üê NNReal.coe_eq_zero]
  -- ‚ä¢ ‚Üëx ^ y = ‚Üë0 ‚Üî ‚Üëx = 0 ‚àß y ‚â† 0
  exact Real.rpow_eq_zero_iff_of_nonneg x.2
  -- üéâ no goals
#align nnreal.rpow_eq_zero_iff NNReal.rpow_eq_zero_iff

@[simp]
theorem zero_rpow {x : ‚Ñù} (h : x ‚â† 0) : (0 : ‚Ñù‚â•0) ^ x = 0 :=
  NNReal.eq <| Real.zero_rpow h
#align nnreal.zero_rpow NNReal.zero_rpow

@[simp]
theorem rpow_one (x : ‚Ñù‚â•0) : x ^ (1 : ‚Ñù) = x :=
  NNReal.eq <| Real.rpow_one _
#align nnreal.rpow_one NNReal.rpow_one

@[simp]
theorem one_rpow (x : ‚Ñù) : (1 : ‚Ñù‚â•0) ^ x = 1 :=
  NNReal.eq <| Real.one_rpow _
#align nnreal.one_rpow NNReal.one_rpow

theorem rpow_add {x : ‚Ñù‚â•0} (hx : x ‚â† 0) (y z : ‚Ñù) : x ^ (y + z) = x ^ y * x ^ z :=
  NNReal.eq <| Real.rpow_add (pos_iff_ne_zero.2 hx) _ _
#align nnreal.rpow_add NNReal.rpow_add

theorem rpow_add' (x : ‚Ñù‚â•0) {y z : ‚Ñù} (h : y + z ‚â† 0) : x ^ (y + z) = x ^ y * x ^ z :=
  NNReal.eq <| Real.rpow_add' x.2 h
#align nnreal.rpow_add' NNReal.rpow_add'

theorem rpow_mul (x : ‚Ñù‚â•0) (y z : ‚Ñù) : x ^ (y * z) = (x ^ y) ^ z :=
  NNReal.eq <| Real.rpow_mul x.2 y z
#align nnreal.rpow_mul NNReal.rpow_mul

theorem rpow_neg (x : ‚Ñù‚â•0) (y : ‚Ñù) : x ^ (-y) = (x ^ y)‚Åª¬π :=
  NNReal.eq <| Real.rpow_neg x.2 _
#align nnreal.rpow_neg NNReal.rpow_neg

theorem rpow_neg_one (x : ‚Ñù‚â•0) : x ^ (-1 : ‚Ñù) = x‚Åª¬π := by simp [rpow_neg]
                                                          -- üéâ no goals
#align nnreal.rpow_neg_one NNReal.rpow_neg_one

theorem rpow_sub {x : ‚Ñù‚â•0} (hx : x ‚â† 0) (y z : ‚Ñù) : x ^ (y - z) = x ^ y / x ^ z :=
  NNReal.eq <| Real.rpow_sub (pos_iff_ne_zero.2 hx) y z
#align nnreal.rpow_sub NNReal.rpow_sub

theorem rpow_sub' (x : ‚Ñù‚â•0) {y z : ‚Ñù} (h : y - z ‚â† 0) : x ^ (y - z) = x ^ y / x ^ z :=
  NNReal.eq <| Real.rpow_sub' x.2 h
#align nnreal.rpow_sub' NNReal.rpow_sub'

theorem rpow_inv_rpow_self {y : ‚Ñù} (hy : y ‚â† 0) (x : ‚Ñù‚â•0) : (x ^ y) ^ (1 / y) = x := by
  field_simp [‚Üê rpow_mul]
  -- üéâ no goals
#align nnreal.rpow_inv_rpow_self NNReal.rpow_inv_rpow_self

theorem rpow_self_rpow_inv {y : ‚Ñù} (hy : y ‚â† 0) (x : ‚Ñù‚â•0) : (x ^ (1 / y)) ^ y = x := by
  field_simp [‚Üê rpow_mul]
  -- üéâ no goals
#align nnreal.rpow_self_rpow_inv NNReal.rpow_self_rpow_inv

theorem inv_rpow (x : ‚Ñù‚â•0) (y : ‚Ñù) : x‚Åª¬π ^ y = (x ^ y)‚Åª¬π :=
  NNReal.eq <| Real.inv_rpow x.2 y
#align nnreal.inv_rpow NNReal.inv_rpow

theorem div_rpow (x y : ‚Ñù‚â•0) (z : ‚Ñù) : (x / y) ^ z = x ^ z / y ^ z :=
  NNReal.eq <| Real.div_rpow x.2 y.2 z
#align nnreal.div_rpow NNReal.div_rpow

theorem sqrt_eq_rpow (x : ‚Ñù‚â•0) : sqrt x = x ^ (1 / (2 : ‚Ñù)) := by
  refine' NNReal.eq _
  -- ‚ä¢ ‚Üë(‚Üësqrt x) = ‚Üë(x ^ (1 / 2))
  push_cast
  -- ‚ä¢ Real.sqrt ‚Üëx = ‚Üëx ^ (1 / 2)
  exact Real.sqrt_eq_rpow x.1
  -- üéâ no goals
#align nnreal.sqrt_eq_rpow NNReal.sqrt_eq_rpow

@[simp, norm_cast]
theorem rpow_nat_cast (x : ‚Ñù‚â•0) (n : ‚Ñï) : x ^ (n : ‚Ñù) = x ^ n :=
  NNReal.eq <| by simpa only [coe_rpow, coe_pow] using Real.rpow_nat_cast x n
                  -- üéâ no goals
#align nnreal.rpow_nat_cast NNReal.rpow_nat_cast

@[simp]
theorem rpow_two (x : ‚Ñù‚â•0) : x ^ (2 : ‚Ñù) = x ^ 2 := by
  rw [‚Üê rpow_nat_cast]
  -- ‚ä¢ x ^ 2 = x ^ ‚Üë2
  simp only [Nat.cast_ofNat]
  -- üéâ no goals
#align nnreal.rpow_two NNReal.rpow_two

theorem mul_rpow {x y : ‚Ñù‚â•0} {z : ‚Ñù} : (x * y) ^ z = x ^ z * y ^ z :=
  NNReal.eq <| Real.mul_rpow x.2 y.2
#align nnreal.mul_rpow NNReal.mul_rpow

/-- `rpow` as a `MonoidHom`-/
@[simps]
def rpowMonoidHom (r : ‚Ñù) : ‚Ñù‚â•0 ‚Üí* ‚Ñù‚â•0 where
  toFun := (¬∑ ^ r)
  map_one' := one_rpow _
  map_mul' _x _y := mul_rpow

/-- `rpow` variant of `List.prod_map_pow` for `‚Ñù‚â•0`-/
theorem list_prod_map_rpow (l : List ‚Ñù‚â•0) (r : ‚Ñù) :
    (l.map (¬∑ ^ r)).prod = l.prod ^ r :=
  l.prod_hom (rpowMonoidHom r)

theorem list_prod_map_rpow' {Œπ} (l : List Œπ) (f : Œπ ‚Üí ‚Ñù‚â•0) (r : ‚Ñù) :
    (l.map (f ¬∑ ^ r)).prod = (l.map f).prod ^ r := by
  rw [‚Üêlist_prod_map_rpow, List.map_map]; rfl
  -- ‚ä¢ List.prod (List.map (fun x => f x ^ r) l) = List.prod (List.map ((fun x => x ‚Ä¶
                                          -- üéâ no goals

/-- `rpow` version of `Multiset.prod_map_pow` for `‚Ñù‚â•0`. -/
lemma multiset_prod_map_rpow {Œπ} (s : Multiset Œπ) (f : Œπ ‚Üí ‚Ñù‚â•0) (r : ‚Ñù) :
    (s.map (f ¬∑ ^ r)).prod = (s.map f).prod ^ r :=
  s.prod_hom' (rpowMonoidHom r) _

/-- `rpow` version of `Finset.prod_pow` for `‚Ñù‚â•0`. -/
lemma finset_prod_rpow {Œπ} (s : Finset Œπ) (f : Œπ ‚Üí ‚Ñù‚â•0) (r : ‚Ñù) :
    (‚àè i in s, f i ^ r) = (‚àè i in s, f i) ^ r :=
  multiset_prod_map_rpow _ _ _

-- note: these don't really belong here, but they're much easier to prove in terms of the above

section Real

/-- `rpow` version of `List.prod_map_pow` for `Real`. -/
theorem _root_.Real.list_prod_map_rpow (l : List ‚Ñù) (hl : ‚àÄ x ‚àà l, (0 : ‚Ñù) ‚â§ x) (r : ‚Ñù) :
    (l.map (¬∑ ^ r)).prod = l.prod ^ r := by
  lift l to List ‚Ñù‚â•0 using hl
  -- ‚ä¢ List.prod (List.map (fun x => x ^ r) (List.map toReal l)) = List.prod (List. ‚Ä¶
  have := congr_arg ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù) (NNReal.list_prod_map_rpow l r)
  -- ‚ä¢ List.prod (List.map (fun x => x ^ r) (List.map toReal l)) = List.prod (List. ‚Ä¶
  push_cast at this
  -- ‚ä¢ List.prod (List.map (fun x => x ^ r) (List.map toReal l)) = List.prod (List. ‚Ä¶
  rw [List.map_map] at this ‚ä¢
  -- ‚ä¢ List.prod (List.map ((fun x => x ^ r) ‚àò toReal) l) = List.prod (List.map toR ‚Ä¶
  exact_mod_cast this
  -- üéâ no goals

theorem _root_.Real.list_prod_map_rpow' {Œπ} (l : List Œπ) (f : Œπ ‚Üí ‚Ñù)
    (hl : ‚àÄ i ‚àà l, (0 : ‚Ñù) ‚â§ f i) (r : ‚Ñù) :
    (l.map (f ¬∑ ^ r)).prod = (l.map f).prod ^ r := by
  rw [‚ÜêReal.list_prod_map_rpow (l.map f) _ r, List.map_map]; rfl
  -- ‚ä¢ List.prod (List.map (fun x => f x ^ r) l) = List.prod (List.map ((fun x => x ‚Ä¶
                                                             -- ‚ä¢ ‚àÄ (x : ‚Ñù), x ‚àà List.map f l ‚Üí 0 ‚â§ x
  simpa using hl
  -- üéâ no goals

/-- `rpow` version of `Multiset.prod_map_pow`. -/
theorem _root_.Real.multiset_prod_map_rpow {Œπ} (s : Multiset Œπ) (f : Œπ ‚Üí ‚Ñù)
    (hs : ‚àÄ i ‚àà s, (0 : ‚Ñù) ‚â§ f i) (r : ‚Ñù) :
    (s.map (f ¬∑ ^ r)).prod = (s.map f).prod ^ r := by
  induction' s using Quotient.inductionOn with l
  -- ‚ä¢ Multiset.prod (Multiset.map (fun x => f x ^ r) (Quotient.mk (List.isSetoid Œπ ‚Ä¶
  simpa using Real.list_prod_map_rpow' l f hs r
  -- üéâ no goals

/-- `rpow` version of `Finset.prod_pow`. -/
theorem _root_.Real.finset_prod_rpow
    {Œπ} (s : Finset Œπ) (f : Œπ ‚Üí ‚Ñù) (hs : ‚àÄ i ‚àà s, 0 ‚â§ f i) (r : ‚Ñù) :
    (‚àè i in s, f i ^ r) = (‚àè i in s, f i) ^ r :=
  Real.multiset_prod_map_rpow s.val f hs r

end Real

theorem rpow_le_rpow {x y : ‚Ñù‚â•0} {z : ‚Ñù} (h‚ÇÅ : x ‚â§ y) (h‚ÇÇ : 0 ‚â§ z) : x ^ z ‚â§ y ^ z :=
  Real.rpow_le_rpow x.2 h‚ÇÅ h‚ÇÇ
#align nnreal.rpow_le_rpow NNReal.rpow_le_rpow

theorem rpow_lt_rpow {x y : ‚Ñù‚â•0} {z : ‚Ñù} (h‚ÇÅ : x < y) (h‚ÇÇ : 0 < z) : x ^ z < y ^ z :=
  Real.rpow_lt_rpow x.2 h‚ÇÅ h‚ÇÇ
#align nnreal.rpow_lt_rpow NNReal.rpow_lt_rpow

theorem rpow_lt_rpow_iff {x y : ‚Ñù‚â•0} {z : ‚Ñù} (hz : 0 < z) : x ^ z < y ^ z ‚Üî x < y :=
  Real.rpow_lt_rpow_iff x.2 y.2 hz
#align nnreal.rpow_lt_rpow_iff NNReal.rpow_lt_rpow_iff

theorem rpow_le_rpow_iff {x y : ‚Ñù‚â•0} {z : ‚Ñù} (hz : 0 < z) : x ^ z ‚â§ y ^ z ‚Üî x ‚â§ y :=
  Real.rpow_le_rpow_iff x.2 y.2 hz
#align nnreal.rpow_le_rpow_iff NNReal.rpow_le_rpow_iff

theorem le_rpow_one_div_iff {x y : ‚Ñù‚â•0} {z : ‚Ñù} (hz : 0 < z) : x ‚â§ y ^ (1 / z) ‚Üî x ^ z ‚â§ y := by
  rw [‚Üê rpow_le_rpow_iff hz, rpow_self_rpow_inv hz.ne']
  -- üéâ no goals
#align nnreal.le_rpow_one_div_iff NNReal.le_rpow_one_div_iff

theorem rpow_one_div_le_iff {x y : ‚Ñù‚â•0} {z : ‚Ñù} (hz : 0 < z) : x ^ (1 / z) ‚â§ y ‚Üî x ‚â§ y ^ z := by
  rw [‚Üê rpow_le_rpow_iff hz, rpow_self_rpow_inv hz.ne']
  -- üéâ no goals
#align nnreal.rpow_one_div_le_iff NNReal.rpow_one_div_le_iff

theorem rpow_lt_rpow_of_exponent_lt {x : ‚Ñù‚â•0} {y z : ‚Ñù} (hx : 1 < x) (hyz : y < z) :
    x ^ y < x ^ z :=
  Real.rpow_lt_rpow_of_exponent_lt hx hyz
#align nnreal.rpow_lt_rpow_of_exponent_lt NNReal.rpow_lt_rpow_of_exponent_lt

theorem rpow_le_rpow_of_exponent_le {x : ‚Ñù‚â•0} {y z : ‚Ñù} (hx : 1 ‚â§ x) (hyz : y ‚â§ z) :
    x ^ y ‚â§ x ^ z :=
  Real.rpow_le_rpow_of_exponent_le hx hyz
#align nnreal.rpow_le_rpow_of_exponent_le NNReal.rpow_le_rpow_of_exponent_le

theorem rpow_lt_rpow_of_exponent_gt {x : ‚Ñù‚â•0} {y z : ‚Ñù} (hx0 : 0 < x) (hx1 : x < 1) (hyz : z < y) :
    x ^ y < x ^ z :=
  Real.rpow_lt_rpow_of_exponent_gt hx0 hx1 hyz
#align nnreal.rpow_lt_rpow_of_exponent_gt NNReal.rpow_lt_rpow_of_exponent_gt

theorem rpow_le_rpow_of_exponent_ge {x : ‚Ñù‚â•0} {y z : ‚Ñù} (hx0 : 0 < x) (hx1 : x ‚â§ 1) (hyz : z ‚â§ y) :
    x ^ y ‚â§ x ^ z :=
  Real.rpow_le_rpow_of_exponent_ge hx0 hx1 hyz
#align nnreal.rpow_le_rpow_of_exponent_ge NNReal.rpow_le_rpow_of_exponent_ge

theorem rpow_pos {p : ‚Ñù} {x : ‚Ñù‚â•0} (hx_pos : 0 < x) : 0 < x ^ p := by
  have rpow_pos_of_nonneg : ‚àÄ {p : ‚Ñù}, 0 < p ‚Üí 0 < x ^ p := by
    intro p hp_pos
    rw [‚Üê zero_rpow hp_pos.ne']
    exact rpow_lt_rpow hx_pos hp_pos
  rcases lt_trichotomy (0 : ‚Ñù) p with (hp_pos | rfl | hp_neg)
  ¬∑ exact rpow_pos_of_nonneg hp_pos
    -- üéâ no goals
  ¬∑ simp only [zero_lt_one, rpow_zero]
    -- üéâ no goals
  ¬∑ rw [‚Üê neg_neg p, rpow_neg, inv_pos]
    -- ‚ä¢ 0 < x ^ (-p)
    exact rpow_pos_of_nonneg (neg_pos.mpr hp_neg)
    -- üéâ no goals
#align nnreal.rpow_pos NNReal.rpow_pos

theorem rpow_lt_one {x : ‚Ñù‚â•0} {z : ‚Ñù} (hx1 : x < 1) (hz : 0 < z) : x ^ z < 1 :=
  Real.rpow_lt_one (coe_nonneg x) hx1 hz
#align nnreal.rpow_lt_one NNReal.rpow_lt_one

theorem rpow_le_one {x : ‚Ñù‚â•0} {z : ‚Ñù} (hx2 : x ‚â§ 1) (hz : 0 ‚â§ z) : x ^ z ‚â§ 1 :=
  Real.rpow_le_one x.2 hx2 hz
#align nnreal.rpow_le_one NNReal.rpow_le_one

theorem rpow_lt_one_of_one_lt_of_neg {x : ‚Ñù‚â•0} {z : ‚Ñù} (hx : 1 < x) (hz : z < 0) : x ^ z < 1 :=
  Real.rpow_lt_one_of_one_lt_of_neg hx hz
#align nnreal.rpow_lt_one_of_one_lt_of_neg NNReal.rpow_lt_one_of_one_lt_of_neg

theorem rpow_le_one_of_one_le_of_nonpos {x : ‚Ñù‚â•0} {z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z ‚â§ 0) : x ^ z ‚â§ 1 :=
  Real.rpow_le_one_of_one_le_of_nonpos hx hz
#align nnreal.rpow_le_one_of_one_le_of_nonpos NNReal.rpow_le_one_of_one_le_of_nonpos

theorem one_lt_rpow {x : ‚Ñù‚â•0} {z : ‚Ñù} (hx : 1 < x) (hz : 0 < z) : 1 < x ^ z :=
  Real.one_lt_rpow hx hz
#align nnreal.one_lt_rpow NNReal.one_lt_rpow

theorem one_le_rpow {x : ‚Ñù‚â•0} {z : ‚Ñù} (h : 1 ‚â§ x) (h‚ÇÅ : 0 ‚â§ z) : 1 ‚â§ x ^ z :=
  Real.one_le_rpow h h‚ÇÅ
#align nnreal.one_le_rpow NNReal.one_le_rpow

theorem one_lt_rpow_of_pos_of_lt_one_of_neg {x : ‚Ñù‚â•0} {z : ‚Ñù} (hx1 : 0 < x) (hx2 : x < 1)
    (hz : z < 0) : 1 < x ^ z :=
  Real.one_lt_rpow_of_pos_of_lt_one_of_neg hx1 hx2 hz
#align nnreal.one_lt_rpow_of_pos_of_lt_one_of_neg NNReal.one_lt_rpow_of_pos_of_lt_one_of_neg

theorem one_le_rpow_of_pos_of_le_one_of_nonpos {x : ‚Ñù‚â•0} {z : ‚Ñù} (hx1 : 0 < x) (hx2 : x ‚â§ 1)
    (hz : z ‚â§ 0) : 1 ‚â§ x ^ z :=
  Real.one_le_rpow_of_pos_of_le_one_of_nonpos hx1 hx2 hz
#align nnreal.one_le_rpow_of_pos_of_le_one_of_nonpos NNReal.one_le_rpow_of_pos_of_le_one_of_nonpos

theorem rpow_le_self_of_le_one {x : ‚Ñù‚â•0} {z : ‚Ñù} (hx : x ‚â§ 1) (h_one_le : 1 ‚â§ z) : x ^ z ‚â§ x := by
  rcases eq_bot_or_bot_lt x with (rfl | (h : 0 < x))
  -- ‚ä¢ ‚ä• ^ z ‚â§ ‚ä•
  ¬∑ have : z ‚â† 0 := by linarith
    -- ‚ä¢ ‚ä• ^ z ‚â§ ‚ä•
    simp [this]
    -- üéâ no goals
  nth_rw 2 [‚Üê NNReal.rpow_one x]
  -- ‚ä¢ x ^ z ‚â§ x ^ 1
  exact NNReal.rpow_le_rpow_of_exponent_ge h hx h_one_le
  -- üéâ no goals
#align nnreal.rpow_le_self_of_le_one NNReal.rpow_le_self_of_le_one

theorem rpow_left_injective {x : ‚Ñù} (hx : x ‚â† 0) : Function.Injective fun y : ‚Ñù‚â•0 => y ^ x :=
  fun y z hyz => by simpa only [rpow_inv_rpow_self hx] using congr_arg (fun y => y ^ (1 / x)) hyz
                    -- üéâ no goals
#align nnreal.rpow_left_injective NNReal.rpow_left_injective

theorem rpow_eq_rpow_iff {x y : ‚Ñù‚â•0} {z : ‚Ñù} (hz : z ‚â† 0) : x ^ z = y ^ z ‚Üî x = y :=
  (rpow_left_injective hz).eq_iff
#align nnreal.rpow_eq_rpow_iff NNReal.rpow_eq_rpow_iff

theorem rpow_left_surjective {x : ‚Ñù} (hx : x ‚â† 0) : Function.Surjective fun y : ‚Ñù‚â•0 => y ^ x :=
  fun y => ‚ü®y ^ x‚Åª¬π, by simp_rw [‚Üê rpow_mul, _root_.inv_mul_cancel hx, rpow_one]‚ü©
                        -- üéâ no goals
#align nnreal.rpow_left_surjective NNReal.rpow_left_surjective

theorem rpow_left_bijective {x : ‚Ñù} (hx : x ‚â† 0) : Function.Bijective fun y : ‚Ñù‚â•0 => y ^ x :=
  ‚ü®rpow_left_injective hx, rpow_left_surjective hx‚ü©
#align nnreal.rpow_left_bijective NNReal.rpow_left_bijective

theorem eq_rpow_one_div_iff {x y : ‚Ñù‚â•0} {z : ‚Ñù} (hz : z ‚â† 0) : x = y ^ (1 / z) ‚Üî x ^ z = y := by
  rw [‚Üê rpow_eq_rpow_iff hz, rpow_self_rpow_inv hz]
  -- üéâ no goals
#align nnreal.eq_rpow_one_div_iff NNReal.eq_rpow_one_div_iff

theorem rpow_one_div_eq_iff {x y : ‚Ñù‚â•0} {z : ‚Ñù} (hz : z ‚â† 0) : x ^ (1 / z) = y ‚Üî x = y ^ z := by
  rw [‚Üê rpow_eq_rpow_iff hz, rpow_self_rpow_inv hz]
  -- üéâ no goals
#align nnreal.rpow_one_div_eq_iff NNReal.rpow_one_div_eq_iff

theorem pow_nat_rpow_nat_inv (x : ‚Ñù‚â•0) {n : ‚Ñï} (hn : n ‚â† 0) : (x ^ n) ^ (n‚Åª¬π : ‚Ñù) = x := by
  rw [‚Üê NNReal.coe_eq, coe_rpow, NNReal.coe_pow]
  -- ‚ä¢ (‚Üëx ^ n) ^ (‚Üën)‚Åª¬π = ‚Üëx
  exact Real.pow_nat_rpow_nat_inv x.2 hn
  -- üéâ no goals
#align nnreal.pow_nat_rpow_nat_inv NNReal.pow_nat_rpow_nat_inv

theorem rpow_nat_inv_pow_nat (x : ‚Ñù‚â•0) {n : ‚Ñï} (hn : n ‚â† 0) : (x ^ (n‚Åª¬π : ‚Ñù)) ^ n = x := by
  rw [‚Üê NNReal.coe_eq, NNReal.coe_pow, coe_rpow]
  -- ‚ä¢ (‚Üëx ^ (‚Üën)‚Åª¬π) ^ n = ‚Üëx
  exact Real.rpow_nat_inv_pow_nat x.2 hn
  -- üéâ no goals
#align nnreal.rpow_nat_inv_pow_nat NNReal.rpow_nat_inv_pow_nat

theorem _root_.Real.toNNReal_rpow_of_nonneg {x y : ‚Ñù} (hx : 0 ‚â§ x) :
    Real.toNNReal (x ^ y) = Real.toNNReal x ^ y := by
  nth_rw 1 [‚Üê Real.coe_toNNReal x hx]
  -- ‚ä¢ toNNReal (‚Üë(toNNReal x) ^ y) = toNNReal x ^ y
  rw [‚Üê NNReal.coe_rpow, Real.toNNReal_coe]
  -- üéâ no goals
#align real.to_nnreal_rpow_of_nonneg Real.toNNReal_rpow_of_nonneg

theorem strictMono_rpow_of_pos {z : ‚Ñù} (h : 0 < z) : StrictMono fun x : ‚Ñù‚â•0 => x ^ z :=
  fun x y hxy => by simp only [NNReal.rpow_lt_rpow hxy h, coe_lt_coe]
                    -- üéâ no goals

theorem monotone_rpow_of_nonneg {z : ‚Ñù} (h : 0 ‚â§ z) : Monotone fun x : ‚Ñù‚â•0 => x ^ z :=
  h.eq_or_lt.elim (fun h0 => h0 ‚ñ∏ by simp only [rpow_zero, monotone_const]) fun h0 =>
                                     -- üéâ no goals
    (strictMono_rpow_of_pos h0).monotone

/-- Bundles `fun x : ‚Ñù‚â•0 => x ^ y` into an order isomorphism when `y : ‚Ñù` is positive,
where the inverse is `fun x : ‚Ñù‚â•0 => x ^ (1 / y)`. -/
@[simps! apply]
def orderIsoRpow (y : ‚Ñù) (hy : 0 < y) : ‚Ñù‚â•0 ‚âÉo ‚Ñù‚â•0 :=
  (strictMono_rpow_of_pos hy).orderIsoOfRightInverse (fun x => x ^ y) (fun x => x ^ (1 / y))
    fun x => by
      dsimp
      -- ‚ä¢ (x ^ (1 / y)) ^ y = x
      rw [‚Üê rpow_mul, one_div_mul_cancel hy.ne.symm, rpow_one]
      -- üéâ no goals

theorem orderIsoRpow_symm_eq (y : ‚Ñù) (hy : 0 < y) :
    (orderIsoRpow y hy).symm = orderIsoRpow (1 / y) (one_div_pos.2 hy) := by
  simp only [orderIsoRpow, one_div_one_div]; rfl
  -- ‚ä¢ OrderIso.symm (StrictMono.orderIsoOfRightInverse (fun x => x ^ y) (_ : Stric ‚Ä¶
                                             -- üéâ no goals

end NNReal

namespace ENNReal

/-- The real power function `x^y` on extended nonnegative reals, defined for `x : ‚Ñù‚â•0‚àû` and
`y : ‚Ñù` as the restriction of the real power function if `0 < x < ‚ä§`, and with the natural values
for `0` and `‚ä§` (i.e., `0 ^ x = 0` for `x > 0`, `1` for `x = 0` and `‚ä§` for `x < 0`, and
`‚ä§ ^ x = 1 / 0 ^ x`). -/
noncomputable def rpow : ‚Ñù‚â•0‚àû ‚Üí ‚Ñù ‚Üí ‚Ñù‚â•0‚àû
  | some x, y => if x = 0 ‚àß y < 0 then ‚ä§ else (x ^ y : ‚Ñù‚â•0)
  | none, y => if 0 < y then ‚ä§ else if y = 0 then 1 else 0
#align ennreal.rpow ENNReal.rpow

noncomputable instance : Pow ‚Ñù‚â•0‚àû ‚Ñù :=
  ‚ü®rpow‚ü©

@[simp]
theorem rpow_eq_pow (x : ‚Ñù‚â•0‚àû) (y : ‚Ñù) : rpow x y = x ^ y :=
  rfl
#align ennreal.rpow_eq_pow ENNReal.rpow_eq_pow

@[simp]
theorem rpow_zero {x : ‚Ñù‚â•0‚àû} : x ^ (0 : ‚Ñù) = 1 := by
  cases x <;>
  -- ‚ä¢ none ^ 0 = 1
    ¬∑ dsimp only [(¬∑ ^ ¬∑), Pow.pow, rpow]
      -- ‚ä¢ (if 0 < 0 then ‚ä§ else if 0 = 0 then 1 else 0) = 1
      -- ‚ä¢ (if val‚úù = 0 ‚àß 0 < 0 then ‚ä§ else ‚Üë(NNReal.rpow val‚úù 0)) = 1
      -- üéâ no goals
      simp [lt_irrefl]
      -- üéâ no goals
#align ennreal.rpow_zero ENNReal.rpow_zero

theorem top_rpow_def (y : ‚Ñù) : (‚ä§ : ‚Ñù‚â•0‚àû) ^ y = if 0 < y then ‚ä§ else if y = 0 then 1 else 0 :=
  rfl
#align ennreal.top_rpow_def ENNReal.top_rpow_def

@[simp]
theorem top_rpow_of_pos {y : ‚Ñù} (h : 0 < y) : (‚ä§ : ‚Ñù‚â•0‚àû) ^ y = ‚ä§ := by simp [top_rpow_def, h]
                                                                       -- üéâ no goals
#align ennreal.top_rpow_of_pos ENNReal.top_rpow_of_pos

@[simp]
theorem top_rpow_of_neg {y : ‚Ñù} (h : y < 0) : (‚ä§ : ‚Ñù‚â•0‚àû) ^ y = 0 := by
  simp [top_rpow_def, asymm h, ne_of_lt h]
  -- üéâ no goals
#align ennreal.top_rpow_of_neg ENNReal.top_rpow_of_neg

@[simp]
theorem zero_rpow_of_pos {y : ‚Ñù} (h : 0 < y) : (0 : ‚Ñù‚â•0‚àû) ^ y = 0 := by
  rw [‚Üê ENNReal.coe_zero, ‚Üê ENNReal.some_eq_coe]
  -- ‚ä¢ Option.some 0 ^ y = Option.some 0
  dsimp only [(¬∑ ^ ¬∑), rpow, Pow.pow]
  -- ‚ä¢ (if 0 = 0 ‚àß y < 0 then ‚ä§ else ‚Üë(NNReal.rpow 0 y)) = Option.some 0
  simp [h, asymm h, ne_of_gt h]
  -- üéâ no goals
#align ennreal.zero_rpow_of_pos ENNReal.zero_rpow_of_pos

@[simp]
theorem zero_rpow_of_neg {y : ‚Ñù} (h : y < 0) : (0 : ‚Ñù‚â•0‚àû) ^ y = ‚ä§ := by
  rw [‚Üê ENNReal.coe_zero, ‚Üê ENNReal.some_eq_coe]
  -- ‚ä¢ Option.some 0 ^ y = ‚ä§
  dsimp only [(¬∑ ^ ¬∑), rpow, Pow.pow]
  -- ‚ä¢ (if 0 = 0 ‚àß y < 0 then ‚ä§ else ‚Üë(NNReal.rpow 0 y)) = ‚ä§
  simp [h, ne_of_gt h]
  -- üéâ no goals
#align ennreal.zero_rpow_of_neg ENNReal.zero_rpow_of_neg

theorem zero_rpow_def (y : ‚Ñù) : (0 : ‚Ñù‚â•0‚àû) ^ y = if 0 < y then 0 else if y = 0 then 1 else ‚ä§ := by
  rcases lt_trichotomy (0 : ‚Ñù) y with (H | rfl | H)
  ¬∑ simp [H, ne_of_gt, zero_rpow_of_pos, lt_irrefl]
    -- üéâ no goals
  ¬∑ simp [lt_irrefl]
    -- üéâ no goals
  ¬∑ simp [H, asymm H, ne_of_lt, zero_rpow_of_neg]
    -- üéâ no goals
#align ennreal.zero_rpow_def ENNReal.zero_rpow_def

@[simp]
theorem zero_rpow_mul_self (y : ‚Ñù) : (0 : ‚Ñù‚â•0‚àû) ^ y * (0 : ‚Ñù‚â•0‚àû) ^ y = (0 : ‚Ñù‚â•0‚àû) ^ y := by
  rw [zero_rpow_def]
  -- ‚ä¢ ((if 0 < y then 0 else if y = 0 then 1 else ‚ä§) * if 0 < y then 0 else if y = ‚Ä¶
  split_ifs
  exacts [zero_mul _, one_mul _, top_mul_top]
  -- üéâ no goals
#align ennreal.zero_rpow_mul_self ENNReal.zero_rpow_mul_self

@[norm_cast]
theorem coe_rpow_of_ne_zero {x : ‚Ñù‚â•0} (h : x ‚â† 0) (y : ‚Ñù) : (x : ‚Ñù‚â•0‚àû) ^ y = (x ^ y : ‚Ñù‚â•0) := by
  rw [‚Üê ENNReal.some_eq_coe]
  -- ‚ä¢ Option.some x ^ y = ‚Üë(x ^ y)
  dsimp only [(¬∑ ^ ¬∑), Pow.pow, rpow]
  -- ‚ä¢ (if x = 0 ‚àß y < 0 then ‚ä§ else ‚Üë(NNReal.rpow x y)) = ‚Üë(NNReal.rpow x y)
  simp [h]
  -- üéâ no goals
#align ennreal.coe_rpow_of_ne_zero ENNReal.coe_rpow_of_ne_zero

@[norm_cast]
theorem coe_rpow_of_nonneg (x : ‚Ñù‚â•0) {y : ‚Ñù} (h : 0 ‚â§ y) : (x : ‚Ñù‚â•0‚àû) ^ y = (x ^ y : ‚Ñù‚â•0) := by
  by_cases hx : x = 0
  -- ‚ä¢ ‚Üëx ^ y = ‚Üë(x ^ y)
  ¬∑ rcases le_iff_eq_or_lt.1 h with (H | H)
    -- ‚ä¢ ‚Üëx ^ y = ‚Üë(x ^ y)
    ¬∑ simp [hx, H.symm]
      -- üéâ no goals
    ¬∑ simp [hx, zero_rpow_of_pos H, NNReal.zero_rpow (ne_of_gt H)]
      -- üéâ no goals
  ¬∑ exact coe_rpow_of_ne_zero hx _
    -- üéâ no goals
#align ennreal.coe_rpow_of_nonneg ENNReal.coe_rpow_of_nonneg

theorem coe_rpow_def (x : ‚Ñù‚â•0) (y : ‚Ñù) :
    (x : ‚Ñù‚â•0‚àû) ^ y = if x = 0 ‚àß y < 0 then ‚ä§ else (x ^ y : ‚Ñù‚â•0‚àû) :=
  rfl
#align ennreal.coe_rpow_def ENNReal.coe_rpow_def

@[simp]
theorem rpow_one (x : ‚Ñù‚â•0‚àû) : x ^ (1 : ‚Ñù) = x := by
  cases x
  -- ‚ä¢ none ^ 1 = none
  ¬∑ exact dif_pos zero_lt_one
    -- üéâ no goals
  ¬∑ change ite _ _ _ = _
    -- ‚ä¢ (if val‚úù = 0 ‚àß 1 < 0 then ‚ä§ else ‚Üë(val‚úù ^ 1)) = Option.some val‚úù
    simp only [NNReal.rpow_one, some_eq_coe, ite_eq_right_iff, top_ne_coe, and_imp]
    -- ‚ä¢ val‚úù = 0 ‚Üí 1 < 0 ‚Üí False
    exact fun _ => zero_le_one.not_lt
    -- üéâ no goals
#align ennreal.rpow_one ENNReal.rpow_one

@[simp]
theorem one_rpow (x : ‚Ñù) : (1 : ‚Ñù‚â•0‚àû) ^ x = 1 := by
  rw [‚Üê coe_one, coe_rpow_of_ne_zero one_ne_zero]
  -- ‚ä¢ ‚Üë(1 ^ x) = ‚Üë1
  simp
  -- üéâ no goals
#align ennreal.one_rpow ENNReal.one_rpow

@[simp]
theorem rpow_eq_zero_iff {x : ‚Ñù‚â•0‚àû} {y : ‚Ñù} : x ^ y = 0 ‚Üî x = 0 ‚àß 0 < y ‚à® x = ‚ä§ ‚àß y < 0 := by
  cases' x with x
  -- ‚ä¢ none ^ y = 0 ‚Üî none = 0 ‚àß 0 < y ‚à® none = ‚ä§ ‚àß y < 0
  ¬∑ rcases lt_trichotomy y 0 with (H | H | H) <;>
      simp [H, top_rpow_of_neg, top_rpow_of_pos, le_of_lt]
      -- üéâ no goals
      -- üéâ no goals
      -- üéâ no goals
  ¬∑ by_cases h : x = 0
    -- ‚ä¢ Option.some x ^ y = 0 ‚Üî Option.some x = 0 ‚àß 0 < y ‚à® Option.some x = ‚ä§ ‚àß y < 0
    ¬∑ rcases lt_trichotomy y 0 with (H | H | H) <;>
        simp [h, H, zero_rpow_of_neg, zero_rpow_of_pos, le_of_lt]
        -- üéâ no goals
        -- üéâ no goals
        -- üéâ no goals
    ¬∑ simp [coe_rpow_of_ne_zero h, h]
      -- üéâ no goals
#align ennreal.rpow_eq_zero_iff ENNReal.rpow_eq_zero_iff

@[simp]
theorem rpow_eq_top_iff {x : ‚Ñù‚â•0‚àû} {y : ‚Ñù} : x ^ y = ‚ä§ ‚Üî x = 0 ‚àß y < 0 ‚à® x = ‚ä§ ‚àß 0 < y := by
  cases' x with x
  -- ‚ä¢ none ^ y = ‚ä§ ‚Üî none = 0 ‚àß y < 0 ‚à® none = ‚ä§ ‚àß 0 < y
  ¬∑ rcases lt_trichotomy y 0 with (H | H | H) <;>
      simp [H, top_rpow_of_neg, top_rpow_of_pos, le_of_lt]
      -- üéâ no goals
      -- üéâ no goals
      -- üéâ no goals
  ¬∑ by_cases h : x = 0
    -- ‚ä¢ Option.some x ^ y = ‚ä§ ‚Üî Option.some x = 0 ‚àß y < 0 ‚à® Option.some x = ‚ä§ ‚àß 0 < y
    ¬∑ rcases lt_trichotomy y 0 with (H | H | H) <;>
        simp [h, H, zero_rpow_of_neg, zero_rpow_of_pos, le_of_lt]
        -- üéâ no goals
        -- üéâ no goals
        -- üéâ no goals
    ¬∑ simp [coe_rpow_of_ne_zero h, h]
      -- üéâ no goals
#align ennreal.rpow_eq_top_iff ENNReal.rpow_eq_top_iff

theorem rpow_eq_top_iff_of_pos {x : ‚Ñù‚â•0‚àû} {y : ‚Ñù} (hy : 0 < y) : x ^ y = ‚ä§ ‚Üî x = ‚ä§ := by
  simp [rpow_eq_top_iff, hy, asymm hy]
  -- üéâ no goals
#align ennreal.rpow_eq_top_iff_of_pos ENNReal.rpow_eq_top_iff_of_pos

theorem rpow_eq_top_of_nonneg (x : ‚Ñù‚â•0‚àû) {y : ‚Ñù} (hy0 : 0 ‚â§ y) : x ^ y = ‚ä§ ‚Üí x = ‚ä§ := by
  rw [ENNReal.rpow_eq_top_iff]
  -- ‚ä¢ x = 0 ‚àß y < 0 ‚à® x = ‚ä§ ‚àß 0 < y ‚Üí x = ‚ä§
  rintro (h|h)
  -- ‚ä¢ x = ‚ä§
  ¬∑ exfalso
    -- ‚ä¢ False
    rw [lt_iff_not_ge] at h
    -- ‚ä¢ False
    exact h.right hy0
    -- üéâ no goals
  ¬∑ exact h.left
    -- üéâ no goals
#align ennreal.rpow_eq_top_of_nonneg ENNReal.rpow_eq_top_of_nonneg

theorem rpow_ne_top_of_nonneg {x : ‚Ñù‚â•0‚àû} {y : ‚Ñù} (hy0 : 0 ‚â§ y) (h : x ‚â† ‚ä§) : x ^ y ‚â† ‚ä§ :=
  mt (ENNReal.rpow_eq_top_of_nonneg x hy0) h
#align ennreal.rpow_ne_top_of_nonneg ENNReal.rpow_ne_top_of_nonneg

theorem rpow_lt_top_of_nonneg {x : ‚Ñù‚â•0‚àû} {y : ‚Ñù} (hy0 : 0 ‚â§ y) (h : x ‚â† ‚ä§) : x ^ y < ‚ä§ :=
  lt_top_iff_ne_top.mpr (ENNReal.rpow_ne_top_of_nonneg hy0 h)
#align ennreal.rpow_lt_top_of_nonneg ENNReal.rpow_lt_top_of_nonneg

theorem rpow_add {x : ‚Ñù‚â•0‚àû} (y z : ‚Ñù) (hx : x ‚â† 0) (h'x : x ‚â† ‚ä§) : x ^ (y + z) = x ^ y * x ^ z := by
  cases' x with x
  -- ‚ä¢ none ^ (y + z) = none ^ y * none ^ z
  ¬∑ exact (h'x rfl).elim
    -- üéâ no goals
  have : x ‚â† 0 := fun h => by simp [h] at hx
  -- ‚ä¢ Option.some x ^ (y + z) = Option.some x ^ y * Option.some x ^ z
  simp [coe_rpow_of_ne_zero this, NNReal.rpow_add this]
  -- üéâ no goals
#align ennreal.rpow_add ENNReal.rpow_add

theorem rpow_neg (x : ‚Ñù‚â•0‚àû) (y : ‚Ñù) : x ^ (-y) = (x ^ y)‚Åª¬π := by
  cases' x with x
  -- ‚ä¢ none ^ (-y) = (none ^ y)‚Åª¬π
  ¬∑ rcases lt_trichotomy y 0 with (H | H | H) <;>
      simp [top_rpow_of_pos, top_rpow_of_neg, H, neg_pos.mpr]
      -- üéâ no goals
      -- üéâ no goals
      -- üéâ no goals
  ¬∑ by_cases h : x = 0
    -- ‚ä¢ Option.some x ^ (-y) = (Option.some x ^ y)‚Åª¬π
    ¬∑ rcases lt_trichotomy y 0 with (H | H | H) <;>
        simp [h, zero_rpow_of_pos, zero_rpow_of_neg, H, neg_pos.mpr]
        -- üéâ no goals
        -- üéâ no goals
        -- üéâ no goals
    ¬∑ have A : x ^ y ‚â† 0 := by simp [h]
      -- ‚ä¢ Option.some x ^ (-y) = (Option.some x ^ y)‚Åª¬π
      simp [coe_rpow_of_ne_zero h, ‚Üê coe_inv A, NNReal.rpow_neg]
      -- üéâ no goals
#align ennreal.rpow_neg ENNReal.rpow_neg

theorem rpow_sub {x : ‚Ñù‚â•0‚àû} (y z : ‚Ñù) (hx : x ‚â† 0) (h'x : x ‚â† ‚ä§) : x ^ (y - z) = x ^ y / x ^ z := by
  rw [sub_eq_add_neg, rpow_add _ _ hx h'x, rpow_neg, div_eq_mul_inv]
  -- üéâ no goals
#align ennreal.rpow_sub ENNReal.rpow_sub

theorem rpow_neg_one (x : ‚Ñù‚â•0‚àû) : x ^ (-1 : ‚Ñù) = x‚Åª¬π := by simp [rpow_neg]
                                                           -- üéâ no goals
#align ennreal.rpow_neg_one ENNReal.rpow_neg_one

theorem rpow_mul (x : ‚Ñù‚â•0‚àû) (y z : ‚Ñù) : x ^ (y * z) = (x ^ y) ^ z := by
  cases' x with x
  -- ‚ä¢ none ^ (y * z) = (none ^ y) ^ z
  ¬∑ rcases lt_trichotomy y 0 with (Hy | Hy | Hy) <;>
        rcases lt_trichotomy z 0 with (Hz | Hz | Hz) <;>
      simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos,
        mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
  ¬∑ by_cases h : x = 0
    -- ‚ä¢ Option.some x ^ (y * z) = (Option.some x ^ y) ^ z
    ¬∑ rcases lt_trichotomy y 0 with (Hy | Hy | Hy) <;>
          rcases lt_trichotomy z 0 with (Hz | Hz | Hz) <;>
        simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos,
          mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]
    ¬∑ have : x ^ y ‚â† 0 := by simp [h]
      -- ‚ä¢ Option.some x ^ (y * z) = (Option.some x ^ y) ^ z
      simp [coe_rpow_of_ne_zero h, coe_rpow_of_ne_zero this, NNReal.rpow_mul]
      -- üéâ no goals
#align ennreal.rpow_mul ENNReal.rpow_mul

@[simp, norm_cast]
theorem rpow_nat_cast (x : ‚Ñù‚â•0‚àû) (n : ‚Ñï) : x ^ (n : ‚Ñù) = x ^ n := by
  cases x
  -- ‚ä¢ none ^ ‚Üën = none ^ n
  ¬∑ cases n <;> simp [top_rpow_of_pos (Nat.cast_add_one_pos _), top_pow (Nat.succ_pos _)]
    -- ‚ä¢ none ^ ‚ÜëNat.zero = none ^ Nat.zero
                -- üéâ no goals
                -- üéâ no goals
  ¬∑ simp [coe_rpow_of_nonneg _ (Nat.cast_nonneg n)]
    -- üéâ no goals
#align ennreal.rpow_nat_cast ENNReal.rpow_nat_cast

@[simp]
theorem rpow_two (x : ‚Ñù‚â•0‚àû) : x ^ (2 : ‚Ñù) = x ^ 2 := by
  rw [‚Üê rpow_nat_cast]
  -- ‚ä¢ x ^ 2 = x ^ ‚Üë2
  simp only [Nat.cast_ofNat]
  -- üéâ no goals
#align ennreal.rpow_two ENNReal.rpow_two

theorem mul_rpow_eq_ite (x y : ‚Ñù‚â•0‚àû) (z : ‚Ñù) :
    (x * y) ^ z = if (x = 0 ‚àß y = ‚ä§ ‚à® x = ‚ä§ ‚àß y = 0) ‚àß z < 0 then ‚ä§ else x ^ z * y ^ z := by
  rcases eq_or_ne z 0 with (rfl | hz); ¬∑ simp
  -- ‚ä¢ (x * y) ^ 0 = if (x = 0 ‚àß y = ‚ä§ ‚à® x = ‚ä§ ‚àß y = 0) ‚àß 0 < 0 then ‚ä§ else x ^ 0 * ‚Ä¶
                                         -- üéâ no goals
  replace hz := hz.lt_or_lt
  -- ‚ä¢ (x * y) ^ z = if (x = 0 ‚àß y = ‚ä§ ‚à® x = ‚ä§ ‚àß y = 0) ‚àß z < 0 then ‚ä§ else x ^ z * ‚Ä¶
  wlog hxy : x ‚â§ y
  -- ‚ä¢ (x * y) ^ z = if (x = 0 ‚àß y = ‚ä§ ‚à® x = ‚ä§ ‚àß y = 0) ‚àß z < 0 then ‚ä§ else x ^ z * ‚Ä¶
  ¬∑ convert this y x z hz (le_of_not_le hxy) using 2 <;> simp only [mul_comm, and_comm, or_comm]
                                                         -- üéâ no goals
                                                         -- üéâ no goals
                                                         -- üéâ no goals
  rcases eq_or_ne x 0 with (rfl | hx0)
  -- ‚ä¢ (0 * y) ^ z = if (0 = 0 ‚àß y = ‚ä§ ‚à® 0 = ‚ä§ ‚àß y = 0) ‚àß z < 0 then ‚ä§ else 0 ^ z * ‚Ä¶
  ¬∑ induction y using ENNReal.recTopCoe <;> cases' hz with hz hz <;> simp [*, hz.not_lt]
    -- ‚ä¢ (0 * ‚ä§) ^ z = if (0 = 0 ‚àß ‚ä§ = ‚ä§ ‚à® 0 = ‚ä§ ‚àß ‚ä§ = 0) ‚àß z < 0 then ‚ä§ else 0 ^ z * ‚Ä¶
                                            -- ‚ä¢ (0 * ‚ä§) ^ z = if (0 = 0 ‚àß ‚ä§ = ‚ä§ ‚à® 0 = ‚ä§ ‚àß ‚ä§ = 0) ‚àß z < 0 then ‚ä§ else 0 ^ z * ‚Ä¶
                                            -- ‚ä¢ (0 * ‚Üëx‚úù) ^ z = if (0 = 0 ‚àß ‚Üëx‚úù = ‚ä§ ‚à® 0 = ‚ä§ ‚àß ‚Üëx‚úù = 0) ‚àß z < 0 then ‚ä§ else 0 ‚Ä¶
                                                                     -- üéâ no goals
                                                                     -- üéâ no goals
                                                                     -- üéâ no goals
                                                                     -- üéâ no goals
  rcases eq_or_ne y 0 with (rfl | hy0)
  -- ‚ä¢ (x * 0) ^ z = if (x = 0 ‚àß 0 = ‚ä§ ‚à® x = ‚ä§ ‚àß 0 = 0) ‚àß z < 0 then ‚ä§ else x ^ z * ‚Ä¶
  ¬∑ exact (hx0 (bot_unique hxy)).elim
    -- üéâ no goals
  induction x using ENNReal.recTopCoe
  -- ‚ä¢ (‚ä§ * y) ^ z = if (‚ä§ = 0 ‚àß y = ‚ä§ ‚à® ‚ä§ = ‚ä§ ‚àß y = 0) ‚àß z < 0 then ‚ä§ else ‚ä§ ^ z * ‚Ä¶
  ¬∑ cases' hz with hz hz <;> simp [hz, top_unique hxy]
    -- ‚ä¢ (‚ä§ * y) ^ z = if (‚ä§ = 0 ‚àß y = ‚ä§ ‚à® ‚ä§ = ‚ä§ ‚àß y = 0) ‚àß z < 0 then ‚ä§ else ‚ä§ ^ z * ‚Ä¶
                             -- üéâ no goals
                             -- üéâ no goals
  induction y using ENNReal.recTopCoe
  -- ‚ä¢ (‚Üëx‚úù * ‚ä§) ^ z = if (‚Üëx‚úù = 0 ‚àß ‚ä§ = ‚ä§ ‚à® ‚Üëx‚úù = ‚ä§ ‚àß ‚ä§ = 0) ‚àß z < 0 then ‚ä§ else ‚Üë ‚Ä¶
  ¬∑ rw [ne_eq, coe_eq_zero] at hx0
    -- ‚ä¢ (‚Üëx‚úù * ‚ä§) ^ z = if (‚Üëx‚úù = 0 ‚àß ‚ä§ = ‚ä§ ‚à® ‚Üëx‚úù = ‚ä§ ‚àß ‚ä§ = 0) ‚àß z < 0 then ‚ä§ else ‚Üë ‚Ä¶
    cases' hz with hz hz <;> simp [*]
    -- ‚ä¢ (‚Üëx‚úù * ‚ä§) ^ z = if (‚Üëx‚úù = 0 ‚àß ‚ä§ = ‚ä§ ‚à® ‚Üëx‚úù = ‚ä§ ‚àß ‚ä§ = 0) ‚àß z < 0 then ‚ä§ else ‚Üë ‚Ä¶
                             -- üéâ no goals
                             -- üéâ no goals
  simp only [*, false_and_iff, and_false_iff, false_or_iff, if_false]
  -- ‚ä¢ (‚Üëx‚úù¬π * ‚Üëx‚úù) ^ z = ‚Üëx‚úù¬π ^ z * ‚Üëx‚úù ^ z
  norm_cast at *
  -- ‚ä¢ ‚Üë(x‚úù¬π * x‚úù) ^ z = ‚Üëx‚úù¬π ^ z * ‚Üëx‚úù ^ z
  rw [coe_rpow_of_ne_zero (mul_ne_zero hx0 hy0), NNReal.mul_rpow]
  -- ‚ä¢ ‚Üë(x‚úù¬π ^ z * x‚úù ^ z) = ‚Üëx‚úù¬π ^ z * ‚Üëx‚úù ^ z
  norm_cast
  -- üéâ no goals
#align ennreal.mul_rpow_eq_ite ENNReal.mul_rpow_eq_ite

theorem mul_rpow_of_ne_top {x y : ‚Ñù‚â•0‚àû} (hx : x ‚â† ‚ä§) (hy : y ‚â† ‚ä§) (z : ‚Ñù) :
    (x * y) ^ z = x ^ z * y ^ z := by simp [*, mul_rpow_eq_ite]
                                      -- üéâ no goals
#align ennreal.mul_rpow_of_ne_top ENNReal.mul_rpow_of_ne_top

@[norm_cast]
theorem coe_mul_rpow (x y : ‚Ñù‚â•0) (z : ‚Ñù) : ((x : ‚Ñù‚â•0‚àû) * y) ^ z = (x : ‚Ñù‚â•0‚àû) ^ z * (y : ‚Ñù‚â•0‚àû) ^ z :=
  mul_rpow_of_ne_top coe_ne_top coe_ne_top z
#align ennreal.coe_mul_rpow ENNReal.coe_mul_rpow

theorem mul_rpow_of_ne_zero {x y : ‚Ñù‚â•0‚àû} (hx : x ‚â† 0) (hy : y ‚â† 0) (z : ‚Ñù) :
    (x * y) ^ z = x ^ z * y ^ z := by simp [*, mul_rpow_eq_ite]
                                      -- üéâ no goals
#align ennreal.mul_rpow_of_ne_zero ENNReal.mul_rpow_of_ne_zero

theorem mul_rpow_of_nonneg (x y : ‚Ñù‚â•0‚àû) {z : ‚Ñù} (hz : 0 ‚â§ z) : (x * y) ^ z = x ^ z * y ^ z := by
  simp [hz.not_lt, mul_rpow_eq_ite]
  -- üéâ no goals
#align ennreal.mul_rpow_of_nonneg ENNReal.mul_rpow_of_nonneg

theorem inv_rpow (x : ‚Ñù‚â•0‚àû) (y : ‚Ñù) : x‚Åª¬π ^ y = (x ^ y)‚Åª¬π := by
  rcases eq_or_ne y 0 with (rfl | hy); ¬∑ simp only [rpow_zero, inv_one]
  -- ‚ä¢ x‚Åª¬π ^ 0 = (x ^ 0)‚Åª¬π
                                         -- üéâ no goals
  replace hy := hy.lt_or_lt
  -- ‚ä¢ x‚Åª¬π ^ y = (x ^ y)‚Åª¬π
  rcases eq_or_ne x 0 with (rfl | h0); ¬∑ cases hy <;> simp [*]
  -- ‚ä¢ 0‚Åª¬π ^ y = (0 ^ y)‚Åª¬π
                                         -- ‚ä¢ 0‚Åª¬π ^ y = (0 ^ y)‚Åª¬π
                                                      -- üéâ no goals
                                                      -- üéâ no goals
  rcases eq_or_ne x ‚ä§ with (rfl | h_top); ¬∑ cases hy <;> simp [*]
  -- ‚ä¢ ‚ä§‚Åª¬π ^ y = (‚ä§ ^ y)‚Åª¬π
                                            -- ‚ä¢ ‚ä§‚Åª¬π ^ y = (‚ä§ ^ y)‚Åª¬π
                                                         -- üéâ no goals
                                                         -- üéâ no goals
  apply ENNReal.eq_inv_of_mul_eq_one_left
  -- ‚ä¢ x‚Åª¬π ^ y * x ^ y = 1
  rw [‚Üê mul_rpow_of_ne_zero (ENNReal.inv_ne_zero.2 h_top) h0, ENNReal.inv_mul_cancel h0 h_top,
    one_rpow]
#align ennreal.inv_rpow ENNReal.inv_rpow

theorem div_rpow_of_nonneg (x y : ‚Ñù‚â•0‚àû) {z : ‚Ñù} (hz : 0 ‚â§ z) : (x / y) ^ z = x ^ z / y ^ z := by
  rw [div_eq_mul_inv, mul_rpow_of_nonneg _ _ hz, inv_rpow, div_eq_mul_inv]
  -- üéâ no goals
#align ennreal.div_rpow_of_nonneg ENNReal.div_rpow_of_nonneg

theorem strictMono_rpow_of_pos {z : ‚Ñù} (h : 0 < z) : StrictMono fun x : ‚Ñù‚â•0‚àû => x ^ z := by
  intro x y hxy
  -- ‚ä¢ (fun x => x ^ z) x < (fun x => x ^ z) y
  lift x to ‚Ñù‚â•0 using ne_top_of_lt hxy
  -- ‚ä¢ (fun x => x ^ z) ‚Üëx < (fun x => x ^ z) y
  rcases eq_or_ne y ‚àû with (rfl | hy)
  -- ‚ä¢ (fun x => x ^ z) ‚Üëx < (fun x => x ^ z) ‚ä§
  ¬∑ simp only [top_rpow_of_pos h, coe_rpow_of_nonneg _ h.le, coe_lt_top]
    -- üéâ no goals
  ¬∑ lift y to ‚Ñù‚â•0 using hy
    -- ‚ä¢ (fun x => x ^ z) ‚Üëx < (fun x => x ^ z) ‚Üëy
    simp only [coe_rpow_of_nonneg _ h.le, NNReal.rpow_lt_rpow (coe_lt_coe.1 hxy) h, coe_lt_coe]
    -- üéâ no goals
#align ennreal.strict_mono_rpow_of_pos ENNReal.strictMono_rpow_of_pos

theorem monotone_rpow_of_nonneg {z : ‚Ñù} (h : 0 ‚â§ z) : Monotone fun x : ‚Ñù‚â•0‚àû => x ^ z :=
  h.eq_or_lt.elim (fun h0 => h0 ‚ñ∏ by simp only [rpow_zero, monotone_const]) fun h0 =>
                                     -- üéâ no goals
    (strictMono_rpow_of_pos h0).monotone
#align ennreal.monotone_rpow_of_nonneg ENNReal.monotone_rpow_of_nonneg

/-- Bundles `fun x : ‚Ñù‚â•0‚àû => x ^ y` into an order isomorphism when `y : ‚Ñù` is positive,
where the inverse is `fun x : ‚Ñù‚â•0‚àû => x ^ (1 / y)`. -/
@[simps! apply]
def orderIsoRpow (y : ‚Ñù) (hy : 0 < y) : ‚Ñù‚â•0‚àû ‚âÉo ‚Ñù‚â•0‚àû :=
  (strictMono_rpow_of_pos hy).orderIsoOfRightInverse (fun x => x ^ y) (fun x => x ^ (1 / y))
    fun x => by
    dsimp
    -- ‚ä¢ (x ^ (1 / y)) ^ y = x
    rw [‚Üê rpow_mul, one_div_mul_cancel hy.ne.symm, rpow_one]
    -- üéâ no goals
#align ennreal.order_iso_rpow ENNReal.orderIsoRpow

theorem orderIsoRpow_symm_apply (y : ‚Ñù) (hy : 0 < y) :
    (orderIsoRpow y hy).symm = orderIsoRpow (1 / y) (one_div_pos.2 hy) := by
  simp only [orderIsoRpow, one_div_one_div]
  -- ‚ä¢ OrderIso.symm (StrictMono.orderIsoOfRightInverse (fun x => x ^ y) (_ : Stric ‚Ä¶
  rfl
  -- üéâ no goals
#align ennreal.order_iso_rpow_symm_apply ENNReal.orderIsoRpow_symm_apply

theorem rpow_le_rpow {x y : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (h‚ÇÅ : x ‚â§ y) (h‚ÇÇ : 0 ‚â§ z) : x ^ z ‚â§ y ^ z :=
  monotone_rpow_of_nonneg h‚ÇÇ h‚ÇÅ
#align ennreal.rpow_le_rpow ENNReal.rpow_le_rpow

theorem rpow_lt_rpow {x y : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (h‚ÇÅ : x < y) (h‚ÇÇ : 0 < z) : x ^ z < y ^ z :=
  strictMono_rpow_of_pos h‚ÇÇ h‚ÇÅ
#align ennreal.rpow_lt_rpow ENNReal.rpow_lt_rpow

theorem rpow_le_rpow_iff {x y : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (hz : 0 < z) : x ^ z ‚â§ y ^ z ‚Üî x ‚â§ y :=
  (strictMono_rpow_of_pos hz).le_iff_le
#align ennreal.rpow_le_rpow_iff ENNReal.rpow_le_rpow_iff

theorem rpow_lt_rpow_iff {x y : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (hz : 0 < z) : x ^ z < y ^ z ‚Üî x < y :=
  (strictMono_rpow_of_pos hz).lt_iff_lt
#align ennreal.rpow_lt_rpow_iff ENNReal.rpow_lt_rpow_iff

theorem le_rpow_one_div_iff {x y : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (hz : 0 < z) : x ‚â§ y ^ (1 / z) ‚Üî x ^ z ‚â§ y := by
  nth_rw 1 [‚Üê rpow_one x]
  -- ‚ä¢ x ^ 1 ‚â§ y ^ (1 / z) ‚Üî x ^ z ‚â§ y
  nth_rw 1 [‚Üê @_root_.mul_inv_cancel _ _ z hz.ne']
  -- ‚ä¢ x ^ (z * z‚Åª¬π) ‚â§ y ^ (1 / z) ‚Üî x ^ z ‚â§ y
  rw [rpow_mul, ‚Üê one_div, @rpow_le_rpow_iff _ _ (1 / z) (by simp [hz])]
  -- üéâ no goals
#align ennreal.le_rpow_one_div_iff ENNReal.le_rpow_one_div_iff

theorem lt_rpow_one_div_iff {x y : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (hz : 0 < z) : x < y ^ (1 / z) ‚Üî x ^ z < y := by
  nth_rw 1 [‚Üê rpow_one x]
  -- ‚ä¢ x ^ 1 < y ^ (1 / z) ‚Üî x ^ z < y
  nth_rw 1 [‚Üê @_root_.mul_inv_cancel _ _ z (ne_of_lt hz).symm]
  -- ‚ä¢ x ^ (z * z‚Åª¬π) < y ^ (1 / z) ‚Üî x ^ z < y
  rw [rpow_mul, ‚Üê one_div, @rpow_lt_rpow_iff _ _ (1 / z) (by simp [hz])]
  -- üéâ no goals
#align ennreal.lt_rpow_one_div_iff ENNReal.lt_rpow_one_div_iff

theorem rpow_one_div_le_iff {x y : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (hz : 0 < z) : x ^ (1 / z) ‚â§ y ‚Üî x ‚â§ y ^ z := by
  nth_rw 1 [‚Üê ENNReal.rpow_one y]
  -- ‚ä¢ x ^ (1 / z) ‚â§ y ^ 1 ‚Üî x ‚â§ y ^ z
  nth_rw 2 [‚Üê @_root_.mul_inv_cancel _ _ z hz.ne.symm]
  -- ‚ä¢ x ^ (1 / z) ‚â§ y ^ (z * z‚Åª¬π) ‚Üî x ‚â§ y ^ z
  rw [ENNReal.rpow_mul, ‚Üê one_div, ENNReal.rpow_le_rpow_iff (one_div_pos.2 hz)]
  -- üéâ no goals
#align ennreal.rpow_one_div_le_iff ENNReal.rpow_one_div_le_iff

theorem rpow_lt_rpow_of_exponent_lt {x : ‚Ñù‚â•0‚àû} {y z : ‚Ñù} (hx : 1 < x) (hx' : x ‚â† ‚ä§) (hyz : y < z) :
    x ^ y < x ^ z := by
  lift x to ‚Ñù‚â•0 using hx'
  -- ‚ä¢ ‚Üëx ^ y < ‚Üëx ^ z
  rw [one_lt_coe_iff] at hx
  -- ‚ä¢ ‚Üëx ^ y < ‚Üëx ^ z
  simp [coe_rpow_of_ne_zero (ne_of_gt (lt_trans zero_lt_one hx)),
    NNReal.rpow_lt_rpow_of_exponent_lt hx hyz]
#align ennreal.rpow_lt_rpow_of_exponent_lt ENNReal.rpow_lt_rpow_of_exponent_lt

theorem rpow_le_rpow_of_exponent_le {x : ‚Ñù‚â•0‚àû} {y z : ‚Ñù} (hx : 1 ‚â§ x) (hyz : y ‚â§ z) :
    x ^ y ‚â§ x ^ z := by
  cases x
  -- ‚ä¢ none ^ y ‚â§ none ^ z
  ¬∑ rcases lt_trichotomy y 0 with (Hy | Hy | Hy) <;>
    rcases lt_trichotomy z 0 with (Hz | Hz | Hz) <;>
    simp [Hy, Hz, top_rpow_of_neg, top_rpow_of_pos, le_refl] <;>
    -- üéâ no goals
    -- üéâ no goals
    -- üéâ no goals
    -- ‚ä¢ False
    -- üéâ no goals
    -- üéâ no goals
    -- ‚ä¢ False
    -- ‚ä¢ False
    -- üéâ no goals
    linarith
    -- üéâ no goals
    -- üéâ no goals
    -- üéâ no goals
  ¬∑ simp only [one_le_coe_iff, some_eq_coe] at hx
    -- ‚ä¢ Option.some val‚úù ^ y ‚â§ Option.some val‚úù ^ z
    simp [coe_rpow_of_ne_zero (ne_of_gt (lt_of_lt_of_le zero_lt_one hx)),
      NNReal.rpow_le_rpow_of_exponent_le hx hyz]
#align ennreal.rpow_le_rpow_of_exponent_le ENNReal.rpow_le_rpow_of_exponent_le

theorem rpow_lt_rpow_of_exponent_gt {x : ‚Ñù‚â•0‚àû} {y z : ‚Ñù} (hx0 : 0 < x) (hx1 : x < 1) (hyz : z < y) :
    x ^ y < x ^ z := by
  lift x to ‚Ñù‚â•0 using ne_of_lt (lt_of_lt_of_le hx1 le_top)
  -- ‚ä¢ ‚Üëx ^ y < ‚Üëx ^ z
  simp only [coe_lt_one_iff, coe_pos] at hx0 hx1
  -- ‚ä¢ ‚Üëx ^ y < ‚Üëx ^ z
  simp [coe_rpow_of_ne_zero (ne_of_gt hx0), NNReal.rpow_lt_rpow_of_exponent_gt hx0 hx1 hyz]
  -- üéâ no goals
#align ennreal.rpow_lt_rpow_of_exponent_gt ENNReal.rpow_lt_rpow_of_exponent_gt

theorem rpow_le_rpow_of_exponent_ge {x : ‚Ñù‚â•0‚àû} {y z : ‚Ñù} (hx1 : x ‚â§ 1) (hyz : z ‚â§ y) :
    x ^ y ‚â§ x ^ z := by
  lift x to ‚Ñù‚â•0 using ne_of_lt (lt_of_le_of_lt hx1 coe_lt_top)
  -- ‚ä¢ ‚Üëx ^ y ‚â§ ‚Üëx ^ z
  by_cases h : x = 0
  -- ‚ä¢ ‚Üëx ^ y ‚â§ ‚Üëx ^ z
  ¬∑ rcases lt_trichotomy y 0 with (Hy | Hy | Hy) <;>
    rcases lt_trichotomy z 0 with (Hz | Hz | Hz) <;>
    simp [Hy, Hz, h, zero_rpow_of_neg, zero_rpow_of_pos, le_refl] <;>
    -- üéâ no goals
    -- ‚ä¢ False
    -- ‚ä¢ False
    -- üéâ no goals
    -- üéâ no goals
    -- ‚ä¢ False
    -- üéâ no goals
    -- üéâ no goals
    -- üéâ no goals
    linarith
    -- üéâ no goals
    -- üéâ no goals
    -- üéâ no goals
  ¬∑ rw [coe_le_one_iff] at hx1
    -- ‚ä¢ ‚Üëx ^ y ‚â§ ‚Üëx ^ z
    simp [coe_rpow_of_ne_zero h,
      NNReal.rpow_le_rpow_of_exponent_ge (bot_lt_iff_ne_bot.mpr h) hx1 hyz]
#align ennreal.rpow_le_rpow_of_exponent_ge ENNReal.rpow_le_rpow_of_exponent_ge

theorem rpow_le_self_of_le_one {x : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (hx : x ‚â§ 1) (h_one_le : 1 ‚â§ z) : x ^ z ‚â§ x := by
  nth_rw 2 [‚Üê ENNReal.rpow_one x]
  -- ‚ä¢ x ^ z ‚â§ x ^ 1
  exact ENNReal.rpow_le_rpow_of_exponent_ge hx h_one_le
  -- üéâ no goals
#align ennreal.rpow_le_self_of_le_one ENNReal.rpow_le_self_of_le_one

theorem le_rpow_self_of_one_le {x : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (hx : 1 ‚â§ x) (h_one_le : 1 ‚â§ z) : x ‚â§ x ^ z := by
  nth_rw 1 [‚Üê ENNReal.rpow_one x]
  -- ‚ä¢ x ^ 1 ‚â§ x ^ z
  exact ENNReal.rpow_le_rpow_of_exponent_le hx h_one_le
  -- üéâ no goals
#align ennreal.le_rpow_self_of_one_le ENNReal.le_rpow_self_of_one_le

theorem rpow_pos_of_nonneg {p : ‚Ñù} {x : ‚Ñù‚â•0‚àû} (hx_pos : 0 < x) (hp_nonneg : 0 ‚â§ p) : 0 < x ^ p := by
  by_cases hp_zero : p = 0
  -- ‚ä¢ 0 < x ^ p
  ¬∑ simp [hp_zero, zero_lt_one]
    -- üéâ no goals
  ¬∑ rw [‚Üê Ne.def] at hp_zero
    -- ‚ä¢ 0 < x ^ p
    have hp_pos := lt_of_le_of_ne hp_nonneg hp_zero.symm
    -- ‚ä¢ 0 < x ^ p
    rw [‚Üê zero_rpow_of_pos hp_pos]
    -- ‚ä¢ 0 ^ p < x ^ p
    exact rpow_lt_rpow hx_pos hp_pos
    -- üéâ no goals
#align ennreal.rpow_pos_of_nonneg ENNReal.rpow_pos_of_nonneg

theorem rpow_pos {p : ‚Ñù} {x : ‚Ñù‚â•0‚àû} (hx_pos : 0 < x) (hx_ne_top : x ‚â† ‚ä§) : 0 < x ^ p := by
  cases' lt_or_le 0 p with hp_pos hp_nonpos
  -- ‚ä¢ 0 < x ^ p
  ¬∑ exact rpow_pos_of_nonneg hx_pos (le_of_lt hp_pos)
    -- üéâ no goals
  ¬∑ rw [‚Üê neg_neg p, rpow_neg, ENNReal.inv_pos]
    -- ‚ä¢ x ^ (-p) ‚â† ‚ä§
    exact rpow_ne_top_of_nonneg (Right.nonneg_neg_iff.mpr hp_nonpos) hx_ne_top
    -- üéâ no goals
#align ennreal.rpow_pos ENNReal.rpow_pos

theorem rpow_lt_one {x : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (hx : x < 1) (hz : 0 < z) : x ^ z < 1 := by
  lift x to ‚Ñù‚â•0 using ne_of_lt (lt_of_lt_of_le hx le_top)
  -- ‚ä¢ ‚Üëx ^ z < 1
  simp only [coe_lt_one_iff] at hx
  -- ‚ä¢ ‚Üëx ^ z < 1
  simp [coe_rpow_of_nonneg _ (le_of_lt hz), NNReal.rpow_lt_one hx hz]
  -- üéâ no goals
#align ennreal.rpow_lt_one ENNReal.rpow_lt_one

theorem rpow_le_one {x : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (hx : x ‚â§ 1) (hz : 0 ‚â§ z) : x ^ z ‚â§ 1 := by
  lift x to ‚Ñù‚â•0 using ne_of_lt (lt_of_le_of_lt hx coe_lt_top)
  -- ‚ä¢ ‚Üëx ^ z ‚â§ 1
  simp only [coe_le_one_iff] at hx
  -- ‚ä¢ ‚Üëx ^ z ‚â§ 1
  simp [coe_rpow_of_nonneg _ hz, NNReal.rpow_le_one hx hz]
  -- üéâ no goals
#align ennreal.rpow_le_one ENNReal.rpow_le_one

theorem rpow_lt_one_of_one_lt_of_neg {x : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (hx : 1 < x) (hz : z < 0) : x ^ z < 1 := by
  cases x
  -- ‚ä¢ none ^ z < 1
  ¬∑ simp [top_rpow_of_neg hz, zero_lt_one]
    -- üéâ no goals
  ¬∑ simp only [some_eq_coe, one_lt_coe_iff] at hx
    -- ‚ä¢ Option.some val‚úù ^ z < 1
    simp [coe_rpow_of_ne_zero (ne_of_gt (lt_trans zero_lt_one hx)),
      NNReal.rpow_lt_one_of_one_lt_of_neg hx hz]
#align ennreal.rpow_lt_one_of_one_lt_of_neg ENNReal.rpow_lt_one_of_one_lt_of_neg

theorem rpow_le_one_of_one_le_of_neg {x : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (hx : 1 ‚â§ x) (hz : z < 0) : x ^ z ‚â§ 1 := by
  cases x
  -- ‚ä¢ none ^ z ‚â§ 1
  ¬∑ simp [top_rpow_of_neg hz, zero_lt_one]
    -- üéâ no goals
  ¬∑ simp only [one_le_coe_iff, some_eq_coe] at hx
    -- ‚ä¢ Option.some val‚úù ^ z ‚â§ 1
    simp [coe_rpow_of_ne_zero (ne_of_gt (lt_of_lt_of_le zero_lt_one hx)),
      NNReal.rpow_le_one_of_one_le_of_nonpos hx (le_of_lt hz)]
#align ennreal.rpow_le_one_of_one_le_of_neg ENNReal.rpow_le_one_of_one_le_of_neg

theorem one_lt_rpow {x : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (hx : 1 < x) (hz : 0 < z) : 1 < x ^ z := by
  cases x
  -- ‚ä¢ 1 < none ^ z
  ¬∑ simp [top_rpow_of_pos hz]
    -- üéâ no goals
  ¬∑ simp only [some_eq_coe, one_lt_coe_iff] at hx
    -- ‚ä¢ 1 < Option.some val‚úù ^ z
    simp [coe_rpow_of_nonneg _ (le_of_lt hz), NNReal.one_lt_rpow hx hz]
    -- üéâ no goals
#align ennreal.one_lt_rpow ENNReal.one_lt_rpow

theorem one_le_rpow {x : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (hx : 1 ‚â§ x) (hz : 0 < z) : 1 ‚â§ x ^ z := by
  cases x
  -- ‚ä¢ 1 ‚â§ none ^ z
  ¬∑ simp [top_rpow_of_pos hz]
    -- üéâ no goals
  ¬∑ simp only [one_le_coe_iff, some_eq_coe] at hx
    -- ‚ä¢ 1 ‚â§ Option.some val‚úù ^ z
    simp [coe_rpow_of_nonneg _ (le_of_lt hz), NNReal.one_le_rpow hx (le_of_lt hz)]
    -- üéâ no goals
#align ennreal.one_le_rpow ENNReal.one_le_rpow

theorem one_lt_rpow_of_pos_of_lt_one_of_neg {x : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (hx1 : 0 < x) (hx2 : x < 1)
    (hz : z < 0) : 1 < x ^ z := by
  lift x to ‚Ñù‚â•0 using ne_of_lt (lt_of_lt_of_le hx2 le_top)
  -- ‚ä¢ 1 < ‚Üëx ^ z
  simp only [coe_lt_one_iff, coe_pos] at hx1 hx2 ‚ä¢
  -- ‚ä¢ 1 < ‚Üëx ^ z
  simp [coe_rpow_of_ne_zero (ne_of_gt hx1), NNReal.one_lt_rpow_of_pos_of_lt_one_of_neg hx1 hx2 hz]
  -- üéâ no goals
#align ennreal.one_lt_rpow_of_pos_of_lt_one_of_neg ENNReal.one_lt_rpow_of_pos_of_lt_one_of_neg

theorem one_le_rpow_of_pos_of_le_one_of_neg {x : ‚Ñù‚â•0‚àû} {z : ‚Ñù} (hx1 : 0 < x) (hx2 : x ‚â§ 1)
    (hz : z < 0) : 1 ‚â§ x ^ z := by
  lift x to ‚Ñù‚â•0 using ne_of_lt (lt_of_le_of_lt hx2 coe_lt_top)
  -- ‚ä¢ 1 ‚â§ ‚Üëx ^ z
  simp only [coe_le_one_iff, coe_pos] at hx1 hx2 ‚ä¢
  -- ‚ä¢ 1 ‚â§ ‚Üëx ^ z
  simp [coe_rpow_of_ne_zero (ne_of_gt hx1),
    NNReal.one_le_rpow_of_pos_of_le_one_of_nonpos hx1 hx2 (le_of_lt hz)]
#align ennreal.one_le_rpow_of_pos_of_le_one_of_neg ENNReal.one_le_rpow_of_pos_of_le_one_of_neg

theorem toNNReal_rpow (x : ‚Ñù‚â•0‚àû) (z : ‚Ñù) : x.toNNReal ^ z = (x ^ z).toNNReal := by
  rcases lt_trichotomy z 0 with (H | H | H)
  ¬∑ cases' x with x
    -- ‚ä¢ ENNReal.toNNReal none ^ z = ENNReal.toNNReal (none ^ z)
    ¬∑ simp [H, ne_of_lt]
      -- üéâ no goals
    by_cases hx : x = 0
    -- ‚ä¢ ENNReal.toNNReal (Option.some x) ^ z = ENNReal.toNNReal (Option.some x ^ z)
    ¬∑ simp [hx, H, ne_of_lt]
      -- üéâ no goals
    ¬∑ simp [coe_rpow_of_ne_zero hx]
      -- üéâ no goals
  ¬∑ simp [H]
    -- üéâ no goals
  ¬∑ cases x
    -- ‚ä¢ ENNReal.toNNReal none ^ z = ENNReal.toNNReal (none ^ z)
    ¬∑ simp [H, ne_of_gt]
      -- üéâ no goals
    simp [coe_rpow_of_nonneg _ (le_of_lt H)]
    -- üéâ no goals
#align ennreal.to_nnreal_rpow ENNReal.toNNReal_rpow

theorem toReal_rpow (x : ‚Ñù‚â•0‚àû) (z : ‚Ñù) : x.toReal ^ z = (x ^ z).toReal := by
  rw [ENNReal.toReal, ENNReal.toReal, ‚Üê NNReal.coe_rpow, ENNReal.toNNReal_rpow]
  -- üéâ no goals
#align ennreal.to_real_rpow ENNReal.toReal_rpow

theorem ofReal_rpow_of_pos {x p : ‚Ñù} (hx_pos : 0 < x) :
    ENNReal.ofReal x ^ p = ENNReal.ofReal (x ^ p) := by
  simp_rw [ENNReal.ofReal]
  -- ‚ä¢ ‚Üë(toNNReal x) ^ p = ‚Üë(toNNReal (x ^ p))
  rw [coe_rpow_of_ne_zero, coe_eq_coe, Real.toNNReal_rpow_of_nonneg hx_pos.le]
  -- ‚ä¢ toNNReal x ‚â† 0
  simp [hx_pos]
  -- üéâ no goals
#align ennreal.of_real_rpow_of_pos ENNReal.ofReal_rpow_of_pos

theorem ofReal_rpow_of_nonneg {x p : ‚Ñù} (hx_nonneg : 0 ‚â§ x) (hp_nonneg : 0 ‚â§ p) :
    ENNReal.ofReal x ^ p = ENNReal.ofReal (x ^ p) := by
  by_cases hp0 : p = 0
  -- ‚ä¢ ENNReal.ofReal x ^ p = ENNReal.ofReal (x ^ p)
  ¬∑ simp [hp0]
    -- üéâ no goals
  by_cases hx0 : x = 0
  -- ‚ä¢ ENNReal.ofReal x ^ p = ENNReal.ofReal (x ^ p)
  ¬∑ rw [‚Üê Ne.def] at hp0
    -- ‚ä¢ ENNReal.ofReal x ^ p = ENNReal.ofReal (x ^ p)
    have hp_pos : 0 < p := lt_of_le_of_ne hp_nonneg hp0.symm
    -- ‚ä¢ ENNReal.ofReal x ^ p = ENNReal.ofReal (x ^ p)
    simp [hx0, hp_pos, hp_pos.ne.symm]
    -- üéâ no goals
  rw [‚Üê Ne.def] at hx0
  -- ‚ä¢ ENNReal.ofReal x ^ p = ENNReal.ofReal (x ^ p)
  exact ofReal_rpow_of_pos (hx_nonneg.lt_of_ne hx0.symm)
  -- üéâ no goals
#align ennreal.of_real_rpow_of_nonneg ENNReal.ofReal_rpow_of_nonneg

theorem rpow_left_injective {x : ‚Ñù} (hx : x ‚â† 0) : Function.Injective fun y : ‚Ñù‚â•0‚àû => y ^ x := by
  intro y z hyz
  -- ‚ä¢ y = z
  dsimp only at hyz
  -- ‚ä¢ y = z
  rw [‚Üê rpow_one y, ‚Üê rpow_one z, ‚Üê _root_.mul_inv_cancel hx, rpow_mul, rpow_mul, hyz]
  -- üéâ no goals
#align ennreal.rpow_left_injective ENNReal.rpow_left_injective

theorem rpow_left_surjective {x : ‚Ñù} (hx : x ‚â† 0) : Function.Surjective fun y : ‚Ñù‚â•0‚àû => y ^ x :=
  fun y => ‚ü®y ^ x‚Åª¬π, by simp_rw [‚Üê rpow_mul, _root_.inv_mul_cancel hx, rpow_one]‚ü©
                        -- üéâ no goals
#align ennreal.rpow_left_surjective ENNReal.rpow_left_surjective

theorem rpow_left_bijective {x : ‚Ñù} (hx : x ‚â† 0) : Function.Bijective fun y : ‚Ñù‚â•0‚àû => y ^ x :=
  ‚ü®rpow_left_injective hx, rpow_left_surjective hx‚ü©
#align ennreal.rpow_left_bijective ENNReal.rpow_left_bijective

end ENNReal

-- Porting note(https://github.com/leanprover-community/mathlib4/issues/6038): restore
-- section Tactics

-- /-!
-- ## Tactic extensions for powers on `‚Ñù‚â•0` and `‚Ñù‚â•0‚àû`
-- -/


-- namespace NormNum

-- theorem nnrpow_pos (a : ‚Ñù‚â•0) (b : ‚Ñù) (b' : ‚Ñï) (c : ‚Ñù‚â•0) (hb : b = b') (h : a ^ b' = c) :
--     a ^ b = c := by rw [‚Üê h, hb, NNReal.rpow_nat_cast]
-- #align norm_num.nnrpow_pos NormNum.nnrpow_pos

-- theorem nnrpow_neg (a : ‚Ñù‚â•0) (b : ‚Ñù) (b' : ‚Ñï) (c c' : ‚Ñù‚â•0) (hb : b = b') (h : a ^ b' = c)
--     (hc : c‚Åª¬π = c') : a ^ (-b) = c' := by
--   rw [‚Üê hc, ‚Üê h, hb, NNReal.rpow_neg, NNReal.rpow_nat_cast]
-- #align norm_num.nnrpow_neg NormNum.nnrpow_neg

-- theorem ennrpow_pos (a : ‚Ñù‚â•0‚àû) (b : ‚Ñù) (b' : ‚Ñï) (c : ‚Ñù‚â•0‚àû) (hb : b = b') (h : a ^ b' = c) :
--     a ^ b = c := by rw [‚Üê h, hb, ENNReal.rpow_nat_cast]
-- #align norm_num.ennrpow_pos NormNum.ennrpow_pos

-- theorem ennrpow_neg (a : ‚Ñù‚â•0‚àû) (b : ‚Ñù) (b' : ‚Ñï) (c c' : ‚Ñù‚â•0‚àû) (hb : b = b') (h : a ^ b' = c)
--     (hc : c‚Åª¬π = c') : a ^ (-b) = c' := by
--   rw [‚Üê hc, ‚Üê h, hb, ENNReal.rpow_neg, ENNReal.rpow_nat_cast]
-- #align norm_num.ennrpow_neg NormNum.ennrpow_neg

-- /-- Evaluate `NNReal.rpow a b` where `a` is a rational numeral and `b` is an integer. -/
-- unsafe def prove_nnrpow : expr ‚Üí expr ‚Üí tactic (expr √ó expr) :=
--   prove_rpow' `` nnrpow_pos `` nnrpow_neg `` NNReal.rpow_zero q(‚Ñù‚â•0) q(‚Ñù) q((1 : ‚Ñù‚â•0))
-- #align norm_num.prove_nnrpow norm_num.prove_nnrpow

-- /-- Evaluate `ENNReal.rpow a b` where `a` is a rational numeral and `b` is an integer. -/
-- unsafe def prove_ennrpow : expr ‚Üí expr ‚Üí tactic (expr √ó expr) :=
--   prove_rpow' `` ennrpow_pos `` ennrpow_neg `` ENNReal.rpow_zero q(‚Ñù‚â•0‚àû) q(‚Ñù) q((1 : ‚Ñù‚â•0‚àû))
-- #align norm_num.prove_ennrpow norm_num.prove_ennrpow

-- /-- Evaluates expressions of the form `rpow a b` and `a ^ b` in the special case where
-- `b` is an integer and `a` is a positive rational (so it's really just a rational power). -/
-- @[norm_num]
-- unsafe def eval_nnrpow_ennrpow : expr ‚Üí tactic (expr √ó expr)
--   | q(@Pow.pow _ _ NNReal.Real.hasPow $(a) $(b)) => b.to_int >> prove_nnrpow a b
--   | q(NNReal.rpow $(a) $(b)) => b.to_int >> prove_nnrpow a b
--   | q(@Pow.pow _ _ ENNReal.Real.hasPow $(a) $(b)) => b.to_int >> prove_ennrpow a b
--   | q(ENNReal.rpow $(a) $(b)) => b.to_int >> prove_ennrpow a b
--   | _ => tactic.failed
-- #align norm_num.eval_nnrpow_ennrpow norm_num.eval_nnrpow_ennrpow

-- end NormNum

-- namespace Tactic

-- namespace Positivity

-- private theorem nnrpow_pos {a : ‚Ñù‚â•0} (ha : 0 < a) (b : ‚Ñù) : 0 < a ^ b :=
--   NNReal.rpow_pos ha
-- #align tactic.positivity.nnrpow_pos tactic.positivity.nnrpow_pos

-- /-- Auxiliary definition for the `positivity` tactic to handle real powers of nonnegative reals.
-- -/
-- unsafe def prove_nnrpow (a b : expr) : tactic strictness := do
--   let strictness_a ‚Üê core a
--   match strictness_a with
--     | positive p => positive <$> mk_app `` nnrpow_pos [p, b]
--     | _ => failed
-- #align tactic.positivity.prove_nnrpow tactic.positivity.prove_nnrpow

-- -- We already know `0 ‚â§ x` for all `x : ‚Ñù‚â•0`
-- private theorem ennrpow_pos {a : ‚Ñù‚â•0‚àû} {b : ‚Ñù} (ha : 0 < a) (hb : 0 < b) : 0 < a ^ b :=
--   ENNReal.rpow_pos_of_nonneg ha hb.le
-- #align tactic.positivity.ennrpow_pos tactic.positivity.ennrpow_pos

-- /-- Auxiliary definition for the `positivity` tactic to handle real powers of extended
-- nonnegative reals. -/
-- unsafe def prove_ennrpow (a b : expr) : tactic strictness := do
--   let strictness_a ‚Üê core a
--   let strictness_b ‚Üê core b
--   match strictness_a, strictness_b with
--     | positive pa, positive pb => positive <$> mk_app `` ennrpow_pos [pa, pb]
--     | positive pa, nonnegative pb => positive <$> mk_app `` ENNReal.rpow_pos_of_nonneg [pa, pb]
--     | _, _ => failed
-- #align tactic.positivity.prove_ennrpow tactic.positivity.prove_ennrpow

-- -- We already know `0 ‚â§ x` for all `x : ‚Ñù‚â•0‚àû`
-- end Positivity

-- open Positivity

-- /-- Extension for the `positivity` tactic: exponentiation by a real number is nonnegative when
-- the base is nonnegative and positive when the base is positive. -/
-- @[positivity]
-- unsafe def positivity_nnrpow_ennrpow : expr ‚Üí tactic strictness
--   | q(@Pow.pow _ _ NNReal.Real.hasPow $(a) $(b)) => prove_nnrpow a b
--   | q(NNReal.rpow $(a) $(b)) => prove_nnrpow a b
--   | q(@Pow.pow _ _ ENNReal.Real.hasPow $(a) $(b)) => prove_ennrpow a b
--   | q(ENNReal.rpow $(a) $(b)) => prove_ennrpow a b
--   | _ => failed
-- #align tactic.positivity_nnrpow_ennrpow tactic.positivity_nnrpow_ennrpow

-- end Tactic

-- end Tactics
