/-
Copyright (c) 2023 David Loeffler. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: David Loeffler
-/
import Mathlib.Analysis.SpecialFunctions.Integrals
import Mathlib.MeasureTheory.Integral.PeakFunction

#align_import analysis.special_functions.trigonometric.euler_sine_prod from "leanprover-community/mathlib"@"2c1d8ca2812b64f88992a5294ea3dba144755cd1"

/-! # Euler's infinite product for the sine function

This file proves the infinite product formula

$$ \sin \pi z = \pi z \prod_{n = 1}^\infty \left(1 - \frac{z ^ 2}{n ^ 2}\right) $$

for any real or complex `z`. Our proof closely follows the article
[Salwinski, *Euler's Sine Product Formula: An Elementary Proof*][salwinski2018]: the basic strategy
is to prove a recurrence relation for the integrals `‚à´ x in 0..œÄ/2, cos 2 z x * cos x ^ (2 * n)`,
generalising the arguments used to prove Wallis' limit formula for `œÄ`.
-/


local macro_rules | `($x ^ $y) => `(HPow.hPow $x $y) -- Porting note: See issue lean4#2220

open scoped Real Topology BigOperators

open Real Set Filter intervalIntegral MeasureTheory.MeasureSpace

namespace EulerSine

section IntegralRecursion

/-! ## Recursion formula for the integral of `cos (2 * z * x) * cos x ^ n`

We evaluate the integral of `cos (2 * z * x) * cos x ^ n`, for any complex `z` and even integers
`n`, via repeated integration by parts. -/


variable {z : ‚ÑÇ} {n : ‚Ñï}

theorem antideriv_cos_comp_const_mul (hz : z ‚â† 0) (x : ‚Ñù) :
    HasDerivAt (fun y : ‚Ñù => Complex.sin (2 * z * y) / (2 * z)) (Complex.cos (2 * z * x)) x := by
  have a : HasDerivAt (fun y : ‚ÑÇ => y * (2 * z)) _ x := hasDerivAt_mul_const _
  -- ‚ä¢ HasDerivAt (fun y => Complex.sin (2 * z * ‚Üëy) / (2 * z)) (Complex.cos (2 * z ‚Ä¶
  have b : HasDerivAt (fun y : ‚ÑÇ => Complex.sin (y * (2 * z))) _ x :=
    HasDerivAt.comp (x : ‚ÑÇ) (Complex.hasDerivAt_sin (x * (2 * z))) a
  have c := b.comp_ofReal.div_const (2 * z)
  -- ‚ä¢ HasDerivAt (fun y => Complex.sin (2 * z * ‚Üëy) / (2 * z)) (Complex.cos (2 * z ‚Ä¶
  field_simp at c; simp only [fun y => mul_comm y (2 * z)] at c
  -- ‚ä¢ HasDerivAt (fun y => Complex.sin (2 * z * ‚Üëy) / (2 * z)) (Complex.cos (2 * z ‚Ä¶
                   -- ‚ä¢ HasDerivAt (fun y => Complex.sin (2 * z * ‚Üëy) / (2 * z)) (Complex.cos (2 * z ‚Ä¶
  exact c
  -- üéâ no goals
#align euler_sine.antideriv_cos_comp_const_mul EulerSine.antideriv_cos_comp_const_mul

theorem antideriv_sin_comp_const_mul (hz : z ‚â† 0) (x : ‚Ñù) :
    HasDerivAt (fun y : ‚Ñù => -Complex.cos (2 * z * y) / (2 * z)) (Complex.sin (2 * z * x)) x := by
  have a : HasDerivAt (fun y : ‚ÑÇ => y * (2 * z)) _ x := hasDerivAt_mul_const _
  -- ‚ä¢ HasDerivAt (fun y => -Complex.cos (2 * z * ‚Üëy) / (2 * z)) (Complex.sin (2 *  ‚Ä¶
  have b : HasDerivAt (fun y : ‚ÑÇ => Complex.cos (y * (2 * z))) _ x :=
    HasDerivAt.comp (x : ‚ÑÇ) (Complex.hasDerivAt_cos (x * (2 * z))) a
  have c := (b.comp_ofReal.div_const (2 * z)).neg
  -- ‚ä¢ HasDerivAt (fun y => -Complex.cos (2 * z * ‚Üëy) / (2 * z)) (Complex.sin (2 *  ‚Ä¶
  field_simp at c; simp only [fun y => mul_comm y (2 * z)] at c
  -- ‚ä¢ HasDerivAt (fun y => -Complex.cos (2 * z * ‚Üëy) / (2 * z)) (Complex.sin (2 *  ‚Ä¶
                   -- ‚ä¢ HasDerivAt (fun y => -Complex.cos (2 * z * ‚Üëy) / (2 * z)) (Complex.sin (2 *  ‚Ä¶
  exact c
  -- üéâ no goals
#align euler_sine.antideriv_sin_comp_const_mul EulerSine.antideriv_sin_comp_const_mul

theorem integral_cos_mul_cos_pow_aux (hn : 2 ‚â§ n) (hz : z ‚â† 0) :
    (‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.cos (2 * z * x) * (cos x : ‚ÑÇ) ^ n) =
      n / (2 * z) *
        ‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.sin (2 * z * x) * sin x * (cos x : ‚ÑÇ) ^ (n - 1) := by
  have der1 :
    ‚àÄ x : ‚Ñù,
      x ‚àà uIcc 0 (œÄ / 2) ‚Üí
        HasDerivAt (fun y : ‚Ñù => (cos y : ‚ÑÇ) ^ n) (-n * sin x * (cos x : ‚ÑÇ) ^ (n - 1)) x := by
    intro x _
    have b : HasDerivAt (fun y : ‚Ñù => (cos y : ‚ÑÇ)) (-sin x) x := by
      simpa using (hasDerivAt_cos x).ofReal_comp
    convert HasDerivAt.comp x (hasDerivAt_pow _ _) b using 1
    ring
  convert (config := { sameFun := true })
    integral_mul_deriv_eq_deriv_mul der1 (fun x _ => antideriv_cos_comp_const_mul hz x) _ _ using 2
  ¬∑ ext1 x; rw [mul_comm]
    -- ‚ä¢ Complex.cos (2 * z * ‚Üëx) * ‚Üë(cos x) ^ n = ‚Üë(cos x) ^ n * Complex.cos (2 * z  ‚Ä¶
            -- üéâ no goals
  ¬∑ rw [Complex.ofReal_zero, mul_zero, Complex.sin_zero, zero_div,
      mul_zero, sub_zero, cos_pi_div_two, Complex.ofReal_zero,
      zero_pow (by positivity : 0 < n), zero_mul, zero_sub, ‚Üê integral_neg, ‚Üê
      integral_const_mul]
    refine' integral_congr fun x _ => _
    -- ‚ä¢ ‚Üën / (2 * z) * (Complex.sin (2 * z * ‚Üëx) * ‚Üë(sin x) * ‚Üë(cos x) ^ (n - 1)) =  ‚Ä¶
    field_simp; ring
    -- ‚ä¢ ‚Üën * (Complex.sin (2 * z * ‚Üëx) * Complex.sin ‚Üëx * Complex.cos ‚Üëx ^ (n - 1))  ‚Ä¶
                -- üéâ no goals
  ¬∑ apply Continuous.intervalIntegrable
    -- ‚ä¢ Continuous fun x => -‚Üën * ‚Üë(sin x) * ‚Üë(cos x) ^ (n - 1)
    exact
      (continuous_const.mul (Complex.continuous_ofReal.comp continuous_sin)).mul
        ((Complex.continuous_ofReal.comp continuous_cos).pow (n - 1))
  ¬∑ apply Continuous.intervalIntegrable
    -- ‚ä¢ Continuous fun x => Complex.cos (2 * z * ‚Üëx)
    exact Complex.continuous_cos.comp (continuous_const.mul Complex.continuous_ofReal)
    -- üéâ no goals
#align euler_sine.integral_cos_mul_cos_pow_aux EulerSine.integral_cos_mul_cos_pow_aux

theorem integral_sin_mul_sin_mul_cos_pow_eq (hn : 2 ‚â§ n) (hz : z ‚â† 0) :
    (‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.sin (2 * z * x) * sin x * (cos x : ‚ÑÇ) ^ (n - 1)) =
      (n / (2 * z) * ‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.cos (2 * z * x) * (cos x : ‚ÑÇ) ^ n) -
        (n - 1) / (2 * z) *
          ‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.cos (2 * z * x) * (cos x : ‚ÑÇ) ^ (n - 2) := by
  have der1 :
    ‚àÄ x : ‚Ñù,
      x ‚àà uIcc 0 (œÄ / 2) ‚Üí
        HasDerivAt (fun y : ‚Ñù => sin y * (cos y : ‚ÑÇ) ^ (n - 1))
          ((cos x : ‚ÑÇ) ^ n - (n - 1) * (sin x : ‚ÑÇ) ^ 2 * (cos x : ‚ÑÇ) ^ (n - 2)) x := by
    intro x _
    have c := HasDerivAt.comp (x : ‚ÑÇ) (hasDerivAt_pow (n - 1) _) (Complex.hasDerivAt_cos x)
    convert ((Complex.hasDerivAt_sin x).mul c).comp_ofReal using 1
    ¬∑ ext1 y; simp only [Complex.ofReal_sin, Complex.ofReal_cos, Function.comp]
    ¬∑ simp only [Complex.ofReal_cos, Complex.ofReal_sin]
      rw [mul_neg, mul_neg, ‚Üê sub_eq_add_neg, Function.comp_apply]
      congr 1
      ¬∑ rw [‚Üê pow_succ, Nat.sub_add_cancel (by linarith : 1 ‚â§ n)]
      ¬∑ have : ((n - 1 : ‚Ñï) : ‚ÑÇ) = (n : ‚ÑÇ) - 1 := by
          rw [Nat.cast_sub (one_le_two.trans hn), Nat.cast_one]
        rw [Nat.sub_sub, this]
        ring
  convert
    integral_mul_deriv_eq_deriv_mul der1 (fun x _ => antideriv_sin_comp_const_mul hz x) _ _ using 1
  ¬∑ refine' integral_congr fun x _ => _
    -- ‚ä¢ Complex.sin (2 * z * ‚Üëx) * ‚Üë(sin x) * ‚Üë(cos x) ^ (n - 1) = ‚Üë(sin x) * ‚Üë(cos  ‚Ä¶
    ring_nf
    -- üéâ no goals
  ¬∑ -- now a tedious rearrangement of terms
    -- gather into a single integral, and deal with continuity subgoals:
    rw [sin_zero, cos_pi_div_two, Complex.ofReal_zero, zero_pow, zero_mul,
      mul_zero, zero_mul, zero_mul, sub_zero, zero_sub, ‚Üê
      integral_neg, ‚Üê integral_const_mul, ‚Üê integral_const_mul, ‚Üê integral_sub]
    rotate_left
    ¬∑ apply Continuous.intervalIntegrable
      -- ‚ä¢ Continuous fun x => ‚Üën / (2 * z) * (Complex.cos (2 * z * ‚Üëx) * ‚Üë(cos x) ^ n)
      exact
        continuous_const.mul
          ((Complex.continuous_cos.comp (continuous_const.mul Complex.continuous_ofReal)).mul
            ((Complex.continuous_ofReal.comp continuous_cos).pow n))
    ¬∑ apply Continuous.intervalIntegrable
      -- ‚ä¢ Continuous fun x => (‚Üën - 1) / (2 * z) * (Complex.cos (2 * z * ‚Üëx) * ‚Üë(cos x ‚Ä¶
      exact
        continuous_const.mul
          ((Complex.continuous_cos.comp (continuous_const.mul Complex.continuous_ofReal)).mul
            ((Complex.continuous_ofReal.comp continuous_cos).pow (n - 2)))
    ¬∑ apply Nat.sub_pos_of_lt; exact one_lt_two.trans_le hn
      -- ‚ä¢ 1 < n
                               -- üéâ no goals
    refine' integral_congr fun x _ => _
    -- ‚ä¢ ‚Üën / (2 * z) * (Complex.cos (2 * z * ‚Üëx) * ‚Üë(cos x) ^ n) - (‚Üën - 1) / (2 * z ‚Ä¶
    dsimp only
    -- ‚ä¢ ‚Üën / (2 * z) * (Complex.cos (2 * z * ‚Üëx) * ‚Üë(cos x) ^ n) - (‚Üën - 1) / (2 * z ‚Ä¶
    -- get rid of real trig functions and divisions by 2 * z:
    rw [Complex.ofReal_cos, Complex.ofReal_sin, Complex.sin_sq, ‚Üê mul_div_right_comm, ‚Üê
      mul_div_right_comm, ‚Üê sub_div, mul_div, ‚Üê neg_div]
    congr 1
    -- ‚ä¢ ‚Üën * (Complex.cos (2 * z * ‚Üëx) * Complex.cos ‚Üëx ^ n) - (‚Üën - 1) * (Complex.c ‚Ä¶
    have : Complex.cos x ^ n = Complex.cos x ^ (n - 2) * Complex.cos x ^ 2 := by
      conv_lhs => rw [‚Üê Nat.sub_add_cancel hn, pow_add]
    rw [this]
    -- ‚ä¢ ‚Üën * (Complex.cos (2 * z * ‚Üëx) * (Complex.cos ‚Üëx ^ (n - 2) * Complex.cos ‚Üëx  ‚Ä¶
    ring
    -- üéâ no goals
  ¬∑ apply Continuous.intervalIntegrable
    -- ‚ä¢ Continuous fun x => ‚Üë(cos x) ^ n - (‚Üën - ‚Üë1) * ‚Üë(sin x) ^ 2 * ‚Üë(cos x) ^ (n  ‚Ä¶
    exact
      ((Complex.continuous_ofReal.comp continuous_cos).pow n).sub
        ((continuous_const.mul ((Complex.continuous_ofReal.comp continuous_sin).pow 2)).mul
          ((Complex.continuous_ofReal.comp continuous_cos).pow (n - 2)))
  ¬∑ apply Continuous.intervalIntegrable
    -- ‚ä¢ Continuous fun x => Complex.sin (2 * z * ‚Üëx)
    exact Complex.continuous_sin.comp (continuous_const.mul Complex.continuous_ofReal)
    -- üéâ no goals
#align euler_sine.integral_sin_mul_sin_mul_cos_pow_eq EulerSine.integral_sin_mul_sin_mul_cos_pow_eq

/-- Note this also holds for `z = 0`, but we do not need this case for `sin_pi_mul_eq`.  -/
theorem integral_cos_mul_cos_pow (hn : 2 ‚â§ n) (hz : z ‚â† 0) :
    (((1 : ‚ÑÇ) - (4 : ‚ÑÇ) * z ^ 2 / (n : ‚ÑÇ) ^ 2) *
      ‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.cos (2 * z * x) * (cos x : ‚ÑÇ) ^ n) =
      (n - 1 : ‚ÑÇ) / n *
        ‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.cos (2 * z * x) * (cos x : ‚ÑÇ) ^ (n - 2) := by
  have nne : (n : ‚ÑÇ) ‚â† 0 := by
    contrapose! hn; rw [Nat.cast_eq_zero] at hn; rw [hn]; exact zero_lt_two
  have := integral_cos_mul_cos_pow_aux hn hz
  -- ‚ä¢ (1 - 4 * z ^ 2 / ‚Üën ^ 2) * ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, Complex.cos (2 * z * ‚Üëx)  ‚Ä¶
  rw [integral_sin_mul_sin_mul_cos_pow_eq hn hz, sub_eq_neg_add, mul_add, ‚Üê sub_eq_iff_eq_add]
    at this
  convert congr_arg (fun u : ‚ÑÇ => -u * (2 * z) ^ 2 / n ^ 2) this using 1 <;> field_simp <;> ring
  -- ‚ä¢ (1 - 4 * z ^ 2 / ‚Üën ^ 2) * ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, Complex.cos (2 * z * ‚Üëx)  ‚Ä¶
                                                                             -- ‚ä¢ ((‚Üën ^ 2 - 4 * z ^ 2) * ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, Complex.cos (2 * z * ‚Üëx) * C ‚Ä¶
                                                                             -- ‚ä¢ ((‚Üën - 1) * ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, Complex.cos (2 * z * ‚Üëx) * Complex.cos ‚Üë ‚Ä¶
                                                                                            -- üéâ no goals
                                                                                            -- üéâ no goals
#align euler_sine.integral_cos_mul_cos_pow EulerSine.integral_cos_mul_cos_pow

/-- Note this also holds for `z = 0`, but we do not need this case for `sin_pi_mul_eq`. -/
theorem integral_cos_mul_cos_pow_even (n : ‚Ñï) (hz : z ‚â† 0) :
    (((1 : ‚ÑÇ) - z ^ 2 / ((n : ‚ÑÇ) + 1) ^ 2) *
        ‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.cos (2 * z * x) * (cos x : ‚ÑÇ) ^ (2 * n + 2)) =
      (2 * n + 1 : ‚ÑÇ) / (2 * n + 2) *
        ‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.cos (2 * z * x) * (cos x : ‚ÑÇ) ^ (2 * n) := by
  convert integral_cos_mul_cos_pow (by linarith : 2 ‚â§ 2 * n + 2) hz using 3
  ¬∑ simp only [Nat.cast_add, Nat.cast_mul, Nat.cast_two]
    -- ‚ä¢ z ^ 2 / (‚Üën + 1) ^ 2 = 4 * z ^ 2 / (2 * ‚Üën + 2) ^ 2
    nth_rw 2 [‚Üê mul_one (2 : ‚ÑÇ)]
    -- ‚ä¢ z ^ 2 / (‚Üën + 1) ^ 2 = 4 * z ^ 2 / (2 * ‚Üën + 2 * 1) ^ 2
    rw [‚Üê mul_add, mul_pow, ‚Üê div_div]
    -- ‚ä¢ z ^ 2 / (‚Üën + 1) ^ 2 = 4 * z ^ 2 / 2 ^ 2 / (‚Üën + 1) ^ 2
    ring
    -- üéâ no goals
  ¬∑ push_cast; ring
    -- ‚ä¢ 2 * ‚Üën + 1 = 2 * ‚Üën + 2 - 1
               -- üéâ no goals
  ¬∑ push_cast; ring
    -- ‚ä¢ 2 * ‚Üën + 2 = 2 * ‚Üën + 2
               -- üéâ no goals
#align euler_sine.integral_cos_mul_cos_pow_even EulerSine.integral_cos_mul_cos_pow_even

/-- Relate the integral `cos x ^ n` over `[0, œÄ/2]` to the integral of `sin x ^ n` over `[0, œÄ]`,
which is studied in `Data.Real.Pi.Wallis` and other places. -/
theorem integral_cos_pow_eq (n : ‚Ñï) :
    (‚à´ x in (0 : ‚Ñù)..œÄ / 2, cos x ^ n) = 1 / 2 * ‚à´ x in (0 : ‚Ñù)..œÄ, sin x ^ n := by
  rw [mul_comm (1 / 2 : ‚Ñù), ‚Üê div_eq_iff (one_div_ne_zero (two_ne_zero' ‚Ñù)), ‚Üê div_mul, div_one,
    mul_two]
  have L : IntervalIntegrable _ volume 0 (œÄ / 2) := (continuous_sin.pow n).intervalIntegrable _ _
  -- ‚ä¢ (‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, cos x ^ n) + ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, cos x ^ n = ‚à´  ‚Ä¶
  have R : IntervalIntegrable _ volume (œÄ / 2) œÄ := (continuous_sin.pow n).intervalIntegrable _ _
  -- ‚ä¢ (‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, cos x ^ n) + ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, cos x ^ n = ‚à´  ‚Ä¶
  rw [‚Üê integral_add_adjacent_intervals L R]
  -- ‚ä¢ (‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, cos x ^ n) + ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, cos x ^ n = (‚à´ ‚Ä¶
  -- Porting note: was `congr 1` but it timeouts
  refine congr_arg‚ÇÇ _ ?_ ?_
  -- ‚ä¢ ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, cos x ^ n = ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, sin x ^ n
  ¬∑ nth_rw 1 [(by ring : 0 = œÄ / 2 - œÄ / 2)]
    -- ‚ä¢ ‚à´ (x : ‚Ñù) in œÄ / 2 - œÄ / 2 ..œÄ / 2, cos x ^ n = ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, sin  ‚Ä¶
    nth_rw 3 [(by ring : œÄ / 2 = œÄ / 2 - 0)]
    -- ‚ä¢ ‚à´ (x : ‚Ñù) in œÄ / 2 - œÄ / 2 ..œÄ / 2 - 0, cos x ^ n = ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2,  ‚Ä¶
    rw [‚Üê integral_comp_sub_left]
    -- ‚ä¢ ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, cos (œÄ / 2 - x) ^ n = ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, sin x  ‚Ä¶
    refine' integral_congr fun x _ => _
    -- ‚ä¢ cos (œÄ / 2 - x) ^ n = sin x ^ n
    rw [cos_pi_div_two_sub]
    -- üéâ no goals
  ¬∑ nth_rw 3 [(by ring : œÄ = œÄ / 2 + œÄ / 2)]
    -- ‚ä¢ ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, cos x ^ n = ‚à´ (x : ‚Ñù) in œÄ / 2 ..œÄ / 2 + œÄ / 2, sin  ‚Ä¶
    nth_rw 2 [(by ring : œÄ / 2 = 0 + œÄ / 2)]
    -- ‚ä¢ ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, cos x ^ n = ‚à´ (x : ‚Ñù) in 0 + œÄ / 2 ..œÄ / 2 + œÄ / 2,  ‚Ä¶
    rw [‚Üê integral_comp_add_right]
    -- ‚ä¢ ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, cos x ^ n = ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, sin (x + œÄ / 2)  ‚Ä¶
    refine' integral_congr fun x _ => _
    -- ‚ä¢ cos x ^ n = sin (x + œÄ / 2) ^ n
    rw [sin_add_pi_div_two]
    -- üéâ no goals
#align euler_sine.integral_cos_pow_eq EulerSine.integral_cos_pow_eq

theorem integral_cos_pow_pos (n : ‚Ñï) : 0 < ‚à´ x in (0 : ‚Ñù)..œÄ / 2, cos x ^ n :=
  (integral_cos_pow_eq n).symm ‚ñ∏ mul_pos one_half_pos (integral_sin_pow_pos _)
#align euler_sine.integral_cos_pow_pos EulerSine.integral_cos_pow_pos

/-- Finite form of Euler's sine product, with remainder term expressed as a ratio of cosine
integrals. -/
theorem sin_pi_mul_eq (z : ‚ÑÇ) (n : ‚Ñï) :
    Complex.sin (œÄ * z) =
      ((œÄ * z * ‚àè j in Finset.range n, ((1 : ‚ÑÇ) - z ^ 2 / ((j : ‚ÑÇ) + 1) ^ 2)) *
          ‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.cos (2 * z * x) * (cos x : ‚ÑÇ) ^ (2 * n)) /
        (‚à´ x in (0 : ‚Ñù)..œÄ / 2, cos x ^ (2 * n) : ‚Ñù) := by
  rcases eq_or_ne z 0 with (rfl | hz)
  -- ‚ä¢ Complex.sin (‚ÜëœÄ * 0) = ((‚ÜëœÄ * 0 * ‚àè j in Finset.range n, (1 - 0 ^ 2 / (‚Üëj +  ‚Ä¶
  ¬∑ simp
    -- üéâ no goals
  induction' n with n hn
  -- ‚ä¢ Complex.sin (‚ÜëœÄ * z) = ((‚ÜëœÄ * z * ‚àè j in Finset.range Nat.zero, (1 - z ^ 2 / ‚Ä¶
  ¬∑ simp_rw [Nat.zero_eq, mul_zero, pow_zero, mul_one, Finset.prod_range_zero, mul_one,
      integral_one, sub_zero]
    rw [integral_cos_mul_complex (mul_ne_zero two_ne_zero hz), Complex.ofReal_zero,
      mul_zero, Complex.sin_zero, zero_div, sub_zero,
      (by push_cast; field_simp; ring : 2 * z * ‚Üë(œÄ / 2) = œÄ * z)]
    field_simp [Complex.ofReal_ne_zero.mpr pi_pos.ne']
    -- ‚ä¢ Complex.sin (‚ÜëœÄ * z) * (2 * z * ‚ÜëœÄ) = ‚ÜëœÄ * z * Complex.sin (‚ÜëœÄ * z) * 2
    ring
    -- üéâ no goals
  ¬∑ rw [hn, Finset.prod_range_succ]
    -- ‚ä¢ ((‚ÜëœÄ * z * ‚àè j in Finset.range n, (1 - z ^ 2 / (‚Üëj + 1) ^ 2)) * ‚à´ (x : ‚Ñù) in ‚Ä¶
    set A := ‚àè j in Finset.range n, ((1 : ‚ÑÇ) - z ^ 2 / ((j : ‚ÑÇ) + 1) ^ 2)
    -- ‚ä¢ (‚ÜëœÄ * z * A * ‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, Complex.cos (2 * z * ‚Üëx) * ‚Üë(cos x) ^  ‚Ä¶
    set B := ‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.cos (2 * z * x) * (cos x : ‚ÑÇ) ^ (2 * n)
    -- ‚ä¢ ‚ÜëœÄ * z * A * B / ‚Üë(‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, cos x ^ (2 * n)) = (‚ÜëœÄ * z * (A * ‚Ä¶
    set C := ‚à´ x in (0 : ‚Ñù)..œÄ / 2, cos x ^ (2 * n)
    -- ‚ä¢ ‚ÜëœÄ * z * A * B / ‚ÜëC = (‚ÜëœÄ * z * (A * (1 - z ^ 2 / (‚Üën + 1) ^ 2)) * ‚à´ (x : ‚Ñù) ‚Ä¶
    have aux' : 2 * n.succ = 2 * n + 2 := by rw [Nat.succ_eq_add_one, mul_add, mul_one]
    -- ‚ä¢ ‚ÜëœÄ * z * A * B / ‚ÜëC = (‚ÜëœÄ * z * (A * (1 - z ^ 2 / (‚Üën + 1) ^ 2)) * ‚à´ (x : ‚Ñù) ‚Ä¶
    have : (‚à´ x in (0 : ‚Ñù)..œÄ / 2, cos x ^ (2 * n.succ)) = (2 * (n : ‚Ñù) + 1) / (2 * n + 2) * C := by
      rw [integral_cos_pow_eq]
      dsimp only
      rw [integral_cos_pow_eq, aux', integral_sin_pow, sin_zero, sin_pi, pow_succ,
        zero_mul, zero_mul, zero_mul, sub_zero, zero_div,
        zero_add, ‚Üê mul_assoc, ‚Üê mul_assoc, mul_comm (1 / 2 : ‚Ñù) _, Nat.cast_mul, Nat.cast_eq_ofNat]
    rw [this]
    -- ‚ä¢ ‚ÜëœÄ * z * A * B / ‚ÜëC = (‚ÜëœÄ * z * (A * (1 - z ^ 2 / (‚Üën + 1) ^ 2)) * ‚à´ (x : ‚Ñù) ‚Ä¶
    change
      œÄ * z * A * B / C =
        (œÄ * z * (A * ((1 : ‚ÑÇ) - z ^ 2 / ((n : ‚ÑÇ) + 1) ^ 2)) *
            ‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.cos (2 * z * x) * (cos x : ‚ÑÇ) ^ (2 * n.succ)) /
          ((2 * n + 1) / (2 * n + 2) * C : ‚Ñù)
    have :
      (œÄ * z * (A * ((1 : ‚ÑÇ) - z ^ 2 / ((n : ‚ÑÇ) + 1) ^ 2)) *
          ‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.cos (2 * z * x) * (cos x : ‚ÑÇ) ^ (2 * n.succ)) =
        œÄ * z * A *
          (((1 : ‚ÑÇ) - z ^ 2 / (n.succ : ‚ÑÇ) ^ 2) *
            ‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.cos (2 * z * x) * (cos x : ‚ÑÇ) ^ (2 * n.succ)) := by
      nth_rw 2 [Nat.succ_eq_add_one]
      rw [Nat.cast_add_one]
      ring
    rw [this]
    -- ‚ä¢ ‚ÜëœÄ * z * A * B / ‚ÜëC = ‚ÜëœÄ * z * A * ((1 - z ^ 2 / ‚Üë(Nat.succ n) ^ 2) * ‚à´ (x : ‚Ä¶
    suffices
      (((1 : ‚ÑÇ) - z ^ 2 / (n.succ : ‚ÑÇ) ^ 2) *
          ‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.cos (2 * z * x) * (cos x : ‚ÑÇ) ^ (2 * n.succ)) =
        (2 * n + 1) / (2 * n + 2) * B by
      rw [this, Complex.ofReal_mul, Complex.ofReal_div]
      have : (C : ‚ÑÇ) ‚â† 0 := Complex.ofReal_ne_zero.mpr (integral_cos_pow_pos _).ne'
      have : 2 * (n : ‚ÑÇ) + 1 ‚â† 0 := by
        convert (Nat.cast_add_one_ne_zero (2 * n) : (‚Üë(2 * n) + 1 : ‚ÑÇ) ‚â† 0)
        simp
      have : 2 * (n : ‚ÑÇ) + 2 ‚â† 0 := by
        convert (Nat.cast_add_one_ne_zero (2 * n + 1) : (‚Üë(2 * n + 1) + 1 : ‚ÑÇ) ‚â† 0) using 1
        push_cast; ring
      field_simp; ring
    convert integral_cos_mul_cos_pow_even n hz
    -- ‚ä¢ ‚Üë(Nat.succ n) = ‚Üën + 1
    rw [Nat.cast_succ]
    -- üéâ no goals
#align euler_sine.sin_pi_mul_eq EulerSine.sin_pi_mul_eq

end IntegralRecursion

/-! ## Conclusion of the proof

The main theorem `Complex.tendsto_euler_sin_prod`, and its real variant
`Real.tendsto_euler_sin_prod`, now follow by combining `sin_pi_mul_eq` with a lemma
stating that the sequence of measures on `[0, œÄ/2]` given by integration against `cos x ^ n`
(suitably normalised) tends to the Dirac measure at 0, as a special case of the general result
`tendsto_set_integral_pow_smul_of_unique_maximum_of_isCompact_of_continuousOn`. -/


theorem tendsto_integral_cos_pow_mul_div {f : ‚Ñù ‚Üí ‚ÑÇ} (hf : ContinuousOn f (Icc 0 (œÄ / 2))) :
    Tendsto
      (fun n : ‚Ñï => (‚à´ x in (0 : ‚Ñù)..œÄ / 2, (cos x : ‚ÑÇ) ^ n * f x) /
        (‚à´ x in (0 : ‚Ñù)..œÄ / 2, cos x ^ n : ‚Ñù))
      atTop (ùìù <| f 0) := by
  simp_rw [div_eq_inv_mul (Œ± := ‚ÑÇ), ‚Üê Complex.ofReal_inv, integral_of_le pi_div_two_pos.le,
    ‚Üê MeasureTheory.integral_Icc_eq_integral_Ioc, ‚Üê Complex.ofReal_pow, ‚Üê Complex.real_smul]
  have c_lt : ‚àÄ y : ‚Ñù, y ‚àà Icc 0 (œÄ / 2) ‚Üí y ‚â† 0 ‚Üí cos y < cos 0 := fun y hy hy' =>
    cos_lt_cos_of_nonneg_of_le_pi_div_two (le_refl 0) hy.2 (lt_of_le_of_ne hy.1 hy'.symm)
  have c_nonneg : ‚àÄ x : ‚Ñù, x ‚àà Icc 0 (œÄ / 2) ‚Üí 0 ‚â§ cos x := fun x hx =>
    cos_nonneg_of_mem_Icc ((Icc_subset_Icc_left (neg_nonpos_of_nonneg pi_div_two_pos.le)) hx)
  have c_zero_pos : 0 < cos 0 := by rw [cos_zero]; exact zero_lt_one
  -- ‚ä¢ Tendsto (fun n => (‚à´ (x : ‚Ñù) in Icc 0 (œÄ / 2), cos x ^ n)‚Åª¬π ‚Ä¢ ‚à´ (x : ‚Ñù) in I ‚Ä¶
  have zero_mem : (0 : ‚Ñù) ‚àà closure (interior (Icc 0 (œÄ / 2))) := by
    rw [interior_Icc, closure_Ioo pi_div_two_pos.ne, left_mem_Icc]
    exact pi_div_two_pos.le
  exact
    tendsto_set_integral_pow_smul_of_unique_maximum_of_isCompact_of_continuousOn isCompact_Icc
      continuousOn_cos c_lt c_nonneg c_zero_pos zero_mem hf
#align euler_sine.tendsto_integral_cos_pow_mul_div EulerSine.tendsto_integral_cos_pow_mul_div

/-- Euler's infinite product formula for the complex sine function. -/
theorem _root_.Complex.tendsto_euler_sin_prod (z : ‚ÑÇ) :
    Tendsto (fun n : ‚Ñï => œÄ * z * ‚àè j in Finset.range n, ((1 : ‚ÑÇ) - z ^ 2 / ((j : ‚ÑÇ) + 1) ^ 2))
      atTop (ùìù <| Complex.sin (œÄ * z)) := by
  have A :
    Tendsto
      (fun n : ‚Ñï =>
        ((œÄ * z * ‚àè j in Finset.range n, ((1 : ‚ÑÇ) - z ^ 2 / ((j : ‚ÑÇ) + 1) ^ 2)) *
            ‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.cos (2 * z * x) * (cos x : ‚ÑÇ) ^ (2 * n)) /
          (‚à´ x in (0 : ‚Ñù)..œÄ / 2, cos x ^ (2 * n) : ‚Ñù))
      atTop (ùìù <| _) :=
    Tendsto.congr (fun n => sin_pi_mul_eq z n) tendsto_const_nhds
  have : ùìù (Complex.sin (œÄ * z)) = ùìù (Complex.sin (œÄ * z) * 1) := by rw [mul_one]
  -- ‚ä¢ Tendsto (fun n => ‚ÜëœÄ * z * ‚àè j in Finset.range n, (1 - z ^ 2 / (‚Üëj + 1) ^ 2) ‚Ä¶
  simp_rw [this, mul_div_assoc] at A
  -- ‚ä¢ Tendsto (fun n => ‚ÜëœÄ * z * ‚àè j in Finset.range n, (1 - z ^ 2 / (‚Üëj + 1) ^ 2) ‚Ä¶
  convert (tendsto_mul_iff_of_ne_zero _ one_ne_zero).mp A
  -- ‚ä¢ Tendsto (fun n => (‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, Complex.cos (2 * z * ‚Üëx) * ‚Üë(cos  ‚Ä¶
  suffices :
    Tendsto
      (fun n : ‚Ñï =>
        (‚à´ x in (0 : ‚Ñù)..œÄ / 2, Complex.cos (2 * z * x) * (cos x : ‚ÑÇ) ^ n) /
          (‚à´ x in (0 : ‚Ñù)..œÄ / 2, cos x ^ n : ‚Ñù))
      atTop (ùìù 1)
  exact this.comp (tendsto_id.const_mul_atTop' zero_lt_two)
  -- ‚ä¢ Tendsto (fun n => (‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, Complex.cos (2 * z * ‚Üëx) * ‚Üë(cos  ‚Ä¶
  have : ContinuousOn (fun x : ‚Ñù => Complex.cos (2 * z * x)) (Icc 0 (œÄ / 2)) :=
    (Complex.continuous_cos.comp (continuous_const.mul Complex.continuous_ofReal)).continuousOn
  convert tendsto_integral_cos_pow_mul_div this using 1
  -- ‚ä¢ (fun n => (‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, Complex.cos (2 * z * ‚Üëx) * ‚Üë(cos x) ^ n)  ‚Ä¶
  ¬∑ ext1 n; congr 2 with x : 1; rw [mul_comm]
    -- ‚ä¢ (‚à´ (x : ‚Ñù) in 0 ..œÄ / 2, Complex.cos (2 * z * ‚Üëx) * ‚Üë(cos x) ^ n) / ‚Üë(‚à´ (x : ‚Ä¶
            -- ‚ä¢ Complex.cos (2 * z * ‚Üëx) * ‚Üë(cos x) ^ n = ‚Üë(cos x) ^ n * Complex.cos (2 * z  ‚Ä¶
                                -- üéâ no goals
  ¬∑ rw [Complex.ofReal_zero, mul_zero, Complex.cos_zero]
    -- üéâ no goals
#align complex.tendsto_euler_sin_prod Complex.tendsto_euler_sin_prod

/-- Euler's infinite product formula for the real sine function. -/
theorem _root_.Real.tendsto_euler_sin_prod (x : ‚Ñù) :
    Tendsto (fun n : ‚Ñï => œÄ * x * ‚àè j in Finset.range n, ((1 : ‚Ñù) - x ^ 2 / ((j : ‚Ñù) + 1) ^ 2))
      atTop (ùìù <| sin (œÄ * x)) := by
  convert (Complex.continuous_re.tendsto _).comp (Complex.tendsto_euler_sin_prod x) using 1
  -- ‚ä¢ (fun n => œÄ * x * ‚àè j in Finset.range n, (1 - x ^ 2 / (‚Üëj + 1) ^ 2)) = Compl ‚Ä¶
  ¬∑ ext1 n
    -- ‚ä¢ œÄ * x * ‚àè j in Finset.range n, (1 - x ^ 2 / (‚Üëj + 1) ^ 2) = (Complex.re ‚àò fu ‚Ä¶
    rw [Function.comp_apply, ‚Üê Complex.ofReal_mul, Complex.ofReal_mul_re]
    -- ‚ä¢ œÄ * x * ‚àè j in Finset.range n, (1 - x ^ 2 / (‚Üëj + 1) ^ 2) = œÄ * x * (‚àè j in  ‚Ä¶
    suffices
      (‚àè j : ‚Ñï in Finset.range n, ((1 : ‚ÑÇ) - (x : ‚ÑÇ) ^ 2 / ((j : ‚ÑÇ) + 1) ^ 2)) =
        (‚àè j : ‚Ñï in Finset.range n, ((1 : ‚Ñù) - x ^ 2 / ((j : ‚Ñù) + 1) ^ 2) : ‚Ñù) by
      rw [this, Complex.ofReal_re]
    rw [Complex.ofReal_prod]
    -- ‚ä¢ ‚àè j in Finset.range n, (1 - ‚Üëx ^ 2 / (‚Üëj + 1) ^ 2) = ‚àè i in Finset.range n,  ‚Ä¶
    refine' Finset.prod_congr (by rfl) fun n _ => _
    -- ‚ä¢ 1 - ‚Üëx ^ 2 / (‚Üën + 1) ^ 2 = ‚Üë(1 - x ^ 2 / (‚Üën + 1) ^ 2)
    norm_cast
    -- üéâ no goals
  ¬∑ rw [‚Üê Complex.ofReal_mul, ‚Üê Complex.ofReal_sin, Complex.ofReal_re]
    -- üéâ no goals
#align real.tendsto_euler_sin_prod Real.tendsto_euler_sin_prod

end EulerSine
