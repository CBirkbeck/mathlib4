/-
Copyright (c) 2024 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order
import Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Isometric
import Mathlib.Analysis.CStarAlgebra.SpecialFunctions.PosPart
import Mathlib.Analysis.SpecialFunctions.ContinuousFunctionalCalculus.Rpow
import Mathlib.Topology.ApproximateUnit

/-! # Nonnegative contractions in a C‚ãÜ-algebra form an approximate unit

This file shows that the collection of positive contractions (of norm strictly less than one)
in a possibly non-unital C‚ãÜ-algebra form a directed set. The key step uses the continuous functional
calculus applied with the functions `fun x : ‚Ñù‚â•0, 1 - (1 + x)‚Åª¬π` and `fun x : ‚Ñù‚â•0, x * (1 - x)‚Åª¬π`,
which are inverses on the interval `{x : ‚Ñù‚â•0 | x < 1}`.

In addition, this file defines `IsIncreasingApproximateUnit` to be a filter `l` that is an
approximate unit contained in the closed unit ball of nonnegative elements. Every C‚ãÜ-algebra has
a filter generated by the sections `{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a` and `‚Äña‚Äñ < 1`, and
moreover, this filter is an increasing approximate unit.

## Main declarations

+ `CFC.monotoneOn_one_sub_one_add_inv`: the function `f := fun x : ‚Ñù‚â•0, 1 - (1 + x)‚Åª¬π` is
  *operator monotone* on `Set.Ici (0 : A)` (i.e., `cfc‚Çô f` is monotone on `{x : A | 0 ‚â§ x}`).
+ `Set.InvOn.one_sub_one_add_inv`: the functions `f := fun x : ‚Ñù‚â•0, 1 - (1 + x)‚Åª¬π` and
  `g := fun x : ‚Ñù‚â•0, x * (1 - x)‚Åª¬π` are inverses on `{x : ‚Ñù‚â•0 | x < 1}`.
+ `CStarAlgebra.directedOn_nonneg_ball`: the set `{x : A | 0 ‚â§ x} ‚à© Metric.ball 0 1` is directed.
+ `Filter.IsIncreasingApproximateUnit`: a filter `l` is an *increasing approximate unit* if it is an
  approximate unit contained in the closed unit ball of nonnegative elements.
+ `CStarAlgebra.approximateUnit`: the filter generated by the sections
  `{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a` with `‚Äña‚Äñ < 1`.
+ `CStarAlgebra.increasingApproximateUnit`: the filter `CStarAlgebra.approximateUnit` is an
  increasing approximate unit.

-/

variable {A : Type*} [NonUnitalCStarAlgebra A]

local notation "œÉ‚Çô" => quasispectrum
local notation "œÉ" => spectrum

open Unitization NNReal CStarAlgebra

variable [PartialOrder A] [StarOrderedRing A]

lemma CFC.monotoneOn_one_sub_one_add_inv :
    MonotoneOn (cfc‚Çô (fun x : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + x)‚Åª¬π)) (Set.Ici (0 : A)) := by
  intro a ha b hb hab
  simp only [Set.mem_Ici] at ha hb
  rw [‚Üê inr_le_iff .., nnreal_cfc‚Çô_eq_cfc_inr a _, nnreal_cfc‚Çô_eq_cfc_inr b _]
  rw [‚Üê inr_le_iff a b (.of_nonneg ha) (.of_nonneg hb)] at hab
  rw [‚Üê inr_nonneg_iff] at ha hb
  have h_cfc_one_sub (c : A‚Å∫¬π) (hc : 0 ‚â§ c := by cfc_tac) :
      cfc (fun x : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + x)‚Åª¬π) c = 1 - cfc (¬∑‚Åª¬π : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0) (1 + c) := by
    rw [cfc_tsub _ _ _ (fun x _ ‚Ü¶ by simp) (hg := by fun_prop (disch := intro _ _; positivity)),
      cfc_const_one ‚Ñù‚â•0 c, cfc_comp' (¬∑‚Åª¬π) (1 + ¬∑) c ?_, cfc_add .., cfc_const_one ‚Ñù‚â•0 c,
      cfc_id' ‚Ñù‚â•0 c]
    exact continuousOn_id.inv‚ÇÄ (Set.forall_mem_image.mpr fun x _ ‚Ü¶ by dsimp only [id]; positivity)
  rw [h_cfc_one_sub (a : A‚Å∫¬π), h_cfc_one_sub (b : A‚Å∫¬π)]
  gcongr
  rw [‚Üê CFC.rpow_neg_one_eq_cfc_inv, ‚Üê CFC.rpow_neg_one_eq_cfc_inv]
  exact rpow_neg_one_le_rpow_neg_one (add_nonneg zero_le_one ha) (by gcongr) <|
    isUnit_of_le isUnit_one zero_le_one <| le_add_of_nonneg_right ha

lemma Set.InvOn.one_sub_one_add_inv : Set.InvOn (fun x ‚Ü¶ 1 - (1 + x)‚Åª¬π) (fun x ‚Ü¶ x * (1 - x)‚Åª¬π)
    {x : ‚Ñù‚â•0 | x < 1} {x : ‚Ñù‚â•0 | x < 1} := by
  have : (fun x : ‚Ñù‚â•0 ‚Ü¶ x * (1 + x)‚Åª¬π) = fun x ‚Ü¶ 1 - (1 + x)‚Åª¬π := by
    ext x : 1
    field_simp
    simp [tsub_mul, inv_mul_cancel‚ÇÄ]
  rw [‚Üê this]
  constructor <;> intro x (hx : x < 1)
  ¬∑ have : 0 < 1 - x := tsub_pos_of_lt hx
    field_simp [tsub_add_cancel_of_le hx.le, tsub_tsub_cancel_of_le hx.le]
  ¬∑ field_simp [mul_tsub]

lemma norm_cfc‚Çô_one_sub_one_add_inv_lt_one (a : A) :
    ‚Äñcfc‚Çô (fun x : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + x)‚Åª¬π) a‚Äñ < 1 :=
  nnnorm_cfc‚Çô_nnreal_lt fun x _ ‚Ü¶ tsub_lt_self zero_lt_one (by positivity)

-- the calls to `fun_prop` with a discharger set off the linter
set_option linter.style.multiGoal false in
lemma CStarAlgebra.directedOn_nonneg_ball :
    DirectedOn (¬∑ ‚â§ ¬∑) ({x : A | 0 ‚â§ x} ‚à© Metric.ball 0 1) := by
  let f : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0 := fun x => 1 - (1 + x)‚Åª¬π
  let g : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0 := fun x => x * (1 - x)‚Åª¬π
  suffices ‚àÄ a b : A, 0 ‚â§ a ‚Üí 0 ‚â§ b ‚Üí ‚Äña‚Äñ < 1 ‚Üí ‚Äñb‚Äñ < 1 ‚Üí
      a ‚â§ cfc‚Çô f (cfc‚Çô g a + cfc‚Çô g b) by
    rintro a ‚ü®(ha‚ÇÅ : 0 ‚â§ a), ha‚ÇÇ‚ü© b ‚ü®(hb‚ÇÅ : 0 ‚â§ b), hb‚ÇÇ‚ü©
    simp only [Metric.mem_ball, dist_zero_right] at ha‚ÇÇ hb‚ÇÇ
    refine ‚ü®cfc‚Çô f (cfc‚Çô g a + cfc‚Çô g b), ‚ü®by simp, ?_‚ü©, ?_, ?_‚ü©
    ¬∑ simpa only [Metric.mem_ball, dist_zero_right] using norm_cfc‚Çô_one_sub_one_add_inv_lt_one _
    ¬∑ exact this a b ha‚ÇÅ hb‚ÇÅ ha‚ÇÇ hb‚ÇÇ
    ¬∑ exact add_comm (cfc‚Çô g a) (cfc‚Çô g b) ‚ñ∏ this b a hb‚ÇÅ ha‚ÇÅ hb‚ÇÇ ha‚ÇÇ
  rintro a b ha‚ÇÅ - ha‚ÇÇ -
  calc
    a = cfc‚Çô (f ‚àò g) a := by
      conv_lhs => rw [‚Üê cfc‚Çô_id ‚Ñù‚â•0 a]
      refine cfc‚Çô_congr (Set.InvOn.one_sub_one_add_inv.1.eqOn.symm.mono fun x hx ‚Ü¶ ?_)
      exact lt_of_le_of_lt (le_nnnorm_of_mem_quasispectrum hx) ha‚ÇÇ
    _ = cfc‚Çô f (cfc‚Çô g a) := by
      rw [cfc‚Çô_comp f g a ?_ (by simp [f, tsub_self]) ?_ (by simp [g]) ha‚ÇÅ]
      ¬∑ fun_prop (disch := intro _ _; positivity)
      ¬∑ have (x) (hx : x ‚àà œÉ‚Çô ‚Ñù‚â•0 a) :  1 - x ‚â† 0 := by
          refine tsub_pos_of_lt ?_ |>.ne'
          exact lt_of_le_of_lt (le_nnnorm_of_mem_quasispectrum hx) ha‚ÇÇ
        fun_prop (disch := assumption)
    _ ‚â§ cfc‚Çô f (cfc‚Çô g a + cfc‚Çô g b) := by
      have hab' : cfc‚Çô g a ‚â§ cfc‚Çô g a + cfc‚Çô g b := le_add_of_nonneg_right cfc‚Çô_nonneg_of_predicate
      exact CFC.monotoneOn_one_sub_one_add_inv cfc‚Çô_nonneg_of_predicate
        (cfc‚Çô_nonneg_of_predicate.trans hab') hab'

section ApproximateUnit

open Metric Filter Topology

/-- An *increasing approximate unit* in a C‚ãÜ-algebra is an approximate unit contained in the
closed unit ball of nonnegative elements. -/
structure Filter.IsIncreasingApproximateUnit (l : Filter A) extends l.IsApproximateUnit : Prop where
  eventually_nonneg : ‚àÄ·∂† x in l, 0 ‚â§ x
  eventually_norm : ‚àÄ·∂† x in l, ‚Äñx‚Äñ ‚â§ 1

namespace Filter.IsIncreasingApproximateUnit

omit [StarOrderedRing A] in
lemma eventually_nnnorm {l : Filter A} (hl : l.IsIncreasingApproximateUnit) :
    ‚àÄ·∂† x in l, ‚Äñx‚Äñ‚Çä ‚â§ 1 :=
  hl.eventually_norm

lemma eventually_isSelfAdjoint {l : Filter A} (hl : l.IsIncreasingApproximateUnit) :
    ‚àÄ·∂† x in l, IsSelfAdjoint x :=
  hl.eventually_nonneg.mp <| .of_forall fun _ ‚Ü¶ IsSelfAdjoint.of_nonneg

lemma eventually_star_eq {l : Filter A} (hl : l.IsIncreasingApproximateUnit) :
    ‚àÄ·∂† x in l, star x = x :=
  hl.eventually_isSelfAdjoint.mp <| .of_forall fun _ ‚Ü¶ IsSelfAdjoint.star_eq

end Filter.IsIncreasingApproximateUnit

namespace CStarAlgebra

open Submodule in
/-- To show that `l` is a one-sided approximate unit for `A`, it suffices to verify it only for
`m : A` with `0 ‚â§ m` and `‚Äñm‚Äñ < 1`. -/
lemma tendsto_mul_right_of_forall_nonneg_tendsto {l : Filter A}
    (h : ‚àÄ m, 0 ‚â§ m ‚Üí ‚Äñm‚Äñ < 1 ‚Üí Tendsto (¬∑ * m) l (ùìù m)) (m : A) :
    Tendsto (¬∑ * m) l (ùìù m) := by
  obtain ‚ü®n, c, x, rfl‚ü© := mem_span_set'.mp <| by
    show m ‚àà span ‚ÑÇ ({x | 0 ‚â§ x} ‚à© ball 0 1)
    simp [span_nonneg_inter_unitBall]
  simp_rw [Finset.mul_sum]
  refine tendsto_finset_sum _ fun i _ ‚Ü¶ ?_
  simp_rw [mul_smul_comm]
  exact tendsto_const_nhds.smul <| h (x i) (x i).2.1 <| by simpa using (x i).2.2

omit [PartialOrder A] in
/-- Multiplication on the left by `m` tends to `ùìù m` if and only if multiplication on the right
does, provided the elements are eventually selfadjoint along the filter `l`. -/
lemma tendsto_mul_left_iff_tendsto_mul_right {l : Filter A} (hl : ‚àÄ·∂† x in l, IsSelfAdjoint x) :
    (‚àÄ m, Tendsto (m * ¬∑) l (ùìù m)) ‚Üî (‚àÄ m, Tendsto (¬∑ * m) l (ùìù m)) := by
  refine ‚ü®fun h m ‚Ü¶ ?_, fun h m ‚Ü¶ ?_‚ü©
  all_goals
    apply (star_star m ‚ñ∏ (continuous_star.tendsto _ |>.comp <| h (star m))).congr'
    filter_upwards [hl] with x hx
    simp [hx.star_eq]

variable (A)

/-- The sections of positive strict contractions form a filter basis. -/
lemma isBasis_nonneg_sections :
    IsBasis (fun x : A ‚Ü¶ 0 ‚â§ x ‚àß ‚Äñx‚Äñ < 1) ({x | ¬∑ ‚â§ x}) where
  nonempty := ‚ü®0, by simp‚ü©
  inter {x y} hx hy := by
    peel directedOn_nonneg_ball x (by simpa) y (by simpa) with z hz
    exact ‚ü®by simpa using hz.1, fun a ha ‚Ü¶ ‚ü®hz.2.1.trans ha, hz.2.2.trans ha‚ü©‚ü©

/-- The canonical approximate unit in a C‚ãÜ-algebra generated by the basis of sets
`{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a`. See also `CStarAlgebra.hasBasis_approximateUnit`. -/
def approximateUnit : Filter A :=
  (isBasis_nonneg_sections A).filter ‚äì ùìü (closedBall 0 1)

/-- The canonical approximate unit in a C‚ãÜ-algebra has a basis of sets
`{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a`. -/
lemma hasBasis_approximateUnit :
    (approximateUnit A).HasBasis (fun x : A ‚Ü¶ 0 ‚â§ x ‚àß ‚Äñx‚Äñ < 1) ({x | ¬∑ ‚â§ x} ‚à© closedBall 0 1) :=
  isBasis_nonneg_sections A |>.hasBasis.inf_principal (closedBall 0 1)

instance : (approximateUnit A).NeBot :=
  hasBasis_approximateUnit A |>.neBot_iff.mpr fun hx ‚Ü¶ ‚ü®_, ‚ü®le_rfl, by simpa using hx.2.le‚ü©‚ü©

lemma eventually_ge_approximateUnit {e : A} (he‚ÇÄ : 0 ‚â§ e) (he‚ÇÅ : ‚Äñe‚Äñ < 1) :
    ‚àÄ·∂† x in approximateUnit A, e ‚â§ x := .filter_mono inf_le_left <|
  (isBasis_nonneg_sections A).hasBasis.eventually_iff.mpr ‚ü®e, ‚ü®he‚ÇÄ, he‚ÇÅ‚ü©, fun _ ‚Ü¶ id‚ü©

lemma eventually_nonneg_approximateUnit : ‚àÄ·∂† x in approximateUnit A, 0 ‚â§ x :=
  eventually_ge_approximateUnit A le_rfl (by simp)

lemma eventually_norm_le_approximateUnit : ‚àÄ·∂† x in approximateUnit A, ‚Äñx‚Äñ ‚â§ 1 :=
  .filter_mono inf_le_right <| by simp

/-- This is a common reasoning sequence in C‚ãÜ-algebra theory. If `0 ‚â§ x ‚â§ y ‚â§ 1`, then the norm
of `z - y * z` is controled by the norm of `star z * (1 - x) * z`, which is advantageous because the
latter is nonnegative. This is a key step in establishing the existence of an increasing approximate
unit in general C‚ãÜ-algebras. -/
lemma sq_nnnorm_sub_mul_self_le {A : Type*} [CStarAlgebra A] [PartialOrder A] [StarOrderedRing A]
    {x : A} (z : A) (hx : x ‚àà Set.Icc 0 1) :
    ‚Äñz - x * z‚Äñ‚Çä ^ 2 ‚â§ ‚Äñstar z * (1 - x) * z‚Äñ‚Çä := by
  have hx' : 1 - x ‚àà Set.Icc 0 1 := Set.sub_mem_Icc_zero_iff_right.mpr hx
  rw [‚Üê one_sub_mul, sq, ‚Üê CStarRing.nnnorm_star_mul_self]
  refine nnnorm_le_nnnorm_of_nonneg_of_le (star_mul_self_nonneg _) ?_
  rw [star_mul, star_sub, star_one, ‚Üê mul_assoc, mul_assoc _ _ (1 - x), hx.1.star_eq, ‚Üê sq]
  exact conjugate_le_conjugate (by simpa using pow_antitone hx'.1 hx'.2 one_le_two) z

/-- This is a common reasoning sequence in C‚ãÜ-algebra theory. If `0 ‚â§ x ‚â§ y ‚â§ 1`, then the norm
of `z - y * z` is controled by the norm of `star z * (1 - x) * z`, which is advantageous because the
latter is nonnegative. This is a key step in establishing the existence of an increasing approximate
unit in general C‚ãÜ-algebras. -/
lemma sq_norm_sub_mul_self_le {A : Type*} [CStarAlgebra A] [PartialOrder A] [StarOrderedRing A]
    {x : A} (z : A) (hx : x ‚àà Set.Icc 0 1) :
    ‚Äñz - x * z‚Äñ ^ 2 ‚â§ ‚Äñstar z * (1 - x) * z‚Äñ :=
  sq_nnnorm_sub_mul_self_le _ hx

variable {A} in
/-- A variant of `sq_norm_sub_mul_self_le` for non-unital algebras that passes to the
unitization. -/
lemma sq_norm_sub_mul_self_le_inr {x : A} (z : A) (hx‚ÇÄ : 0 ‚â§ x) (hx‚ÇÅ : ‚Äñx‚Äñ ‚â§ 1) :
    ‚Äñz - x * z‚Äñ ^ 2 ‚â§ ‚Äñstar (z : A‚Å∫¬π) * (1 - x) * z‚Äñ := by
  rw [‚Üê norm_inr (ùïú := ‚ÑÇ), inr_sub, inr_mul]
  refine sq_norm_sub_mul_self_le _ ?_
  rw [Set.mem_Icc, inr_nonneg_iff, ‚Üê norm_le_one_iff_of_nonneg _, norm_inr]
  exact ‚ü®hx‚ÇÄ, hx‚ÇÅ‚ü©

variable {A} in
/-- This shows `CStarAlgebra.approximateUnit` is a one-sided approximate unit, but this is marked
`private` because it is only used to prove `CStarAlgebra.increasingApproximateUnit`. -/
private lemma tendsto_mul_right_approximateUnit (m : A) :
    Tendsto (¬∑ * m) (approximateUnit A) (ùìù m) := by
  refine tendsto_mul_right_of_forall_nonneg_tendsto (fun m hm‚ÇÄ hm‚ÇÅ ‚Ü¶ ?_) m
  rw [tendsto_iff_norm_sub_tendsto_zero, tendsto_zero_iff_sq (.of_forall fun _ ‚Ü¶ norm_nonneg _)]
  have : ‚àÄ·∂† x in approximateUnit A, ‚Äñx * m - m‚Äñ ^ 2 ‚â§ ‚Äñstar (m : A‚Å∫¬π) * (1 - x) * m‚Äñ := by
    filter_upwards [eventually_nonneg_approximateUnit A, eventually_norm_le_approximateUnit A]
    simp_rw [norm_sub_rev]
    exact fun _ ‚Ü¶ sq_norm_sub_mul_self_le_inr _
  refine tendsto_of_tendsto_of_tendsto_of_le_of_le' tendsto_const_nhds ?_
    (.of_forall fun _ ‚Ü¶ sq_nonneg _) this

  suffices ‚àÄ Œµ, 0 < Œµ ‚Üí ‚àÉ e : A, 0 ‚â§ e ‚àß ‚Äñe‚Äñ < 1 ‚àß ‚Äñstar (m : A‚Å∫¬π) * (1 - e) * m‚Äñ ‚â§ Œµ by
    simp_rw [‚Üê tendsto_zero_iff_norm_tendsto_zero, Metric.nhds_basis_closedBall.tendsto_right_iff,
      mem_closedBall_zero_iff]
    peel this with Œµ hŒµ this
    rcases this with ‚ü®e, he‚ÇÄ, he‚ÇÅ, he‚ü©
    filter_upwards [eventually_ge_approximateUnit A he‚ÇÄ he‚ÇÅ, eventually_norm_le_approximateUnit A]
      with a hea ha‚ÇÅ
    have ha‚ÇÄ : 0 ‚â§ a := he‚ÇÄ.trans hea
    have ha‚ÇÄ' : 0 ‚â§ (a : A‚Å∫¬π) := inr_nonneg_iff.mpr ha‚ÇÄ
    refine le_trans (norm_le_norm_of_nonneg_of_le ?_ ?_) he
    ¬∑ refine conjugate_nonneg (sub_nonneg_of_le ?_) (m : A‚Å∫¬π)
      rwa [‚Üê norm_le_one_iff_of_nonneg (a : A‚Å∫¬π) ha‚ÇÄ', norm_inr]
    ¬∑ refine conjugate_le_conjugate (sub_le_sub_iff_left _ |>.mpr ?_) (m : A‚Å∫¬π)
      exact inr_le_iff _ _ he‚ÇÄ.isSelfAdjoint ha‚ÇÄ.isSelfAdjoint |>.mpr hea

  intro Œµ hŒµ
  lift Œµ to ‚Ñù‚â•0 using hŒµ.le
  rw [coe_pos] at hŒµ
  set e : A := cfc‚Çô (fun y : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + y)‚Åª¬π) (Œµ‚Åª¬π ‚Ä¢ m) with e_def
  have he‚ÇÄ : 0 ‚â§ e := cfc‚Çô_nonneg_of_predicate
  have he‚ÇÅ : ‚Äñe‚Äñ < 1 := norm_cfc‚Çô_one_sub_one_add_inv_lt_one (Œµ‚Åª¬π ‚Ä¢ m)
  refine ‚ü®e, he‚ÇÄ, he‚ÇÅ, ?_‚ü©
  rw [‚Üê norm_inr (ùïú := ‚ÑÇ)] at hm‚ÇÅ he‚ÇÅ
  rw [‚Üê inr_nonneg_iff] at he‚ÇÄ hm‚ÇÄ
  have cont : Continuous (fun y : ‚Ñù‚â•0 ‚Ü¶ 1 - (1 + y)‚Åª¬π) := by
    rw [continuous_iff_continuousOn_univ]
    fun_prop (disch := intro _ _; positivity)
  have cont' : ContinuousOn (fun y ‚Ü¶ (1 + Œµ‚Åª¬π ‚Ä¢ y)‚Åª¬π) (spectrum ‚Ñù‚â•0 (m : A‚Å∫¬π)) :=
    ContinuousOn.inv‚ÇÄ (by fun_prop) fun _ _ ‚Ü¶ by positivity
  have : star (m : A‚Å∫¬π) * (1 - e) * m =
      cfc (fun y : ‚Ñù‚â•0 ‚Ü¶ y * (1 + Œµ‚Åª¬π ‚Ä¢ y)‚Åª¬π * y) (m : A‚Å∫¬π) := by
    rw [hm‚ÇÄ.star_eq, e_def, nnreal_cfc‚Çô_eq_cfc_inr _ _ (by simp [tsub_self]), inr_smul,
      cfc_mul _ _ (m : A‚Å∫¬π) (continuousOn_id' _ |>.mul cont') (continuousOn_id' _),
      cfc_mul _ _ (m : A‚Å∫¬π) (continuousOn_id' _) cont', cfc_id' ..]
    rw [‚Üê cfc_one (R := ‚Ñù‚â•0) (m : A‚Å∫¬π), ‚Üê cfc_comp_smul _ _ _ cont.continuousOn hm‚ÇÄ,
      ‚Üê cfc_tsub _ _ (m : A‚Å∫¬π) (by simp) hm‚ÇÄ (by fun_prop) (continuousOn_const.sub cont')]
    simp [tsub_tsub_cancel_of_le]
  rw [this, ‚Üê coe_nnnorm, coe_le_coe]
  refine nnnorm_cfc_nnreal_le fun y hy ‚Ü¶ ?_
  field_simp
  calc
    y * Œµ * y / (Œµ + y) ‚â§ Œµ * 1 := by
      rw [mul_div_assoc]
      refine mul_le_mul (mul_le_of_le_one_left (zero_le _) ?_)
        (div_le_one (by positivity) |>.mpr le_add_self)
        (by positivity) (by positivity)
      exact_mod_cast spectrum.coe_le_norm_of_mem hy |>.trans hm‚ÇÅ.le
    _ = Œµ := mul_one _

/-- The filter `CStarAlgebra.approximateUnit` generated by the sections
`{x | a ‚â§ x} ‚à© closedBall 0 1` for `0 ‚â§ a` forms an increasing approximate unit. -/
lemma increasingApproximateUnit :
    IsIncreasingApproximateUnit (approximateUnit A) where
  tendsto_mul_left := by
    rw [tendsto_mul_left_iff_tendsto_mul_right]
    ¬∑ exact tendsto_mul_right_approximateUnit
    ¬∑ filter_upwards [eventually_nonneg_approximateUnit A] using fun _ h ‚Ü¶ h.isSelfAdjoint
  tendsto_mul_right := tendsto_mul_right_approximateUnit
  eventually_nonneg := eventually_nonneg_approximateUnit A
  eventually_norm := eventually_norm_le_approximateUnit A
  neBot := inferInstance

end CStarAlgebra

end ApproximateUnit
