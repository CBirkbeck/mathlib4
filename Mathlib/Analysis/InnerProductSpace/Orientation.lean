/-
Copyright (c) 2022 Joseph Myers. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Joseph Myers, Heather Macbeth
-/
import Mathlib.Analysis.InnerProductSpace.GramSchmidtOrtho
import Mathlib.LinearAlgebra.Orientation

#align_import analysis.inner_product_space.orientation from "leanprover-community/mathlib"@"bd65478311e4dfd41f48bf38c7e3b02fb75d0163"

/-!
# Orientations of real inner product spaces.

This file provides definitions and proves lemmas about orientations of real inner product spaces.

## Main definitions

* `OrthonormalBasis.adjustToOrientation` takes an orthonormal basis and an orientation, and
  returns an orthonormal basis with that orientation: either the original orthonormal basis, or one
  constructed by negating a single (arbitrary) basis vector.
* `Orientation.finOrthonormalBasis` is an orthonormal basis, indexed by `Fin n`, with the given
  orientation.
* `Orientation.volumeForm` is a nonvanishing top-dimensional alternating form on an oriented real
  inner product space, uniquely defined by compatibility with the orientation and inner product
  structure.

## Main theorems

* `Orientation.volumeForm_apply_le` states that the result of applying the volume form to a set of
  `n` vectors, where `n` is the dimension the inner product space, is bounded by the product of the
  lengths of the vectors.
* `Orientation.abs_volumeForm_apply_of_pairwise_orthogonal` states that the result of applying the
  volume form to a set of `n` orthogonal vectors, where `n` is the dimension the inner product
  space, is equal up to sign to the product of the lengths of the vectors.

-/


noncomputable section

variable {E : Type*} [NormedAddCommGroup E] [InnerProductSpace ‚Ñù E]

open FiniteDimensional

open scoped BigOperators RealInnerProductSpace

namespace OrthonormalBasis

variable {Œπ : Type*} [Fintype Œπ] [DecidableEq Œπ] [ne : Nonempty Œπ] (e f : OrthonormalBasis Œπ ‚Ñù E)
  (x : Orientation ‚Ñù E Œπ)

/-- The change-of-basis matrix between two orthonormal bases with the same orientation has
determinant 1. -/
theorem det_to_matrix_orthonormalBasis_of_same_orientation
    (h : e.toBasis.orientation = f.toBasis.orientation) : e.toBasis.det f = 1 := by
  apply (e.det_to_matrix_orthonormalBasis_real f).resolve_right
  -- ‚ä¢ ¬¨‚Üë(Basis.det (OrthonormalBasis.toBasis e)) ‚Üëf = -1
  have : 0 < e.toBasis.det f := by
    rw [e.toBasis.orientation_eq_iff_det_pos] at h
    simpa using h
  linarith
  -- üéâ no goals
#align orthonormal_basis.det_to_matrix_orthonormal_basis_of_same_orientation OrthonormalBasis.det_to_matrix_orthonormalBasis_of_same_orientation

/-- The change-of-basis matrix between two orthonormal bases with the opposite orientations has
determinant -1. -/
theorem det_to_matrix_orthonormalBasis_of_opposite_orientation
    (h : e.toBasis.orientation ‚â† f.toBasis.orientation) : e.toBasis.det f = -1 := by
  contrapose! h
  -- ‚ä¢ Basis.orientation (OrthonormalBasis.toBasis e) = Basis.orientation (Orthonor ‚Ä¶
  simp [e.toBasis.orientation_eq_iff_det_pos,
    (e.det_to_matrix_orthonormalBasis_real f).resolve_right h]
#align orthonormal_basis.det_to_matrix_orthonormal_basis_of_opposite_orientation OrthonormalBasis.det_to_matrix_orthonormalBasis_of_opposite_orientation

variable {e f}

/-- Two orthonormal bases with the same orientation determine the same "determinant" top-dimensional
form on `E`, and conversely. -/
theorem same_orientation_iff_det_eq_det :
    e.toBasis.det = f.toBasis.det ‚Üî e.toBasis.orientation = f.toBasis.orientation := by
  constructor
  -- ‚ä¢ Basis.det (OrthonormalBasis.toBasis e) = Basis.det (OrthonormalBasis.toBasis ‚Ä¶
  ¬∑ intro h
    -- ‚ä¢ Basis.orientation (OrthonormalBasis.toBasis e) = Basis.orientation (Orthonor ‚Ä¶
    dsimp [Basis.orientation]
    -- ‚ä¢ rayOfNeZero ‚Ñù (Basis.det (OrthonormalBasis.toBasis e)) (_ : Basis.det (Ortho ‚Ä¶
    congr
    -- üéâ no goals
  ¬∑ intro h
    -- ‚ä¢ Basis.det (OrthonormalBasis.toBasis e) = Basis.det (OrthonormalBasis.toBasis ‚Ä¶
    rw [e.toBasis.det.eq_smul_basis_det f.toBasis]
    -- ‚ä¢ ‚Üë(Basis.det (OrthonormalBasis.toBasis e)) ‚Üë(OrthonormalBasis.toBasis f) ‚Ä¢ Ba ‚Ä¶
    simp [e.det_to_matrix_orthonormalBasis_of_same_orientation f h]
    -- üéâ no goals
#align orthonormal_basis.same_orientation_iff_det_eq_det OrthonormalBasis.same_orientation_iff_det_eq_det

variable (e f)

/-- Two orthonormal bases with opposite orientations determine opposite "determinant"
top-dimensional forms on `E`. -/
theorem det_eq_neg_det_of_opposite_orientation (h : e.toBasis.orientation ‚â† f.toBasis.orientation) :
    e.toBasis.det = -f.toBasis.det := by
  rw [e.toBasis.det.eq_smul_basis_det f.toBasis]
  -- ‚ä¢ ‚Üë(Basis.det (OrthonormalBasis.toBasis e)) ‚Üë(OrthonormalBasis.toBasis f) ‚Ä¢ Ba ‚Ä¶
  -- Porting note: added `neg_one_smul` with explicit type
  simp [e.det_to_matrix_orthonormalBasis_of_opposite_orientation f h,
    neg_one_smul ‚Ñù (M := AlternatingMap ‚Ñù E ‚Ñù Œπ)]
#align orthonormal_basis.det_eq_neg_det_of_opposite_orientation OrthonormalBasis.det_eq_neg_det_of_opposite_orientation

section AdjustToOrientation

/-- `OrthonormalBasis.adjustToOrientation`, applied to an orthonormal basis, preserves the
property of orthonormality. -/
theorem orthonormal_adjustToOrientation : Orthonormal ‚Ñù (e.toBasis.adjustToOrientation x) := by
  apply e.orthonormal.orthonormal_of_forall_eq_or_eq_neg
  -- ‚ä¢ ‚àÄ (i : Œπ), ‚Üë(Basis.adjustToOrientation (OrthonormalBasis.toBasis e) x) i = ‚Üë ‚Ä¶
  simpa using e.toBasis.adjustToOrientation_apply_eq_or_eq_neg x
  -- üéâ no goals
#align orthonormal_basis.orthonormal_adjust_to_orientation OrthonormalBasis.orthonormal_adjustToOrientation

/-- Given an orthonormal basis and an orientation, return an orthonormal basis giving that
orientation: either the original basis, or one constructed by negating a single (arbitrary) basis
vector. -/
def adjustToOrientation : OrthonormalBasis Œπ ‚Ñù E :=
  (e.toBasis.adjustToOrientation x).toOrthonormalBasis (e.orthonormal_adjustToOrientation x)
#align orthonormal_basis.adjust_to_orientation OrthonormalBasis.adjustToOrientation

theorem toBasis_adjustToOrientation :
    (e.adjustToOrientation x).toBasis = e.toBasis.adjustToOrientation x :=
  (e.toBasis.adjustToOrientation x).toBasis_toOrthonormalBasis _
#align orthonormal_basis.to_basis_adjust_to_orientation OrthonormalBasis.toBasis_adjustToOrientation

/-- `adjustToOrientation` gives an orthonormal basis with the required orientation. -/
@[simp]
theorem orientation_adjustToOrientation : (e.adjustToOrientation x).toBasis.orientation = x := by
  rw [e.toBasis_adjustToOrientation]
  -- ‚ä¢ Basis.orientation (Basis.adjustToOrientation (OrthonormalBasis.toBasis e) x) ‚Ä¶
  exact e.toBasis.orientation_adjustToOrientation x
  -- üéâ no goals
#align orthonormal_basis.orientation_adjust_to_orientation OrthonormalBasis.orientation_adjustToOrientation

/-- Every basis vector from `adjustToOrientation` is either that from the original basis or its
negation. -/
theorem adjustToOrientation_apply_eq_or_eq_neg (i : Œπ) :
    e.adjustToOrientation x i = e i ‚à® e.adjustToOrientation x i = -e i := by
  simpa [‚Üê e.toBasis_adjustToOrientation] using
    e.toBasis.adjustToOrientation_apply_eq_or_eq_neg x i
#align orthonormal_basis.adjust_to_orientation_apply_eq_or_eq_neg OrthonormalBasis.adjustToOrientation_apply_eq_or_eq_neg

theorem det_adjustToOrientation :
    (e.adjustToOrientation x).toBasis.det = e.toBasis.det ‚à®
      (e.adjustToOrientation x).toBasis.det = -e.toBasis.det := by
  simpa using e.toBasis.det_adjustToOrientation x
  -- üéâ no goals
#align orthonormal_basis.det_adjust_to_orientation OrthonormalBasis.det_adjustToOrientation

theorem abs_det_adjustToOrientation (v : Œπ ‚Üí E) :
    |(e.adjustToOrientation x).toBasis.det v| = |e.toBasis.det v| := by
  simp [toBasis_adjustToOrientation]
  -- üéâ no goals
#align orthonormal_basis.abs_det_adjust_to_orientation OrthonormalBasis.abs_det_adjustToOrientation

end AdjustToOrientation

end OrthonormalBasis

namespace Orientation

variable {n : ‚Ñï}

open OrthonormalBasis

/-- An orthonormal basis, indexed by `Fin n`, with the given orientation. -/
protected def finOrthonormalBasis (hn : 0 < n) (h : finrank ‚Ñù E = n) (x : Orientation ‚Ñù E (Fin n)) :
    OrthonormalBasis (Fin n) ‚Ñù E := by
  haveI := Fin.pos_iff_nonempty.1 hn
  -- ‚ä¢ OrthonormalBasis (Fin n) ‚Ñù E
  haveI := finiteDimensional_of_finrank (h.symm ‚ñ∏ hn : 0 < finrank ‚Ñù E)
  -- ‚ä¢ OrthonormalBasis (Fin n) ‚Ñù E
  exact ((@stdOrthonormalBasis _ _ _ _ _ this).reindex <| finCongr h).adjustToOrientation x
  -- üéâ no goals
#align orientation.fin_orthonormal_basis Orientation.finOrthonormalBasis

/-- `Orientation.finOrthonormalBasis` gives a basis with the required orientation. -/
@[simp]
theorem finOrthonormalBasis_orientation (hn : 0 < n) (h : finrank ‚Ñù E = n)
    (x : Orientation ‚Ñù E (Fin n)) : (x.finOrthonormalBasis hn h).toBasis.orientation = x := by
  haveI := Fin.pos_iff_nonempty.1 hn
  -- ‚ä¢ Basis.orientation (OrthonormalBasis.toBasis (Orientation.finOrthonormalBasis ‚Ä¶
  haveI := finiteDimensional_of_finrank (h.symm ‚ñ∏ hn : 0 < finrank ‚Ñù E)
  -- ‚ä¢ Basis.orientation (OrthonormalBasis.toBasis (Orientation.finOrthonormalBasis ‚Ä¶
  exact ((@stdOrthonormalBasis _ _ _ _ _ this).reindex <|
    finCongr h).orientation_adjustToOrientation x
#align orientation.fin_orthonormal_basis_orientation Orientation.finOrthonormalBasis_orientation

section VolumeForm

variable [_i : Fact (finrank ‚Ñù E = n)] (o : Orientation ‚Ñù E (Fin n))

-- Porting note: added instance
instance : IsEmpty (Fin Nat.zero) := by simp only [Nat.zero_eq]; infer_instance
                                        -- ‚ä¢ IsEmpty (Fin 0)
                                                                 -- üéâ no goals

/-- The volume form on an oriented real inner product space, a nonvanishing top-dimensional
alternating form uniquely defined by compatibility with the orientation and inner product structure.
-/
irreducible_def volumeForm : AlternatingMap ‚Ñù E ‚Ñù (Fin n) := by
  classical
    cases' n with n
    ¬∑ let opos : AlternatingMap ‚Ñù E ‚Ñù (Fin 0) := AlternatingMap.constOfIsEmpty ‚Ñù E (Fin 0) (1 : ‚Ñù)
      exact o.eq_or_eq_neg_of_isEmpty.by_cases (fun _ => opos) fun _ => -opos
    ¬∑ exact (o.finOrthonormalBasis n.succ_pos _i.out).toBasis.det
#align orientation.volume_form Orientation.volumeForm

@[simp]
theorem volumeForm_zero_pos [_i : Fact (finrank ‚Ñù E = 0)] :
    Orientation.volumeForm (positiveOrientation : Orientation ‚Ñù E (Fin 0)) =
      AlternatingMap.constLinearEquivOfIsEmpty 1 := by
  simp [volumeForm, Or.by_cases, if_pos]
  -- üéâ no goals
#align orientation.volume_form_zero_pos Orientation.volumeForm_zero_pos

theorem volumeForm_zero_neg [_i : Fact (finrank ‚Ñù E = 0)] :
    Orientation.volumeForm (-positiveOrientation : Orientation ‚Ñù E (Fin 0)) =
      -AlternatingMap.constLinearEquivOfIsEmpty 1 := by
  simp_rw [volumeForm, Or.by_cases, positiveOrientation]
  -- ‚ä¢ Nat.rec (motive := fun t => 0 = t ‚Üí AlternatingMap ‚Ñù E ‚Ñù (Fin 0)) (fun h =>  ‚Ä¶
  apply if_neg
  -- ‚ä¢ ¬¨-rayOfNeZero ‚Ñù (‚ÜëAlternatingMap.constLinearEquivOfIsEmpty 1) (_ : ‚ÜëAlternat ‚Ä¶
  simp only [neg_rayOfNeZero]
  -- ‚ä¢ ¬¨rayOfNeZero ‚Ñù (-‚ÜëAlternatingMap.constLinearEquivOfIsEmpty 1) (_ : -‚ÜëAlterna ‚Ä¶
  rw [ray_eq_iff, SameRay.sameRay_comm]
  -- ‚ä¢ ¬¨SameRay ‚Ñù (‚ÜëAlternatingMap.constLinearEquivOfIsEmpty 1) (-‚ÜëAlternatingMap.c ‚Ä¶
  intro h
  -- ‚ä¢ False
  simpa using
    congr_arg AlternatingMap.constLinearEquivOfIsEmpty.symm (eq_zero_of_sameRay_self_neg h)
#align orientation.volume_form_zero_neg Orientation.volumeForm_zero_neg

/-- The volume form on an oriented real inner product space can be evaluated as the determinant with
respect to any orthonormal basis of the space compatible with the orientation. -/
theorem volumeForm_robust (b : OrthonormalBasis (Fin n) ‚Ñù E) (hb : b.toBasis.orientation = o) :
    o.volumeForm = b.toBasis.det := by
  cases n
  -- ‚ä¢ volumeForm o = Basis.det (OrthonormalBasis.toBasis b)
  ¬∑ classical
      have : o = positiveOrientation := hb.symm.trans b.toBasis.orientation_isEmpty
      simp_rw [volumeForm, Or.by_cases, dif_pos this, Basis.det_isEmpty]
  ¬∑ simp_rw [volumeForm]
    -- ‚ä¢ Basis.det (OrthonormalBasis.toBasis (Orientation.finOrthonormalBasis (_ : 0  ‚Ä¶
    rw [same_orientation_iff_det_eq_det, hb]
    -- ‚ä¢ Basis.orientation (OrthonormalBasis.toBasis (Orientation.finOrthonormalBasis ‚Ä¶
    exact o.finOrthonormalBasis_orientation _ _
    -- üéâ no goals
#align orientation.volume_form_robust Orientation.volumeForm_robust

/-- The volume form on an oriented real inner product space can be evaluated as the determinant with
respect to any orthonormal basis of the space compatible with the orientation. -/
theorem volumeForm_robust_neg (b : OrthonormalBasis (Fin n) ‚Ñù E) (hb : b.toBasis.orientation ‚â† o) :
    o.volumeForm = -b.toBasis.det := by
  cases' n with n
  -- ‚ä¢ volumeForm o = -Basis.det (OrthonormalBasis.toBasis b)
  ¬∑ classical
      have : positiveOrientation ‚â† o := by rwa [b.toBasis.orientation_isEmpty] at hb
      simp_rw [volumeForm, Or.by_cases, dif_neg this.symm, Basis.det_isEmpty]
  let e : OrthonormalBasis (Fin n.succ) ‚Ñù E := o.finOrthonormalBasis n.succ_pos Fact.out
  -- ‚ä¢ volumeForm o = -Basis.det (OrthonormalBasis.toBasis b)
  simp_rw [volumeForm]
  -- ‚ä¢ Basis.det (OrthonormalBasis.toBasis (Orientation.finOrthonormalBasis (_ : 0  ‚Ä¶
  apply e.det_eq_neg_det_of_opposite_orientation b
  -- ‚ä¢ Basis.orientation (OrthonormalBasis.toBasis e) ‚â† Basis.orientation (Orthonor ‚Ä¶
  convert hb.symm
  -- ‚ä¢ Basis.orientation (OrthonormalBasis.toBasis e) = o
  exact o.finOrthonormalBasis_orientation _ _
  -- üéâ no goals
#align orientation.volume_form_robust_neg Orientation.volumeForm_robust_neg

@[simp]
theorem volumeForm_neg_orientation : (-o).volumeForm = -o.volumeForm := by
  cases' n with n
  -- ‚ä¢ volumeForm (-o) = -volumeForm o
  ¬∑ refine' o.eq_or_eq_neg_of_isEmpty.elim _ _ <;> rintro rfl
    -- ‚ä¢ o = positiveOrientation ‚Üí volumeForm (-o) = -volumeForm o
                                                   -- ‚ä¢ volumeForm (-positiveOrientation) = -volumeForm positiveOrientation
                                                   -- ‚ä¢ volumeForm (- -positiveOrientation) = -volumeForm (-positiveOrientation)
    ¬∑ simp [volumeForm_zero_neg]
      -- üéâ no goals
    ¬∑ rw [neg_neg (positiveOrientation (R := ‚Ñù))] -- Porting note: added
      -- ‚ä¢ volumeForm positiveOrientation = -volumeForm (-positiveOrientation)
      simp [volumeForm_zero_neg]
      -- üéâ no goals
  let e : OrthonormalBasis (Fin n.succ) ‚Ñù E := o.finOrthonormalBasis n.succ_pos Fact.out
  -- ‚ä¢ volumeForm (-o) = -volumeForm o
  have h‚ÇÅ : e.toBasis.orientation = o := o.finOrthonormalBasis_orientation _ _
  -- ‚ä¢ volumeForm (-o) = -volumeForm o
  have h‚ÇÇ : e.toBasis.orientation ‚â† -o := by
    symm
    rw [e.toBasis.orientation_ne_iff_eq_neg, h‚ÇÅ]
  rw [o.volumeForm_robust e h‚ÇÅ, (-o).volumeForm_robust_neg e h‚ÇÇ]
  -- üéâ no goals
#align orientation.volume_form_neg_orientation Orientation.volumeForm_neg_orientation

theorem volumeForm_robust' (b : OrthonormalBasis (Fin n) ‚Ñù E) (v : Fin n ‚Üí E) :
    |o.volumeForm v| = |b.toBasis.det v| := by
  cases n
  -- ‚ä¢ |‚Üë(volumeForm o) v| = |‚Üë(Basis.det (OrthonormalBasis.toBasis b)) v|
  ¬∑ refine' o.eq_or_eq_neg_of_isEmpty.elim _ _ <;> rintro rfl <;> simp
    -- ‚ä¢ o = positiveOrientation ‚Üí |‚Üë(volumeForm o) v| = |‚Üë(Basis.det (OrthonormalBas ‚Ä¶
                                                   -- ‚ä¢ |‚Üë(volumeForm positiveOrientation) v| = |‚Üë(Basis.det (OrthonormalBasis.toBas ‚Ä¶
                                                   -- ‚ä¢ |‚Üë(volumeForm (-positiveOrientation)) v| = |‚Üë(Basis.det (OrthonormalBasis.to ‚Ä¶
                                                                  -- üéâ no goals
                                                                  -- üéâ no goals
  ¬∑ rw [o.volumeForm_robust (b.adjustToOrientation o) (b.orientation_adjustToOrientation o),
      b.abs_det_adjustToOrientation]
#align orientation.volume_form_robust' Orientation.volumeForm_robust'

/-- Let `v` be an indexed family of `n` vectors in an oriented `n`-dimensional real inner
product space `E`. The output of the volume form of `E` when evaluated on `v` is bounded in absolute
value by the product of the norms of the vectors `v i`. -/
theorem abs_volumeForm_apply_le (v : Fin n ‚Üí E) : |o.volumeForm v| ‚â§ ‚àè i : Fin n, ‚Äñv i‚Äñ := by
  cases' n with n
  -- ‚ä¢ |‚Üë(volumeForm o) v| ‚â§ ‚àè i : Fin Nat.zero, ‚Äñv i‚Äñ
  ¬∑ refine' o.eq_or_eq_neg_of_isEmpty.elim _ _ <;> rintro rfl <;> simp
    -- ‚ä¢ o = positiveOrientation ‚Üí |‚Üë(volumeForm o) v| ‚â§ ‚àè i : Fin Nat.zero, ‚Äñv i‚Äñ
                                                   -- ‚ä¢ |‚Üë(volumeForm positiveOrientation) v| ‚â§ ‚àè i : Fin Nat.zero, ‚Äñv i‚Äñ
                                                   -- ‚ä¢ |‚Üë(volumeForm (-positiveOrientation)) v| ‚â§ ‚àè i : Fin Nat.zero, ‚Äñv i‚Äñ
                                                                  -- üéâ no goals
                                                                  -- üéâ no goals
  haveI : FiniteDimensional ‚Ñù E := fact_finiteDimensional_of_finrank_eq_succ n
  -- ‚ä¢ |‚Üë(volumeForm o) v| ‚â§ ‚àè i : Fin (Nat.succ n), ‚Äñv i‚Äñ
  have : finrank ‚Ñù E = Fintype.card (Fin n.succ) := by simpa using _i.out
  -- ‚ä¢ |‚Üë(volumeForm o) v| ‚â§ ‚àè i : Fin (Nat.succ n), ‚Äñv i‚Äñ
  let b : OrthonormalBasis (Fin n.succ) ‚Ñù E := gramSchmidtOrthonormalBasis this v
  -- ‚ä¢ |‚Üë(volumeForm o) v| ‚â§ ‚àè i : Fin (Nat.succ n), ‚Äñv i‚Äñ
  have hb : b.toBasis.det v = ‚àè i, ‚ü™b i, v i‚ü´ := gramSchmidtOrthonormalBasis_det this v
  -- ‚ä¢ |‚Üë(volumeForm o) v| ‚â§ ‚àè i : Fin (Nat.succ n), ‚Äñv i‚Äñ
  rw [o.volumeForm_robust' b, hb, Finset.abs_prod]
  -- ‚ä¢ ‚àè x : Fin (Nat.succ n), |inner (‚Üëb x) (v x)| ‚â§ ‚àè i : Fin (Nat.succ n), ‚Äñv i‚Äñ
  apply Finset.prod_le_prod
  -- ‚ä¢ ‚àÄ (i : Fin (Nat.succ n)), i ‚àà Finset.univ ‚Üí 0 ‚â§ |inner (‚Üëb i) (v i)|
  ¬∑ intro i _
    -- ‚ä¢ 0 ‚â§ |inner (‚Üëb i) (v i)|
    positivity
    -- üéâ no goals
  intro i _
  -- ‚ä¢ |inner (‚Üëb i) (v i)| ‚â§ ‚Äñv i‚Äñ
  convert abs_real_inner_le_norm (b i) (v i)
  -- ‚ä¢ ‚Äñv i‚Äñ = ‚Äñ‚Üëb i‚Äñ * ‚Äñv i‚Äñ
  simp [b.orthonormal.1 i]
  -- üéâ no goals
#align orientation.abs_volume_form_apply_le Orientation.abs_volumeForm_apply_le

theorem volumeForm_apply_le (v : Fin n ‚Üí E) : o.volumeForm v ‚â§ ‚àè i : Fin n, ‚Äñv i‚Äñ :=
  (le_abs_self _).trans (o.abs_volumeForm_apply_le v)
#align orientation.volume_form_apply_le Orientation.volumeForm_apply_le

/-- Let `v` be an indexed family of `n` orthogonal vectors in an oriented `n`-dimensional
real inner product space `E`. The output of the volume form of `E` when evaluated on `v` is, up to
sign, the product of the norms of the vectors `v i`. -/
theorem abs_volumeForm_apply_of_pairwise_orthogonal {v : Fin n ‚Üí E}
    (hv : Pairwise fun i j => ‚ü™v i, v j‚ü´ = 0) : |o.volumeForm v| = ‚àè i : Fin n, ‚Äñv i‚Äñ := by
  cases' n with n
  -- ‚ä¢ |‚Üë(volumeForm o) v| = ‚àè i : Fin Nat.zero, ‚Äñv i‚Äñ
  ¬∑ refine' o.eq_or_eq_neg_of_isEmpty.elim _ _ <;> rintro rfl <;> simp
    -- ‚ä¢ o = positiveOrientation ‚Üí |‚Üë(volumeForm o) v| = ‚àè i : Fin Nat.zero, ‚Äñv i‚Äñ
                                                   -- ‚ä¢ |‚Üë(volumeForm positiveOrientation) v| = ‚àè i : Fin Nat.zero, ‚Äñv i‚Äñ
                                                   -- ‚ä¢ |‚Üë(volumeForm (-positiveOrientation)) v| = ‚àè i : Fin Nat.zero, ‚Äñv i‚Äñ
                                                                  -- üéâ no goals
                                                                  -- üéâ no goals
  haveI : FiniteDimensional ‚Ñù E := fact_finiteDimensional_of_finrank_eq_succ n
  -- ‚ä¢ |‚Üë(volumeForm o) v| = ‚àè i : Fin (Nat.succ n), ‚Äñv i‚Äñ
  have hdim : finrank ‚Ñù E = Fintype.card (Fin n.succ) := by simpa using _i.out
  -- ‚ä¢ |‚Üë(volumeForm o) v| = ‚àè i : Fin (Nat.succ n), ‚Äñv i‚Äñ
  let b : OrthonormalBasis (Fin n.succ) ‚Ñù E := gramSchmidtOrthonormalBasis hdim v
  -- ‚ä¢ |‚Üë(volumeForm o) v| = ‚àè i : Fin (Nat.succ n), ‚Äñv i‚Äñ
  have hb : b.toBasis.det v = ‚àè i, ‚ü™b i, v i‚ü´ := gramSchmidtOrthonormalBasis_det hdim v
  -- ‚ä¢ |‚Üë(volumeForm o) v| = ‚àè i : Fin (Nat.succ n), ‚Äñv i‚Äñ
  rw [o.volumeForm_robust' b, hb, Finset.abs_prod]
  -- ‚ä¢ ‚àè x : Fin (Nat.succ n), |inner (‚Üëb x) (v x)| = ‚àè i : Fin (Nat.succ n), ‚Äñv i‚Äñ
  by_cases h : ‚àÉ i, v i = 0
  -- ‚ä¢ ‚àè x : Fin (Nat.succ n), |inner (‚Üëb x) (v x)| = ‚àè i : Fin (Nat.succ n), ‚Äñv i‚Äñ
  obtain ‚ü®i, hi‚ü© := h
  -- ‚ä¢ ‚àè x : Fin (Nat.succ n), |inner (‚Üëb x) (v x)| = ‚àè i : Fin (Nat.succ n), ‚Äñv i‚Äñ
  ¬∑ rw [Finset.prod_eq_zero (Finset.mem_univ i), Finset.prod_eq_zero (Finset.mem_univ i)] <;>
    -- ‚ä¢ ‚Äñv i‚Äñ = 0
      simp [hi]
      -- üéâ no goals
      -- üéâ no goals
  push_neg at h
  -- ‚ä¢ ‚àè x : Fin (Nat.succ n), |inner (‚Üëb x) (v x)| = ‚àè i : Fin (Nat.succ n), ‚Äñv i‚Äñ
  congr
  -- ‚ä¢ (fun x => |inner (‚Üëb x) (v x)|) = fun i => ‚Äñv i‚Äñ
  ext i
  -- ‚ä¢ |inner (‚Üëb i) (v i)| = ‚Äñv i‚Äñ
  have hb : b i = ‚Äñv i‚Äñ‚Åª¬π ‚Ä¢ v i := gramSchmidtOrthonormalBasis_apply_of_orthogonal hdim hv (h i)
  -- ‚ä¢ |inner (‚Üëb i) (v i)| = ‚Äñv i‚Äñ
  simp only [hb, inner_smul_left, real_inner_self_eq_norm_mul_norm, IsROrC.conj_to_real]
  -- ‚ä¢ |‚Äñv i‚Äñ‚Åª¬π * (‚Äñv i‚Äñ * ‚Äñv i‚Äñ)| = ‚Äñv i‚Äñ
  rw [abs_of_nonneg]
  -- ‚ä¢ ‚Äñv i‚Äñ‚Åª¬π * (‚Äñv i‚Äñ * ‚Äñv i‚Äñ) = ‚Äñv i‚Äñ
  ¬∑ field_simp
    -- üéâ no goals
  ¬∑ positivity
    -- üéâ no goals
#align orientation.abs_volume_form_apply_of_pairwise_orthogonal Orientation.abs_volumeForm_apply_of_pairwise_orthogonal

/-- The output of the volume form of an oriented real inner product space `E` when evaluated on an
orthonormal basis is ¬±1. -/
theorem abs_volumeForm_apply_of_orthonormal (v : OrthonormalBasis (Fin n) ‚Ñù E) :
    |o.volumeForm v| = 1 := by
  simpa [o.volumeForm_robust' v v] using congr_arg abs v.toBasis.det_self
  -- üéâ no goals
#align orientation.abs_volume_form_apply_of_orthonormal Orientation.abs_volumeForm_apply_of_orthonormal

theorem volumeForm_map {F : Type*} [NormedAddCommGroup F] [InnerProductSpace ‚Ñù F]
    [Fact (finrank ‚Ñù F = n)] (œÜ : E ‚âÉ‚Çó·µ¢[‚Ñù] F) (x : Fin n ‚Üí F) :
    (Orientation.map (Fin n) œÜ.toLinearEquiv o).volumeForm x = o.volumeForm (œÜ.symm ‚àò x) := by
  cases' n with n
  -- ‚ä¢ ‚Üë(volumeForm (‚Üë(map (Fin Nat.zero) œÜ.toLinearEquiv) o)) x = ‚Üë(volumeForm o)  ‚Ä¶
  ¬∑ refine' o.eq_or_eq_neg_of_isEmpty.elim _ _ <;> rintro rfl <;> simp
    -- ‚ä¢ o = positiveOrientation ‚Üí ‚Üë(volumeForm (‚Üë(map (Fin Nat.zero) œÜ.toLinearEquiv ‚Ä¶
                                                   -- ‚ä¢ ‚Üë(volumeForm (‚Üë(map (Fin Nat.zero) œÜ.toLinearEquiv) positiveOrientation)) x  ‚Ä¶
                                                   -- ‚ä¢ ‚Üë(volumeForm (‚Üë(map (Fin Nat.zero) œÜ.toLinearEquiv) (-positiveOrientation))) ‚Ä¶
                                                                  -- üéâ no goals
                                                                  -- üéâ no goals
  let e : OrthonormalBasis (Fin n.succ) ‚Ñù E := o.finOrthonormalBasis n.succ_pos Fact.out
  -- ‚ä¢ ‚Üë(volumeForm (‚Üë(map (Fin (Nat.succ n)) œÜ.toLinearEquiv) o)) x = ‚Üë(volumeForm ‚Ä¶
  have he : e.toBasis.orientation = o :=
    o.finOrthonormalBasis_orientation n.succ_pos Fact.out
  have heœÜ : (e.map œÜ).toBasis.orientation = Orientation.map (Fin n.succ) œÜ.toLinearEquiv o := by
    rw [‚Üê he]
    exact e.toBasis.orientation_map œÜ.toLinearEquiv
  rw [(Orientation.map (Fin n.succ) œÜ.toLinearEquiv o).volumeForm_robust (e.map œÜ) heœÜ]
  -- ‚ä¢ ‚Üë(Basis.det (OrthonormalBasis.toBasis (OrthonormalBasis.map e œÜ))) x = ‚Üë(vol ‚Ä¶
  rw [o.volumeForm_robust e he]
  -- ‚ä¢ ‚Üë(Basis.det (OrthonormalBasis.toBasis (OrthonormalBasis.map e œÜ))) x = ‚Üë(Bas ‚Ä¶
  simp
  -- üéâ no goals
#align orientation.volume_form_map Orientation.volumeForm_map

/-- The volume form is invariant under pullback by a positively-oriented isometric automorphism. -/
theorem volumeForm_comp_linearIsometryEquiv (œÜ : E ‚âÉ‚Çó·µ¢[‚Ñù] E)
    (hœÜ : 0 < LinearMap.det (œÜ.toLinearEquiv : E ‚Üí‚Çó[‚Ñù] E)) (x : Fin n ‚Üí E) :
    o.volumeForm (œÜ ‚àò x) = o.volumeForm x := by
  cases' n with n -- Porting note: need to explicitly prove `FiniteDimensional ‚Ñù E`
  -- ‚ä¢ ‚Üë(volumeForm o) (‚ÜëœÜ ‚àò x) = ‚Üë(volumeForm o) x
  ¬∑ refine' o.eq_or_eq_neg_of_isEmpty.elim _ _ <;> rintro rfl <;> simp
    -- ‚ä¢ o = positiveOrientation ‚Üí ‚Üë(volumeForm o) (‚ÜëœÜ ‚àò x) = ‚Üë(volumeForm o) x
                                                   -- ‚ä¢ ‚Üë(volumeForm positiveOrientation) (‚ÜëœÜ ‚àò x) = ‚Üë(volumeForm positiveOrientatio ‚Ä¶
                                                   -- ‚ä¢ ‚Üë(volumeForm (-positiveOrientation)) (‚ÜëœÜ ‚àò x) = ‚Üë(volumeForm (-positiveOrien ‚Ä¶
                                                                  -- üéâ no goals
                                                                  -- üéâ no goals
  haveI : FiniteDimensional ‚Ñù E := fact_finiteDimensional_of_finrank_eq_succ n
  -- ‚ä¢ ‚Üë(volumeForm o) (‚ÜëœÜ ‚àò x) = ‚Üë(volumeForm o) x
  convert o.volumeForm_map œÜ (œÜ ‚àò x)
  -- ‚ä¢ o = ‚Üë(map (Fin (Nat.succ n)) œÜ.toLinearEquiv) o
  ¬∑ symm
    -- ‚ä¢ ‚Üë(map (Fin (Nat.succ n)) œÜ.toLinearEquiv) o = o
    rwa [‚Üê o.map_eq_iff_det_pos œÜ.toLinearEquiv] at hœÜ
    -- ‚ä¢ Fintype.card (Fin (Nat.succ n)) = finrank ‚Ñù E
    rw [_i.out, Fintype.card_fin]
    -- üéâ no goals
  ¬∑ ext
    -- ‚ä¢ x x‚úù = (‚Üë(LinearIsometryEquiv.symm œÜ) ‚àò ‚ÜëœÜ ‚àò x) x‚úù
    simp
    -- üéâ no goals
#align orientation.volume_form_comp_linear_isometry_equiv Orientation.volumeForm_comp_linearIsometryEquiv

end VolumeForm

end Orientation
