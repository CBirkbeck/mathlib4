/-
Copyright (c) 2019 S√©bastien Gou√´zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: S√©bastien Gou√´zel
-/
import Mathlib.Analysis.Asymptotics.AsymptoticEquivalent
import Mathlib.Analysis.NormedSpace.AddTorsor
import Mathlib.Analysis.NormedSpace.AffineIsometry
import Mathlib.Analysis.NormedSpace.OperatorNorm
import Mathlib.Analysis.NormedSpace.RieszLemma
import Mathlib.Topology.Algebra.Module.FiniteDimension
import Mathlib.Topology.Algebra.InfiniteSum.Module
import Mathlib.Topology.Instances.Matrix

#align_import analysis.normed_space.finite_dimension from "leanprover-community/mathlib"@"9425b6f8220e53b059f5a4904786c3c4b50fc057"

/-!
# Finite dimensional normed spaces over complete fields

Over a complete nontrivially normed field, in finite dimension, all norms are equivalent and all
linear maps are continuous. Moreover, a finite-dimensional subspace is always complete and closed.

## Main results:

* `FiniteDimensional.complete` : a finite-dimensional space over a complete field is complete. This
  is not registered as an instance, as the field would be an unknown metavariable in typeclass
  resolution.
* `Submodule.closed_of_finiteDimensional` : a finite-dimensional subspace over a complete field is
  closed
* `FiniteDimensional.proper` : a finite-dimensional space over a proper field is proper. This
  is not registered as an instance, as the field would be an unknown metavariable in typeclass
  resolution. It is however registered as an instance for `ùïú = ‚Ñù` and `ùïú = ‚ÑÇ`. As properness
  implies completeness, there is no need to also register `FiniteDimensional.complete` on `‚Ñù` or
  `‚ÑÇ`.
* `finiteDimensional_of_isCompact_closedBall`: Riesz' theorem: if the closed unit ball is
  compact, then the space is finite-dimensional.

## Implementation notes

The fact that all norms are equivalent is not written explicitly, as it would mean having two norms
on a single space, which is not the way type classes work. However, if one has a
finite-dimensional vector space `E` with a norm, and a copy `E'` of this type with another norm,
then the identities from `E` to `E'` and from `E'`to `E` are continuous thanks to
`LinearMap.continuous_of_finiteDimensional`. This gives the desired norm equivalence.
-/


universe u v w x

noncomputable section

open Set FiniteDimensional TopologicalSpace Filter Asymptotics Classical BigOperators Topology
  NNReal

namespace LinearIsometry

open LinearMap

variable {R : Type*} [Semiring R]

variable {F E‚ÇÅ : Type*} [SeminormedAddCommGroup F] [NormedAddCommGroup E‚ÇÅ] [Module R E‚ÇÅ]

variable {R‚ÇÅ : Type*} [Field R‚ÇÅ] [Module R‚ÇÅ E‚ÇÅ] [Module R‚ÇÅ F] [FiniteDimensional R‚ÇÅ E‚ÇÅ]
  [FiniteDimensional R‚ÇÅ F]

/-- A linear isometry between finite dimensional spaces of equal dimension can be upgraded
    to a linear isometry equivalence. -/
def toLinearIsometryEquiv (li : E‚ÇÅ ‚Üí‚Çó·µ¢[R‚ÇÅ] F) (h : finrank R‚ÇÅ E‚ÇÅ = finrank R‚ÇÅ F) :
    E‚ÇÅ ‚âÉ‚Çó·µ¢[R‚ÇÅ] F where
  toLinearEquiv := li.toLinearMap.linearEquivOfInjective li.injective h
  norm_map' := li.norm_map'
#align linear_isometry.to_linear_isometry_equiv LinearIsometry.toLinearIsometryEquiv

@[simp]
theorem coe_toLinearIsometryEquiv (li : E‚ÇÅ ‚Üí‚Çó·µ¢[R‚ÇÅ] F) (h : finrank R‚ÇÅ E‚ÇÅ = finrank R‚ÇÅ F) :
    (li.toLinearIsometryEquiv h : E‚ÇÅ ‚Üí F) = li :=
  rfl
#align linear_isometry.coe_to_linear_isometry_equiv LinearIsometry.coe_toLinearIsometryEquiv

@[simp]
theorem toLinearIsometryEquiv_apply (li : E‚ÇÅ ‚Üí‚Çó·µ¢[R‚ÇÅ] F) (h : finrank R‚ÇÅ E‚ÇÅ = finrank R‚ÇÅ F)
    (x : E‚ÇÅ) : (li.toLinearIsometryEquiv h) x = li x :=
  rfl
#align linear_isometry.to_linear_isometry_equiv_apply LinearIsometry.toLinearIsometryEquiv_apply

end LinearIsometry

namespace AffineIsometry

open AffineMap

variable {ùïú : Type*} {V‚ÇÅ V‚ÇÇ : Type*} {P‚ÇÅ P‚ÇÇ : Type*} [NormedField ùïú] [NormedAddCommGroup V‚ÇÅ]
  [SeminormedAddCommGroup V‚ÇÇ] [NormedSpace ùïú V‚ÇÅ] [NormedSpace ùïú V‚ÇÇ] [MetricSpace P‚ÇÅ]
  [PseudoMetricSpace P‚ÇÇ] [NormedAddTorsor V‚ÇÅ P‚ÇÅ] [NormedAddTorsor V‚ÇÇ P‚ÇÇ]

variable [FiniteDimensional ùïú V‚ÇÅ] [FiniteDimensional ùïú V‚ÇÇ]

/-- An affine isometry between finite dimensional spaces of equal dimension can be upgraded
    to an affine isometry equivalence. -/
def toAffineIsometryEquiv [Inhabited P‚ÇÅ] (li : P‚ÇÅ ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ) (h : finrank ùïú V‚ÇÅ = finrank ùïú V‚ÇÇ) :
    P‚ÇÅ ‚âÉ·µÉ‚Å±[ùïú] P‚ÇÇ :=
  AffineIsometryEquiv.mk' li (li.linearIsometry.toLinearIsometryEquiv h)
    (Inhabited.default (Œ± := P‚ÇÅ)) fun p => by simp
                                              -- üéâ no goals
#align affine_isometry.to_affine_isometry_equiv AffineIsometry.toAffineIsometryEquiv

@[simp]
theorem coe_toAffineIsometryEquiv [Inhabited P‚ÇÅ] (li : P‚ÇÅ ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ)
    (h : finrank ùïú V‚ÇÅ = finrank ùïú V‚ÇÇ) : (li.toAffineIsometryEquiv h : P‚ÇÅ ‚Üí P‚ÇÇ) = li :=
  rfl
#align affine_isometry.coe_to_affine_isometry_equiv AffineIsometry.coe_toAffineIsometryEquiv

@[simp]
theorem toAffineIsometryEquiv_apply [Inhabited P‚ÇÅ] (li : P‚ÇÅ ‚Üí·µÉ‚Å±[ùïú] P‚ÇÇ)
    (h : finrank ùïú V‚ÇÅ = finrank ùïú V‚ÇÇ) (x : P‚ÇÅ) : (li.toAffineIsometryEquiv h) x = li x :=
  rfl
#align affine_isometry.to_affine_isometry_equiv_apply AffineIsometry.toAffineIsometryEquiv_apply

end AffineIsometry

section CompleteField

variable {ùïú : Type u} [NontriviallyNormedField ùïú] {E : Type v} [NormedAddCommGroup E]
  [NormedSpace ùïú E] {F : Type w} [NormedAddCommGroup F] [NormedSpace ùïú F] {F' : Type x}
  [AddCommGroup F'] [Module ùïú F'] [TopologicalSpace F'] [TopologicalAddGroup F']
  [ContinuousSMul ùïú F'] [CompleteSpace ùïú]

section Affine

variable {PE PF : Type*} [MetricSpace PE] [NormedAddTorsor E PE] [MetricSpace PF]
  [NormedAddTorsor F PF] [FiniteDimensional ùïú E]

theorem AffineMap.continuous_of_finiteDimensional (f : PE ‚Üí·µÉ[ùïú] PF) : Continuous f :=
  AffineMap.continuous_linear_iff.1 f.linear.continuous_of_finiteDimensional
#align affine_map.continuous_of_finite_dimensional AffineMap.continuous_of_finiteDimensional

theorem AffineEquiv.continuous_of_finiteDimensional (f : PE ‚âÉ·µÉ[ùïú] PF) : Continuous f :=
  f.toAffineMap.continuous_of_finiteDimensional
#align affine_equiv.continuous_of_finite_dimensional AffineEquiv.continuous_of_finiteDimensional

/-- Reinterpret an affine equivalence as a homeomorphism. -/
def AffineEquiv.toHomeomorphOfFiniteDimensional (f : PE ‚âÉ·µÉ[ùïú] PF) : PE ‚âÉ‚Çú PF where
  toEquiv := f.toEquiv
  continuous_toFun := f.continuous_of_finiteDimensional
  continuous_invFun :=
    haveI : FiniteDimensional ùïú F := f.linear.finiteDimensional
    f.symm.continuous_of_finiteDimensional
#align affine_equiv.to_homeomorph_of_finite_dimensional AffineEquiv.toHomeomorphOfFiniteDimensional

@[simp]
theorem AffineEquiv.coe_toHomeomorphOfFiniteDimensional (f : PE ‚âÉ·µÉ[ùïú] PF) :
    ‚áëf.toHomeomorphOfFiniteDimensional = f :=
  rfl
#align affine_equiv.coe_to_homeomorph_of_finite_dimensional AffineEquiv.coe_toHomeomorphOfFiniteDimensional

@[simp]
theorem AffineEquiv.coe_toHomeomorphOfFiniteDimensional_symm (f : PE ‚âÉ·µÉ[ùïú] PF) :
    ‚áëf.toHomeomorphOfFiniteDimensional.symm = f.symm :=
  rfl
#align affine_equiv.coe_to_homeomorph_of_finite_dimensional_symm AffineEquiv.coe_toHomeomorphOfFiniteDimensional_symm

end Affine

theorem ContinuousLinearMap.continuous_det : Continuous fun f : E ‚ÜíL[ùïú] E => f.det := by
  change Continuous fun f : E ‚ÜíL[ùïú] E => LinearMap.det (f : E ‚Üí‚Çó[ùïú] E)
  -- ‚ä¢ Continuous fun f => ‚ÜëLinearMap.det ‚Üëf
  -- Porting note: this could be easier with `det_cases`
  by_cases h : ‚àÉ s : Finset E, Nonempty (Basis (‚Ü•s) ùïú E)
  -- ‚ä¢ Continuous fun f => ‚ÜëLinearMap.det ‚Üëf
  ¬∑ rcases h with ‚ü®s, ‚ü®b‚ü©‚ü©
    -- ‚ä¢ Continuous fun f => ‚ÜëLinearMap.det ‚Üëf
    haveI : FiniteDimensional ùïú E := FiniteDimensional.of_fintype_basis b
    -- ‚ä¢ Continuous fun f => ‚ÜëLinearMap.det ‚Üëf
    simp_rw [LinearMap.det_eq_det_toMatrix_of_finset b]
    -- ‚ä¢ Continuous fun f => Matrix.det (‚Üë(LinearMap.toMatrix b b) ‚Üëf)
    refine' Continuous.matrix_det _
    -- ‚ä¢ Continuous fun f => ‚Üë(LinearMap.toMatrix b b) ‚Üëf
    exact
      ((LinearMap.toMatrix b b).toLinearMap.comp
          (ContinuousLinearMap.coeLM ùïú)).continuous_of_finiteDimensional
  ¬∑ -- Porting note: was `unfold LinearMap.det`
    rw [LinearMap.det_def]
    -- ‚ä¢ Continuous fun f => ‚Üë(if H : ‚àÉ s, Nonempty (Basis { x // x ‚àà s } ùïú E) then L ‚Ä¶
    simpa only [h, MonoidHom.one_apply, dif_neg, not_false_iff] using continuous_const
    -- üéâ no goals
#align continuous_linear_map.continuous_det ContinuousLinearMap.continuous_det

/-- Any `K`-Lipschitz map from a subset `s` of a metric space `Œ±` to a finite-dimensional real
vector space `E'` can be extended to a Lipschitz map on the whole space `Œ±`, with a slightly worse
constant `C * K` where `C` only depends on `E'`. We record a working value for this constant `C`
as `lipschitzExtensionConstant E'`. -/
irreducible_def lipschitzExtensionConstant (E' : Type*) [NormedAddCommGroup E'] [NormedSpace ‚Ñù E']
  [FiniteDimensional ‚Ñù E'] : ‚Ñù‚â•0 :=
  let A := (Basis.ofVectorSpace ‚Ñù E').equivFun.toContinuousLinearEquiv
  max (‚ÄñA.symm.toContinuousLinearMap‚Äñ‚Çä * ‚ÄñA.toContinuousLinearMap‚Äñ‚Çä) 1
#align lipschitz_extension_constant lipschitzExtensionConstant

theorem lipschitzExtensionConstant_pos (E' : Type*) [NormedAddCommGroup E'] [NormedSpace ‚Ñù E']
    [FiniteDimensional ‚Ñù E'] : 0 < lipschitzExtensionConstant E' := by
  rw [lipschitzExtensionConstant]
  -- ‚ä¢ 0 <
  exact zero_lt_one.trans_le (le_max_right _ _)
  -- üéâ no goals
#align lipschitz_extension_constant_pos lipschitzExtensionConstant_pos

/-- Any `K`-Lipschitz map from a subset `s` of a metric space `Œ±` to a finite-dimensional real
vector space `E'` can be extended to a Lipschitz map on the whole space `Œ±`, with a slightly worse
constant `lipschitzExtensionConstant E' * K`. -/
theorem LipschitzOnWith.extend_finite_dimension {Œ± : Type*} [PseudoMetricSpace Œ±] {E' : Type*}
    [NormedAddCommGroup E'] [NormedSpace ‚Ñù E'] [FiniteDimensional ‚Ñù E'] {s : Set Œ±} {f : Œ± ‚Üí E'}
    {K : ‚Ñù‚â•0} (hf : LipschitzOnWith K f s) :
    ‚àÉ g : Œ± ‚Üí E', LipschitzWith (lipschitzExtensionConstant E' * K) g ‚àß EqOn f g s := by
  /- This result is already known for spaces `Œπ ‚Üí ‚Ñù`. We use a continuous linear equiv between
    `E'` and such a space to transfer the result to `E'`. -/
  let Œπ : Type _ := Basis.ofVectorSpaceIndex ‚Ñù E'
  -- ‚ä¢ ‚àÉ g, LipschitzWith (lipschitzExtensionConstant E' * K) g ‚àß EqOn f g s
  let A := (Basis.ofVectorSpace ‚Ñù E').equivFun.toContinuousLinearEquiv
  -- ‚ä¢ ‚àÉ g, LipschitzWith (lipschitzExtensionConstant E' * K) g ‚àß EqOn f g s
  have LA : LipschitzWith ‚ÄñA.toContinuousLinearMap‚Äñ‚Çä A := by apply A.lipschitz
  -- ‚ä¢ ‚àÉ g, LipschitzWith (lipschitzExtensionConstant E' * K) g ‚àß EqOn f g s
  have L : LipschitzOnWith (‚ÄñA.toContinuousLinearMap‚Äñ‚Çä * K) (A ‚àò f) s :=
    LA.comp_lipschitzOnWith hf
  obtain ‚ü®g, hg, gs‚ü© :
    ‚àÉ g : Œ± ‚Üí Œπ ‚Üí ‚Ñù, LipschitzWith (‚ÄñA.toContinuousLinearMap‚Äñ‚Çä * K) g ‚àß EqOn (A ‚àò f) g s :=
    L.extend_pi
  refine' ‚ü®A.symm ‚àò g, _, _‚ü©
  -- ‚ä¢ LipschitzWith (lipschitzExtensionConstant E' * K) (‚Üë(ContinuousLinearEquiv.s ‚Ä¶
  ¬∑ have LAsymm : LipschitzWith ‚ÄñA.symm.toContinuousLinearMap‚Äñ‚Çä A.symm := by
      apply A.symm.lipschitz
    apply (LAsymm.comp hg).weaken
    -- ‚ä¢ ‚Äñ‚Üë(ContinuousLinearEquiv.symm A)‚Äñ‚Çä * (‚Äñ‚ÜëA‚Äñ‚Çä * K) ‚â§ lipschitzExtensionConstan ‚Ä¶
    rw [lipschitzExtensionConstant, ‚Üê mul_assoc]
    -- ‚ä¢ ‚Äñ‚Üë(ContinuousLinearEquiv.symm A)‚Äñ‚Çä * ‚Äñ‚ÜëA‚Äñ‚Çä * K ‚â§
    refine' mul_le_mul' (le_max_left _ _) le_rfl
    -- üéâ no goals
  ¬∑ intro x hx
    -- ‚ä¢ f x = (‚Üë(ContinuousLinearEquiv.symm A) ‚àò g) x
    have : A (f x) = g x := gs hx
    -- ‚ä¢ f x = (‚Üë(ContinuousLinearEquiv.symm A) ‚àò g) x
    simp only [(¬∑ ‚àò ¬∑), ‚Üê this, A.symm_apply_apply]
    -- üéâ no goals
#align lipschitz_on_with.extend_finite_dimension LipschitzOnWith.extend_finite_dimension

theorem LinearMap.exists_antilipschitzWith [FiniteDimensional ùïú E] (f : E ‚Üí‚Çó[ùïú] F)
    (hf : LinearMap.ker f = ‚ä•) : ‚àÉ K > 0, AntilipschitzWith K f := by
  cases subsingleton_or_nontrivial E
  -- ‚ä¢ ‚àÉ K, K > 0 ‚àß AntilipschitzWith K ‚Üëf
  ¬∑ exact ‚ü®1, zero_lt_one, AntilipschitzWith.of_subsingleton‚ü©
    -- üéâ no goals
  ¬∑ rw [LinearMap.ker_eq_bot] at hf
    -- ‚ä¢ ‚àÉ K, K > 0 ‚àß AntilipschitzWith K ‚Üëf
    let e : E ‚âÉL[ùïú] LinearMap.range f := (LinearEquiv.ofInjective f hf).toContinuousLinearEquiv
    -- ‚ä¢ ‚àÉ K, K > 0 ‚àß AntilipschitzWith K ‚Üëf
    exact ‚ü®_, e.nnnorm_symm_pos, e.antilipschitz‚ü©
    -- üéâ no goals
#align linear_map.exists_antilipschitz_with LinearMap.exists_antilipschitzWith

protected theorem LinearIndependent.eventually {Œπ} [Finite Œπ] {f : Œπ ‚Üí E}
    (hf : LinearIndependent ùïú f) : ‚àÄ·∂† g in ùìù f, LinearIndependent ùïú g := by
  cases nonempty_fintype Œπ
  -- ‚ä¢ ‚àÄ·∂† (g : Œπ ‚Üí E) in ùìù f, LinearIndependent ùïú g
  simp only [Fintype.linearIndependent_iff'] at hf ‚ä¢
  -- ‚ä¢ ‚àÄ·∂† (g : Œπ ‚Üí E) in ùìù f, LinearMap.ker (‚Üë(LinearMap.lsum ùïú (fun x => ùïú) ‚Ñï) fun ‚Ä¶
  rcases LinearMap.exists_antilipschitzWith _ hf with ‚ü®K, K0, hK‚ü©
  -- ‚ä¢ ‚àÄ·∂† (g : Œπ ‚Üí E) in ùìù f, LinearMap.ker (‚Üë(LinearMap.lsum ùïú (fun x => ùïú) ‚Ñï) fun ‚Ä¶
  have : Tendsto (fun g : Œπ ‚Üí E => ‚àë i, ‚Äñg i - f i‚Äñ) (ùìù f) (ùìù <| ‚àë i, ‚Äñf i - f i‚Äñ) :=
    tendsto_finset_sum _ fun i _ =>
      Tendsto.norm <| ((continuous_apply i).tendsto _).sub tendsto_const_nhds
  simp only [sub_self, norm_zero, Finset.sum_const_zero] at this
  -- ‚ä¢ ‚àÄ·∂† (g : Œπ ‚Üí E) in ùìù f, LinearMap.ker (‚Üë(LinearMap.lsum ùïú (fun x => ùïú) ‚Ñï) fun ‚Ä¶
  refine' (this.eventually (gt_mem_nhds <| inv_pos.2 K0)).mono fun g hg => _
  -- ‚ä¢ LinearMap.ker (‚Üë(LinearMap.lsum ùïú (fun x => ùïú) ‚Ñï) fun i => LinearMap.smulRig ‚Ä¶
  replace hg : ‚àë i, ‚Äñg i - f i‚Äñ‚Çä < K‚Åª¬π
  -- ‚ä¢ ‚àë i : Œπ, ‚Äñg i - f i‚Äñ‚Çä < K‚Åª¬π
  ¬∑ rw [‚Üê NNReal.coe_lt_coe]
    -- ‚ä¢ ‚Üë(‚àë i : Œπ, ‚Äñg i - f i‚Äñ‚Çä) < ‚ÜëK‚Åª¬π
    push_cast
    -- ‚ä¢ ‚àë x : Œπ, ‚Äñg x - f x‚Äñ < (‚ÜëK)‚Åª¬π
    exact hg
    -- üéâ no goals
  rw [LinearMap.ker_eq_bot]
  -- ‚ä¢ Function.Injective ‚Üë(‚Üë(LinearMap.lsum ùïú (fun x => ùïú) ‚Ñï) fun i => LinearMap.s ‚Ä¶
  refine' (hK.add_sub_lipschitzWith (LipschitzWith.of_dist_le_mul fun v u => _) hg).injective
  -- ‚ä¢ dist ((‚Üë(‚Üë(LinearMap.lsum ùïú (fun x => ùïú) ‚Ñï) fun i => LinearMap.smulRight Lin ‚Ä¶
  simp only [dist_eq_norm, LinearMap.lsum_apply, Pi.sub_apply, LinearMap.sum_apply,
    LinearMap.comp_apply, LinearMap.proj_apply, LinearMap.smulRight_apply, LinearMap.id_apply, ‚Üê
    Finset.sum_sub_distrib, ‚Üê smul_sub, ‚Üê sub_smul, NNReal.coe_sum, coe_nnnorm, Finset.sum_mul]
  refine' norm_sum_le_of_le _ fun i _ => _
  -- ‚ä¢ ‚Äñ(v i - u i) ‚Ä¢ (g i - f i)‚Äñ ‚â§ ‚Äñg i - f i‚Äñ * ‚Äñv - u‚Äñ
  rw [norm_smul, mul_comm]
  -- ‚ä¢ ‚Äñg i - f i‚Äñ * ‚Äñv i - u i‚Äñ ‚â§ ‚Äñg i - f i‚Äñ * ‚Äñv - u‚Äñ
  gcongr
  -- ‚ä¢ ‚Äñv i - u i‚Äñ ‚â§ ‚Äñv - u‚Äñ
  exact norm_le_pi_norm (v - u) i
  -- üéâ no goals
#align linear_independent.eventually LinearIndependent.eventually

theorem isOpen_setOf_linearIndependent {Œπ : Type*} [Finite Œπ] :
    IsOpen { f : Œπ ‚Üí E | LinearIndependent ùïú f } :=
  isOpen_iff_mem_nhds.2 fun _ => LinearIndependent.eventually
#align is_open_set_of_linear_independent isOpen_setOf_linearIndependent

theorem isOpen_setOf_nat_le_rank (n : ‚Ñï) :
    IsOpen { f : E ‚ÜíL[ùïú] F | ‚Üën ‚â§ (f : E ‚Üí‚Çó[ùïú] F).rank } := by
  simp only [LinearMap.le_rank_iff_exists_linearIndependent_finset, setOf_exists, ‚Üê exists_prop]
  -- ‚ä¢ IsOpen (‚ãÉ (i : Finset E) (_ : Finset.card i = n), {x | LinearIndependent ùïú f ‚Ä¶
  refine' isOpen_biUnion fun t _ => _
  -- ‚ä¢ IsOpen {x | LinearIndependent ùïú fun x_1 => ‚Üë‚Üëx ‚Üëx_1}
  have : Continuous fun f : E ‚ÜíL[ùïú] F => fun x : (t : Set E) => f x :=
    continuous_pi fun x => (ContinuousLinearMap.apply ùïú F (x : E)).continuous
  exact isOpen_setOf_linearIndependent.preimage this
  -- üéâ no goals
#align is_open_set_of_nat_le_rank isOpen_setOf_nat_le_rank

theorem Basis.op_nnnorm_le {Œπ : Type*} [Fintype Œπ] (v : Basis Œπ ùïú E) {u : E ‚ÜíL[ùïú] F} (M : ‚Ñù‚â•0)
    (hu : ‚àÄ i, ‚Äñu (v i)‚Äñ‚Çä ‚â§ M) : ‚Äñu‚Äñ‚Çä ‚â§ Fintype.card Œπ ‚Ä¢ ‚Äñv.equivFunL.toContinuousLinearMap‚Äñ‚Çä * M :=
  u.op_nnnorm_le_bound _ fun e => by
    set œÜ := v.equivFunL.toContinuousLinearMap
    -- ‚ä¢ ‚Äñ‚Üëu e‚Äñ‚Çä ‚â§ Fintype.card Œπ ‚Ä¢ ‚ÄñœÜ‚Äñ‚Çä * M * ‚Äñe‚Äñ‚Çä
    calc
      ‚Äñu e‚Äñ‚Çä = ‚Äñu (‚àë i, v.equivFun e i ‚Ä¢ v i)‚Äñ‚Çä := by rw [v.sum_equivFun]
      _ = ‚Äñ‚àë i, v.equivFun e i ‚Ä¢ (u <| v i)‚Äñ‚Çä := by simp [u.map_sum, LinearMap.map_smul]
      _ ‚â§ ‚àë i, ‚Äñv.equivFun e i ‚Ä¢ (u <| v i)‚Äñ‚Çä := (nnnorm_sum_le _ _)
      _ = ‚àë i, ‚Äñv.equivFun e i‚Äñ‚Çä * ‚Äñu (v i)‚Äñ‚Çä := by simp only [nnnorm_smul]
      _ ‚â§ ‚àë i, ‚Äñv.equivFun e i‚Äñ‚Çä * M := by gcongr; apply hu
      _ = (‚àë i, ‚Äñv.equivFun e i‚Äñ‚Çä) * M := Finset.sum_mul.symm
      _ ‚â§ Fintype.card Œπ ‚Ä¢ (‚ÄñœÜ‚Äñ‚Çä * ‚Äñe‚Äñ‚Çä) * M := by
        gcongr
        calc
          ‚àë i, ‚Äñv.equivFun e i‚Äñ‚Çä ‚â§ Fintype.card Œπ ‚Ä¢ ‚ÄñœÜ e‚Äñ‚Çä := Pi.sum_nnnorm_apply_le_nnnorm _
          _ ‚â§ Fintype.card Œπ ‚Ä¢ (‚ÄñœÜ‚Äñ‚Çä * ‚Äñe‚Äñ‚Çä) := nsmul_le_nsmul_of_le_right (œÜ.le_op_nnnorm e) _
      _ = Fintype.card Œπ ‚Ä¢ ‚ÄñœÜ‚Äñ‚Çä * M * ‚Äñe‚Äñ‚Çä := by simp only [smul_mul_assoc, mul_right_comm]
#align basis.op_nnnorm_le Basis.op_nnnorm_le

theorem Basis.op_norm_le {Œπ : Type*} [Fintype Œπ] (v : Basis Œπ ùïú E) {u : E ‚ÜíL[ùïú] F} {M : ‚Ñù}
    (hM : 0 ‚â§ M) (hu : ‚àÄ i, ‚Äñu (v i)‚Äñ ‚â§ M) :
    ‚Äñu‚Äñ ‚â§ Fintype.card Œπ ‚Ä¢ ‚Äñv.equivFunL.toContinuousLinearMap‚Äñ * M := by
  simpa using NNReal.coe_le_coe.mpr (v.op_nnnorm_le ‚ü®M, hM‚ü© hu)
  -- üéâ no goals
#align basis.op_norm_le Basis.op_norm_le

/-- A weaker version of `Basis.op_nnnorm_le` that abstracts away the value of `C`. -/
theorem Basis.exists_op_nnnorm_le {Œπ : Type*} [Finite Œπ] (v : Basis Œπ ùïú E) :
    ‚àÉ C > (0 : ‚Ñù‚â•0), ‚àÄ {u : E ‚ÜíL[ùïú] F} (M : ‚Ñù‚â•0), (‚àÄ i, ‚Äñu (v i)‚Äñ‚Çä ‚â§ M) ‚Üí ‚Äñu‚Äñ‚Çä ‚â§ C * M := by
  cases nonempty_fintype Œπ
  -- ‚ä¢ ‚àÉ C, C > 0 ‚àß ‚àÄ {u : E ‚ÜíL[ùïú] F} (M : ‚Ñù‚â•0), (‚àÄ (i : Œπ), ‚Äñ‚Üëu (‚Üëv i)‚Äñ‚Çä ‚â§ M) ‚Üí ‚Äñu ‚Ä¶
  exact
    ‚ü®max (Fintype.card Œπ ‚Ä¢ ‚Äñv.equivFunL.toContinuousLinearMap‚Äñ‚Çä) 1,
      zero_lt_one.trans_le (le_max_right _ _), fun {u} M hu =>
      (v.op_nnnorm_le M hu).trans <| mul_le_mul_of_nonneg_right (le_max_left _ _) (zero_le M)‚ü©
#align basis.exists_op_nnnorm_le Basis.exists_op_nnnorm_le

/-- A weaker version of `Basis.op_norm_le` that abstracts away the value of `C`. -/
theorem Basis.exists_op_norm_le {Œπ : Type*} [Finite Œπ] (v : Basis Œπ ùïú E) :
    ‚àÉ C > (0 : ‚Ñù), ‚àÄ {u : E ‚ÜíL[ùïú] F} {M : ‚Ñù}, 0 ‚â§ M ‚Üí (‚àÄ i, ‚Äñu (v i)‚Äñ ‚â§ M) ‚Üí ‚Äñu‚Äñ ‚â§ C * M := by
  obtain ‚ü®C, hC, h‚ü© := v.exists_op_nnnorm_le (F := F)
  -- ‚ä¢ ‚àÉ C, C > 0 ‚àß ‚àÄ {u : E ‚ÜíL[ùïú] F} {M : ‚Ñù}, 0 ‚â§ M ‚Üí (‚àÄ (i : Œπ), ‚Äñ‚Üëu (‚Üëv i)‚Äñ ‚â§ M) ‚Ä¶
  -- Porting note: used `Subtype.forall'` below
  refine ‚ü®C, hC, ?_‚ü©
  -- ‚ä¢ ‚àÄ {u : E ‚ÜíL[ùïú] F} {M : ‚Ñù}, 0 ‚â§ M ‚Üí (‚àÄ (i : Œπ), ‚Äñ‚Üëu (‚Üëv i)‚Äñ ‚â§ M) ‚Üí ‚Äñu‚Äñ ‚â§ ‚ÜëC * M
  intro u M hM H
  -- ‚ä¢ ‚Äñu‚Äñ ‚â§ ‚ÜëC * M
  simpa using h ‚ü®M, hM‚ü© H
  -- üéâ no goals
#align basis.exists_op_norm_le Basis.exists_op_norm_le

instance [FiniteDimensional ùïú E] [SecondCountableTopology F] :
    SecondCountableTopology (E ‚ÜíL[ùïú] F) := by
  set d := FiniteDimensional.finrank ùïú E
  -- ‚ä¢ SecondCountableTopology (E ‚ÜíL[ùïú] F)
  suffices
    ‚àÄ Œµ > (0 : ‚Ñù), ‚àÉ n : (E ‚ÜíL[ùïú] F) ‚Üí Fin d ‚Üí ‚Ñï, ‚àÄ f g : E ‚ÜíL[ùïú] F, n f = n g ‚Üí dist f g ‚â§ Œµ from
    Metric.secondCountable_of_countable_discretization fun Œµ Œµ_pos =>
      ‚ü®Fin d ‚Üí ‚Ñï, by infer_instance, this Œµ Œµ_pos‚ü©
  intro Œµ Œµ_pos
  -- ‚ä¢ ‚àÉ n, ‚àÄ (f g : E ‚ÜíL[ùïú] F), n f = n g ‚Üí dist f g ‚â§ Œµ
  obtain ‚ü®u : ‚Ñï ‚Üí F, hu : DenseRange u‚ü© := exists_dense_seq F
  -- ‚ä¢ ‚àÉ n, ‚àÄ (f g : E ‚ÜíL[ùïú] F), n f = n g ‚Üí dist f g ‚â§ Œµ
  let v := FiniteDimensional.finBasis ùïú E
  -- ‚ä¢ ‚àÉ n, ‚àÄ (f g : E ‚ÜíL[ùïú] F), n f = n g ‚Üí dist f g ‚â§ Œµ
  obtain
    ‚ü®C : ‚Ñù, C_pos : 0 < C, hC :
      ‚àÄ {œÜ : E ‚ÜíL[ùïú] F} {M : ‚Ñù}, 0 ‚â§ M ‚Üí (‚àÄ i, ‚ÄñœÜ (v i)‚Äñ ‚â§ M) ‚Üí ‚ÄñœÜ‚Äñ ‚â§ C * M‚ü© :=
    v.exists_op_norm_le (E := E) (F := F)
  have h_2C : 0 < 2 * C := mul_pos zero_lt_two C_pos
  -- ‚ä¢ ‚àÉ n, ‚àÄ (f g : E ‚ÜíL[ùïú] F), n f = n g ‚Üí dist f g ‚â§ Œµ
  have hŒµ2C : 0 < Œµ / (2 * C) := div_pos Œµ_pos h_2C
  -- ‚ä¢ ‚àÉ n, ‚àÄ (f g : E ‚ÜíL[ùïú] F), n f = n g ‚Üí dist f g ‚â§ Œµ
  have : ‚àÄ œÜ : E ‚ÜíL[ùïú] F, ‚àÉ n : Fin d ‚Üí ‚Ñï, ‚ÄñœÜ - (v.constrL <| u ‚àò n)‚Äñ ‚â§ Œµ / 2 := by
    intro œÜ
    have : ‚àÄ i, ‚àÉ n, ‚ÄñœÜ (v i) - u n‚Äñ ‚â§ Œµ / (2 * C) := by
      simp only [norm_sub_rev]
      intro i
      have : œÜ (v i) ‚àà closure (range u) := hu _
      obtain ‚ü®n, hn‚ü© : ‚àÉ n, ‚Äñu n - œÜ (v i)‚Äñ < Œµ / (2 * C) := by
        rw [mem_closure_iff_nhds_basis Metric.nhds_basis_ball] at this
        specialize this (Œµ / (2 * C)) hŒµ2C
        simpa [dist_eq_norm]
      exact ‚ü®n, le_of_lt hn‚ü©
    choose n hn using this
    use n
    replace hn : ‚àÄ i : Fin d, ‚Äñ(œÜ - (v.constrL <| u ‚àò n)) (v i)‚Äñ ‚â§ Œµ / (2 * C)
    ¬∑ simp [hn]
    have : C * (Œµ / (2 * C)) = Œµ / 2 := by
      rw [eq_div_iff (two_ne_zero : (2 : ‚Ñù) ‚â† 0), mul_comm, ‚Üê mul_assoc,
        mul_div_cancel' _ (ne_of_gt h_2C)]
    specialize hC (le_of_lt hŒµ2C) hn
    rwa [this] at hC
  choose n hn using this
  -- ‚ä¢ ‚àÉ n, ‚àÄ (f g : E ‚ÜíL[ùïú] F), n f = n g ‚Üí dist f g ‚â§ Œµ
  set Œ¶ := fun œÜ : E ‚ÜíL[ùïú] F => v.constrL <| u ‚àò n œÜ
  -- ‚ä¢ ‚àÉ n, ‚àÄ (f g : E ‚ÜíL[ùïú] F), n f = n g ‚Üí dist f g ‚â§ Œµ
  change ‚àÄ z, dist z (Œ¶ z) ‚â§ Œµ / 2 at hn
  -- ‚ä¢ ‚àÉ n, ‚àÄ (f g : E ‚ÜíL[ùïú] F), n f = n g ‚Üí dist f g ‚â§ Œµ
  use n
  -- ‚ä¢ ‚àÄ (f g : E ‚ÜíL[ùïú] F), n f = n g ‚Üí dist f g ‚â§ Œµ
  intro x y hxy
  -- ‚ä¢ dist x y ‚â§ Œµ
  calc
    dist x y ‚â§ dist x (Œ¶ x) + dist (Œ¶ x) y := dist_triangle _ _ _
    _ = dist x (Œ¶ x) + dist y (Œ¶ y) := by simp [hxy, dist_comm]
    _ ‚â§ Œµ := by linarith [hn x, hn y]

variable (ùïú E)

theorem FiniteDimensional.complete [FiniteDimensional ùïú E] : CompleteSpace E := by
  set e := ContinuousLinearEquiv.ofFinrankEq (@finrank_fin_fun ùïú _ _ (finrank ùïú E)).symm
  -- ‚ä¢ CompleteSpace E
  have : UniformEmbedding e.toLinearEquiv.toEquiv.symm := e.symm.uniformEmbedding
  -- ‚ä¢ CompleteSpace E
  exact (completeSpace_congr this).1 (by infer_instance)
  -- üéâ no goals
#align finite_dimensional.complete FiniteDimensional.complete

variable {ùïú E}

/-- A finite-dimensional subspace is complete. -/
theorem Submodule.complete_of_finiteDimensional (s : Submodule ùïú E) [FiniteDimensional ùïú s] :
    IsComplete (s : Set E) :=
  completeSpace_coe_iff_isComplete.1 (FiniteDimensional.complete ùïú s)
#align submodule.complete_of_finite_dimensional Submodule.complete_of_finiteDimensional

/-- A finite-dimensional subspace is closed. -/
theorem Submodule.closed_of_finiteDimensional (s : Submodule ùïú E) [FiniteDimensional ùïú s] :
    IsClosed (s : Set E) :=
  s.complete_of_finiteDimensional.isClosed
#align submodule.closed_of_finite_dimensional Submodule.closed_of_finiteDimensional

theorem AffineSubspace.closed_of_finiteDimensional {P : Type*} [MetricSpace P]
    [NormedAddTorsor E P] (s : AffineSubspace ùïú P) [FiniteDimensional ùïú s.direction] :
    IsClosed (s : Set P) :=
  s.isClosed_direction_iff.mp s.direction.closed_of_finiteDimensional
#align affine_subspace.closed_of_finite_dimensional AffineSubspace.closed_of_finiteDimensional

section Riesz

/-- In an infinite dimensional space, given a finite number of points, one may find a point
with norm at most `R` which is at distance at least `1` of all these points. -/
theorem exists_norm_le_le_norm_sub_of_finset {c : ùïú} (hc : 1 < ‚Äñc‚Äñ) {R : ‚Ñù} (hR : ‚Äñc‚Äñ < R)
    (h : ¬¨FiniteDimensional ùïú E) (s : Finset E) : ‚àÉ x : E, ‚Äñx‚Äñ ‚â§ R ‚àß ‚àÄ y ‚àà s, 1 ‚â§ ‚Äñy - x‚Äñ := by
  let F := Submodule.span ùïú (s : Set E)
  -- ‚ä¢ ‚àÉ x, ‚Äñx‚Äñ ‚â§ R ‚àß ‚àÄ (y : E), y ‚àà s ‚Üí 1 ‚â§ ‚Äñy - x‚Äñ
  haveI : FiniteDimensional ùïú F :=
    Module.finite_def.2
      ((Submodule.fg_top _).2 (Submodule.fg_def.2 ‚ü®s, Finset.finite_toSet _, rfl‚ü©))
  have Fclosed : IsClosed (F : Set E) := Submodule.closed_of_finiteDimensional _
  -- ‚ä¢ ‚àÉ x, ‚Äñx‚Äñ ‚â§ R ‚àß ‚àÄ (y : E), y ‚àà s ‚Üí 1 ‚â§ ‚Äñy - x‚Äñ
  have : ‚àÉ x, x ‚àâ F := by
    contrapose! h
    have : (‚ä§ : Submodule ùïú E) = F := by
      ext x
      simp [h]
    have : FiniteDimensional ùïú (‚ä§ : Submodule ùïú E) := by rwa [this]
    refine' Module.finite_def.2 ((Submodule.fg_top _).1 (Module.finite_def.1 this))
  obtain ‚ü®x, xR, hx‚ü© : ‚àÉ x : E, ‚Äñx‚Äñ ‚â§ R ‚àß ‚àÄ y : E, y ‚àà F ‚Üí 1 ‚â§ ‚Äñx - y‚Äñ :=
    riesz_lemma_of_norm_lt hc hR Fclosed this
  have hx' : ‚àÄ y : E, y ‚àà F ‚Üí 1 ‚â§ ‚Äñy - x‚Äñ := by
    intro y hy
    rw [‚Üê norm_neg]
    simpa using hx y hy
  exact ‚ü®x, xR, fun y hy => hx' _ (Submodule.subset_span hy)‚ü©
  -- üéâ no goals
#align exists_norm_le_le_norm_sub_of_finset exists_norm_le_le_norm_sub_of_finset

/-- In an infinite-dimensional normed space, there exists a sequence of points which are all
bounded by `R` and at distance at least `1`. For a version not assuming `c` and `R`, see
`exists_seq_norm_le_one_le_norm_sub`. -/
theorem exists_seq_norm_le_one_le_norm_sub' {c : ùïú} (hc : 1 < ‚Äñc‚Äñ) {R : ‚Ñù} (hR : ‚Äñc‚Äñ < R)
    (h : ¬¨FiniteDimensional ùïú E) :
    ‚àÉ f : ‚Ñï ‚Üí E, (‚àÄ n, ‚Äñf n‚Äñ ‚â§ R) ‚àß ‚àÄ m n, m ‚â† n ‚Üí 1 ‚â§ ‚Äñf m - f n‚Äñ := by
  have : IsSymm E fun x y : E => 1 ‚â§ ‚Äñx - y‚Äñ := by
    constructor
    intro x y hxy
    rw [‚Üê norm_neg]
    simpa
  apply
    exists_seq_of_forall_finset_exists' (fun x : E => ‚Äñx‚Äñ ‚â§ R) fun (x : E) (y : E) => 1 ‚â§ ‚Äñx - y‚Äñ
  rintro s -
  -- ‚ä¢ ‚àÉ y, ‚Äñy‚Äñ ‚â§ R ‚àß ‚àÄ (x : E), x ‚àà s ‚Üí 1 ‚â§ ‚Äñx - y‚Äñ
  exact exists_norm_le_le_norm_sub_of_finset hc hR h s
  -- üéâ no goals
#align exists_seq_norm_le_one_le_norm_sub' exists_seq_norm_le_one_le_norm_sub'

theorem exists_seq_norm_le_one_le_norm_sub (h : ¬¨FiniteDimensional ùïú E) :
    ‚àÉ (R : ‚Ñù) (f : ‚Ñï ‚Üí E), 1 < R ‚àß (‚àÄ n, ‚Äñf n‚Äñ ‚â§ R) ‚àß ‚àÄ m n, m ‚â† n ‚Üí 1 ‚â§ ‚Äñf m - f n‚Äñ := by
  obtain ‚ü®c, hc‚ü© : ‚àÉ c : ùïú, 1 < ‚Äñc‚Äñ := NormedField.exists_one_lt_norm ùïú
  -- ‚ä¢ ‚àÉ R f, 1 < R ‚àß (‚àÄ (n : ‚Ñï), ‚Äñf n‚Äñ ‚â§ R) ‚àß ‚àÄ (m n : ‚Ñï), m ‚â† n ‚Üí 1 ‚â§ ‚Äñf m - f n‚Äñ
  have A : ‚Äñc‚Äñ < ‚Äñc‚Äñ + 1 := by linarith
  -- ‚ä¢ ‚àÉ R f, 1 < R ‚àß (‚àÄ (n : ‚Ñï), ‚Äñf n‚Äñ ‚â§ R) ‚àß ‚àÄ (m n : ‚Ñï), m ‚â† n ‚Üí 1 ‚â§ ‚Äñf m - f n‚Äñ
  rcases exists_seq_norm_le_one_le_norm_sub' hc A h with ‚ü®f, hf‚ü©
  -- ‚ä¢ ‚àÉ R f, 1 < R ‚àß (‚àÄ (n : ‚Ñï), ‚Äñf n‚Äñ ‚â§ R) ‚àß ‚àÄ (m n : ‚Ñï), m ‚â† n ‚Üí 1 ‚â§ ‚Äñf m - f n‚Äñ
  exact ‚ü®‚Äñc‚Äñ + 1, f, hc.trans A, hf.1, hf.2‚ü©
  -- üéâ no goals
#align exists_seq_norm_le_one_le_norm_sub exists_seq_norm_le_one_le_norm_sub

variable (ùïú)

/-- **Riesz's theorem**: if a closed ball with center zero of positive radius is compact in a vector
space, then the space is finite-dimensional. -/
theorem finiteDimensional_of_isCompact_closed_ball‚ÇÄ {r : ‚Ñù} (rpos : 0 < r)
    (h : IsCompact (Metric.closedBall (0 : E) r)) : FiniteDimensional ùïú E := by
  by_contra hfin
  -- ‚ä¢ False
  obtain ‚ü®R, f, Rgt, fle, lef‚ü© :
    ‚àÉ (R : ‚Ñù) (f : ‚Ñï ‚Üí E), 1 < R ‚àß (‚àÄ n, ‚Äñf n‚Äñ ‚â§ R) ‚àß ‚àÄ m n, m ‚â† n ‚Üí 1 ‚â§ ‚Äñf m - f n‚Äñ :=
    exists_seq_norm_le_one_le_norm_sub hfin
  have rRpos : 0 < r / R := div_pos rpos (zero_lt_one.trans Rgt)
  -- ‚ä¢ False
  obtain ‚ü®c, hc‚ü© : ‚àÉ c : ùïú, 0 < ‚Äñc‚Äñ ‚àß ‚Äñc‚Äñ < r / R := NormedField.exists_norm_lt _ rRpos
  -- ‚ä¢ False
  let g := fun n : ‚Ñï => c ‚Ä¢ f n
  -- ‚ä¢ False
  have A : ‚àÄ n, g n ‚àà Metric.closedBall (0 : E) r := by
    intro n
    simp only [norm_smul, dist_zero_right, Metric.mem_closedBall]
    calc
      ‚Äñc‚Äñ * ‚Äñf n‚Äñ ‚â§ r / R * R := by gcongr; exact hc.2.le; apply fle
      _ = r := by field_simp [(zero_lt_one.trans Rgt).ne']
  -- Porting note: moved type ascriptions because of exists_prop changes
  obtain ‚ü®x : E, _ : x ‚àà Metric.closedBall (0 : E) r, œÜ : ‚Ñï ‚Üí ‚Ñï, œÜmono : StrictMono œÜ,
    œÜlim : Tendsto (g ‚àò œÜ) atTop (ùìù x)‚ü© := h.tendsto_subseq A
  have B : CauchySeq (g ‚àò œÜ) := œÜlim.cauchySeq
  -- ‚ä¢ False
  obtain ‚ü®N, hN‚ü© : ‚àÉ N : ‚Ñï, ‚àÄ n : ‚Ñï, N ‚â§ n ‚Üí dist ((g ‚àò œÜ) n) ((g ‚àò œÜ) N) < ‚Äñc‚Äñ :=
    Metric.cauchySeq_iff'.1 B ‚Äñc‚Äñ hc.1
  apply lt_irrefl ‚Äñc‚Äñ
  -- ‚ä¢ ‚Äñc‚Äñ < ‚Äñc‚Äñ
  calc
    ‚Äñc‚Äñ ‚â§ dist (g (œÜ (N + 1))) (g (œÜ N)) := by
      conv_lhs => rw [‚Üê mul_one ‚Äñc‚Äñ]
      simp only [dist_eq_norm, ‚Üê smul_sub, norm_smul]
      gcongr
      apply lef _ _ (ne_of_gt _)
      exact œÜmono (Nat.lt_succ_self N)
    _ < ‚Äñc‚Äñ := hN (N + 1) (Nat.le_succ N)
#align finite_dimensional_of_is_compact_closed_ball‚ÇÄ finiteDimensional_of_isCompact_closed_ball‚ÇÄ

/-- **Riesz's theorem**: if a closed ball of positive radius is compact in a vector space, then the
space is finite-dimensional. -/
theorem finiteDimensional_of_isCompact_closedBall {r : ‚Ñù} (rpos : 0 < r) {c : E}
    (h : IsCompact (Metric.closedBall c r)) : FiniteDimensional ùïú E := by
  apply finiteDimensional_of_isCompact_closed_ball‚ÇÄ ùïú rpos
  -- ‚ä¢ IsCompact (Metric.closedBall 0 r)
  have : Continuous fun x => -c + x := continuous_const.add continuous_id
  -- ‚ä¢ IsCompact (Metric.closedBall 0 r)
  simpa using h.image this
  -- üéâ no goals
#align finite_dimensional_of_is_compact_closed_ball finiteDimensional_of_isCompact_closedBall

/-- If a function has compact multiplicative support, then either the function is trivial or the
space is finite-dimensional. -/
@[to_additive
      "If a function has compact support, then either the function is trivial or the space is
      finite-dimensional."]
theorem HasCompactMulSupport.eq_one_or_finiteDimensional {X : Type*} [TopologicalSpace X] [One X]
    [T2Space X] {f : E ‚Üí X} (hf : HasCompactMulSupport f) (h'f : Continuous f) :
    f = 1 ‚à® FiniteDimensional ùïú E := by
  by_cases h : ‚àÄ x, f x = 1
  -- ‚ä¢ f = 1 ‚à® FiniteDimensional ùïú E
  ¬∑ apply Or.inl
    -- ‚ä¢ f = 1
    ext x
    -- ‚ä¢ f x = OfNat.ofNat 1 x
    exact h x
    -- üéâ no goals
  apply Or.inr
  -- ‚ä¢ FiniteDimensional ùïú E
  push_neg at h
  -- ‚ä¢ FiniteDimensional ùïú E
  obtain ‚ü®x, hx‚ü© : ‚àÉ x, f x ‚â† 1 := h
  -- ‚ä¢ FiniteDimensional ùïú E
  have : Function.mulSupport f ‚àà ùìù x := h'f.isOpen_mulSupport.mem_nhds hx
  -- ‚ä¢ FiniteDimensional ùïú E
  -- Porting note: moved type ascriptions because of exists_prop changes
  obtain ‚ü®r : ‚Ñù, rpos : 0 < r, hr : Metric.closedBall x r ‚äÜ Function.mulSupport f‚ü© :=
    Metric.nhds_basis_closedBall.mem_iff.1 this
  have : IsCompact (Metric.closedBall x r) :=
    isCompact_of_isClosed_subset hf Metric.isClosed_ball (hr.trans (subset_mulTSupport _))
  exact finiteDimensional_of_isCompact_closedBall ùïú rpos this
  -- üéâ no goals
#align has_compact_mul_support.eq_one_or_finite_dimensional HasCompactMulSupport.eq_one_or_finiteDimensional
#align has_compact_support.eq_zero_or_finite_dimensional HasCompactSupport.eq_zero_or_finiteDimensional

end Riesz

/-- An injective linear map with finite-dimensional domain is a closed embedding. -/
theorem LinearEquiv.closedEmbedding_of_injective {f : E ‚Üí‚Çó[ùïú] F} (hf : LinearMap.ker f = ‚ä•)
    [FiniteDimensional ùïú E] : ClosedEmbedding f :=
  let g := LinearEquiv.ofInjective f (LinearMap.ker_eq_bot.mp hf)
  { embedding_subtype_val.comp g.toContinuousLinearEquiv.toHomeomorph.embedding with
    closed_range := by
      haveI := f.finiteDimensional_range
      -- ‚ä¢ IsClosed (range ‚Üëf)
      simpa [LinearMap.range_coe f] using f.range.closed_of_finiteDimensional }
      -- üéâ no goals
#align linear_equiv.closed_embedding_of_injective LinearEquiv.closedEmbedding_of_injective

theorem ContinuousLinearMap.exists_right_inverse_of_surjective [FiniteDimensional ùïú F]
    (f : E ‚ÜíL[ùïú] F) (hf : LinearMap.range f = ‚ä§) :
    ‚àÉ g : F ‚ÜíL[ùïú] E, f.comp g = ContinuousLinearMap.id ùïú F :=
  let ‚ü®g, hg‚ü© := (f : E ‚Üí‚Çó[ùïú] F).exists_rightInverse_of_surjective hf
  ‚ü®LinearMap.toContinuousLinearMap g, ContinuousLinearMap.ext <| LinearMap.ext_iff.1 hg‚ü©
#align continuous_linear_map.exists_right_inverse_of_surjective ContinuousLinearMap.exists_right_inverse_of_surjective

theorem closedEmbedding_smul_left {c : E} (hc : c ‚â† 0) : ClosedEmbedding fun x : ùïú => x ‚Ä¢ c :=
  LinearEquiv.closedEmbedding_of_injective (LinearMap.ker_toSpanSingleton ùïú E hc)
#align closed_embedding_smul_left closedEmbedding_smul_left

-- `smul` is a closed map in the first argument.
theorem isClosedMap_smul_left (c : E) : IsClosedMap fun x : ùïú => x ‚Ä¢ c := by
  by_cases hc : c = 0
  -- ‚ä¢ IsClosedMap fun x => x ‚Ä¢ c
  ¬∑ simp_rw [hc, smul_zero]
    -- ‚ä¢ IsClosedMap fun x => 0
    exact isClosedMap_const
    -- üéâ no goals
  ¬∑ exact (closedEmbedding_smul_left hc).isClosedMap
    -- üéâ no goals
#align is_closed_map_smul_left isClosedMap_smul_left

open ContinuousLinearMap

/-- Continuous linear equivalence between continuous linear functions `ùïú‚Åø ‚Üí E` and `E‚Åø`.
The spaces `ùïú‚Åø` and `E‚Åø` are represented as `Œπ ‚Üí ùïú` and `Œπ ‚Üí E`, respectively,
where `Œπ` is a finite type. -/
def ContinuousLinearEquiv.piRing (Œπ : Type*) [Fintype Œπ] [DecidableEq Œπ] :
    ((Œπ ‚Üí ùïú) ‚ÜíL[ùïú] E) ‚âÉL[ùïú] Œπ ‚Üí E :=
  { LinearMap.toContinuousLinearMap.symm.trans (LinearEquiv.piRing ùïú E Œπ ùïú) with
    continuous_toFun := by
      refine' continuous_pi fun i => _
      -- ‚ä¢ Continuous fun a => AddHom.toFun (‚Üë{ toLinearMap := ‚Üësrc‚úù, invFun := src‚úù.in ‚Ä¶
      exact (ContinuousLinearMap.apply ùïú E (Pi.single i 1)).continuous
      -- üéâ no goals
    continuous_invFun := by
      simp_rw [LinearEquiv.invFun_eq_symm, LinearEquiv.trans_symm, LinearEquiv.symm_symm]
      -- ‚ä¢ Continuous ‚Üë(LinearEquiv.trans (LinearEquiv.symm (LinearEquiv.piRing ùïú E Œπ ùïú ‚Ä¶
      -- Note: added explicit type and removed `change` that tried to achieve the same
      refine AddMonoidHomClass.continuous_of_bound
        (LinearMap.toContinuousLinearMap.toLinearMap.comp
            (LinearEquiv.piRing ùïú E Œπ ùïú).symm.toLinearMap)
        (Fintype.card Œπ : ‚Ñù) fun g => ?_
      rw [‚Üê nsmul_eq_mul]
      -- ‚ä¢ ‚Äñ‚Üë(LinearMap.comp ‚ÜëLinearMap.toContinuousLinearMap ‚Üë(LinearEquiv.symm (Linea ‚Ä¶
      refine op_norm_le_bound _ (nsmul_nonneg (norm_nonneg g) (Fintype.card Œπ)) fun t => ?_
      -- ‚ä¢ ‚Äñ‚Üë(‚Üë(LinearMap.comp ‚ÜëLinearMap.toContinuousLinearMap ‚Üë(LinearEquiv.symm (Lin ‚Ä¶
      simp_rw [LinearMap.coe_comp, LinearEquiv.coe_toLinearMap, Function.comp_apply,
        LinearMap.coe_toContinuousLinearMap', LinearEquiv.piRing_symm_apply]
      apply le_trans (norm_sum_le _ _)
      -- ‚ä¢ ‚àë i : Œπ, ‚Äñt i ‚Ä¢ g i‚Äñ ‚â§ Fintype.card Œπ ‚Ä¢ ‚Äñg‚Äñ * ‚Äñt‚Äñ
      rw [smul_mul_assoc]
      -- ‚ä¢ ‚àë i : Œπ, ‚Äñt i ‚Ä¢ g i‚Äñ ‚â§ Fintype.card Œπ ‚Ä¢ (‚Äñg‚Äñ * ‚Äñt‚Äñ)
      refine' Finset.sum_le_card_nsmul _ _ _ fun i _ => _
      -- ‚ä¢ ‚Äñt i ‚Ä¢ g i‚Äñ ‚â§ ‚Äñg‚Äñ * ‚Äñt‚Äñ
      rw [norm_smul, mul_comm]
      -- ‚ä¢ ‚Äñg i‚Äñ * ‚Äñt i‚Äñ ‚â§ ‚Äñg‚Äñ * ‚Äñt‚Äñ
      gcongr <;> apply norm_le_pi_norm }
      -- ‚ä¢ ‚Äñg i‚Äñ ‚â§ ‚Äñg‚Äñ
                 -- üéâ no goals
                 -- üéâ no goals
#align continuous_linear_equiv.pi_ring ContinuousLinearEquiv.piRing

/-- A family of continuous linear maps is continuous on `s` if all its applications are. -/
theorem continuousOn_clm_apply {X : Type*} [TopologicalSpace X] [FiniteDimensional ùïú E]
    {f : X ‚Üí E ‚ÜíL[ùïú] F} {s : Set X} : ContinuousOn f s ‚Üî ‚àÄ y, ContinuousOn (fun x => f x y) s := by
  refine' ‚ü®fun h y => (ContinuousLinearMap.apply ùïú F y).continuous.comp_continuousOn h, fun h => _‚ü©
  -- ‚ä¢ ContinuousOn f s
  let d := finrank ùïú E
  -- ‚ä¢ ContinuousOn f s
  have hd : d = finrank ùïú (Fin d ‚Üí ùïú) := (finrank_fin_fun ùïú).symm
  -- ‚ä¢ ContinuousOn f s
  let e‚ÇÅ : E ‚âÉL[ùïú] Fin d ‚Üí ùïú := ContinuousLinearEquiv.ofFinrankEq hd
  -- ‚ä¢ ContinuousOn f s
  let e‚ÇÇ : (E ‚ÜíL[ùïú] F) ‚âÉL[ùïú] Fin d ‚Üí F :=
    (e‚ÇÅ.arrowCongr (1 : F ‚âÉL[ùïú] F)).trans (ContinuousLinearEquiv.piRing (Fin d))
  rw [‚Üê Function.comp.left_id f, ‚Üê e‚ÇÇ.symm_comp_self]
  -- ‚ä¢ ContinuousOn ((‚Üë(ContinuousLinearEquiv.symm e‚ÇÇ) ‚àò ‚Üëe‚ÇÇ) ‚àò f) s
  exact e‚ÇÇ.symm.continuous.comp_continuousOn (continuousOn_pi.mpr fun i => h _)
  -- üéâ no goals
#align continuous_on_clm_apply continuousOn_clm_apply

theorem continuous_clm_apply {X : Type*} [TopologicalSpace X] [FiniteDimensional ùïú E]
    {f : X ‚Üí E ‚ÜíL[ùïú] F} : Continuous f ‚Üî ‚àÄ y, Continuous fun x => f x y := by
  simp_rw [continuous_iff_continuousOn_univ, continuousOn_clm_apply]
  -- üéâ no goals
#align continuous_clm_apply continuous_clm_apply

end CompleteField

section ProperField

variable (ùïú : Type u) [NontriviallyNormedField ùïú] (E : Type v) [NormedAddCommGroup E]
  [NormedSpace ùïú E] [ProperSpace ùïú]

/-- Any finite-dimensional vector space over a proper field is proper.
We do not register this as an instance to avoid an instance loop when trying to prove the
properness of `ùïú`, and the search for `ùïú` as an unknown metavariable. Declare the instance
explicitly when needed. -/
theorem FiniteDimensional.proper [FiniteDimensional ùïú E] : ProperSpace E := by
  set e := ContinuousLinearEquiv.ofFinrankEq (@finrank_fin_fun ùïú _ _ (finrank ùïú E)).symm
  -- ‚ä¢ ProperSpace E
  exact e.symm.antilipschitz.properSpace e.symm.continuous e.symm.surjective
  -- üéâ no goals
#align finite_dimensional.proper FiniteDimensional.proper

end ProperField

/- Over the real numbers, we can register the previous statement as an instance as it will not
cause problems in instance resolution since the properness of `‚Ñù` is already known. -/
instance (priority := 900) FiniteDimensional.proper_real (E : Type u) [NormedAddCommGroup E]
    [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E] : ProperSpace E :=
  FiniteDimensional.proper ‚Ñù E
#align finite_dimensional.proper_real FiniteDimensional.proper_real

/-- If `E` is a finite dimensional normed real vector space, `x : E`, and `s` is a neighborhood of
`x` that is not equal to the whole space, then there exists a point `y ‚àà frontier s` at distance
`Metric.infDist x s·∂ú` from `x`. See also
`IsCompact.exists_mem_frontier_infDist_compl_eq_dist`. -/
theorem exists_mem_frontier_infDist_compl_eq_dist {E : Type*} [NormedAddCommGroup E]
    [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E] {x : E} {s : Set E} (hx : x ‚àà s) (hs : s ‚â† univ) :
    ‚àÉ y ‚àà frontier s, Metric.infDist x s·∂ú = dist x y := by
  rcases Metric.exists_mem_closure_infDist_eq_dist (nonempty_compl.2 hs) x with ‚ü®y, hys, hyd‚ü©
  -- ‚ä¢ ‚àÉ y, y ‚àà frontier s ‚àß Metric.infDist x s·∂ú = dist x y
  rw [closure_compl] at hys
  -- ‚ä¢ ‚àÉ y, y ‚àà frontier s ‚àß Metric.infDist x s·∂ú = dist x y
  refine'
    ‚ü®y,
      ‚ü®Metric.closedBall_infDist_compl_subset_closure hx <| Metric.mem_closedBall.2 <| ge_of_eq _,
        hys‚ü©,
      hyd‚ü©
  rwa [dist_comm]
  -- üéâ no goals
#align exists_mem_frontier_inf_dist_compl_eq_dist exists_mem_frontier_infDist_compl_eq_dist

/-- If `K` is a compact set in a nontrivial real normed space and `x ‚àà K`, then there exists a point
`y` of the boundary of `K` at distance `Metric.infDist x K·∂ú` from `x`. See also
`exists_mem_frontier_infDist_compl_eq_dist`. -/
nonrec theorem IsCompact.exists_mem_frontier_infDist_compl_eq_dist {E : Type*}
    [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [Nontrivial E] {x : E} {K : Set E} (hK : IsCompact K)
    (hx : x ‚àà K) :
    ‚àÉ y ‚àà frontier K, Metric.infDist x K·∂ú = dist x y := by
  obtain hx' | hx' : x ‚àà interior K ‚à™ frontier K := by
    rw [‚Üê closure_eq_interior_union_frontier]
    exact subset_closure hx
  ¬∑ rw [mem_interior_iff_mem_nhds, Metric.nhds_basis_closedBall.mem_iff] at hx'
    -- ‚ä¢ ‚àÉ y, y ‚àà frontier K ‚àß Metric.infDist x K·∂ú = dist x y
    rcases hx' with ‚ü®r, hr‚ÇÄ, hrK‚ü©
    -- ‚ä¢ ‚àÉ y, y ‚àà frontier K ‚àß Metric.infDist x K·∂ú = dist x y
    have : FiniteDimensional ‚Ñù E :=
      finiteDimensional_of_isCompact_closedBall ‚Ñù hr‚ÇÄ
        (isCompact_of_isClosed_subset hK Metric.isClosed_ball hrK)
    exact exists_mem_frontier_infDist_compl_eq_dist hx hK.ne_univ
    -- üéâ no goals
  ¬∑ refine' ‚ü®x, hx', _‚ü©
    -- ‚ä¢ Metric.infDist x K·∂ú = dist x x
    rw [frontier_eq_closure_inter_closure] at hx'
    -- ‚ä¢ Metric.infDist x K·∂ú = dist x x
    rw [Metric.infDist_zero_of_mem_closure hx'.2, dist_self]
    -- üéâ no goals
#align is_compact.exists_mem_frontier_inf_dist_compl_eq_dist IsCompact.exists_mem_frontier_infDist_compl_eq_dist

/-- In a finite dimensional vector space over `‚Ñù`, the series `‚àë x, ‚Äñf x‚Äñ` is unconditionally
summable if and only if the series `‚àë x, f x` is unconditionally summable. One implication holds in
any complete normed space, while the other holds only in finite dimensional spaces. -/
theorem summable_norm_iff {Œ± E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    [FiniteDimensional ‚Ñù E] {f : Œ± ‚Üí E} : (Summable fun x => ‚Äñf x‚Äñ) ‚Üî Summable f := by
  refine' ‚ü®summable_of_summable_norm, fun hf => _‚ü©
  -- ‚ä¢ Summable fun x => ‚Äñf x‚Äñ
  -- First we use a finite basis to reduce the problem to the case `E = Fin N ‚Üí ‚Ñù`
  suffices ‚àÄ {N : ‚Ñï} {g : Œ± ‚Üí Fin N ‚Üí ‚Ñù}, Summable g ‚Üí Summable fun x => ‚Äñg x‚Äñ by
    obtain v := finBasis ‚Ñù E
    set e := v.equivFunL
    have : Summable fun x => ‚Äñe (f x)‚Äñ := this (e.summable.2 hf)
    refine'
      summable_of_norm_bounded _ (this.mul_left ‚Üë‚Äñ(e.symm : (Fin (finrank ‚Ñù E) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E)‚Äñ‚Çä)
        fun i => _
    simpa using (e.symm : (Fin (finrank ‚Ñù E) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E).le_op_norm (e <| f i)
  clear! E
  -- ‚ä¢ ‚àÄ {N : ‚Ñï} {g : Œ± ‚Üí Fin N ‚Üí ‚Ñù}, Summable g ‚Üí Summable fun x => ‚Äñg x‚Äñ
  -- Now we deal with `g : Œ± ‚Üí Fin N ‚Üí ‚Ñù`
  intro N g hg
  -- ‚ä¢ Summable fun x => ‚Äñg x‚Äñ
  have : ‚àÄ i, Summable fun x => ‚Äñg x i‚Äñ := fun i => (Pi.summable.1 hg i).abs
  -- ‚ä¢ Summable fun x => ‚Äñg x‚Äñ
  refine'
    summable_of_norm_bounded _ (summable_sum fun i (_ : i ‚àà Finset.univ) => this i) fun x => _
  rw [norm_norm, pi_norm_le_iff_of_nonneg]
  -- ‚ä¢ ‚àÄ (i : Fin N), ‚Äñg x i‚Äñ ‚â§ ‚àë i : Fin N, ‚Äñg x i‚Äñ
  ¬∑ refine' fun i => Finset.single_le_sum (f := fun i => ‚Äñg x i‚Äñ) (fun i _ => _) (Finset.mem_univ i)
    -- ‚ä¢ 0 ‚â§ (fun i => ‚Äñg x i‚Äñ) i
    exact norm_nonneg (g x i)
    -- üéâ no goals
  ¬∑ exact Finset.sum_nonneg fun _ _ => norm_nonneg _
    -- üéâ no goals
#align summable_norm_iff summable_norm_iff

theorem summable_of_isBigO' {Œπ E F : Type*} [NormedAddCommGroup E] [CompleteSpace E]
    [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [FiniteDimensional ‚Ñù F] {f : Œπ ‚Üí E} {g : Œπ ‚Üí F}
    (hg : Summable g) (h : f =O[cofinite] g) : Summable f :=
  summable_of_isBigO (summable_norm_iff.mpr hg) h.norm_right
set_option linter.uppercaseLean3 false in
#align summable_of_is_O' summable_of_isBigO'

theorem summable_of_isBigO_nat' {E F : Type*} [NormedAddCommGroup E] [CompleteSpace E]
    [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [FiniteDimensional ‚Ñù F] {f : ‚Ñï ‚Üí E} {g : ‚Ñï ‚Üí F}
    (hg : Summable g) (h : f =O[atTop] g) : Summable f :=
  summable_of_isBigO_nat (summable_norm_iff.mpr hg) h.norm_right
set_option linter.uppercaseLean3 false in
#align summable_of_is_O_nat' summable_of_isBigO_nat'

theorem summable_of_isEquivalent {Œπ E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    [FiniteDimensional ‚Ñù E] {f : Œπ ‚Üí E} {g : Œπ ‚Üí E} (hg : Summable g) (h : f ~[cofinite] g) :
    Summable f :=
  hg.trans_sub (summable_of_isBigO' hg h.isLittleO.isBigO)
#align summable_of_is_equivalent summable_of_isEquivalent

theorem summable_of_isEquivalent_nat {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    [FiniteDimensional ‚Ñù E] {f : ‚Ñï ‚Üí E} {g : ‚Ñï ‚Üí E} (hg : Summable g) (h : f ~[atTop] g) :
    Summable f :=
  hg.trans_sub (summable_of_isBigO_nat' hg h.isLittleO.isBigO)
#align summable_of_is_equivalent_nat summable_of_isEquivalent_nat

theorem IsEquivalent.summable_iff {Œπ E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    [FiniteDimensional ‚Ñù E] {f : Œπ ‚Üí E} {g : Œπ ‚Üí E} (h : f ~[cofinite] g) :
    Summable f ‚Üî Summable g :=
  ‚ü®fun hf => summable_of_isEquivalent hf h.symm, fun hg => summable_of_isEquivalent hg h‚ü©
#align is_equivalent.summable_iff IsEquivalent.summable_iff

theorem IsEquivalent.summable_iff_nat {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
    [FiniteDimensional ‚Ñù E] {f : ‚Ñï ‚Üí E} {g : ‚Ñï ‚Üí E} (h : f ~[atTop] g) : Summable f ‚Üî Summable g :=
  ‚ü®fun hf => summable_of_isEquivalent_nat hf h.symm, fun hg => summable_of_isEquivalent_nat hg h‚ü©
#align is_equivalent.summable_iff_nat IsEquivalent.summable_iff_nat
