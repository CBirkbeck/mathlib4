/-
Copyright (c) 2022 Moritz Doll. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Moritz Doll
-/
import Mathlib.Analysis.LocallyConvex.BalancedCoreHull
import Mathlib.Analysis.LocallyConvex.WithSeminorms
import Mathlib.Analysis.Convex.Gauge

/-!
# Absolutely convex sets

A set is called absolutely convex or disked if it is convex and balanced.
The importance of absolutely convex sets comes from the fact that every locally convex
topological vector space has a basis consisting of absolutely convex sets.

## Main definitions

* `gaugeSeminormFamily`: the seminorm family induced by all open absolutely convex neighborhoods
of zero.

## Main statements

* `with_gaugeSeminormFamily`: the topology of a locally convex space is induced by the family
`gaugeSeminormFamily`.

## TODO

* Define the disked hull

## Tags

disks, convex, balanced
-/


open NormedField Set

open NNReal Pointwise Topology

variable {ùïú E F G Œπ : Type*}

section NontriviallyNormedField

variable (ùïú E) {s : Set E}
variable [NontriviallyNormedField ùïú] [AddCommGroup E] [Module ùïú E]
variable [Module ‚Ñù E] [SMulCommClass ‚Ñù ùïú E]
variable [TopologicalSpace E] [LocallyConvexSpace ‚Ñù E] [ContinuousSMul ùïú E]

theorem nhds_basis_abs_convex :
    (ùìù (0 : E)).HasBasis (fun s : Set E => s ‚àà ùìù (0 : E) ‚àß Balanced ùïú s ‚àß Convex ‚Ñù s) id := by
  refine
    (LocallyConvexSpace.convex_basis_zero ‚Ñù E).to_hasBasis (fun s hs => ?_) fun s hs =>
      ‚ü®s, ‚ü®hs.1, hs.2.2‚ü©, rfl.subset‚ü©
  refine ‚ü®convexHull ‚Ñù (balancedCore ùïú s), ?_, convexHull_min (balancedCore_subset s) hs.2‚ü©
  refine ‚ü®Filter.mem_of_superset (balancedCore_mem_nhds_zero hs.1) (subset_convexHull ‚Ñù _), ?_‚ü©
  refine ‚ü®(balancedCore_balanced s).convexHull, ?_‚ü©
  exact convex_convexHull ‚Ñù (balancedCore ùïú s)

variable [ContinuousSMul ‚Ñù E] [TopologicalAddGroup E]

theorem nhds_basis_abs_convex_open :
    (ùìù (0 : E)).HasBasis (fun s => (0 : E) ‚àà s ‚àß IsOpen s ‚àß Balanced ùïú s ‚àß Convex ‚Ñù s) id := by
  refine (nhds_basis_abs_convex ùïú E).to_hasBasis ?_ ?_
  ¬∑ rintro s ‚ü®hs_nhds, hs_balanced, hs_convex‚ü©
    refine ‚ü®interior s, ?_, interior_subset‚ü©
    exact
      ‚ü®mem_interior_iff_mem_nhds.mpr hs_nhds, isOpen_interior,
        hs_balanced.interior (mem_interior_iff_mem_nhds.mpr hs_nhds), hs_convex.interior‚ü©
  rintro s ‚ü®hs_zero, hs_open, hs_balanced, hs_convex‚ü©
  exact ‚ü®s, ‚ü®hs_open.mem_nhds hs_zero, hs_balanced, hs_convex‚ü©, rfl.subset‚ü©

end NontriviallyNormedField

section AbsolutelyConvex

variable (ùïú) [SeminormedRing ùïú] [SMul ùïú E] [SMul ‚Ñù E] [AddCommMonoid E]
/-- The type of absolutely convex sets. -/
def AbsConvex (s : Set E) : Prop := Balanced ùïú s ‚àß Convex ‚Ñù s

variable {ùïú}

theorem absConvex_empty : AbsConvex ùïú (‚àÖ : Set E) := ‚ü®balanced_empty, convex_empty‚ü©

theorem absConvex_univ : AbsConvex ùïú (Set.univ : Set E) := ‚ü®balanced_univ, convex_univ‚ü©

theorem AbsConvex.inter {s : Set E} {t : Set E} (hs : AbsConvex ùïú s) (ht : AbsConvex ùïú t) :
    AbsConvex ùïú (s ‚à© t) := ‚ü®Balanced.inter hs.1 ht.1, Convex.inter hs.2 ht.2‚ü©

theorem absConvex_sInter {S : Set (Set E)} (h : ‚àÄ s ‚àà S, AbsConvex ùïú s) : AbsConvex ùïú (‚ãÇ‚ÇÄ S) :=
  ‚ü®balanced_sInter (fun s hs => (h s hs).1), convex_sInter (fun s hs => (h s hs).2)‚ü©

variable (ùïú)

/-- The absolute convex hull of a set `s` is the minimal absolute convex set that includes `s`. -/
@[simps! isClosed]
def absConvexHull : ClosureOperator (Set E) :=
    .ofCompletePred (AbsConvex ùïú) fun _ ‚Ü¶ absConvex_sInter

variable (s : Set E)

theorem subset_absConvexHull : s ‚äÜ absConvexHull ùïú s :=
  (absConvexHull ùïú).le_closure s

theorem absConvex_absConvexHull : AbsConvex ùïú (absConvexHull ùïú s) :=
    (absConvexHull ùïú).isClosed_closure s

theorem balanced_absConvexHull : Balanced ùïú ((absConvexHull ùïú) s) := (absConvex_absConvexHull ùïú s).1

theorem convex_absConvexHull : Convex ‚Ñù ((absConvexHull ùïú) s) := (absConvex_absConvexHull ùïú s).2

theorem absConvexHull_eq_iInter :
    absConvexHull ùïú s = ‚ãÇ (t : Set E) (_ : s ‚äÜ t) (_ : AbsConvex ùïú t), t := by
  simp [absConvexHull, iInter_subtype, iInter_and]

variable {ùïú s} {t : Set E} {x y : E}

theorem mem_absConvexHull_iff : x ‚àà absConvexHull ùïú s ‚Üî ‚àÄ t, s ‚äÜ t ‚Üí AbsConvex ùïú t ‚Üí x ‚àà t := by
  simp_rw [absConvexHull_eq_iInter, mem_iInter]

theorem absConvexHull_min : s ‚äÜ t ‚Üí AbsConvex ùïú t ‚Üí absConvexHull ùïú s ‚äÜ t :=
  (absConvexHull ùïú).closure_min

theorem AbsConvex.absConvexHull_subset_iff (ht : AbsConvex ùïú t) : absConvexHull ùïú s ‚äÜ t ‚Üî s ‚äÜ t :=
  (show (absConvexHull ùïú).IsClosed t from ht).closure_le_iff

@[mono, gcongr]
theorem absConvexHull_mono (hst : s ‚äÜ t) : absConvexHull ùïú s ‚äÜ absConvexHull ùïú t :=
  (absConvexHull ùïú).monotone hst

lemma absConvexHull_eq_self : absConvexHull ùïú s = s ‚Üî AbsConvex ùïú s :=
  (absConvexHull ùïú).isClosed_iff.symm

alias ‚ü®_, AbsConvex.absConvexHull_eq‚ü© := absConvexHull_eq_self

@[simp]
theorem absConvexHull_univ : absConvexHull ùïú (univ : Set E) = univ :=
  ClosureOperator.closure_top (absConvexHull ùïú)

@[simp]
theorem absConvexHull_empty : absConvexHull ùïú (‚àÖ : Set E) = ‚àÖ :=
  absConvex_empty.absConvexHull_eq

@[simp]
theorem absConvexHull_empty_iff : absConvexHull ùïú s = ‚àÖ ‚Üî s = ‚àÖ := by
  constructor
  ¬∑ intro h
    rw [‚Üê Set.subset_empty_iff, ‚Üê h]
    exact subset_absConvexHull ùïú _
  ¬∑ rintro rfl
    exact absConvexHull_empty

@[simp]
theorem absConvexHull_nonempty_iff : (absConvexHull ùïú s).Nonempty ‚Üî s.Nonempty := by
  rw [nonempty_iff_ne_empty, nonempty_iff_ne_empty, Ne, Ne]
  exact not_congr absConvexHull_empty_iff

protected alias ‚ü®_, Set.Nonempty.absConvexHull‚ü© := absConvexHull_nonempty_iff

end AbsolutelyConvex

section

variable (ùïú) [NontriviallyNormedField ùïú] --[NormOneClass ùïú]
variable [AddCommGroup E] [Module ‚Ñù E] [Module ùïú E]

theorem absConvexHull_eq_convexHull_balancedHull  [SMulCommClass ‚Ñù ùïú E] {s : Set E} :
    absConvexHull ùïú s = convexHull ‚Ñù (balancedHull ùïú s) := by
  apply le_antisymm
  ¬∑ exact absConvexHull_min
      (subset_trans (subset_convexHull ‚Ñù s) (convexHull_mono (subset_balancedHull ùïú)))
      ‚ü®Balanced.convexHull (balancedHull.balanced s), convex_convexHull _ _‚ü©
  ¬∑ rw [‚Üê Convex.convexHull_eq (convex_absConvexHull ùïú s)]
    exact convexHull_mono
      (Balanced.balancedHull_subset_of_subset (balanced_absConvexHull ùïú s)
        (subset_absConvexHull ùïú s))

theorem AbsConvex.hullAdd {s t : Set E} :
    absConvexHull ùïú (s + t) ‚äÜ absConvexHull ùïú s + absConvexHull ùïú t :=
  absConvexHull_min (add_subset_add (subset_absConvexHull ùïú s) (subset_absConvexHull ùïú t))
    ‚ü®Balanced.add (balanced_absConvexHull ùïú s) (balanced_absConvexHull ùïú t),
      Convex.add (convex_absConvexHull ùïú s) (convex_absConvexHull ùïú t)‚ü©

end

section

variable [AddCommGroup E] [Module ‚Ñù E]

lemma balancedHull_subseteq_convexHull {s : Set E} : balancedHull ‚Ñù s ‚äÜ convexHull ‚Ñù (s ‚à™ -s) := by
  intro a ha
  obtain ‚ü®r, hr, y, hy, rfl‚ü© := mem_balancedHull_iff.1 ha
  apply segment_subset_convexHull (mem_union_left (-s) hy) (mem_union_right _ (neg_mem_neg.mpr hy))
  use (1+r)/2
  use (1-r)/2
  constructor
  ¬∑ rw [‚Üê zero_div 2]
    exact (div_le_div_right zero_lt_two).mpr (neg_le_iff_add_nonneg'.mp (neg_le_of_abs_le hr))
  ¬∑ constructor
    ¬∑ rw [‚Üê zero_div 2]
      exact (div_le_div_right zero_lt_two).mpr (sub_nonneg_of_le (le_of_max_le_left hr))
    ¬∑ constructor
      ¬∑ ring_nf
      ¬∑ rw [smul_neg, ‚Üê sub_eq_add_neg, ‚Üê sub_smul]
        apply congrFun (congrArg HSMul.hSMul _) y
        ring_nf

theorem absConvexHull_eq_convexHull_union_neg {s : Set E} :
    absConvexHull ‚Ñù s = convexHull ‚Ñù (s ‚à™ -s) := by
  rw [absConvexHull_eq_convexHull_balancedHull]
  exact le_antisymm (by
    rw [‚Üê Convex.convexHull_eq (convex_convexHull ‚Ñù (s ‚à™ -s)) ]
    exact convexHull_mono balancedHull_subseteq_convexHull)
    (convexHull_mono (union_subset (subset_balancedHull ‚Ñù)
      (fun _ _ => by rw [mem_balancedHull_iff]; use -1; aesop)))

theorem absConvexHull_inter_neg_eq {s : Set E} :
    absConvexHull ‚Ñù (s ‚à© -s) = convexHull ‚Ñù (s ‚à© -s) := by
  rw [absConvexHull_eq_convexHull_union_neg, inter_neg, neg_neg, inter_comm, union_self]

end

section

variable [AddCommGroup E] [Module ‚Ñù E]

lemma half_add_half_of_convex {V : Set E} (h : Convex ‚Ñù V) : (1/2 : ‚Ñù) ‚Ä¢ V + (1/2 : ‚Ñù) ‚Ä¢ V = V := by
  apply le_antisymm
  ¬∑ apply convex_iff_pointwise_add_subset.mp h (le_of_lt (half_pos Real.zero_lt_one))
      (le_of_lt (half_pos Real.zero_lt_one))
      (add_halves 1)
  ¬∑ intro x hx
    have e1 : x = (1/2 : ‚Ñù) ‚Ä¢ x + (1/2 : ‚Ñù) ‚Ä¢ x := by
      rw [‚Üê two_smul ‚Ñù]
      simp only [one_div, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true, smul_inv_smul‚ÇÄ]
    rw [e1]
    apply add_mem_add
    exact smul_mem_smul_set hx
    exact smul_mem_smul_set hx

lemma add_self_eq_smul_two {V : Set E} (h : Convex ‚Ñù V) : V + V = (2 : ‚Ñù) ‚Ä¢ V := by
  have v1 : Convex ‚Ñù ((2 : ‚Ñù) ‚Ä¢ V) := Convex.smul h 2
  rw [‚Üê half_add_half_of_convex v1]
  simp only [one_div, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true, inv_smul_smul‚ÇÄ]

lemma help' (a b :E) (h : a = b) : (1/2 : ‚Ñù) ‚Ä¢ a = (1/2 : ‚Ñù) ‚Ä¢b := by
  exact congrArg (HSMul.hSMul (1 / 2)) h

lemma help (a b :E) (h : (2:‚Ñù)‚Ä¢a = (2:‚Ñù)‚Ä¢b) : a = b := by
  have e1 : (1/2 : ‚Ñù) ‚Ä¢ ((2:‚Ñù)‚Ä¢a) = (1/2 : ‚Ñù) ‚Ä¢((2:‚Ñù)‚Ä¢b) := by
    apply help'
    exact h
  simp at e1
  exact e1

variable (E ùïú) {s : Set E}
variable [NontriviallyNormedField ùïú]  [Module ùïú E]
variable [SMulCommClass ‚Ñù ùïú E]
variable [TopologicalSpace E] [TopologicalAddGroup E]  [lcs : LocallyConvexSpace ‚Ñù E]
  [ContinuousSMul ‚Ñù E]

-- TVS II.25 Prop3
theorem totallyBounded_absConvexHull
    (hs : TotallyBounded (uniformSpace := TopologicalAddGroup.toUniformSpace E) s) :
    TotallyBounded (uniformSpace := TopologicalAddGroup.toUniformSpace E) (absConvexHull ‚Ñù s) := by
  intro d' hd'
  letI := TopologicalAddGroup.toUniformSpace E
  obtain ‚ü®d,‚ü®hd‚ÇÅ, hd‚ÇÇ‚ü©‚ü© := comp_mem_uniformity_sets hd'
  obtain ‚ü®N,‚ü®hN‚ÇÅ,hN‚ÇÇ‚ü©‚ü© := hd‚ÇÅ
  obtain ‚ü®S,‚ü®hS‚ÇÅ,hS‚ÇÇ,hS‚ÇÉ‚ü©‚ü© := (locallyConvexSpace_iff_exists_convex_subset_zero ‚Ñù E).mp lcs N hN‚ÇÅ
  let V := S ‚à© -S
  let d‚ÇÇ := {(x,y) | y-x ‚àà S} ‚à© {(x,y) | y-x ‚àà -S}
  obtain ‚ü®t,‚ü®htf,hts‚ü©‚ü© := hs d‚ÇÇ (by
    rw [uniformity_eq_comap_nhds_zero' E]
    simp_all only [Filter.inter_mem_iff, Filter.mem_comap, d‚ÇÇ]
    apply And.intro
    ¬∑ aesop
    ¬∑ use -S
      constructor
      ¬∑ exact neg_mem_nhds_zero E hS‚ÇÅ
      ¬∑ exact fun ‚¶Éa‚¶Ñ a ‚Ü¶ a
    )
  have e1 (y : E) : {x | (x, y) ‚àà d‚ÇÇ} = y +·µ• V := by
    apply le_antisymm
    ¬∑ intro x hx
      rw [Set.mem_vadd']
      aesop
    ¬∑ intro x hx
      rw [Set.mem_vadd'] at hx
      aesop
  have e2 {t‚ÇÅ : Set E} : ‚ãÉ y ‚àà t‚ÇÅ, {x | (x, y) ‚àà d‚ÇÇ} = t‚ÇÅ + V := by
    aesop
  rw [e2] at hts
  have e3 : (absConvexHull ‚Ñù) s ‚äÜ (absConvexHull ‚Ñù) (t + V) := by
    exact absConvexHull_mono hts
  have e4 : (absConvexHull ‚Ñù) s ‚äÜ ((absConvexHull ‚Ñù) t) + (absConvexHull ‚Ñù) V :=
    le_trans e3 (AbsConvex.hullAdd _)
  have e5 : (absConvexHull ‚Ñù) V = V := by
    rw [AbsConvex.absConvexHull_eq]
    rw [‚Üê absConvexHull_eq_self]
    rw [absConvexHull_inter_neg_eq]
    rw [Convex.convexHull_eq]
    exact Convex.inter hS‚ÇÇ (Convex.neg hS‚ÇÇ)
  rw [e5] at e4
  rw [absConvexHull_eq_convexHull_union_neg (s := t)] at e4
  have e6 : TotallyBounded (uniformSpace := TopologicalAddGroup.toUniformSpace E)
      ((convexHull ‚Ñù) (t ‚à™ -t)) := by
    apply IsCompact.totallyBounded
    apply Set.Finite.isCompact_convexHull
    apply finite_union.mpr ‚ü®htf,Finite.neg htf‚ü©
  have e0 : d‚ÇÇ = symmetrizeRel {(x,y) | y-x ‚àà S} := by
    simp_all only [mem_neg, neg_sub, d‚ÇÇ]
    rfl
  obtain ‚ü®t',‚ü®htf',hts'‚ü©‚ü© := e6 d‚ÇÇ (by
    rw [e0]
    apply symmetrize_mem_uniformity
    rw [uniformity_eq_comap_nhds_zero']
    aesop
  )
  rw [e2] at hts'
  have e7: (absConvexHull ‚Ñù) s ‚äÜ t' + (V + V) := by
    apply le_trans
    apply e4
    rw [‚Üê add_assoc]
    apply Set.add_subset_add_right
    apply hts'
  rw [add_self_eq_smul_two] at e7
  have e8 (y : E): y +·µ• ((2 : ‚Ñù) ‚Ä¢ V) ‚äÜ {x | (x, y) ‚àà d'} := by
    intro x hx
    rw [mem_setOf_eq]
    rw [Set.mem_vadd'] at hx
    obtain ‚ü®z,‚ü®hz‚ÇÅ,hz‚ÇÇ‚ü©‚ü© := hx
    apply hd‚ÇÇ
    rw [vadd_eq_add] at hz‚ÇÇ
    rw [mem_compRel]
    obtain ‚ü®z',‚ü®hz'‚ÇÅ,hz'‚ÇÇ‚ü©‚ü© := hz‚ÇÅ
    simp at hz'‚ÇÇ
    have e11 : (1 / 2 : ‚Ñù) ‚Ä¢ (x + y) - x = -z' := by
      rw [smul_add]
      rw [add_sub_right_comm]
      apply help
      rw [smul_add]
      rw [smul_sub]
      rw [‚Üê smul_assoc]
      simp?
      rw [add_comm]
      rw [two_smul]
      simp
      rw [‚Üê hz‚ÇÇ]
      simp?
      exact id (Eq.symm hz'‚ÇÇ)
    have e12 : y - (1 / 2 : ‚Ñù) ‚Ä¢ (x + y) = -z' := by
      apply help
      rw [smul_sub]
      simp
      rw [two_smul]
      simp
      rw [‚Üê hz‚ÇÇ]
      simp
      exact id (Eq.symm hz'‚ÇÇ)
    use (1/2:‚Ñù)‚Ä¢(x+y)
    constructor
    ¬∑ apply hN‚ÇÇ
      simp only [mem_preimage]
      rw [e11]
      apply hS‚ÇÉ
      aesop
    ¬∑ apply hN‚ÇÇ
      simp only [mem_preimage]
      rw [e12]
      apply hS‚ÇÉ
      aesop
  have e9 : ‚ãÉ y ‚àà t', y +·µ• ((2 : ‚Ñù) ‚Ä¢ V) ‚äÜ ‚ãÉ y ‚àà t', {x | (x, y) ‚àà d'} := by
    apply biUnion_mono
    exact fun ‚¶Éa‚¶Ñ a ‚Ü¶ a
    intro y _
    exact e8 y
  use t'
  constructor
  ¬∑ exact htf'
  ¬∑ apply subset_trans e7
    aesop
  apply Convex.inter
  exact hS‚ÇÇ
  exact Convex.neg hS‚ÇÇ
end

section AbsolutelyConvexSets

variable [TopologicalSpace E] [AddCommMonoid E] [Zero E] [SeminormedRing ùïú]
variable [SMul ùïú E] [SMul ‚Ñù E]
variable (ùïú E)

/-- The type of absolutely convex open sets. -/
def AbsConvexOpenSets :=
  { s : Set E // (0 : E) ‚àà s ‚àß IsOpen s ‚àß AbsConvex ùïú s }

noncomputable instance AbsConvexOpenSets.instCoeTC : CoeTC (AbsConvexOpenSets ùïú E) (Set E) :=
  ‚ü®Subtype.val‚ü©

namespace AbsConvexOpenSets

variable {ùïú E}

theorem coe_zero_mem (s : AbsConvexOpenSets ùïú E) : (0 : E) ‚àà (s : Set E) :=
  s.2.1

theorem coe_isOpen (s : AbsConvexOpenSets ùïú E) : IsOpen (s : Set E) :=
  s.2.2.1

theorem coe_nhds (s : AbsConvexOpenSets ùïú E) : (s : Set E) ‚àà ùìù (0 : E) :=
  s.coe_isOpen.mem_nhds s.coe_zero_mem

theorem coe_balanced (s : AbsConvexOpenSets ùïú E) : Balanced ùïú (s : Set E) :=
  s.2.2.2.1

theorem coe_convex (s : AbsConvexOpenSets ùïú E) : Convex ‚Ñù (s : Set E) :=
  s.2.2.2.2

end AbsConvexOpenSets

instance AbsConvexOpenSets.instNonempty : Nonempty (AbsConvexOpenSets ùïú E) := by
  rw [‚Üê exists_true_iff_nonempty]
  dsimp only [AbsConvexOpenSets]
  rw [Subtype.exists]
  exact ‚ü®Set.univ, ‚ü®mem_univ 0, isOpen_univ, balanced_univ, convex_univ‚ü©, trivial‚ü©

end AbsolutelyConvexSets

variable [RCLike ùïú]
variable [AddCommGroup E] [TopologicalSpace E]
variable [Module ùïú E] [Module ‚Ñù E] [IsScalarTower ‚Ñù ùïú E]
variable [ContinuousSMul ‚Ñù E]
variable (ùïú E)

/-- The family of seminorms defined by the gauges of absolute convex open sets. -/
noncomputable def gaugeSeminormFamily : SeminormFamily ùïú E (AbsConvexOpenSets ùïú E) := fun s =>
  gaugeSeminorm s.coe_balanced s.coe_convex (absorbent_nhds_zero s.coe_nhds)

variable {ùïú E}

theorem gaugeSeminormFamily_ball (s : AbsConvexOpenSets ùïú E) :
    (gaugeSeminormFamily ùïú E s).ball 0 1 = (s : Set E) := by
  dsimp only [gaugeSeminormFamily]
  rw [Seminorm.ball_zero_eq]
  simp_rw [gaugeSeminorm_toFun]
  exact gauge_lt_one_eq_self_of_isOpen s.coe_convex s.coe_zero_mem s.coe_isOpen

variable [TopologicalAddGroup E] [ContinuousSMul ùïú E]
variable [SMulCommClass ‚Ñù ùïú E] [LocallyConvexSpace ‚Ñù E]

/-- The topology of a locally convex space is induced by the gauge seminorm family. -/
theorem with_gaugeSeminormFamily : WithSeminorms (gaugeSeminormFamily ùïú E) := by
  refine SeminormFamily.withSeminorms_of_hasBasis _ ?_
  refine (nhds_basis_abs_convex_open ùïú E).to_hasBasis (fun s hs => ?_) fun s hs => ?_
  ¬∑ refine ‚ü®s, ‚ü®?_, rfl.subset‚ü©‚ü©
    convert (gaugeSeminormFamily _ _).basisSets_singleton_mem ‚ü®s, hs‚ü© one_pos
    rw [gaugeSeminormFamily_ball, Subtype.coe_mk]
  refine ‚ü®s, ‚ü®?_, rfl.subset‚ü©‚ü©
  rw [SeminormFamily.basisSets_iff] at hs
  rcases hs with ‚ü®t, r, hr, rfl‚ü©
  rw [Seminorm.ball_finset_sup_eq_iInter _ _ _ hr]
  -- We have to show that the intersection contains zero, is open, balanced, and convex
  refine
    ‚ü®mem_iInter‚ÇÇ.mpr fun _ _ => by simp [Seminorm.mem_ball_zero, hr],
      isOpen_biInter_finset fun S _ => ?_,
      balanced_iInter‚ÇÇ fun _ _ => Seminorm.balanced_ball_zero _ _,
      convex_iInter‚ÇÇ fun _ _ => Seminorm.convex_ball _ _ _‚ü©
  -- The only nontrivial part is to show that the ball is open
  have hr' : r = ‚Äñ(r : ùïú)‚Äñ * 1 := by simp [abs_of_pos hr]
  have hr'' : (r : ùïú) ‚â† 0 := by simp [hr.ne']
  rw [hr', ‚Üê Seminorm.smul_ball_zero hr'', gaugeSeminormFamily_ball]
  exact S.coe_isOpen.smul‚ÇÄ hr''
