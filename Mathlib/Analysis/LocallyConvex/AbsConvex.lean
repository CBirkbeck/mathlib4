/-
Copyright (c) 2022 Moritz Doll. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Moritz Doll
-/
import Mathlib.Analysis.LocallyConvex.BalancedCoreHull
import Mathlib.Analysis.LocallyConvex.WithSeminorms
import Mathlib.Analysis.Convex.Gauge

/-!
# Absolutely convex sets

A set is called absolutely convex or disked if it is convex and balanced.
The importance of absolutely convex sets comes from the fact that every locally convex
topological vector space has a basis consisting of absolutely convex sets.

## Main definitions

* `absConvexHull`: the absolutely convex hull of a set `s` is the smallest absolutely convex set
  containing `s`.
* `gaugeSeminormFamily`: the seminorm family induced by all open absolutely convex neighborhoods
of zero.

## Main statements

* `absConvexHull_eq_convexHull_balancedHull`: when the locally convex space is a module, the
  absolutely convex hull of a set `s` equals the convex hull of the balanced hull of `s`.
* `absConvexHull_eq_convexHull_union_neg`: the convex hull of `s ‚à™ -s` is the absolute convex hull
  of `s`.
* `with_gaugeSeminormFamily`: the topology of a locally convex space is induced by the family
`gaugeSeminormFamily`.

## Tags

disks, convex, balanced
-/


open NormedField Set

open NNReal Pointwise Topology

variable {ùïú E F G Œπ : Type*}

section AbsolutelyConvex

variable (ùïú) [SeminormedRing ùïú] [SMul ùïú E] [SMul ‚Ñù E] [AddCommMonoid E]
/-- The type of absolutely convex sets. -/
def AbsConvex (s : Set E) : Prop := Balanced ùïú s ‚àß Convex ‚Ñù s

variable {ùïú}

theorem absConvex_empty : AbsConvex ùïú (‚àÖ : Set E) := ‚ü®balanced_empty, convex_empty‚ü©

theorem absConvex_univ : AbsConvex ùïú (Set.univ : Set E) := ‚ü®balanced_univ, convex_univ‚ü©

theorem AbsConvex.inter {s : Set E} {t : Set E} (hs : AbsConvex ùïú s) (ht : AbsConvex ùïú t) :
    AbsConvex ùïú (s ‚à© t) := ‚ü®Balanced.inter hs.1 ht.1, Convex.inter hs.2 ht.2‚ü©

theorem absConvex_sInter {S : Set (Set E)} (h : ‚àÄ s ‚àà S, AbsConvex ùïú s) : AbsConvex ùïú (‚ãÇ‚ÇÄ S) :=
  ‚ü®balanced_sInter (fun s hs => (h s hs).1), convex_sInter (fun s hs => (h s hs).2)‚ü©

variable (ùïú)

/-- The absolute convex hull of a set `s` is the minimal absolute convex set that includes `s`. -/
@[simps! isClosed]
def absConvexHull : ClosureOperator (Set E) :=
    .ofCompletePred (AbsConvex ùïú) fun _ ‚Ü¶ absConvex_sInter

variable (s : Set E)

theorem subset_absConvexHull : s ‚äÜ absConvexHull ùïú s :=
  (absConvexHull ùïú).le_closure s

theorem absConvex_absConvexHull : AbsConvex ùïú (absConvexHull ùïú s) :=
  (absConvexHull ùïú).isClosed_closure s

theorem balanced_absConvexHull : Balanced ùïú ((absConvexHull ùïú) s) :=
  (absConvex_absConvexHull ùïú s).1

theorem convex_absConvexHull : Convex ‚Ñù ((absConvexHull ùïú) s) :=
  (absConvex_absConvexHull ùïú s).2

theorem absConvexHull_eq_iInter :
    absConvexHull ùïú s = ‚ãÇ (t : Set E) (_ : s ‚äÜ t) (_ : AbsConvex ùïú t), t := by
  simp [absConvexHull, iInter_subtype, iInter_and]

variable {ùïú s} {t : Set E} {x y : E}

theorem mem_absConvexHull_iff : x ‚àà absConvexHull ùïú s ‚Üî ‚àÄ t, s ‚äÜ t ‚Üí AbsConvex ùïú t ‚Üí x ‚àà t := by
  simp_rw [absConvexHull_eq_iInter, mem_iInter]

theorem absConvexHull_min : s ‚äÜ t ‚Üí AbsConvex ùïú t ‚Üí absConvexHull ùïú s ‚äÜ t :=
  (absConvexHull ùïú).closure_min

theorem AbsConvex.absConvexHull_subset_iff (ht : AbsConvex ùïú t) : absConvexHull ùïú s ‚äÜ t ‚Üî s ‚äÜ t :=
  (show (absConvexHull ùïú).IsClosed t from ht).closure_le_iff

@[mono, gcongr]
theorem absConvexHull_mono (hst : s ‚äÜ t) : absConvexHull ùïú s ‚äÜ absConvexHull ùïú t :=
  (absConvexHull ùïú).monotone hst

lemma absConvexHull_eq_self : absConvexHull ùïú s = s ‚Üî AbsConvex ùïú s :=
  (absConvexHull ùïú).isClosed_iff.symm

alias ‚ü®_, AbsConvex.absConvexHull_eq‚ü© := absConvexHull_eq_self

@[simp]
theorem absConvexHull_univ : absConvexHull ùïú (univ : Set E) = univ :=
  ClosureOperator.closure_top (absConvexHull ùïú)

@[simp]
theorem absConvexHull_empty : absConvexHull ùïú (‚àÖ : Set E) = ‚àÖ :=
  absConvex_empty.absConvexHull_eq

@[simp]
theorem absConvexHull_empty_iff : absConvexHull ùïú s = ‚àÖ ‚Üî s = ‚àÖ := by
  constructor
  ¬∑ intro h
    rw [‚Üê Set.subset_empty_iff, ‚Üê h]
    exact subset_absConvexHull ùïú _
  ¬∑ rintro rfl
    exact absConvexHull_empty

@[simp]
theorem absConvexHull_nonempty_iff : (absConvexHull ùïú s).Nonempty ‚Üî s.Nonempty := by
  rw [nonempty_iff_ne_empty, nonempty_iff_ne_empty, Ne, Ne]
  exact not_congr absConvexHull_empty_iff

protected alias ‚ü®_, Set.Nonempty.absConvexHull‚ü© := absConvexHull_nonempty_iff

end AbsolutelyConvex

section NontriviallyNormedField

variable (ùïú E) {s : Set E}
variable [NontriviallyNormedField ùïú] [AddCommGroup E] [Module ùïú E]
variable [Module ‚Ñù E] [SMulCommClass ‚Ñù ùïú E]
variable [TopologicalSpace E]  [ContinuousSMul ùïú E]

theorem nhds_basis_abs_convex [LocallyConvexSpace ‚Ñù E] :
    (ùìù (0 : E)).HasBasis (fun s : Set E => s ‚àà ùìù (0 : E) ‚àß AbsConvex ùïú s) id := by
  refine
    (LocallyConvexSpace.convex_basis_zero ‚Ñù E).to_hasBasis (fun s hs => ?_) fun s hs =>
      ‚ü®s, ‚ü®hs.1, hs.2.2‚ü©, rfl.subset‚ü©
  refine ‚ü®convexHull ‚Ñù (balancedCore ùïú s), ?_, convexHull_min (balancedCore_subset s) hs.2‚ü©
  refine ‚ü®Filter.mem_of_superset (balancedCore_mem_nhds_zero hs.1) (subset_convexHull ‚Ñù _), ?_‚ü©
  refine ‚ü®(balancedCore_balanced s).convexHull, ?_‚ü©
  exact convex_convexHull ‚Ñù (balancedCore ùïú s)

variable [ContinuousSMul ‚Ñù E] [TopologicalAddGroup E]

theorem nhds_basis_abs_convex_open [LocallyConvexSpace ‚Ñù E] :
    (ùìù (0 : E)).HasBasis (fun s => (0 : E) ‚àà s ‚àß IsOpen s ‚àß AbsConvex ùïú s) id := by
  refine (nhds_basis_abs_convex ùïú E).to_hasBasis ?_ ?_
  ¬∑ rintro s ‚ü®hs_nhds, hs_balanced, hs_convex‚ü©
    refine ‚ü®interior s, ?_, interior_subset‚ü©
    exact
      ‚ü®mem_interior_iff_mem_nhds.mpr hs_nhds, isOpen_interior,
        hs_balanced.interior (mem_interior_iff_mem_nhds.mpr hs_nhds), hs_convex.interior‚ü©
  rintro s ‚ü®hs_zero, hs_open, hs_balanced, hs_convex‚ü©
  exact ‚ü®s, ‚ü®hs_open.mem_nhds hs_zero, hs_balanced, hs_convex‚ü©, rfl.subset‚ü©

theorem locallyConvexSpace_iff_zero_abs : LocallyConvexSpace ‚Ñù E ‚Üî
    (ùìù 0 : Filter E).HasBasis (fun s : Set E => s ‚àà ùìù (0 : E) ‚àß AbsConvex ‚Ñù s) id :=
  ‚ü®fun _ => nhds_basis_abs_convex ‚Ñù _,
   fun h => LocallyConvexSpace.ofBasisZero ‚Ñù E _ _ h fun _ ‚ü®_,‚ü®_,hN‚ÇÇ‚ü©‚ü© => hN‚ÇÇ‚ü©

theorem locallyConvexSpace_iff_exists_absconvex_subset_zero :
    LocallyConvexSpace ‚Ñù E ‚Üî
    ‚àÄ U ‚àà (ùìù 0 : Filter E), ‚àÉ S ‚àà (ùìù 0 : Filter E), AbsConvex ‚Ñù S ‚àß S ‚äÜ U :=
  (locallyConvexSpace_iff_zero_abs E).trans Filter.hasBasis_self

end NontriviallyNormedField

section

variable (ùïú) [NontriviallyNormedField ùïú]
variable [AddCommGroup E] [Module ‚Ñù E] [Module ùïú E]

theorem AbsConvex.hullAdd {s t : Set E} :
    absConvexHull ùïú (s + t) ‚äÜ absConvexHull ùïú s + absConvexHull ùïú t :=
  absConvexHull_min (add_subset_add (subset_absConvexHull ùïú s) (subset_absConvexHull ùïú t))
    ‚ü®Balanced.add (balanced_absConvexHull ùïú s) (balanced_absConvexHull ùïú t),
      Convex.add (convex_absConvexHull ùïú s) (convex_absConvexHull ùïú t)‚ü©

theorem absConvexHull_eq_convexHull_balancedHull [SMulCommClass ‚Ñù ùïú E] {s : Set E} :
    absConvexHull ùïú s = convexHull ‚Ñù (balancedHull ùïú s) := le_antisymm
  (absConvexHull_min
      (subset_trans (subset_convexHull ‚Ñù s) (convexHull_mono (subset_balancedHull ùïú)))
      ‚ü®Balanced.convexHull (balancedHull.balanced s), convex_convexHull _ _‚ü©)
  (convexHull_min
      (Balanced.balancedHull_subset_of_subset (balanced_absConvexHull ùïú s)
      (subset_absConvexHull ùïú s)) (convex_absConvexHull ùïú s))

end

section

variable [AddCommGroup E] [Module ‚Ñù E]

lemma balancedHull_subseteq_convexHull {s : Set E} : balancedHull ‚Ñù s ‚äÜ convexHull ‚Ñù (s ‚à™ -s) := by
  intro a ha
  obtain ‚ü®r, hr, y, hy, rfl‚ü© := mem_balancedHull_iff.1 ha
  apply segment_subset_convexHull (mem_union_left (-s) hy) (mem_union_right _ (neg_mem_neg.mpr hy))
  use (1+r)/2
  use (1-r)/2
  constructor
  ¬∑ rw [‚Üê zero_div 2]
    exact (div_le_div_right zero_lt_two).mpr (neg_le_iff_add_nonneg'.mp (neg_le_of_abs_le hr))
  ¬∑ constructor
    ¬∑ rw [‚Üê zero_div 2]
      exact (div_le_div_right zero_lt_two).mpr (sub_nonneg_of_le (le_of_max_le_left hr))
    ¬∑ constructor
      ¬∑ ring_nf
      ¬∑ rw [smul_neg, ‚Üê sub_eq_add_neg, ‚Üê sub_smul]
        apply congrFun (congrArg HSMul.hSMul _) y
        ring_nf

theorem absConvexHull_eq_convexHull_union_neg {s : Set E} :
    absConvexHull ‚Ñù s = convexHull ‚Ñù (s ‚à™ -s) := by
  rw [absConvexHull_eq_convexHull_balancedHull]
  exact le_antisymm (by
    rw [‚Üê Convex.convexHull_eq (convex_convexHull ‚Ñù (s ‚à™ -s)) ]
    exact convexHull_mono balancedHull_subseteq_convexHull)
    (convexHull_mono (union_subset (subset_balancedHull ‚Ñù)
      (fun _ _ => by rw [mem_balancedHull_iff]; use -1; aesop)))

theorem absConvexHull_inter_neg_eq {s : Set E} :
    absConvexHull ‚Ñù (s ‚à© -s) = convexHull ‚Ñù (s ‚à© -s) := by
  rw [absConvexHull_eq_convexHull_union_neg, inter_neg, neg_neg, inter_comm, union_self]

end

section

variable [AddCommGroup E] [Module ‚Ñù E]

lemma half_add_half_of_convex {V : Set E} (h : Convex ‚Ñù V) : (1/2 : ‚Ñù) ‚Ä¢ V + (1/2 : ‚Ñù) ‚Ä¢ V = V := by
  rw [‚Üê Convex.add_smul h (le_of_lt (half_pos Real.zero_lt_one))
    (le_of_lt (half_pos Real.zero_lt_one)), add_halves 1, MulAction.one_smul]

lemma add_self_eq_smul_two {V : Set E} (h : Convex ‚Ñù V) : V + V = (2 : ‚Ñù) ‚Ä¢ V := by
  rw [‚Üê one_add_one_eq_two, Convex.add_smul h (zero_le_one' ‚Ñù) (zero_le_one' ‚Ñù), MulAction.one_smul]

lemma help (a b :E) (h : (2:‚Ñù)‚Ä¢a = (2:‚Ñù)‚Ä¢b) : a = b := by
  have e1 : (1/2 : ‚Ñù) ‚Ä¢ ((2:‚Ñù)‚Ä¢a) = (1/2 : ‚Ñù) ‚Ä¢((2:‚Ñù)‚Ä¢b) := by
    apply congrArg (HSMul.hSMul (1 / 2)) h
  simp only [one_div, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true, inv_smul_smul‚ÇÄ] at e1
  exact e1

variable (E ùïú) {s : Set E}
variable [NontriviallyNormedField ùïú]  [Module ùïú E]
variable [SMulCommClass ‚Ñù ùïú E]
variable [TopologicalSpace E] [TopologicalAddGroup E]  [lcs : LocallyConvexSpace ‚Ñù E]
  [ContinuousSMul ‚Ñù E]

-- TVS II.25 Prop3
theorem totallyBounded_absConvexHull
    (hs : TotallyBounded (uniformSpace := TopologicalAddGroup.toUniformSpace E) s) :
    TotallyBounded (uniformSpace := TopologicalAddGroup.toUniformSpace E) (absConvexHull ‚Ñù s) := by
  intro d' hd'
  letI := TopologicalAddGroup.toUniformSpace E
  obtain ‚ü®d,‚ü®‚ü®N,‚ü®hN‚ÇÅ,hN‚ÇÇ‚ü©‚ü©, hd‚ÇÇ‚ü©‚ü© := comp_mem_uniformity_sets hd'
  obtain ‚ü®V,‚ü®hS‚ÇÅ,hS‚ÇÇ,hS‚ÇÉ‚ü©‚ü© := (locallyConvexSpace_iff_exists_absconvex_subset_zero E).mp lcs N hN‚ÇÅ
  let d‚ÇÇ := {(x,y) | y-x ‚àà V}
  obtain ‚ü®t,‚ü®htf,hts‚ü©‚ü© := hs d‚ÇÇ (by
    rw [uniformity_eq_comap_nhds_zero' E]
    aesop)
  have e1' (x : E) : UniformSpace.ball x d‚ÇÇ = x +·µ• V := by
    apply le_antisymm
    ¬∑ intro y hy
      use y-x
      constructor
      ¬∑ aesop
      ¬∑ simp only [vadd_eq_add, add_sub_cancel]
    ¬∑ intro y hy
      obtain ‚ü®z,‚ü®hz‚ÇÅ,hz‚ÇÇ‚ü©‚ü© := hy
      simp only [vadd_eq_add] at hz‚ÇÇ
      have a1: y-x ‚àà V := by
        rw [‚Üê hz‚ÇÇ, add_sub_cancel_left]
        exact hz‚ÇÅ
      rw [UniformSpace.ball]
      aesop
  have s1 : SymmetricRel d‚ÇÇ := by
    ext ‚ü®x,y‚ü©
    simp only [mem_preimage, Prod.swap_prod_mk]
    constructor
    ¬∑ intro h
      simp only [mem_setOf_eq, d‚ÇÇ] at h
      rw [‚Üê Balanced.neg_mem_iff hS‚ÇÇ.1, neg_sub] at h
      exact h
    ¬∑ intro h
      simp only [mem_setOf_eq, d‚ÇÇ] at h
      rw [‚Üê Balanced.neg_mem_iff hS‚ÇÇ.1, neg_sub] at h
      exact h
  have e1 (y : E) : {x | (x, y) ‚àà d‚ÇÇ} = y +·µ• V := by
    rw [‚Üê UniformSpace.ball_eq_of_symmetry s1, e1']
  have e2 {t‚ÇÅ : Set E} : ‚ãÉ y ‚àà t‚ÇÅ, {x | (x, y) ‚àà d‚ÇÇ} = t‚ÇÅ + V := by
    aesop
  rw [e2] at hts
  have e4 : (absConvexHull ‚Ñù) s ‚äÜ (convexHull ‚Ñù) (t ‚à™ -t) + V := by
    rw [‚Üê absConvexHull_eq_convexHull_union_neg (s := t), ‚Üê AbsConvex.absConvexHull_eq hS‚ÇÇ]
    exact le_trans (absConvexHull_mono hts) (AbsConvex.hullAdd _)
  have e6 : TotallyBounded (uniformSpace := TopologicalAddGroup.toUniformSpace E)
      ((convexHull ‚Ñù) (t ‚à™ -t)) := IsCompact.totallyBounded
        (Set.Finite.isCompact_convexHull (finite_union.mpr ‚ü®htf,Finite.neg htf‚ü©))
  obtain ‚ü®t',‚ü®htf',hts'‚ü©‚ü© := e6 d‚ÇÇ (by
    rw [uniformity_eq_comap_nhds_zero']
    aesop
  )
  rw [e2] at hts'
  have e7: (absConvexHull ‚Ñù) s ‚äÜ t' + (2 : ‚Ñù) ‚Ä¢ V := by
    rw [‚Üê add_self_eq_smul_two hS‚ÇÇ.2, ‚Üê add_assoc]
    exact le_trans e4 (Set.add_subset_add_right hts')
  have e8 (y : E): y +·µ• ((2 : ‚Ñù) ‚Ä¢ V) ‚äÜ {x | (x, y) ‚àà d'} := by
    intro x hx
    rw [mem_setOf_eq]
    obtain ‚ü®z,‚ü®hz‚ÇÅ,hz‚ÇÇ‚ü©‚ü© := hx
    apply hd‚ÇÇ
    simp only [vadd_eq_add] at hz‚ÇÇ
    rw [mem_compRel]
    obtain ‚ü®z',‚ü®hz'‚ÇÅ,hz'‚ÇÇ‚ü©‚ü© := hz‚ÇÅ
    simp only at hz'‚ÇÇ
    have e11 : (1 / 2 : ‚Ñù) ‚Ä¢ (x + y) - x = -z' := by
      rw [smul_add]
      rw [add_sub_right_comm]
      apply help
      rw [smul_add]
      rw [smul_sub]
      rw [‚Üê smul_assoc]
      simp only [one_div, smul_eq_mul, isUnit_iff_ne_zero, ne_eq, OfNat.ofNat_ne_zero,
        not_false_eq_true, IsUnit.mul_inv_cancel, one_smul, smul_inv_smul‚ÇÄ, smul_neg]
      rw [add_comm]
      rw [two_smul]
      simp only [sub_add_cancel_right]
      rw [‚Üê hz‚ÇÇ]
      simp only [neg_add_rev, add_neg_cancel_comm_assoc, neg_inj]
      exact id (Eq.symm hz'‚ÇÇ)
    have e12 : y - (1 / 2 : ‚Ñù) ‚Ä¢ (x + y) = -z' := by
      apply help
      rw [smul_sub]
      simp only [one_div, smul_add, ne_eq, OfNat.ofNat_ne_zero, not_false_eq_true, smul_inv_smul‚ÇÄ,
        smul_neg]
      rw [two_smul]
      simp only [add_sub_add_right_eq_sub]
      rw [‚Üê hz‚ÇÇ]
      simp only [sub_add_cancel_left, neg_inj]
      exact id (Eq.symm hz'‚ÇÇ)
    use (1/2:‚Ñù)‚Ä¢(x+y)
    constructor
    ¬∑ apply hN‚ÇÇ
      rw [mem_preimage, e11]
      apply hS‚ÇÉ
      rw [Balanced.neg_mem_iff hS‚ÇÇ.1]
      exact hz'‚ÇÅ
    ¬∑ apply hN‚ÇÇ
      rw [mem_preimage, e12]
      apply hS‚ÇÉ
      rw [Balanced.neg_mem_iff hS‚ÇÇ.1]
      exact hz'‚ÇÅ
  have e9 : ‚ãÉ y ‚àà t', y +·µ• ((2 : ‚Ñù) ‚Ä¢ V) ‚äÜ ‚ãÉ y ‚àà t', {x | (x, y) ‚àà d'} :=
    biUnion_mono (fun ‚¶Éa‚¶Ñ a ‚Ü¶ a) (fun y _ ‚Ü¶ e8 y)
  use t'
  constructor
  ¬∑ exact htf'
  ¬∑ apply subset_trans e7
    aesop
end

section AbsolutelyConvexSets

variable [TopologicalSpace E] [AddCommMonoid E] [Zero E] [SeminormedRing ùïú]
variable [SMul ùïú E] [SMul ‚Ñù E]
variable (ùïú E)

/-- The type of absolutely convex open sets. -/
def AbsConvexOpenSets :=
  { s : Set E // (0 : E) ‚àà s ‚àß IsOpen s ‚àß AbsConvex ùïú s }

noncomputable instance AbsConvexOpenSets.instCoeTC : CoeTC (AbsConvexOpenSets ùïú E) (Set E) :=
  ‚ü®Subtype.val‚ü©

namespace AbsConvexOpenSets

variable {ùïú E}

theorem coe_zero_mem (s : AbsConvexOpenSets ùïú E) : (0 : E) ‚àà (s : Set E) :=
  s.2.1

theorem coe_isOpen (s : AbsConvexOpenSets ùïú E) : IsOpen (s : Set E) :=
  s.2.2.1

theorem coe_nhds (s : AbsConvexOpenSets ùïú E) : (s : Set E) ‚àà ùìù (0 : E) :=
  s.coe_isOpen.mem_nhds s.coe_zero_mem

theorem coe_balanced (s : AbsConvexOpenSets ùïú E) : Balanced ùïú (s : Set E) :=
  s.2.2.2.1

theorem coe_convex (s : AbsConvexOpenSets ùïú E) : Convex ‚Ñù (s : Set E) :=
  s.2.2.2.2

end AbsConvexOpenSets

instance AbsConvexOpenSets.instNonempty : Nonempty (AbsConvexOpenSets ùïú E) := by
  rw [‚Üê exists_true_iff_nonempty]
  dsimp only [AbsConvexOpenSets]
  rw [Subtype.exists]
  exact ‚ü®Set.univ, ‚ü®mem_univ 0, isOpen_univ, balanced_univ, convex_univ‚ü©, trivial‚ü©

end AbsolutelyConvexSets

variable [RCLike ùïú]
variable [AddCommGroup E] [TopologicalSpace E]
variable [Module ùïú E] [Module ‚Ñù E] [IsScalarTower ‚Ñù ùïú E]
variable [ContinuousSMul ‚Ñù E]
variable (ùïú E)

/-- The family of seminorms defined by the gauges of absolute convex open sets. -/
noncomputable def gaugeSeminormFamily : SeminormFamily ùïú E (AbsConvexOpenSets ùïú E) := fun s =>
  gaugeSeminorm s.coe_balanced s.coe_convex (absorbent_nhds_zero s.coe_nhds)

variable {ùïú E}

theorem gaugeSeminormFamily_ball (s : AbsConvexOpenSets ùïú E) :
    (gaugeSeminormFamily ùïú E s).ball 0 1 = (s : Set E) := by
  dsimp only [gaugeSeminormFamily]
  rw [Seminorm.ball_zero_eq]
  simp_rw [gaugeSeminorm_toFun]
  exact gauge_lt_one_eq_self_of_isOpen s.coe_convex s.coe_zero_mem s.coe_isOpen

variable [TopologicalAddGroup E] [ContinuousSMul ùïú E]
variable [SMulCommClass ‚Ñù ùïú E] [LocallyConvexSpace ‚Ñù E]

/-- The topology of a locally convex space is induced by the gauge seminorm family. -/
theorem with_gaugeSeminormFamily : WithSeminorms (gaugeSeminormFamily ùïú E) := by
  refine SeminormFamily.withSeminorms_of_hasBasis _ ?_
  refine (nhds_basis_abs_convex_open ùïú E).to_hasBasis (fun s hs => ?_) fun s hs => ?_
  ¬∑ refine ‚ü®s, ‚ü®?_, rfl.subset‚ü©‚ü©
    convert (gaugeSeminormFamily _ _).basisSets_singleton_mem ‚ü®s, hs‚ü© one_pos
    rw [gaugeSeminormFamily_ball, Subtype.coe_mk]
  refine ‚ü®s, ‚ü®?_, rfl.subset‚ü©‚ü©
  rw [SeminormFamily.basisSets_iff] at hs
  rcases hs with ‚ü®t, r, hr, rfl‚ü©
  rw [Seminorm.ball_finset_sup_eq_iInter _ _ _ hr]
  -- We have to show that the intersection contains zero, is open, balanced, and convex
  refine
    ‚ü®mem_iInter‚ÇÇ.mpr fun _ _ => by simp [Seminorm.mem_ball_zero, hr],
      isOpen_biInter_finset fun S _ => ?_,
      balanced_iInter‚ÇÇ fun _ _ => Seminorm.balanced_ball_zero _ _,
      convex_iInter‚ÇÇ fun _ _ => Seminorm.convex_ball _ _ _‚ü©
  -- The only nontrivial part is to show that the ball is open
  have hr' : r = ‚Äñ(r : ùïú)‚Äñ * 1 := by simp [abs_of_pos hr]
  have hr'' : (r : ùïú) ‚â† 0 := by simp [hr.ne']
  rw [hr', ‚Üê Seminorm.smul_ball_zero hr'', gaugeSeminormFamily_ball]
  exact S.coe_isOpen.smul‚ÇÄ hr''
