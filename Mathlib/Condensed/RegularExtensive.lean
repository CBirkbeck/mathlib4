/-
Copyright (c) 2023 Dagur Asgeirsson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Dagur Asgeirsson, Filippo A. E. Nuccio, Riccardo Brasca
-/
import Mathlib.CategoryTheory.Limits.Preserves.Finite
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Products
import Mathlib.CategoryTheory.Sites.Coherent
/-!
# The Regular and Extensive Coverages
This file defines two coverages on a category `C`.
The first one is called the *regular* coverage and for that to exist, the category `C` must satisfy
a condition called `Regular C`. This means that effective epimorphisms can be "pulled back". The
covering sieves of this coverage are generated by presieves consisting of a single effective
epimorphism.
The second one is called the *extensive* coverage and for that to exist, the category `C` must
satisfy a condition called `Extensive C`. This means `C` has finite coproducts and that those
are preserved by pullbacks. The covering sieves of this coverage are generated by presieves
consisting finitely many arrows that together induce an isomorphism from the coproduct to the
target.
## Main results
* In `extensive_union_regular_generates_coherent`, we prove that the union of these two coverages
  generates the coherent topology on `C` if `C` is precoherent, extensive and regular.
* In `isSheafFor_extensive_of_preservesFiniteProducts` we prove that finite-product preserving
  presheaves are sheaves for extensive sieves.
TODO: figure out under what conditions `Regular` and `Extensive` are implied by `Precoherent`.
-/

universe v u w

namespace CategoryTheory

namespace Coverage

variable {C : Type u} [Category.{v} C]

/-- The union of two coverages is a coverage. -/
@[simps]
def union (x y : Coverage C) : Coverage C where
  covering B := x.covering B ∪ y.covering B
  pullback := by
    rintro X Y f S (hx | hy)
    · obtain ⟨T, hT⟩ := x.pullback f S hx
      exact ⟨T, Or.inl hT.1, hT.2⟩
    · obtain ⟨T, hT⟩ := y.pullback f S hy
      exact ⟨T, Or.inr hT.1, hT.2⟩

end Coverage

open Limits

namespace Presieve

variable {C : Type u} [Category.{v} C] {X : C}

/-- A presieve is *extensive* if it is finite and its arrows induce an isomorphism from the
coproduct to the target. -/
class extensive [HasFiniteCoproducts C] (R : Presieve X) : Prop where
  /-- `R` consists of a finite collection of arrows that together induce an isomorphism from the
  coproduct of their sources. -/
  arrows_sigma_desc_iso : ∃ (α : Type) (_ : Fintype α) (Z : α → C) (π : (a : α) → (Z a ⟶ X)),
    R = Presieve.ofArrows Z π ∧ IsIso (Sigma.desc π)

/-- A presieve is *regular* if it consists of a single effective epimorphism. -/
class regular (R : Presieve X) : Prop where
  /-- `R` consists of a single epimorphism. -/
  single_epi : ∃ (Y : C) (f : Y ⟶ X), R = Presieve.ofArrows (fun (_ : Unit) ↦ Y)
    (fun (_ : Unit) ↦ f) ∧ EffectiveEpi f

end Presieve

section instances

variable {C : Type u} [Category.{v} C]

/--
Given an `EffectiveEpiFamily X π` such that the coproduct of `X` exists, `Sigma.desc π` is an
`EffectiveEpi`.
-/
noncomputable
def EffectiveEpiFamily_descStruct {B : C} {α : Type*} (X : α → C) (π : (a : α) → (X a ⟶ B))
    [HasCoproduct X] [EffectiveEpiFamily X π] : EffectiveEpiStruct (Sigma.desc π) where
  desc e h := EffectiveEpiFamily.desc X π (fun a ↦ Sigma.ι X a ≫ e) (fun a₁ a₂ g₁ g₂ hg ↦ by
    simp only [← Category.assoc]
    apply h (g₁ ≫ Sigma.ι X a₁) (g₂ ≫ Sigma.ι X a₂)
    simpa only [Category.assoc, colimit.ι_desc, Cofan.mk_pt, Cofan.mk_ι_app])
  fac e h := by
    ext a
    simp only [colimit.ι_desc_assoc, Discrete.functor_obj, Cofan.mk_pt, Cofan.mk_ι_app,
      EffectiveEpiFamily.fac]
  uniq e _ m hm := by
    have := EffectiveEpiFamily.uniq X π (fun a ↦ Sigma.ι X a ≫ e) ?_ m
    · apply this
      intro a
      rw [← hm]
      simp only [colimit.ι_desc_assoc, Discrete.functor_obj, Cofan.mk_pt, Cofan.mk_ι_app]
    · intro Z a₁ a₂ g₁ g₂ hg
      rw [← hm]
      simp only [colimit.ι_desc_assoc, Discrete.functor_obj, Cofan.mk_pt, Cofan.mk_ι_app]
      rw [← Category.assoc, hg, Category.assoc]

instance {B : C} {α : Type*} (X : α → C) (π : (a : α) → (X a ⟶ B)) [HasCoproduct X]
    [EffectiveEpiFamily X π] : EffectiveEpi (Sigma.desc π) :=
  ⟨⟨EffectiveEpiFamily_descStruct X π⟩⟩

/--
An `EffectiveEpiFamily` consisting of a single `EffectiveEpi`
-/
noncomputable
def EffectiveEpi_familyStruct {B X : C} (f : X ⟶ B) [EffectiveEpi f] :
    EffectiveEpiFamilyStruct (fun () ↦ X) (fun () ↦ f) where
  desc e h := EffectiveEpi.desc f (e ()) (fun g₁ g₂ hg ↦ h () () g₁ g₂ hg)
  fac e h := fun _ ↦ EffectiveEpi.fac f (e ()) (fun g₁ g₂ hg ↦ h () () g₁ g₂ hg)
  uniq e h m hm := by apply EffectiveEpi.uniq f (e ()) (h () ()); exact hm ()

instance {B X : C} (f : X ⟶ B) [EffectiveEpi f] : EffectiveEpiFamily (fun () ↦ X) (fun () ↦ f) :=
  ⟨⟨EffectiveEpi_familyStruct f⟩⟩

/--
A family of morphisms with the same target inducing an isomorphism from the coproduct to the target
is an `EffectiveEpiFamily`.
-/
noncomputable
def EffectiveEpiFamilyStruct_of_isIso_desc {B : C} {α : Type*} (X : α → C)
    (π : (a : α) → (X a ⟶ B)) [HasCoproduct X] [IsIso (Sigma.desc π)] :
    EffectiveEpiFamilyStruct X π where
  desc e _ := (asIso (Sigma.desc π)).inv ≫ (Sigma.desc e)
  fac e h := by
    intro a
    have : π a = Sigma.ι X a ≫ (asIso (Sigma.desc π)).hom := by simp only [asIso_hom,
      colimit.ι_desc, Cofan.mk_pt, Cofan.mk_ι_app]
    rw [this, Category.assoc]
    simp only [asIso_hom, asIso_inv, IsIso.hom_inv_id_assoc, colimit.ι_desc, Cofan.mk_pt,
      Cofan.mk_ι_app]
  uniq e h m hm := by
    simp only [asIso_inv, IsIso.eq_inv_comp]
    ext a
    simp only [colimit.ι_desc_assoc, Discrete.functor_obj, Cofan.mk_pt, Cofan.mk_ι_app,
      colimit.ι_desc]
    exact hm a

instance {B : C} {α : Type*} (X : α → C) (π : (a : α) → (X a ⟶ B)) [HasCoproduct X]
    [IsIso (Sigma.desc π)] : EffectiveEpiFamily X π :=
  ⟨⟨EffectiveEpiFamilyStruct_of_isIso_desc X π⟩⟩

end instances

variable (C : Type u) [Category.{v} C]

/--
The condition `Regular C` is property that effective epis can be "pulled back" along any
morphism. This is satisfied e.g. by categories that have pullbacks that preserve effective
epimorphisms (like `Profinite` and `CompHaus`), and categories where every object is projective
(like  `Stonean`).
-/
class Regular : Prop where
  /--
  For `X`, `Y`, `Z`, `f`, `g` like in the diagram, where `g` is an effective epi, there exists
  an object `W`, a morphism `i : W ⟶ Z` and an effective epi `h : W ⟶ X` making the diagram
  commute.
  ```
  W --i-→ Z
  |       |
  h       g
  ↓       ↓
  X --f-→ Y
  ```
  -/
  exists_fac : ∀ {X Y Z : C} (f : X ⟶ Y) (g : Z ⟶ Y) [EffectiveEpi g],
    (∃ (W : C) (h : W ⟶ X) (_ : EffectiveEpi h) (i : W ⟶ Z), i ≫ g = h ≫ f)

/--
Describes the property of having pullbacks of morphsims into a finite coproduct, where one
of the morphisms is an inclusion map into the coproduct (up to isomorphism).
-/
class HasPullbacksOfInclusions : Prop where
    /-- For any morphism `f : X ⟶ Z`, where `Z` is the coproduct of `i : (a : α) → Y a ⟶ Z` with
    `α` finite, the pullback of `f` and `i a` exists for every `a : α`. -/
    has_pullback : ∀ {X Z : C} {α : Type _} (f : X ⟶ Z) {Y : (a : α) → C}
    (i : (a : α) → Y a ⟶ Z) [Fintype α] [HasCoproduct Y] [IsIso (Sigma.desc i)] (a : α),
    HasPullback f (i a)

instance [HasPullbacksOfInclusions C] {X Z : C} {α : Type _} (f : X ⟶ Z) {Y : (a : α) → C}
    (i : (a : α) → Y a ⟶ Z) [Fintype α] [HasCoproduct Y] [IsIso (Sigma.desc i)] (a : α) :
    HasPullback f (i a) := HasPullbacksOfInclusions.has_pullback f i a

/--
If `C` has pullbacks then it has the pullbacks relevant to `HasPullbacksOfInclusions`.
-/
instance (priority := 10) [HasPullbacks C] :
  HasPullbacksOfInclusions C := ⟨fun _ _ _ => inferInstance⟩

/--
A category is *extensive* if it has all finite coproducts and those coproducts are preserved
by pullbacks (we only require the relevant pullbacks to exist, via `HasPullbacksOfInclusions`).
-/
class Extensive extends HasFiniteCoproducts C, HasPullbacksOfInclusions C : Prop where
  /-- Pulling back an isomorphism from a coproduct yields an isomorphism. -/
  sigma_desc_iso : ∀ {α : Type} [Fintype α] {X : C} {Z : α → C} (π : (a : α) → Z a ⟶ X)
    {Y : C} (f : Y ⟶ X) (_ : IsIso (Sigma.desc π)),
    IsIso (Sigma.desc ((fun _ ↦ pullback.fst) : (a : α) → pullback f (π a) ⟶ _))

/--
The regular coverage on a regular category `C`.
-/
def regularCoverage [Regular C] : Coverage C where
  covering B := { S | ∃ (X : C) (f : X ⟶ B), S = Presieve.ofArrows (fun (_ : Unit) ↦ X)
    (fun (_ : Unit) ↦ f) ∧ EffectiveEpi f }
  pullback := by
    intro X Y f S ⟨Z, π, hπ, h_epi⟩
    have := Regular.exists_fac f π
    obtain ⟨W, h, _, i, this⟩ := this
    refine ⟨Presieve.singleton h, ⟨?_, ?_⟩⟩
    · exact ⟨W, h, by {rw [Presieve.ofArrows_pUnit h]}, inferInstance⟩
    · intro W g hg
      cases hg
      refine ⟨Z, i, π, ⟨?_, this⟩⟩
      cases hπ
      rw [Presieve.ofArrows_pUnit]
      exact Presieve.singleton.mk

/--
The extensive coverage on an extensive category `C`
-/
def extensiveCoverage [Extensive C] : Coverage C where
  covering B := { S | ∃ (α : Type) (_ : Fintype α) (X : α → C) (π : (a : α) → (X a ⟶ B)),
    S = Presieve.ofArrows X π ∧ IsIso (Sigma.desc π) }
  pullback := by
    intro X Y f S ⟨α, hα, Z, π, hS, h_iso⟩
    let Z' : α → C := fun a ↦ pullback f (π a)
    let π' : (a : α) → Z' a ⟶ Y := fun a ↦ pullback.fst
    refine ⟨@Presieve.ofArrows C _ _ α Z' π', ⟨?_, ?_⟩⟩
    · constructor
      exact ⟨hα, Z', π', ⟨by simp only, Extensive.sigma_desc_iso (fun x => π x) f h_iso⟩⟩
    · intro W g hg
      rcases hg with ⟨a⟩
      refine ⟨Z a, pullback.snd, π a, ?_, by rw [CategoryTheory.Limits.pullback.condition]⟩
      rw [hS]
      refine Presieve.ofArrows.mk a

variable {C}

lemma extensive_union_regular_generates_coherent [Regular C] [Extensive C] [Precoherent C] :
    ((extensiveCoverage C).union (regularCoverage C)).toGrothendieck =
    (coherentTopology C) := by
  ext B S
  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩
  · dsimp [Coverage.toGrothendieck] at *
    induction h with
    | of Y T hT =>
      · apply Coverage.saturate.of
        dsimp [coherentCoverage]
        simp only [Coverage.union, extensiveCoverage, regularCoverage, Set.mem_union,
          Set.mem_setOf_eq] at hT
        apply Or.elim hT
        <;> intro h
        · obtain ⟨α, x, X, π, h⟩ := h
          refine ⟨α, x, X, π, ⟨h.1, ?_⟩⟩
          letI := h.2
          infer_instance
        · obtain ⟨Z, f, ⟨hh, h⟩⟩  := h
          refine ⟨Unit, inferInstance, (fun _ ↦ Z), (fun _ ↦ f), ⟨hh, ?_⟩⟩
          infer_instance
    | top =>
      · apply Coverage.saturate.top
    | transitive Y T =>
      · apply Coverage.saturate.transitive Y T
        · assumption
        · assumption
  · induction h with
    | of Y T hT =>
      · dsimp [coherentCoverage] at hT
        obtain ⟨I, hI, X, f, ⟨h, hT⟩⟩ := hT
        let φ := fun (i : I) ↦ Sigma.ι X i
        let F := Sigma.desc f
        let Z := Sieve.generate T
        let Xs := (∐ fun (i : I) => X i)
        let Zf : Sieve Y := Sieve.generate
          (Presieve.ofArrows (fun (_ : Unit) ↦ Xs) (fun (_ : Unit) ↦ F))
        apply Coverage.saturate.transitive Y Zf
        · apply Coverage.saturate.of
          simp only [Coverage.union, extensiveCoverage, regularCoverage, Set.mem_union,
            Set.mem_setOf_eq]
          right
          refine ⟨Xs, F, ⟨rfl, ?_⟩⟩
          infer_instance
        · intro R g hZfg
          dsimp at hZfg
          rw [Presieve.ofArrows_pUnit] at hZfg
          obtain ⟨W, ψ, σ, ⟨hW, hW'⟩⟩ := hZfg
          dsimp [Presieve.singleton] at hW
          induction hW
          rw [← hW', Sieve.pullback_comp Z]
          suffices : Sieve.pullback ψ ((Sieve.pullback F) Z) ∈ GrothendieckTopology.sieves
            ((extensiveCoverage C).union (regularCoverage C)).toGrothendieck R
          · exact this
          apply GrothendieckTopology.pullback_stable'
          dsimp [Coverage.toGrothendieck]
          suffices : Coverage.saturate ((extensiveCoverage C).union (regularCoverage C)) Xs
            (Z.pullback F)
          · exact this
          suffices : Sieve.generate (Presieve.ofArrows X φ) ≤ Z.pullback F
          · apply Coverage.saturate_of_superset _ this
            apply Coverage.saturate.of
            simp only [Coverage.union, extensiveCoverage, regularCoverage, Set.mem_union,
              Set.mem_setOf_eq]
            left
            refine ⟨I, hI, X, φ, ⟨rfl, ?_⟩⟩
            suffices : Sigma.desc φ = 𝟙 _
            · rw [this]
              exact inferInstance
            ext
            simp only [colimit.ι_desc, Cofan.mk_pt, Cofan.mk_ι_app, Category.comp_id]
          intro Q q hq
          simp only [Sieve.pullback_apply, Sieve.generate_apply]
          simp only [Sieve.generate_apply] at hq
          obtain ⟨E, e, r, hq⟩ := hq
          refine' ⟨E, e, r ≫ F, ⟨_, _⟩⟩
          · rw [h]
            induction hq.1
            dsimp
            simp only [colimit.ι_desc, Cofan.mk_pt, Cofan.mk_ι_app]
            exact Presieve.ofArrows.mk _
          · rw [← hq.2]
            simp only [Category.assoc]
    | top =>
      · apply Coverage.saturate.top
    | transitive Y T =>
      · apply Coverage.saturate.transitive Y T
        · assumption
        · assumption

section ExtensiveSheaves

variable [Extensive C]

instance {X : C} (S : Presieve X) [S.extensive] : S.hasPullbacks where
  has_pullbacks := by
    obtain ⟨_, _, _, _, hS, _⟩ := Presieve.extensive.arrows_sigma_desc_iso (R := S)
    intro _ _ f hf _ hg
    rw [hS] at hf hg
    cases' hg with b
    apply HasPullbacksOfInclusions.has_pullback f

namespace ExtensiveSheafConditionProof

lemma sigma_surjective {α : Type} {Z : α → C} {X : C} (π : (a : α) → Z a ⟶ X) :
    Function.Surjective (fun a => ⟨Z a, π a, Presieve.ofArrows.mk a⟩ :
    α → Σ(Y : C), { f : Y ⟶ X // Presieve.ofArrows Z π f }) :=
  fun ⟨_, ⟨_, hf⟩⟩ ↦ by cases' hf with a _; exact ⟨a, rfl⟩

open Opposite

instance {α : Type} {Z : α → C} {X : C} {π : (a : α) → Z a ⟶ X} [Fintype α] :
    HasProduct fun (x : Σ(Y : C), { f : Y ⟶ X // Presieve.ofArrows Z π f }) ↦ (op x.1) :=
  haveI := Finite.of_surjective _ (sigma_surjective π)
  inferInstance

/-- The canonical map from `Equalizer.FirstObj` to a product indexed by `α` -/
noncomputable
def prod_map {α : Type} {Z : α → C} {X : C} (π : (a : α) → Z a ⟶ X) (F : Cᵒᵖ ⥤ Type max u v) :
    (∏ fun (f : (Σ(Y : C), { f : Y ⟶ X // Presieve.ofArrows Z π f })) => F.obj (op f.fst)) ⟶
    ∏ fun a => F.obj (op (Z a)) :=
  Pi.lift (fun a => Pi.π _ ⟨Z a, π a, Presieve.ofArrows.mk a⟩) ≫ 𝟙 _

/-- The inverse to `Equalizer.forkMap F (Presieve.ofArrows Z π)`. -/
noncomputable
def firstObj_to_base {α : Type} [Fintype α] {Z : α → C} {X : C} (π : (a : α) → Z a ⟶ X)
  (F : Cᵒᵖ ⥤ Type max u v) [PreservesFiniteProducts F] [IsIso (Sigma.desc π)] :
    Equalizer.FirstObj F (Presieve.ofArrows Z π) ⟶ F.obj (op X) :=
  haveI : PreservesLimit (Discrete.functor fun a => op (Z a)) F :=
    (PreservesFiniteProducts.preserves α).preservesLimit
  (prod_map π F) ≫ ((Limits.PreservesProduct.iso F (fun a => op <| Z a)).inv ≫
    F.map (opCoproductIsoProduct Z).inv ≫ F.map (inv (Sigma.desc π).op))

lemma comp_inv_desc_eq_ι {α : Type} [Fintype α] {Z : α → C} {X : C} (π : (a : α) → Z a ⟶ X)
    [IsIso (Sigma.desc π)] (a : α) : π a ≫ inv (Sigma.desc π) = Sigma.ι _ a := by
  simp only [IsIso.comp_inv_eq, colimit.ι_desc, Cofan.mk_pt, Cofan.mk_ι_app]

@[simp]
lemma PreservesProduct.isoInvCompMap {C : Type u} [Category C] {D : Type v} [Category D] (F : C ⥤ D)
    {J : Type w} {f : J → C} [HasProduct f] [HasProduct (fun j => F.obj (f j))]
    [PreservesLimit (Discrete.functor f) F] (j : J) :
    (PreservesProduct.iso F f).inv ≫ F.map (Pi.π _ j) = Pi.π _ j :=
  IsLimit.conePointUniqueUpToIso_inv_comp _ (limit.isLimit _) (⟨j⟩ : Discrete J)

instance {α : Type} [Fintype α] {Z : α → C} {F : C ⥤ Type w}
    [PreservesFiniteProducts F] : PreservesLimit (Discrete.functor fun a => (Z a)) F :=
  (PreservesFiniteProducts.preserves α).preservesLimit

instance {X : C} (S : Presieve X) [S.extensive]
    {F : Cᵒᵖ ⥤ Type max u v} [PreservesFiniteProducts F] : IsIso (Equalizer.forkMap F S) := by
  obtain ⟨α, _, Z, π, hS, _⟩ := Presieve.extensive.arrows_sigma_desc_iso (R := S)
  subst hS
  refine' ⟨firstObj_to_base π F,_,_⟩
  · simp only [firstObj_to_base, ← Category.assoc, Functor.map_inv,
      IsIso.comp_inv_eq, Category.id_comp, ← Functor.mapIso_inv, Iso.comp_inv_eq,
      Functor.mapIso_hom, Iso.comp_inv_eq, ← Functor.map_comp,
      desc_op_comp_opCoproductIsoProduct_hom, PreservesProduct.iso_hom, map_lift_piComparison,
      colimit.ι_desc, Cofan.mk_pt, Cofan.mk_ι_app]
    funext s
    ext a
    simp only [prod_map, types_comp_apply, types_id_apply, Types.Limit.lift_π_apply,
      Fan.mk_pt, Equalizer.forkMap, Fan.mk_π_app, Types.pi_lift_π_apply]
  · refine Limits.Pi.hom_ext _ _ (fun f => ?_)
    simp only [Equalizer.forkMap, Category.assoc, limit.lift_π, Fan.mk_pt, Fan.mk_π_app,
      Category.id_comp]
    obtain ⟨a, ha⟩ := sigma_surjective π f
    rw [firstObj_to_base, Category.assoc, Category.assoc, Category.assoc, ← Functor.map_comp,
      ← op_inv, ← op_comp, ← ha, comp_inv_desc_eq_ι, ← Functor.map_comp,
      opCoproductIsoProduct_inv_comp_ι, PreservesProduct.isoInvCompMap F a]
    simp only [prod_map, Category.comp_id, limit.lift_π, Fan.mk_pt, Fan.mk_π_app]

end ExtensiveSheafConditionProof

open ExtensiveSheafConditionProof in
lemma isSheafFor_extensive_of_preservesFiniteProducts {X : C} (S : Presieve X) [S.extensive]
    (F : Cᵒᵖ ⥤ Type max u v) [PreservesFiniteProducts F] :
    Presieve.IsSheafFor F S := by
  refine' (Equalizer.Presieve.sheaf_condition F S).2 _
  rw [Limits.Types.type_equalizer_iff_unique]
  dsimp [Equalizer.FirstObj]
  suffices : IsIso (Equalizer.forkMap F S)
  · intro y _
    refine' ⟨inv (Equalizer.forkMap F S) y, _, fun y₁ hy₁ => _⟩
    · change (inv (Equalizer.forkMap F S) ≫ (Equalizer.forkMap F S)) y = y
      rw [IsIso.inv_hom_id, types_id_apply]
    · replace hy₁ := congr_arg (inv (Equalizer.forkMap F S)) hy₁
      change ((Equalizer.forkMap F S) ≫ inv (Equalizer.forkMap F S)) _ = _ at hy₁
      rwa [IsIso.hom_inv_id, types_id_apply] at hy₁
  infer_instance

end ExtensiveSheaves

end CategoryTheory
