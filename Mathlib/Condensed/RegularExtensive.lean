/-
Copyright (c) 2023 Dagur Asgeirsson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Dagur Asgeirsson, Filippo A. E. Nuccio, Riccardo Brasca
-/
import Mathlib.CategoryTheory.Limits.Preserves.Finite
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Products
import Mathlib.CategoryTheory.Preadditive.Projective
import Mathlib.CategoryTheory.Sites.RegularExtensive
/-!
# The Regular and Extensive Coverages
This file defines two coverages on a category `C`.
The first one is called the *regular* coverage and for that to exist, the category `C` must satisfy
a condition called `Preregular C`. This means that effective epimorphisms can be "pulled back". The
covering sieves of this coverage are generated by presieves consisting of a single effective
epimorphism.
The second one is called the *extensive* coverage and for that to exist, the category `C` must
satisfy a condition called `Extensive C`. This means `C` has finite coproducts and that those
are preserved by pullbacks. The covering sieves of this coverage are generated by presieves
consisting finitely many arrows that together induce an isomorphism from the coproduct to the
target.
In `extensive_union_regular_generates_coherent`, we prove that the union of these two coverages
generates the coherent topology on `C` if `C` is precoherent, extensive and regular.
TODO: figure out under what conditions `Preregular` and `Extensive` are implied by `Precoherent` and
vice versa.
-/

universe v u w

namespace CategoryTheory

open Limits

variable (C : Type u) [Category.{v} C]

variable {C}

/-- The union of the extensive and regular coverages generates the coherent topology on `C`. -/
lemma extensive_regular_generate_coherent [Preregular C] [Extensive C] [Precoherent C] :
    ((extensiveCoverage C) ‚äî (regularCoverage C)).toGrothendieck =
    (coherentTopology C) := by
  ext B S
  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
  ¬∑ induction h with
    | of Y T hT =>
      apply Coverage.saturate.of
      simp only [Coverage.sup_covering, Set.mem_union] at hT
      exact Or.elim hT
        (fun ‚ü®Œ±, x, X, œÄ, ‚ü®h, _‚ü©‚ü© ‚Ü¶ ‚ü®Œ±, x, X, œÄ, ‚ü®h, inferInstance‚ü©‚ü©)
        (fun ‚ü®Z, f, ‚ü®h, _‚ü©‚ü© ‚Ü¶ ‚ü®Unit, inferInstance, fun _ ‚Ü¶ Z, fun _ ‚Ü¶ f, ‚ü®h, inferInstance‚ü©‚ü©)
    | top => apply Coverage.saturate.top
    | transitive Y T => apply Coverage.saturate.transitive Y T<;> [assumption; assumption]
  ¬∑ induction h with
    | of Y T hT =>
      obtain ‚ü®I, hI, X, f, ‚ü®h, hT‚ü©‚ü© := hT
      let œÜ := fun (i : I) ‚Ü¶ Sigma.Œπ X i
      let F := Sigma.desc f
      let Z := Sieve.generate T
      let Xs := (‚àê fun (i : I) => X i)
      let Zf := Sieve.generate (Presieve.ofArrows (fun (_ : Unit) ‚Ü¶ Xs) (fun (_ : Unit) ‚Ü¶ F))
      apply Coverage.saturate.transitive Y Zf
      ¬∑ apply Coverage.saturate.of
        simp only [Coverage.sup_covering, extensiveCoverage, regularCoverage, Set.mem_union,
          Set.mem_setOf_eq]
        exact Or.inr ‚ü®Xs, F, ‚ü®rfl, inferInstance‚ü©‚ü©
      ¬∑ intro R g hZfg
        dsimp at hZfg
        rw [Presieve.ofArrows_pUnit] at hZfg
        obtain ‚ü®W, œà, œÉ, ‚ü®hW, hW'‚ü©‚ü© := hZfg
        induction hW
        rw [‚Üê hW', Sieve.pullback_comp Z]
        suffices Sieve.pullback œà ((Sieve.pullback F) Z) ‚àà GrothendieckTopology.sieves
          ((extensiveCoverage C) ‚äî (regularCoverage C)).toGrothendieck R by assumption
        apply GrothendieckTopology.pullback_stable'
        suffices Coverage.saturate ((extensiveCoverage C) ‚äî (regularCoverage C)) Xs
          (Z.pullback F) by assumption
        suffices : Sieve.generate (Presieve.ofArrows X œÜ) ‚â§ Z.pullback F
        ¬∑ apply Coverage.saturate_of_superset _ this
          apply Coverage.saturate.of
          simp only [Coverage.sup_covering, extensiveCoverage, regularCoverage, Set.mem_union,
            Set.mem_setOf_eq]
          refine Or.inl ‚ü®I, hI, X, œÜ, ‚ü®rfl, ?_‚ü©‚ü©
          suffices Sigma.desc œÜ = ùüô _ by rw [this]; infer_instance
          ext
          simp only [colimit.Œπ_desc, Cofan.mk_pt, Cofan.mk_Œπ_app, Category.comp_id]
        intro Q q hq
        simp only [Sieve.pullback_apply, Sieve.generate_apply]
        simp only [Sieve.generate_apply] at hq
        obtain ‚ü®E, e, r, hq‚ü© := hq
        refine' ‚ü®E, e, r ‚â´ F, ‚ü®_, _‚ü©‚ü©
        ¬∑ rw [h]
          induction hq.1
          simp only [colimit.Œπ_desc, Cofan.mk_pt, Cofan.mk_Œπ_app]
          exact Presieve.ofArrows.mk _
        ¬∑ rw [‚Üê hq.2]
          simp only [Category.assoc]
    | top => apply Coverage.saturate.top
    | transitive Y T => apply Coverage.saturate.transitive Y T<;> [assumption; assumption]

section ExtensiveSheaves

variable [Extensive C]

/-- A presieve is *extensive* if it is finite and its arrows induce an isomorphism from the
coproduct to the target. -/
class _root_.CategoryTheory.Presieve.extensive [HasFiniteCoproducts C] {X : C} (R : Presieve X) :
    Prop where
  /-- `R` consists of a finite collection of arrows that together induce an isomorphism from the
  coproduct of their sources. -/
  arrows_sigma_desc_iso : ‚àÉ (Œ± : Type) (_ : Fintype Œ±) (Z : Œ± ‚Üí C) (œÄ : (a : Œ±) ‚Üí (Z a ‚ü∂ X)),
    R = Presieve.ofArrows Z œÄ ‚àß IsIso (Sigma.desc œÄ)

instance {X : C} (S : Presieve X) [S.extensive] : S.hasPullbacks where
  has_pullbacks := by
    obtain ‚ü®_, _, _, _, hS, _‚ü© := Presieve.extensive.arrows_sigma_desc_iso (R := S)
    intro _ _ f hf _ hg
    rw [hS] at hf hg
    cases' hg with b
    apply HasPullbacksOfInclusions.has_pullback f

namespace ExtensiveSheafConditionProof

lemma sigma_surjective {Œ± : Type} {Z : Œ± ‚Üí C} {X : C} (œÄ : (a : Œ±) ‚Üí Z a ‚ü∂ X) :
    Function.Surjective (fun a => ‚ü®Z a, œÄ a, Presieve.ofArrows.mk a‚ü© :
    Œ± ‚Üí Œ£(Y : C), { f : Y ‚ü∂ X // Presieve.ofArrows Z œÄ f }) :=
  fun ‚ü®_, ‚ü®_, hf‚ü©‚ü© ‚Ü¶ by cases' hf with a _; exact ‚ü®a, rfl‚ü©

open Opposite

instance {Œ± : Type} {Z : Œ± ‚Üí C} {X : C} {œÄ : (a : Œ±) ‚Üí Z a ‚ü∂ X} [Fintype Œ±] :
    HasProduct fun (x : Œ£(Y : C), { f : Y ‚ü∂ X // Presieve.ofArrows Z œÄ f }) ‚Ü¶ (op x.1) :=
  haveI := Finite.of_surjective _ (sigma_surjective œÄ)
  inferInstance

/-- The canonical map from `Equalizer.FirstObj` to a product indexed by `Œ±` -/
noncomputable
def prod_map {Œ± : Type} {Z : Œ± ‚Üí C} {X : C} (œÄ : (a : Œ±) ‚Üí Z a ‚ü∂ X) (F : C·µí·µñ ‚•§ Type max u v) :
    (‚àè fun (f : (Œ£(Y : C), { f : Y ‚ü∂ X // Presieve.ofArrows Z œÄ f })) => F.obj (op f.fst)) ‚ü∂
    ‚àè fun a => F.obj (op (Z a)) :=
  Pi.lift (fun a => Pi.œÄ _ ‚ü®Z a, œÄ a, Presieve.ofArrows.mk a‚ü©) ‚â´ ùüô _

/-- The inverse to `Equalizer.forkMap F (Presieve.ofArrows Z œÄ)`. -/
noncomputable
def firstObj_to_base {Œ± : Type} [Fintype Œ±] {Z : Œ± ‚Üí C} {X : C} (œÄ : (a : Œ±) ‚Üí Z a ‚ü∂ X)
  (F : C·µí·µñ ‚•§ Type max u v) [PreservesFiniteProducts F] [IsIso (Sigma.desc œÄ)] :
    Equalizer.FirstObj F (Presieve.ofArrows Z œÄ) ‚ü∂ F.obj (op X) :=
  haveI : PreservesLimit (Discrete.functor fun a => op (Z a)) F :=
    (PreservesFiniteProducts.preserves Œ±).preservesLimit
  (prod_map œÄ F) ‚â´ ((Limits.PreservesProduct.iso F (fun a => op <| Z a)).inv ‚â´
    F.map (opCoproductIsoProduct Z).inv ‚â´ F.map (inv (Sigma.desc œÄ).op))

lemma comp_inv_desc_eq_Œπ {Œ± : Type} [Fintype Œ±] {Z : Œ± ‚Üí C} {X : C} (œÄ : (a : Œ±) ‚Üí Z a ‚ü∂ X)
    [IsIso (Sigma.desc œÄ)] (a : Œ±) : œÄ a ‚â´ inv (Sigma.desc œÄ) = Sigma.Œπ _ a := by
  simp only [IsIso.comp_inv_eq, colimit.Œπ_desc, Cofan.mk_pt, Cofan.mk_Œπ_app]

@[simp]
lemma PreservesProduct.isoInvCompMap {C : Type u} [Category C] {D : Type v} [Category D] (F : C ‚•§ D)
    {J : Type w} {f : J ‚Üí C} [HasProduct f] [HasProduct (fun j => F.obj (f j))]
    [PreservesLimit (Discrete.functor f) F] (j : J) :
    (PreservesProduct.iso F f).inv ‚â´ F.map (Pi.œÄ _ j) = Pi.œÄ _ j :=
  IsLimit.conePointUniqueUpToIso_inv_comp _ (limit.isLimit _) (‚ü®j‚ü© : Discrete J)

instance {Œ± : Type} [Fintype Œ±] {Z : Œ± ‚Üí C} {F : C ‚•§ Type w}
    [PreservesFiniteProducts F] : PreservesLimit (Discrete.functor fun a => (Z a)) F :=
  (PreservesFiniteProducts.preserves Œ±).preservesLimit

instance {X : C} (S : Presieve X) [S.extensive]
    {F : C·µí·µñ ‚•§ Type max u v} [PreservesFiniteProducts F] : IsIso (Equalizer.forkMap F S) := by
  obtain ‚ü®Œ±, _, Z, œÄ, hS, _‚ü© := Presieve.extensive.arrows_sigma_desc_iso (R := S)
  subst hS
  refine' ‚ü®firstObj_to_base œÄ F,_,_‚ü©
  ¬∑ simp only [firstObj_to_base, ‚Üê Category.assoc, Functor.map_inv,
      IsIso.comp_inv_eq, Category.id_comp, ‚Üê Functor.mapIso_inv, Iso.comp_inv_eq,
      Functor.mapIso_hom, Iso.comp_inv_eq, ‚Üê Functor.map_comp,
      desc_op_comp_opCoproductIsoProduct_hom, PreservesProduct.iso_hom, map_lift_piComparison,
      colimit.Œπ_desc, Cofan.mk_pt, Cofan.mk_Œπ_app]
    funext s
    ext a
    simp only [prod_map, types_comp_apply, types_id_apply, Types.Limit.lift_œÄ_apply,
      Fan.mk_pt, Equalizer.forkMap, Fan.mk_œÄ_app, Types.pi_lift_œÄ_apply]
  ¬∑ refine Limits.Pi.hom_ext _ _ (fun f => ?_)
    simp only [Equalizer.forkMap, Category.assoc, limit.lift_œÄ, Fan.mk_pt, Fan.mk_œÄ_app,
      Category.id_comp]
    obtain ‚ü®a, ha‚ü© := sigma_surjective œÄ f
    rw [firstObj_to_base, Category.assoc, Category.assoc, Category.assoc, ‚Üê Functor.map_comp,
      ‚Üê op_inv, ‚Üê op_comp, ‚Üê ha, comp_inv_desc_eq_Œπ, ‚Üê Functor.map_comp,
      opCoproductIsoProduct_inv_comp_Œπ, PreservesProduct.isoInvCompMap F a]
    simp only [prod_map, Category.comp_id, limit.lift_œÄ, Fan.mk_pt, Fan.mk_œÄ_app]

end ExtensiveSheafConditionProof

open ExtensiveSheafConditionProof in
lemma isSheafFor_extensive_of_preservesFiniteProducts {X : C} (S : Presieve X) [S.extensive]
    (F : C·µí·µñ ‚•§ Type max u v) [PreservesFiniteProducts F] :
    Presieve.IsSheafFor F S := by
  refine' (Equalizer.Presieve.sheaf_condition F S).2 _
  rw [Limits.Types.type_equalizer_iff_unique]
  dsimp [Equalizer.FirstObj]
  suffices : IsIso (Equalizer.forkMap F S)
  ¬∑ intro y _
    refine' ‚ü®inv (Equalizer.forkMap F S) y, _, fun y‚ÇÅ hy‚ÇÅ => _‚ü©
    ¬∑ change (inv (Equalizer.forkMap F S) ‚â´ (Equalizer.forkMap F S)) y = y
      rw [IsIso.inv_hom_id, types_id_apply]
    ¬∑ replace hy‚ÇÅ := congr_arg (inv (Equalizer.forkMap F S)) hy‚ÇÅ
      change ((Equalizer.forkMap F S) ‚â´ inv (Equalizer.forkMap F S)) _ = _ at hy‚ÇÅ
      rwa [IsIso.hom_inv_id, types_id_apply] at hy‚ÇÅ
  infer_instance

end ExtensiveSheaves

section RegularSheaves

open Opposite

/-- A presieve is *regular* if it consists of a single effective epimorphism. -/
class _root_.CategoryTheory.Presieve.regular {X : C} (R : Presieve X) : Prop where
  /-- `R` consists of a single epimorphism. -/
  single_epi : ‚àÉ (Y : C) (f : Y ‚ü∂ X), R = Presieve.ofArrows (fun (_ : Unit) ‚Ü¶ Y)
    (fun (_ : Unit) ‚Ü¶ f) ‚àß EffectiveEpi f

def MapToEqualizer (P : C·µí·µñ ‚•§ Type (max u v)) {W X B : C} (f : X ‚ü∂ B)
    (g‚ÇÅ g‚ÇÇ : W ‚ü∂ X) (w : g‚ÇÅ ‚â´ f = g‚ÇÇ ‚â´ f) :
    P.obj (op B) ‚Üí { x : P.obj (op X) | P.map g‚ÇÅ.op x = P.map g‚ÇÇ.op x } :=
  fun t ‚Ü¶ ‚ü®P.map f.op t, by
    change (P.map _ ‚â´ P.map _) _ = (P.map _ ‚â´ P.map _) _ ;
    simp_rw [‚Üê P.map_comp, ‚Üê op_comp, w] ‚ü©

def EqualizerCondition (P : C·µí·µñ ‚•§ Type (max u v)) : Prop :=
  ‚àÄ (X B : C) (œÄ : X ‚ü∂ B) [EffectiveEpi œÄ] [HasPullback œÄ œÄ], Function.Bijective
    (MapToEqualizer P œÄ (pullback.fst (f := œÄ) (g := œÄ)) (pullback.snd (f := œÄ) (g := œÄ))
    pullback.condition)

noncomputable
def EqualizerFirstObjIso (F : C·µí·µñ ‚•§ Type (max u v)) {B X : C} (œÄ : X ‚ü∂ B)
     : Equalizer.FirstObj F (Presieve.singleton œÄ) ‚âÖ F.obj (op X) :=
  CategoryTheory.Equalizer.firstObjEqFamily F (Presieve.singleton œÄ) ‚â™‚â´
  { hom := fun e ‚Ü¶ e œÄ (Presieve.singleton_self œÄ)
    inv := fun e _ _ h ‚Ü¶ by
      induction h with
      | mk => exact e
    hom_inv_id := by
      funext _ _ _ h
      induction h with
      | mk => rfl
    inv_hom_id := by aesop }

instance {B X : C} (œÄ : X ‚ü∂ B) [EffectiveEpi œÄ] [HasPullback œÄ œÄ] :
    (Presieve.singleton œÄ).hasPullbacks where
  has_pullbacks hf _ hg := by
    cases hf
    cases hg
    infer_instance

noncomputable
def EqualizerSecondObjIso (F : C·µí·µñ ‚•§ Type (max u v)) {B X : C} (œÄ : X ‚ü∂ B) [EffectiveEpi œÄ]
    [HasPullback œÄ œÄ] :
    Equalizer.Presieve.SecondObj F (Presieve.singleton œÄ) ‚âÖ F.obj (op (Limits.pullback œÄ œÄ)) :=
  Types.productIso.{max u v, max u v} _ ‚â™‚â´
  { hom := fun e ‚Ü¶ e (‚ü®X, ‚ü®œÄ, Presieve.singleton_self œÄ‚ü©‚ü©, ‚ü®X, ‚ü®œÄ, Presieve.singleton_self œÄ‚ü©‚ü©)
    inv := fun x ‚ü®‚ü®_, ‚ü®_, h‚ÇÅ‚ü©‚ü© , ‚ü®_, ‚ü®_, h‚ÇÇ‚ü©‚ü©‚ü© ‚Ü¶ by
      induction h‚ÇÅ
      induction h‚ÇÇ
      exact x
    hom_inv_id := by
      funext _ ‚ü®‚ü®_, ‚ü®_, h‚ÇÅ‚ü©‚ü© , ‚ü®_, ‚ü®_, h‚ÇÇ‚ü©‚ü©‚ü©
      induction h‚ÇÅ
      induction h‚ÇÇ
      rfl
    inv_hom_id := by aesop }

lemma isSheafFor_regular_of_hasPullbacks {B : C} {S : Presieve B} [S.regular] [S.hasPullbacks]
     {F : C·µí·µñ ‚•§ Type (max u v)}
    (hFecs : EqualizerCondition F) : S.IsSheafFor F := by
  obtain ‚ü®X, œÄ, ‚ü®hS, œÄsurj‚ü©‚ü© := Presieve.regular.single_epi (R := S)
  rw [Presieve.ofArrows_pUnit] at hS
  haveI hh : (Presieve.singleton œÄ).hasPullbacks := by rw [‚Üê hS]; infer_instance
  haveI : HasPullback œÄ œÄ := hh.has_pullbacks (Presieve.singleton.mk) (Presieve.singleton.mk)
  subst hS
  rw [Equalizer.Presieve.sheaf_condition, Limits.Types.type_equalizer_iff_unique]
  intro y h
  specialize hFecs X B œÄ
  have fork_comp : Equalizer.forkMap F (Presieve.singleton œÄ) ‚â´ (EqualizerFirstObjIso F œÄ).hom =
      F.map œÄ.op
  ¬∑ dsimp [EqualizerFirstObjIso, Equalizer.forkMap]
    ext b
    simp only [types_comp_apply, Equalizer.firstObjEqFamily_hom, Types.pi_lift_œÄ_apply]
  have fmap_comp : (EqualizerFirstObjIso F œÄ).hom ‚â´ F.map (pullback.fst (f := œÄ) (g := œÄ)).op =
      Equalizer.Presieve.firstMap F (Presieve.singleton œÄ) ‚â´ (EqualizerSecondObjIso F œÄ).hom
  ¬∑ dsimp [EqualizerSecondObjIso, EqualizerFirstObjIso, Equalizer.Presieve.firstMap]
    ext b
    simp only [types_comp_apply, Equalizer.firstObjEqFamily_hom, Types.pi_lift_œÄ_apply]
  have smap_comp : (EqualizerFirstObjIso F œÄ).hom ‚â´ F.map (pullback.snd (f := œÄ) (g := œÄ)).op =
      Equalizer.Presieve.secondMap F (Presieve.singleton œÄ) ‚â´ (EqualizerSecondObjIso F œÄ).hom
  ¬∑ dsimp [EqualizerSecondObjIso, EqualizerFirstObjIso, Equalizer.Presieve.secondMap]
    ext b
    simp only [types_comp_apply, Equalizer.firstObjEqFamily_hom, Types.pi_lift_œÄ_apply]
  have iy_mem : F.map (pullback.fst (f := œÄ) (g := œÄ)).op ((EqualizerFirstObjIso F œÄ).hom y) =
      F.map (pullback.snd (f := œÄ) (g := œÄ)).op ((EqualizerFirstObjIso F œÄ).hom y)
  ¬∑ change ((EqualizerFirstObjIso F œÄ).hom ‚â´ _) y = _
    apply Eq.symm -- how do I avoid this ugly hack?
    change ((EqualizerFirstObjIso F œÄ).hom ‚â´ _) y = _
    rw [fmap_comp, smap_comp]
    dsimp
    rw [h]
  have uniq_F : ‚àÉ! x, F.map œÄ.op x = (EqualizerFirstObjIso F œÄ).hom y
  ¬∑ rw [Function.bijective_iff_existsUnique] at hFecs
    specialize hFecs ‚ü®(EqualizerFirstObjIso F œÄ).hom y, iy_mem‚ü©
    obtain ‚ü®x, hx‚ü© := hFecs
    refine' ‚ü®x, _‚ü©
    dsimp [MapToEqualizer] at *
    refine' ‚ü®Subtype.ext_iff.mp hx.1,_‚ü©
    intro z hz
    apply hx.2
    rwa [Subtype.ext_iff]
  obtain ‚ü®x,hx‚ü© := uniq_F
  dsimp at hx
  rw [‚Üê fork_comp] at hx
  use x
  dsimp
  constructor
  ¬∑ apply_fun (EqualizerFirstObjIso F œÄ).hom
    ¬∑ exact hx.1
    ¬∑ apply Function.Bijective.injective
      rw [‚Üê isIso_iff_bijective]
      exact inferInstance
  ¬∑ intro z hz
    apply_fun (EqualizerFirstObjIso F œÄ).hom at hz
    exact hx.2 z hz

lemma isSheafFor_regular_of_projective {X : C} (S : Presieve X) [S.regular] [Projective X]
    (F : C·µí·µñ ‚•§ Type (max u v)) : S.IsSheafFor F := by
  obtain ‚ü®Y, f, rfl, hf‚ü© := Presieve.regular.single_epi (R := S)
  let g := Projective.factorThru (ùüô _) f
  have hfg : g ‚â´ f = ùüô _ := by
    simp only [Projective.factorThru_comp]
  intro y hy
  refine' ‚ü®F.map g.op <| y f <| Presieve.ofArrows.mk (), fun Z h hZ => _, fun z hz => _‚ü©
  ¬∑ cases' hZ with u
    have := hy (f‚ÇÅ := f) (f‚ÇÇ := f) (ùüô Y) (f ‚â´ g) (Presieve.ofArrows.mk ())
        (Presieve.ofArrows.mk ()) ?_
    ¬∑ rw [op_id, F.map_id, types_id_apply] at this
      rw [‚Üê types_comp_apply (F.map g.op) (F.map f.op), ‚Üê F.map_comp, ‚Üê op_comp]
      exact this.symm
    ¬∑ rw [Category.id_comp, Category.assoc, hfg, Category.comp_id]
  ¬∑ have := congr_arg (F.map g.op) <| hz f (Presieve.ofArrows.mk ())
    rwa [‚Üê types_comp_apply (F.map f.op) (F.map g.op), ‚Üê F.map_comp, ‚Üê op_comp, hfg, op_id,
      F.map_id, types_id_apply] at this

end RegularSheaves

end CategoryTheory
