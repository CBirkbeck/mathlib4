/-
Copyright (c) 2024 Michael Rothgang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Michael Rothgang
-/
import Mathlib.Geometry.Manifold.Diffeomorph
import Mathlib.Geometry.Manifold.Instances.Real
import Mathlib.Geometry.Manifold.Instances.Sphere
import Mathlib.Geometry.Manifold.InteriorBoundary

/-!
# Unoriented bordism theory

In this file, we sketch the beginnings of unoriented bordism theory.
Not all of this might end up in mathlib already (depending on how many pre-requisites are missing),
but a fair number of pieces already can be upstreamed!

-/

/-
Missing API for this to work nicely:
- add disjoint union of top. spaces and induced maps: mathlib has this
- define the disjoint union of smooth manifolds, and the associated maps: show they are smooth
(perhaps prove as abstract nonsense? will see!)

- then: complete definition of unoriented cobordisms; complete constructions I had
- fight DTT hell: why is the product with an interval not recognised?

- define the bordism relation/how to define the set of equivalence classes?
equivalences work nicely in the standard design... that's a "how to do X in Lean" question
- postponed: transitivity of the bordism relation (uses the collar neighbourhood theorem)

- define induced maps between bordism groups (on singular n-manifolds is easy and done)
- functoriality: what exactly do I have to show? also DTT question

- prove some of the easy axioms of homology... perhaps all of it?
- does mathlib have a class "extraordinary homology theory"? this could be an interesting instance...
-/

open scoped Manifold
open Metric (sphere)
open FiniteDimensional Set

noncomputable section

-- Pre-requisite: the interval `Icc x y has boundary {x, y}`, and related results.
-- TODO: move to `Instances/Real`
section BoundaryIntervals

variable {x y : ‚Ñù} [hxy : Fact (x < y)]

variable {E H M : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [TopologicalSpace H]
  [TopologicalSpace M] [ChartedSpace H M] {I : ModelWithCorners ‚Ñù E H}
  [BoundarylessManifold I M]

/-- A product `M √ó [x,y]` has boundary `M √ó {x,y}`. -/
lemma boundary_product : (I.prod (ùì°‚àÇ 1)).boundary (M √ó Icc x y) = Set.prod univ {X, Y} := by
  have : (ùì°‚àÇ 1).boundary (Icc x y) = {X, Y} := by rw [boundary_IccManifold]
  rw [I.boundary_of_boundaryless_left]
  rw [this]

end BoundaryIntervals

-- Let M, M' and W be smooth manifolds.
variable {E E' E'' E''' H H' H'' H''' : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]
  [NormedAddCommGroup E'] [NormedSpace ‚Ñù E'] [NormedAddCommGroup E'']  [NormedSpace ‚Ñù E'']
  [NormedAddCommGroup E'''] [NormedSpace ‚Ñù E''']
  [TopologicalSpace H] [TopologicalSpace H'] [TopologicalSpace H''] [TopologicalSpace H''']

variable {X Y Z : Type*} [TopologicalSpace X] [TopologicalSpace Y] [TopologicalSpace Z]

/-- A **singular `n`-manifold** on a topological space `X` consists of a
closed smooth `n`-manifold `M` and a continuous map `f : M ‚Üí X`. -/
structure SingularNManifold (X : Type*) [TopologicalSpace X] (n : ‚Ñï)
    (M : Type*) [TopologicalSpace M] [ChartedSpace H M]
    (I : ModelWithCorners ‚Ñù E H) [SmoothManifoldWithCorners I M]
    [CompactSpace M] [BoundarylessManifold I M] [FiniteDimensional ‚Ñù E] where
  [hdim : Fact (finrank ‚Ñù E = n)]
  /-- The underlying map `M ‚Üí X` of a singular `n`-manifold `(M,f)` on `X` -/
  f : M ‚Üí X
  hf : Continuous f

namespace SingularNManifold

-- We declare these variables *after* the definition above, so `SingularNManifold` can have
-- its current order of arguments.
variable {M : Type*} [TopologicalSpace M] [ChartedSpace H M]
  {I : ModelWithCorners ‚Ñù E H} [SmoothManifoldWithCorners I M]
  {M' : Type*} [TopologicalSpace M'] [ChartedSpace H' M']
  {I' : ModelWithCorners ‚Ñù E' H'} [SmoothManifoldWithCorners I' M'] {n : ‚Ñï}
  [BoundarylessManifold I M] [CompactSpace M] [FiniteDimensional ‚Ñù E]
  [BoundarylessManifold I' M'] [CompactSpace M'] [FiniteDimensional ‚Ñù E']

/-- If `M` is `n`-dimensional and closed, it is a singular `n`-manifold over itself. -/
noncomputable def refl (hdim : finrank ‚Ñù E = n) : SingularNManifold M n M I where
  hdim := Fact.mk hdim
  f := id
  hf := continuous_id

/-- A map of topological spaces induces a corresponding map of singular n-manifolds. -/
-- This is part of proving functoriality of the bordism groups.
noncomputable def map [Fact (finrank ‚Ñù E = n)] (s : SingularNManifold X n M I)
    {œÜ : X ‚Üí Y} (hœÜ : Continuous œÜ) : SingularNManifold Y n M I where
  f := œÜ ‚àò s.f
  hf := hœÜ.comp s.hf

@[simp]
lemma map_f [Fact (finrank ‚Ñù E = n)]
    (s : SingularNManifold X n M I) {œÜ : X ‚Üí Y} (hœÜ : Continuous œÜ) : (s.map hœÜ).f = œÜ ‚àò s.f :=
  rfl

/-- If `(M', f)` is a singular `n`-manifold on `X` and `M'` another `n`-dimensional smooth manifold,
a smooth map `œÜ : M ‚Üí M'` induces a singular `n`-manifold structore on `M`. -/
noncomputable def comap [Fact (finrank ‚Ñù E = n)] [Fact (finrank ‚Ñù E' = n)]
    (s : SingularNManifold X n M' I')
    {œÜ : M ‚Üí M'} (hœÜ : Smooth I I' œÜ) : SingularNManifold X n M I where
  f := s.f ‚àò œÜ
  hf := s.hf.comp hœÜ.continuous

@[simp]
lemma comap_f [Fact (finrank ‚Ñù E = n)] [Fact (finrank ‚Ñù E' = n)] (s : SingularNManifold X n M' I')
    {œÜ : M ‚Üí M'} (hœÜ : Smooth I I' œÜ) : (s.comap hœÜ).f = s.f ‚àò œÜ :=
  rfl

/-- The canonical singular `n`-manifold associated to the empty set (seen as an `n`-dimensional
manifold, i.e. modelled on an `n`-dimensional space). -/
def empty [Fact (finrank ‚Ñù E = n)] [IsEmpty M] : SingularNManifold X n M I where
  f := fun x ‚Ü¶ (IsEmpty.false x).elim
  hf := by
    rw [continuous_iff_continuousAt]
    exact fun x ‚Ü¶ (IsEmpty.false x).elim

/-- An `n`-dimensional manifold induces a singular `n`-manifold on the one-point space. -/
def trivial [Fact (finrank ‚Ñù E = n)] : SingularNManifold PUnit n M I where
  f := fun _ ‚Ü¶ PUnit.unit
  hf := continuous_const

/-- The product of a singular `n`- and a `m`-manifold into a one-point space
is a singular `n+m`-manifold. -/
-- FUTURE: prove that this observation inducess a commutative ring structure
-- on the unoriented bordism group `Œ©_n^O = Œ©_n^O(pt)`.
def prod {m n : ‚Ñï} [h : Fact (finrank ‚Ñù E = m)] [k : Fact (finrank ‚Ñù E' = n)] :
    SingularNManifold PUnit (m + n) (M √ó M') (I.prod I') where
  f := fun _ ‚Ü¶ PUnit.unit
  hf := continuous_const
  hdim := Fact.mk (by rw [finrank_prod, h.out, k.out])

end SingularNManifold

section HasNiceBoundary

/-- All data defining a smooth manifold structure on the boundary of a smooth manifold:
a charted space structure on the boundary, a model with corners and a smooth manifold structure.
This need not exist (say, if `M` has corners); if `M` has no boundary or boundary and no corners,
such a structure is in fact canonically induced.
(Proving this requires more advanced results than we currently have.)
-/
structure BoundaryManifoldData (M : Type*) [TopologicalSpace M] [ChartedSpace H M]
    (I : ModelWithCorners ‚Ñù E H) [SmoothManifoldWithCorners I M] where
  E' : Type*
  [normedAddCommGroup : NormedAddCommGroup E']
  [normedSpace : NormedSpace ‚Ñù E']
  H' : Type*
  [topologicalSpace : TopologicalSpace H']
  charts : ChartedSpace H' (I.boundary M)
  model : ModelWithCorners ‚Ñù E' H'
  smoothManifold : SmoothManifoldWithCorners model (I.boundary M)

variable {M : Type*} [TopologicalSpace M] [ChartedSpace H M]
  {I : ModelWithCorners ‚Ñù E H} [SmoothManifoldWithCorners I M]
  {N : Type*} [TopologicalSpace N] [ChartedSpace H' N]
  {J : ModelWithCorners ‚Ñù E' H'} [SmoothManifoldWithCorners J N]

instance (d : BoundaryManifoldData M I) : TopologicalSpace d.H' := d.topologicalSpace

instance (d : BoundaryManifoldData M I) : NormedAddCommGroup d.E' := d.normedAddCommGroup

instance (d : BoundaryManifoldData M I) : NormedSpace ‚Ñù d.E' := d.normedSpace

instance (d : BoundaryManifoldData M I) : ChartedSpace d.H' (I.boundary M) := d.charts

instance (d : BoundaryManifoldData M I) : SmoothManifoldWithCorners d.model (I.boundary M) :=
  d.smoothManifold

-- In general, constructing `BoundaryManifoldData` requires deep results: some cases and results
-- we can state already. Boundaryless manifolds have nice boundary, as do products.

/- n-dimensionality, however, requires a finite-dimensional model...
-- FIXME: is this the right design decision?
example {n : ‚Ñï} [FiniteDimensional ‚Ñù E] [IsEmpty M] : ClosedNManifold n M I where
  hdim := sorry -/

variable (M) in
/-- If `M` is boundaryless, its boundary manifold data is easy to construct. -/
def BoundaryManifoldData.of_boundaryless [BoundarylessManifold I M] : BoundaryManifoldData M I where
  E' := E
  H' := E
  charts := ChartedSpace.empty E (I.boundary M : Set M)
  model := modelWithCornersSelf ‚Ñù E
  smoothManifold := by
    -- as-is, this errors with "failed to synthesize ChartedSpace E ‚Üë(I.boundary M)" (which is fair)
    -- adding this line errors with "tactic 'apply' failed, failed to assign synthesized instance"
    --haveI := ChartedSpace.empty E (I.boundary M : Set M)
    sorry -- apply SmoothManifoldWithCorners.empty

-- another trivial case: modelWithCornersSelf on euclidean half space!

variable (M I) in
/-- If `M` is boundaryless and `N` has nice boundary, so does `M √ó N`. -/
def BoundaryManifoldData.prod_of_boundaryless_left [BoundarylessManifold I M]
    (bd : BoundaryManifoldData N J) : BoundaryManifoldData (M √ó N) (I.prod J) where
  E' := E √ó bd.E'
  H' := ModelProd H bd.H'
  charts := by
    haveI := bd.charts
    convert prodChartedSpace H M bd.H' (J.boundary N)
    -- TODO: convert between these... mathematically equivalent...
    -- ChartedSpace (ModelProd H bd.H') ‚Üë((I.prod J).boundary (M √ó N)) =
    --   ChartedSpace (ModelProd H bd.H') (M √ó ‚Üë(J.boundary N))
    sorry
  model := I.prod bd.model
  smoothManifold := by
    convert SmoothManifoldWithCorners.prod (I := I) (I' := bd.model) M (J.boundary N)
    -- same issue as above
    sorry

-- TODO: fix the details once I found a solution for the above
variable (N J) in
/-- If `M` has nice boundary and `N` is boundaryless, `M √ó N` has nice boundary. -/
def BoundaryManifoldData.prod_of_boundaryless_right (bd : BoundaryManifoldData M I)
    [BoundarylessManifold J N] : BoundaryManifoldData (M √ó N) (I.prod J) where
  E' := bd.E' √ó E'
  H' := ModelProd bd.H' H'
  charts := by
    haveI := bd.charts
    convert prodChartedSpace bd.H' (I.boundary M) H' N
    sorry -- same issue as above
  model := bd.model.prod J
  smoothManifold := sorry -- similar

/-- If `M` is modelled on finite-dimensional Euclidean half-space, it has nice boundary.
Proving this requires knowing homology groups of spheres (or similar). -/
def BoundaryManifoldData.of_Euclidean_halfSpace (n : ‚Ñï) [Zero (Fin n)]
    {M : Type*} [TopologicalSpace M] [ChartedSpace (EuclideanHalfSpace n) M]
    [SmoothManifoldWithCorners (ùì°‚àÇ n) M] : BoundaryManifoldData M (ùì°‚àÇ n) :=
  sorry

-- Another example: if E is a half-space in a Banach space, defined by a linear functional,
-- the boundary of B is also nice: this is proven in Roig-Dominguez' textbook

-- TODO: can/should this be HasNiceBoundary M I J instead?
/--  We say a smooth manifold `M` *has nice boundary* if its boundary (as a subspace)
is a smooth manifold such that the inclusion is smooth. (This condition is *not* automatic, for
instance manifolds with corners violate it, but it is satisfied in most cases of interest.

`HasNiceBoundary d` formalises this: the boundary of the manifold `M` modelled on `I`
has a charted space structure and model (included in `d`) which makes it a smooth manifold,
such that the inclusion `‚àÇM ‚Üí M` is smooth. -/
class HasNiceBoundary (bd : BoundaryManifoldData M I) where
  /-- The inclusion of `‚àÇM` into `M` is smooth w.r.t. `d`. -/
  smooth_inclusion : ContMDiff bd.model I 1 ((fun ‚ü®x, _‚ü© ‚Ü¶ x) : (I.boundary M) ‚Üí M)

/-- A manifold without boundary (trivially) has nice boundary. -/
instance [BoundarylessManifold I M] :
    HasNiceBoundary (BoundaryManifoldData.of_boundaryless (I := I) (M := M)) where
  smooth_inclusion :=
    have : I.boundary M = ‚àÖ := ModelWithCorners.Boundaryless.boundary_eq_empty I
    fun p ‚Ü¶ False.elim (IsEmpty.false p)

/-- If `M` has nice boundary and `N` is boundaryless, `M √ó N` also has nice boundary. -/
instance (bd : BoundaryManifoldData M I) [h : HasNiceBoundary bd] [BoundarylessManifold J N] :
    HasNiceBoundary (BoundaryManifoldData.prod_of_boundaryless_right N J bd) where
  smooth_inclusion := by
    let bd'' := BoundaryManifoldData.prod_of_boundaryless_right N J bd
    let I'' := bd''.model
    have h : ContMDiff bd.model I 1 ((fun ‚ü®x, _‚ü© ‚Ü¶ x) : (I.boundary M) ‚Üí M) := h.smooth_inclusion
    have h' : ContMDiff J J 1 (fun x ‚Ü¶ x : N ‚Üí N) := contMDiff_id
    have : ContMDiff ((bd.model).prod J) (I.prod J) 1
        (fun (‚ü®x, _‚ü©, y) ‚Ü¶ (x, y) : (I.boundary M) √ó N ‚Üí M √ó N) := by
      -- TODO: how to apply prod with just two factors? let aux := ContMDiff.prod h h'
      sorry
    convert this
    -- xxx: add as API lemma, that bd''.model is what we think it is... simp only [bd''.model]
    -- TODO need to rewrite: boundary is the product of boundaries, f factors accordingly...
    sorry

/-- If `M` is boundaryless and `N` has nice boundary, `M √ó N` also has nice boundary. -/
instance (bd : BoundaryManifoldData N J) [HasNiceBoundary bd] [BoundarylessManifold I M] :
    HasNiceBoundary (BoundaryManifoldData.prod_of_boundaryless_left M I bd) where
  smooth_inclusion := sorry

end HasNiceBoundary

section DisjUnion

-- Let M, M' and M'' be smooth manifolds *over the same space* `H`.
-- TODO: need we also assume their models are literally the same? or on the same space E?
-- or can something weaker suffice?
variable {M : Type*} [TopologicalSpace M] [cm : ChartedSpace H M]
  {I : ModelWithCorners ‚Ñù E H} [SmoothManifoldWithCorners I M]
  {M' : Type*} [TopologicalSpace M'] [cm': ChartedSpace H M']
  /-{I' : ModelWithCorners ‚Ñù E H}-/ [SmoothManifoldWithCorners I M']
  {M'' : Type*} [TopologicalSpace M''] [ChartedSpace H M'']
  {I'' : ModelWithCorners ‚Ñù E H} [SmoothManifoldWithCorners I M'']

-- TODO: the construction below is bound to generalise... how far?
-- this should work: given an open subset U ‚äÜ M and a partial homeo U ‚Üí H, do I get one M ‚Üí H?
-- def PartialHomeomorph.extension {U : Set M} (hU : IsOpen U) (œÜ : PartialHomeomorph U H) :
--   PartialHomeomorph M H := by
--   refine ?e.disjointUnion ?e' ?Hs ?Ht
--   sorry

/-- Extend a partial homeomorphism from an open subset `U ‚äÜ M` to all of `M`. -/
-- experiment: does this work the same as foo?
def PartialHomeomorph.extend_subtype {U : Set M} [Nonempty H] (œÜ : PartialHomeomorph U H)
    (hU : IsOpen U) : PartialHomeomorph M H where
  toFun := Function.extend Subtype.val œÜ (Classical.arbitrary _)
  invFun := Subtype.val ‚àò œÜ.symm
  left_inv' := by
    rintro x ‚ü®x', hx', hx'eq‚ü©
    rw [‚Üê hx'eq, Subtype.val_injective.extend_apply]
    dsimp
    congr
    exact PartialHomeomorph.left_inv œÜ hx'
  right_inv' x hx := by
    rw [Function.comp, Subtype.val_injective.extend_apply]
    exact œÜ.right_inv' hx
  source := Subtype.val '' œÜ.source
  target := œÜ.target
  map_source' := by
    rintro x ‚ü®x', hx', hx'eq‚ü©
    rw [‚Üê hx'eq, Subtype.val_injective.extend_apply]
    apply œÜ.map_source hx'
  map_target' x hx := ‚ü®œÜ.symm x, œÜ.map_target' hx, rfl‚ü©
  open_source := (hU.openEmbedding_subtype_val.open_iff_image_open).mp œÜ.open_source
  open_target := œÜ.open_target
  -- TODO: missing lemma, want a stronger version of `continuous_sum_elim`;
  -- perhaps use `continuous_sup_dom` to prove
  continuousOn_toFun := by
    dsimp
    -- TODO: why is the extension continuous? mathematically, there's not much to fuss about,
    -- `source` is open, also within U, so we can locally argue with that...
    -- in practice, this seems very annoying!
    refine ContinuousAt.continuousOn ?hcont
    rintro x ‚ü®x', hx', hx'eq‚ü©
    have : ContinuousAt œÜ x' := sorry -- is x', not x
    apply ContinuousAt.congr
    ¬∑ sorry -- apply this--(œÜ.continuousOn_toFun).continuousAt (x := x') ?_
    sorry -- want to use toFun = œÜ on U...
    sorry
  continuousOn_invFun := sorry

/-- A partial homeomorphism `M ‚Üí H` defines a partial homeomorphism `M ‚äï M' ‚Üí H`. -/
def foo [h : Nonempty H] (œÜ : PartialHomeomorph M H) : PartialHomeomorph (M ‚äï M') H where
  -- TODO: this should be describable in terms of existing constructions!
  toFun := Sum.elim œÜ (Classical.arbitrary _)
  invFun := Sum.inl ‚àò œÜ.symm
  source := Sum.inl '' œÜ.source
  target := œÜ.target
  map_source' := by
    rintro x ‚ü®x', hx', hx'eq‚ü©
    rw [‚Üê hx'eq, Sum.elim_inl]
    apply œÜ.map_source hx'
  map_target' x hx := ‚ü®œÜ.symm x, œÜ.map_target' hx, rfl‚ü©
  left_inv' := by
    rintro x ‚ü®x', hx', hx'eq‚ü©
    rw [‚Üê hx'eq, Sum.elim_inl]
    dsimp
    congr
    exact PartialHomeomorph.left_inv œÜ hx'
  right_inv' x hx := by
    rw [Function.comp, Sum.elim_inl]
    exact œÜ.right_inv' hx
  open_source := (openEmbedding_inl.open_iff_image_open).mp œÜ.open_source
  open_target := œÜ.open_target
  -- TODO: missing lemma, want a stronger version of `continuous_sum_elim`;
  -- perhaps use `continuous_sup_dom` to prove
  continuousOn_toFun := sorry
  continuousOn_invFun := sorry

lemma foo_source [Nonempty H] (œÜ : PartialHomeomorph M H) :
    (foo œÜ (M' := M')).source = Sum.inl '' œÜ.source := rfl

/-- A partial homeomorphism `M' ‚Üí H` defines a partial homeomorphism `M ‚äï M' ‚Üí H`. -/
def bar [Nonempty H] (œÜ : PartialHomeomorph M' H) : PartialHomeomorph (M ‚äï M') H where
  toFun := Sum.elim (Classical.arbitrary _) œÜ
  invFun := Sum.inr ‚àò œÜ.symm
  left_inv' := by
    rintro x ‚ü®x', hx', hx'eq‚ü©
    rw [‚Üê hx'eq, Sum.elim_inr]
    dsimp
    congr
    exact PartialHomeomorph.left_inv œÜ hx'
  right_inv' x hx := by
    rw [Function.comp, Sum.elim_inr]
    exact œÜ.right_inv' hx
  source := Sum.inr '' œÜ.source
  target := œÜ.target
  map_source' := by
    rintro x ‚ü®x', hx', hx'eq‚ü©
    rw [‚Üê hx'eq, Sum.elim_inr]
    apply œÜ.map_source hx'
  map_target' x hx := ‚ü®œÜ.symm x, œÜ.map_target' hx, rfl‚ü©
  open_source := (openEmbedding_inr.open_iff_image_open).mp œÜ.open_source
  open_target := œÜ.open_target
  continuousOn_toFun := sorry
  continuousOn_invFun := sorry

lemma bar_source [Nonempty H] (œÜ : PartialHomeomorph M' H) :
    (bar œÜ (M := M)).source = Sum.inr '' œÜ.source := rfl

variable [Nonempty H] -- not sure if I really need this... will see

/-- The disjoint union of two charted spaces on `H` is a charted space over `H`. -/
instance ChartedSpace.sum : ChartedSpace H (M ‚äï M') where
  atlas := (foo '' cm.atlas) ‚à™ (bar '' cm'.atlas)
  -- At `x : M`, the chart is the chart in `M`; at `x' ‚àà M'`, it is the chart in `M'`.
  chartAt := Sum.elim (fun x ‚Ü¶ foo (cm.chartAt x)) (fun x ‚Ü¶ bar (cm'.chartAt x))
  mem_chart_source p := by
    by_cases h : Sum.isLeft p
    ¬∑ let x := Sum.getLeft p h
      rw [Sum.eq_left_getLeft_of_isLeft h]
      let aux := cm.mem_chart_source x
      dsimp
      rw [foo_source]
      use x
    ¬∑ have h' : Sum.isRight p := Sum.not_isLeft.mp h
      let x := Sum.getRight p h'
      rw [Sum.eq_right_getRight_of_isRight h']
      let aux := cm'.mem_chart_source x
      dsimp
      rw [bar_source]
      use x
  chart_mem_atlas p := by
    by_cases h : Sum.isLeft p
    ¬∑ let x := Sum.getLeft p h
      rw [Sum.eq_left_getLeft_of_isLeft h]
      dsimp
      left
      let aux := cm.chart_mem_atlas x
      use ChartedSpace.chartAt x
    ¬∑ have h' : Sum.isRight p := Sum.not_isLeft.mp h
      let x := Sum.getRight p h'
      rw [Sum.eq_right_getRight_of_isRight h']
      dsimp
      right
      let aux := cm'.chart_mem_atlas x
      use ChartedSpace.chartAt x

/-- The disjoint union of two smooth manifolds modelled on `(E,H)`
is a smooth manifold modeled on `(E, H)`. -/
-- XXX. do I really need the same model twice??
instance SmoothManifoldWithCorners.sum : SmoothManifoldWithCorners I (M ‚äï M') := sorry

/-- The inclusion `M ‚Üí M ‚äï M'` is smooth. -/
lemma ContMDiff.inl : ContMDiff I I ‚àû (M' := M ‚äï M') Sum.inl := sorry

/-- The inclusion `M' ‚Üí M ‚äï M'` is smooth. -/
lemma ContMDiff.inr : ContMDiff I I ‚àû (M' := M ‚äï M') Sum.inr := sorry

variable {N J : Type*} [TopologicalSpace N] [ChartedSpace H' N]
  {J : ModelWithCorners ‚Ñù E' H'} [SmoothManifoldWithCorners J N]
variable {N' : Type*} [TopologicalSpace N'] [ChartedSpace H' N'] [SmoothManifoldWithCorners J N']

lemma ContMDiff.sum_elim {f : M ‚Üí N} {g : M' ‚Üí N} (hf : Smooth I J f) (hg : Smooth I J g) :
    ContMDiff I J ‚àû (Sum.elim f g) := sorry

-- actually, want an iff version here...
lemma ContMDiff.sum_map [Nonempty H'] {f : M ‚Üí N} {g : M' ‚Üí N'} (hf : Smooth I J f) (hg : Smooth I J g) :
    ContMDiff I J ‚àû (Sum.map f g) := sorry

-- To what extent to these results exist abstractly?
def Sum.swapEquiv : M ‚äï M' ‚âÉ M' ‚äï M where
  toFun := Sum.swap
  invFun := Sum.swap
  left_inv := Sum.swap_leftInverse
  right_inv := Sum.swap_leftInverse

lemma Continuous.swap : Continuous (@Sum.swap M M') :=
  Continuous.sum_elim continuous_inr continuous_inl

def Homeomorph.swap : M ‚äï M' ‚âÉ‚Çú M' ‚äï M where
  toEquiv := Sum.swapEquiv
  continuous_toFun := Continuous.swap
  continuous_invFun := Continuous.swap

lemma ContMDiff.swap : ContMDiff I I ‚àû (@Sum.swap M M') := ContMDiff.sum_elim inr inl

variable (I M M') in -- TODO: argument order is weird!
def Diffeomorph.swap : Diffeomorph I I (M ‚äï M') (M' ‚äï M) ‚àû where
  toEquiv := Sum.swapEquiv
  contMDiff_toFun := ContMDiff.swap
  contMDiff_invFun := ContMDiff.swap

def Sum.assocLeft : M ‚äï (M' ‚äï N) ‚Üí (M ‚äï M') ‚äï N :=
  Sum.elim (fun x ‚Ü¶ Sum.inl (Sum.inl x)) (Sum.map Sum.inr id)

def Sum.assocRight : (M ‚äï M') ‚äï N ‚Üí M ‚äï (M' ‚äï N) :=
  Sum.elim (Sum.map id Sum.inl) (fun x ‚Ü¶ Sum.inr (Sum.inr x))

def Equiv.swapAssociativity : M ‚äï (M' ‚äï N) ‚âÉ (M ‚äï M') ‚äï N where
  toFun := Sum.assocLeft
  invFun := Sum.assocRight
  left_inv x := by aesop
  right_inv x := by aesop

-- FUTURE: can fun_prop be powered up to solve these automatically? also for differentiability?
def Homeomorph.associativity : M ‚äï (M' ‚äï N) ‚âÉ‚Çú (M ‚äï M') ‚äï N where
  toEquiv := Equiv.swapAssociativity
  continuous_toFun := by
    apply Continuous.sum_elim (by fun_prop)
    exact Continuous.sum_map continuous_inr continuous_id
  continuous_invFun := by
    apply Continuous.sum_elim (by fun_prop)
    exact Continuous.comp continuous_inr continuous_inr

variable (I M M') in
def Diffeomorph.associativity : Diffeomorph I I (M ‚äï (M' ‚äï M'')) ((M ‚äï M') ‚äï M'') ‚àû where
  toEquiv := Equiv.swapAssociativity
  contMDiff_toFun := by
    apply ContMDiff.sum_elim
    ¬∑ exact ContMDiff.comp ContMDiff.inl ContMDiff.inl -- xxx: can I power up fun_prop to do this?
    ¬∑ exact ContMDiff.sum_map ContMDiff.inr contMDiff_id
  contMDiff_invFun := by
    apply ContMDiff.sum_elim
    ¬∑ exact ContMDiff.sum_map contMDiff_id ContMDiff.inl
    ¬∑ exact ContMDiff.comp ContMDiff.inr ContMDiff.inr

def Equiv.sum_empty {Œ± Œ≤ : Type*} [IsEmpty Œ≤] : Œ± ‚äï Œ≤ ‚âÉ Œ± where
  toFun := Sum.elim (@id Œ±) fun x ‚Ü¶ (IsEmpty.false x).elim
  invFun := Sum.inl
  left_inv x := by
    by_cases h : Sum.isLeft x
    ¬∑ rw [Sum.eq_left_getLeft_of_isLeft h]
      dsimp only [Sum.elim_inl, id_eq]
    ¬∑ have h' : Sum.isRight x := Sum.not_isLeft.mp h
      exact (IsEmpty.false (Sum.getRight x h')).elim
  right_inv x := by aesop

def Homeomorph.sum_empty {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [IsEmpty Y] :
  X ‚äï Y ‚âÉ‚Çú X where
  toEquiv := Equiv.sum_empty
  continuous_toFun := Continuous.sum_elim continuous_id (continuous_of_const fun _ ‚Ü¶ congrFun rfl)
  continuous_invFun := continuous_inl

-- should be similar to the continuous version...
lemma contMDiff_of_const {f : M ‚Üí N} (h : ‚àÄ (x y : M), f x = f y) : ContMDiff I J ‚àû f := by
  intro x
  have : f = fun _ ‚Ü¶ f x := by ext y; exact h y x
  rw [this]
  apply contMDiff_const

def Diffeomorph.sum_empty [IsEmpty M'] : Diffeomorph I I (M ‚äï M') M ‚àû where
  toEquiv := Equiv.sum_empty
  contMDiff_toFun := ContMDiff.sum_elim contMDiff_id (contMDiff_of_const (fun _ ‚Ü¶ congrFun rfl))
  contMDiff_invFun := ContMDiff.inl

lemma sdfdsf : (Diffeomorph.swap M I M') ‚àò Sum.inl = Sum.inr := by
  ext
  exact Sum.swap_inl

lemma hogehoge : (Diffeomorph.swap M I M') ‚àò Sum.inr = Sum.inl := by
  ext
  exact Sum.swap_inr

end DisjUnion

namespace UnorientedCobordism

-- TODO: for now, assume all manifolds are modelled on the same chart and model space...
-- Is this necessary (`H` presumably is necessary for disjoint unions to work out...)?
-- How would that work in practice? Post-compose with a suitable equivalence of H resp. E?

variable {M : Type*} [TopologicalSpace M] [ChartedSpace H M]
  {I : ModelWithCorners ‚Ñù E H} [SmoothManifoldWithCorners I M]
  {M' : Type*} [TopologicalSpace M'] [ChartedSpace H M']
  /-{I' : ModelWithCorners ‚Ñù E H}-/ [SmoothManifoldWithCorners I M']
  {M'' : Type*} [TopologicalSpace M''] [ChartedSpace H M'']
  /-{I'' : ModelWithCorners ‚Ñù E H}-/ [SmoothManifoldWithCorners I M''] {n : ‚Ñï}
  [CompactSpace M] [BoundarylessManifold I M]
  [CompactSpace M'] [BoundarylessManifold I M'] [CompactSpace M''] [BoundarylessManifold I M'']
  [CompactSpace M] [FiniteDimensional ‚Ñù E]
  [CompactSpace M'] [FiniteDimensional ‚Ñù E'] [CompactSpace M''] [FiniteDimensional ‚Ñù E'']

variable [Nonempty H]

/-- An **unoriented cobordism** between two singular `n`-manifolds `(M,f)` and `(N,g)` on `X`
is a compact smooth `n`-manifold `W` with a continuous map `F: W ‚Üí X`
whose boundary is diffeomorphic to the disjoint union `M ‚äî N` such that `F` restricts to `f`
resp. `g` in the obvious way. -/
structure UnorientedCobordism (s : SingularNManifold X n M I)
    (t : SingularNManifold X n M' I) {W : Type*} [TopologicalSpace W]
    [ChartedSpace H'' W] {J : ModelWithCorners ‚Ñù E'' H''} [SmoothManifoldWithCorners J W]
    (bd : BoundaryManifoldData W J) [HasNiceBoundary bd] where
  hW : CompactSpace W
  hW' : finrank ‚Ñù E'' = n + 1
  F : W ‚Üí X
  hF : Continuous F
  /-- The boundary of `W` is diffeomorphic to the disjoint union `M ‚äî M'`. -/
  œÜ : Diffeomorph bd.model I (J.boundary W) (M ‚äï M') ‚àû
  /-- `F` restricted to `M ‚Ü™ ‚àÇW` equals `f`: this is formalised more nicely as
  `f = F ‚àò Œπ ‚àò œÜ‚Åª¬π : M ‚Üí X`, where `Œπ : ‚àÇW ‚Üí W` is the inclusion. -/
  hFf : F ‚àò (Subtype.val : J.boundary W ‚Üí W) ‚àò œÜ.symm ‚àò Sum.inl = s.f
  /-- `F` restricted to `N ‚Ü™ ‚àÇW` equals `g` -/
  hFg : F ‚àò (Subtype.val : J.boundary W ‚Üí W) ‚àò œÜ.symm ‚àò Sum.inr = t.f

variable {s : SingularNManifold X n M I}
  {t : SingularNManifold X n M' I} {W : Type*} [TopologicalSpace W] [ChartedSpace H'' W]
  {J : ModelWithCorners ‚Ñù E'' H''} [SmoothManifoldWithCorners J W]
  {bd : BoundaryManifoldData W J} [HasNiceBoundary bd]

-- TODO: can I remove the `Fact`, concluding the empty set otherwise? or is this not useful?
variable {x y : ‚Ñù} [Fact (x < y)] in
def _root_.boundaryData_IccManifold : BoundaryManifoldData ((Icc x y)) (ùì°‚àÇ 1) := sorry

variable (x y : ‚Ñù) [Fact (x < y)] (M I) in
abbrev foo  : BoundaryManifoldData (M √ó (Icc x y)) (I.prod (ùì°‚àÇ 1)) :=
  BoundaryManifoldData.prod_of_boundaryless_left (M := M) (I := I)
    (boundaryData_IccManifold (x := x) (y := y))

variable {x y : ‚Ñù} [Fact (x < y)] in
instance : HasNiceBoundary (foo M I x y) := sorry

/-- If `M` is boundaryless, `‚àÇ(M √ó [0,1])` is diffeomorphic to the disjoint union `M ‚äî M`. -/
-- XXX below is a definition, but that will surely *not* be nice to work with... can I get sth better?
def Diffeomorph.productInterval_sum : Diffeomorph ((foo M I 0 1).model) I
    ((I.prod (ùì°‚àÇ 1)).boundary (M √ó (Icc (0 : ‚Ñù) 1))) (M ‚äï M) ‚àû where
  toFun := by
    rw [boundary_product]
    -- We send M √ó {0} to the first factor and M √ó {1} to the second.
    exact fun p ‚Ü¶ if p.1.2 = 0 then Sum.inl p.1.1 else Sum.inr p.1.1
  invFun := by
    rw [boundary_product]
    exact Sum.elim (fun x ‚Ü¶ ‚ü®(x, 0), trivial, by tauto‚ü©) (fun x ‚Ü¶ ‚ü®(x, 1), trivial, by tauto‚ü©)
  left_inv := sorry
  right_inv := sorry
  contMDiff_toFun := by
    dsimp
    -- Several pieces still missing:
    -- f is C^n iff each restriction to M x {0} is C^n
    -- working with the actual terms.
    sorry
  contMDiff_invFun := by
    -- the following code errors...
    --suffices ContMDiff I (foo M I 0 1).model ‚àû (Sum.elim (fun x ‚Ü¶ ‚ü®(x, 0), trivial, by tauto‚ü©) (fun x ‚Ü¶ ‚ü®(x, 1), trivial, by tauto‚ü©)) by
    --  sorry
    sorry

/-- Each singular `n`-manifold `(M,f)` is cobordant to itself. -/
def refl (s : SingularNManifold X n M I) : UnorientedCobordism s s (foo M I 0 1) where
  hW := by infer_instance
  hW' := by rw [finrank_prod, s.hdim.out, finrank_euclideanSpace_fin]
  F := s.f ‚àò (fun p ‚Ü¶ p.1)
  hF := s.hf.comp continuous_fst
  œÜ := Diffeomorph.productInterval_sum
  -- TODO: most of these proofs should become API lemmas about `Diffeomorph.productInterval_sum`
  hFf := sorry
  hFg := sorry

variable (s : SingularNManifold X n M I) (t : SingularNManifold X n M' I)
  {W : Type*} [TopologicalSpace W] [ChartedSpace H'' W]
  {J : ModelWithCorners ‚Ñù E'' H''} [SmoothManifoldWithCorners J W]
  {bd : BoundaryManifoldData W J} [HasNiceBoundary bd]

/-- Being cobordant is symmetric. -/
def symm (œÜ : UnorientedCobordism s t bd) : UnorientedCobordism t s bd where
  hW := œÜ.hW
  hW' := œÜ.hW'
  F := œÜ.F
  hF := œÜ.hF
  œÜ := Diffeomorph.trans œÜ.œÜ (Diffeomorph.swap M I M')
  -- apply sdfdsf resp. hogehoge, and combine with œÜ.hFf and œÜ.hFg
  hFf := sorry
  hFg := sorry

-- Fleshing out the details for transitivity will take us too far: we merely sketch the necessary
-- pieces.
section transSketch

variable {u : SingularNManifold X n M'' I}
  {W' : Type*} [TopologicalSpace W'] [ChartedSpace H''' W']
  {J' : ModelWithCorners ‚Ñù E''' H'''} [SmoothManifoldWithCorners J' W']
  {bd' : BoundaryManifoldData W' J'} [HasNiceBoundary bd']

-- Idea: glue the cobordisms W and W' along their common boundary M',
-- as identified by the diffeomorphism W ‚Üí M' ‚Üê W'.
-- This could be formalised as an adjunction/attaching maps: these are a special case of pushouts
-- (in the category of topological spaces).
-- mathlib has abstract pushouts (and proved that TopCat has them);
-- `Topology/Category/TopCat/Limits/Pullbacks.lean` provides a concrete description of pullbacks
-- in TopCat. A good next step would be to adapt this argument to pushouts, and use this here.
-- TODO: can I remove the s and t variables from this definition?
def glue (œÜ : UnorientedCobordism s t bd) (œà : UnorientedCobordism t u bd') : Type* := sorry

instance (œÜ : UnorientedCobordism s t bd) (œà : UnorientedCobordism t u bd') :
    TopologicalSpace (glue s t œÜ œà) := sorry

-- This and the next item require the collar neighbourhood theorem.
instance (œÜ : UnorientedCobordism s t bd) (œà : UnorientedCobordism t u bd') :
    ChartedSpace H (glue s t œÜ œà) := sorry

-- TODO: can I remove the s and t variables from this one?
def glueModel (œÜ : UnorientedCobordism s t bd) (œà : UnorientedCobordism t u bd') :
    ModelWithCorners ‚Ñù E H := sorry

instance (œÜ : UnorientedCobordism s t bd) (œà : UnorientedCobordism t u bd') :
    SmoothManifoldWithCorners (glueModel s t œÜ œà) (glue s t œÜ œà) := sorry

-- TODO: can I remove the s and t variables from this one?
def glueBoundaryData (œÜ : UnorientedCobordism s t bd) (œà : UnorientedCobordism t u bd') :
    BoundaryManifoldData (glue s t œÜ œà) (glueModel s t œÜ œà) := sorry

instance (œÜ : UnorientedCobordism s t bd) (œà : UnorientedCobordism t u bd') :
    HasNiceBoundary (glueBoundaryData s t œÜ œà) := sorry

noncomputable def trans (œÜ : UnorientedCobordism s t bd) (œà : UnorientedCobordism t u bd') :
    UnorientedCobordism s u (glueBoundaryData s t œÜ œà) where
  hW := sorry
  hW' := sorry
  F := sorry
  hF := sorry
  œÜ := sorry
  hFf := sorry
  hFg := sorry

end transSketch

end UnorientedCobordism

-- how to encode this in Lean?
-- Two singular `n`-manifolds are cobordant iff there exists a smooth cobordism between them.
-- The unoriented `n`-bordism group `Œ©_n^O(X)` of `X` is the set of all equivalence classes
-- of singular n-manifolds up to bordism.
-- then: functor between these...

-- prove: every element in Œ©_n^O(X) has order two
