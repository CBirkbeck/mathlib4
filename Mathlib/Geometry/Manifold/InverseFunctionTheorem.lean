/-
Copyright (c) 2023 Michael Rothgang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Michael Rothgang
-/
import Mathlib.Analysis.Calculus.Inverse
import Mathlib.Geometry.Manifold.Diffeomorph
import Mathlib.Tactic.RewriteSearch

/-! # The inverse function theorem for manifolds

TODO: write a docstring when I'm done

**TODO**
* allow M and N to be modelled on different normed spaces (even if they must be isomorphic)
* don't assume M and N are smooth: the groupoid containing the C^1 groupoid suffices
* handle models with corners in my "charts are structomorphs" argument

* extend the arguments to manifolds with boundary, for instance like this:
  - at an interior point, we can choose U and V to be open - so the argument for the boundaryless case applies
  - f being C¬π at a boundary point x, means f has a C¬π extension to an open neighbourhood of range I\subset E:
  work with that like in the previous bullet point
  - to phrase these above two bullet points, mathlib needs to gain
  the concepts of interior and boundary points, and that the interior is an open subset
-/

open Function Manifold Set TopologicalSpace Topology

-- Let M and N be manifolds over (E,H) and (E',H'), respectively.
-- We don't assume smoothness, but allow any structure groupoid (which contains C¬π maps).
variable {E E' H H' M N : Type*}
  [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [NormedAddCommGroup E'] [NormedSpace ‚Ñù E']
  [TopologicalSpace H] [TopologicalSpace M] [ChartedSpace H M]
   [TopologicalSpace N] [ChartedSpace H N]
  -- TODO: relax these conditions!!
  (I : ModelWithCorners ‚Ñù E H) [SmoothManifoldWithCorners I M]
  (J : ModelWithCorners ‚Ñù E' H) [SmoothManifoldWithCorners J N]
  -- these lines are what I actually want
  --(I : ModelWithCorners ‚Ñù E H) (G : StructureGroupoid H) [HasGroupoid M G]
  -- (J : ModelWithCorners ‚Ñù E' H') (G' : StructureGroupoid H') [HasGroupoid N G']


-- inconsistent: HasFDerivAt f f' x vs HasMFDerivAt f x f'

/-! Pre-requisite results: the differential of a function is surjective/injective/a linear iso
  iff the differential of its coordinate representation (w.r.t. any charts) is.
  Already proven on a branch; just waiting for the most conceptual proof.

  Let `f: M ‚Üí N` be `C^1` near `x`. For (extended) charts `œÜ` and `œà` around `x` and `f x`,
  respectively, denote `f_loc := œà ‚àò f ‚àò œÜ‚Åª¬π`. We show that the differential `df_x` of `f`
  is injective, surjective resp. a linear isomorphism iff `(df_loc)_(œÜ x)` is. -/
section Prerequisites
variable {f : M ‚Üí N} {x : M}

-- xxx: for unextended charts, this doesn't make sense unless H is also a normed space
variable (hf : ContMDiffAt I J 1 f x)
  {e : LocalHomeomorph M H} (he : e ‚àà atlas H M)
  {e' : LocalHomeomorph N H} (he' : e' ‚àà atlas H N)

/-- `df_x` is a linear isomorphism iff `(df_loc)_(œÜ x)` is a linear isomorphism.-/
-- part 1: isomorphism
def differential_in_charts_iso (dfx : TangentSpace I x ‚âÉL[‚Ñù] TangentSpace J (f x))
    (hx : HasMFDerivAt I J f x dfx) : E ‚âÉL[‚Ñù] E' := sorry

variable (e e') in
-- part 2: this isomorphism is really the fderiv
lemma differential_in_charts_iso_coe (dfx : TangentSpace I x ‚âÉL[‚Ñù] TangentSpace J (f x))
    (hx : HasMFDerivAt I J f x dfx) : (differential_in_charts_iso I J dfx hx).toFun =
      fderiv ‚Ñù ((e'.extend J) ‚àò f ‚àò (e.extend I).symm) ((e.extend I) x) := sorry

-- FIXME: add converse version, differential_iso_of_in_charts plus `coe` version
-- should follow easily from this one

/-- `df_x` is injective iff `(df_loc)_(œÜ x)` is injective.-/
lemma differential_injective_iff_in_charts : Injective (mfderiv I J f x) ‚Üî Injective
    (mfderiv ùìò(‚Ñù, E) ùìò(‚Ñù, E') ((e'.extend J) ‚àò f ‚àò (e.extend I).symm) ((e.extend I) x)) := sorry

/-- `df_x` is surjective iff `(df_loc)_(œÜ x)` is sujective.-/
lemma diff_surjective_iff_in_charts_extend : Surjective (mfderiv I J f x) ‚Üî Surjective
    (mfderiv ùìò(‚Ñù, E) ùìò(‚Ñù, E') ((e'.extend J) ‚àò f ‚àò (e.extend I).symm) ((e.extend I) x)) := sorry
end Prerequisites

-- Experimenting with another design towards local diffeomorphisms.
section LocalDiffeos
variable {G : StructureGroupoid H}

/-- A `Structomorph` on the model space `H` lies in the structure groupoid. -/
lemma Structomorph.toLocalHomeomorph_mem_groupoid (h : Structomorph G H H) : h.toLocalHomeomorph ‚àà G := by
  -- FIXME: is there a more elegant way to prove this?
  have : ‚àÄ (c c' : LocalHomeomorph H H), c ‚àà atlas H H ‚Üí c' ‚àà atlas H H ‚Üí h.toLocalHomeomorph ‚àà G := by
    intro c c' hc hc'
    have : c.symm ‚â´‚Çï h.toHomeomorph.toLocalHomeomorph ‚â´‚Çï c' = h.toLocalHomeomorph := by
      rw [chartedSpaceSelf_atlas.mp hc, chartedSpaceSelf_atlas.mp hc']
      simp
    exact this ‚ñ∏ (h.mem_groupoid c c' hc hc')
  apply this (c := LocalHomeomorph.refl H) (c' := LocalHomeomorph.refl H) rfl rfl

/-- If a local homeomorphism on the model space `H` lies in the structure groupoid,
  it induces a `Structomorph` on the model space `H`. -/
def LocalHomeomorph.toStructomorph_of_mem_groupoid (e : LocalHomeomorph H H)
    (hs : e.source = univ) (ht : e.target = univ) (h : e ‚àà G) : Structomorph G H H := by
  -- XXX: can I simplify this, e.g. by rewriting e.toHomeomorphSourceTarget?
  let ehom : Homeomorph H H := {
    toFun := e.toFun
    invFun := e.invFun
    left_inv := fun x ‚Ü¶e.left_inv' (by rw [hs]; trivial)
    right_inv := fun x ‚Ü¶e.right_inv' (by rw [ht]; trivial)
    continuous_toFun := by
      let r := hs ‚ñ∏ e.continuous_toFun
      exact continuous_iff_continuousOn_univ.mpr r
    continuous_invFun := by
      let r := ht ‚ñ∏ e.continuous_invFun
      exact continuous_iff_continuousOn_univ.mpr r
  }
  exact {
    ehom with
    mem_groupoid := by
      -- As `H` has only one chart, we only need to check ehom ‚àà G: but ehom is equal to e.
      intro c c' hc hc'
      rw [chartedSpaceSelf_atlas.mp hc, chartedSpaceSelf_atlas.mp hc']
      simp only [LocalHomeomorph.refl_symm, LocalHomeomorph.trans_refl, LocalHomeomorph.refl_trans]
      exact G.eq_on_source h (‚ü®hs.symm, eqOn_refl _ _‚ü©)
  }

/-- If `h` is a `Structomorph` on `H`, it is also a local structomorphism at every point. -/
lemma Structomorph.toLocalStructomorphAt (h : Structomorph G H H) {x : H} :
    G.IsLocalStructomorphWithinAt h.toFun univ x :=
  fun y ‚Ü¶ ‚ü®h.toLocalHomeomorph, h.toLocalHomeomorph_mem_groupoid, eqOn_refl h.toFun _, y‚ü©

/-- If `f : H ‚Üí H` is a local structomorphism at each `x`, it induces a structomorphism on `H`. -/
noncomputable def Structomorph.of_localStructomorphs {f : H ‚Üí H}
    (hf : ‚àÄ x, ‚àÉ s : Set H, x ‚àà s ‚àß G.IsLocalStructomorphWithinAt f s x) : Structomorph G H H := by
  -- for each x, choose an s and a local homeomorph x
  choose s hs  using hf
  choose hxs e he using hs
  -- Choose the inverse by taking the point-wise inverse under our construction.
  let g : H ‚Üí H := fun x ‚Ü¶ (e x (hxs x)) x
  -- Now: show all the boilerplate to argue this defines an inverse.
  have hf : Continuous f := by
    have : ‚àÄ x, ContinuousAt f x := by
      intro x
      sorry
    exact continuous_iff_continuousAt.mpr this
  have hg : Continuous g := sorry
  let h : Homeomorph H H := {
    toFun := f
    invFun := g
    left_inv := sorry
    right_inv := sorry
    continuous_toFun := hf
    continuous_invFun := hg
  }
  exact {
    h with
    mem_groupoid := sorry
  }
end LocalDiffeos

-- Work the on the concept of pregroupoids: hopefully, this is the right framework to *state*
-- the Inverse Function theorem in general.
section Pregroupoids
variable (H : Type*) [TopologicalSpace H]
-- warm-up: the pregroupoid of continuous functions
-- I suspect the mathlib definition is misnamed... let me define my own, for practice
def contPregroupoid : Pregroupoid H where
  property := fun f s => ContinuousOn f s
  comp := fun hf hg _ _ _ ‚Ü¶ hg.comp' hf
  id_mem := continuousOn_id
  locality := fun _ h ‚Ü¶ continuousOn_of_locally_continuousOn h
  congr := fun _ congr hf ‚Ü¶ hf.congr congr

/-- A pregroupoid `P` on `H` is called **good** (placeholder name)
  iff it is stable under local inverses:
if `f` lies in `P` and has a local inverse function `g`, then `g` also lies in `P`.
Simplest special case: if `P` is e.g. the contPregroupoid (which is monotone),
suppose `f` is continuous on `U` (i.e., we have `contPregroupoid.property f U`)
and g : H ‚Üí H is a local inverse of `f` on `s`: we have `InvOn g f s t` for some `t ‚äÜ H`.
Then, `g` is continuous on `t` (i.e. property `g t`). -/
structure GoodPregroupoid (H : Type*) [TopologicalSpace H] extends Pregroupoid H where
  inverse : ‚àÄ {f g s t}, property f s ‚Üí InvOn g f s t ‚Üí property g t

/- Note: If `f` is continuous on `u`, while `InvOn g f s t`,
`InvOn.mono` implies `InvOn g f s‚à©u t‚à©f(u)`: thus, it suffices to consider the case `s=u`. -/
example {X Y : Type*} {u s : Set X} {t : Set Y} {f : X ‚Üí Y} {g : Y ‚Üí X} (h : InvOn g f s t) :
  InvOn g f (s ‚à© u) (t ‚à© (f '' u)) := h.mono (inter_subset_left s u) (inter_subset_left _ _)

/-- The groupoid associated to a good pregroupoid. -/
def GoodPregroupoid.groupoid (PG : GoodPregroupoid H) : StructureGroupoid H :=
  (PG.toPregroupoid).groupoid

-- The continuous pregroupoid is not good: not in general, not even if `H` is compact and Hausdorff.
-- Need to show that f continuous on s (and g being the point-wise inverse) implies g cont on t;
-- this is simply false: a bijective function is not bi-continuous in general.
-- A *variant* assuming only compact s were true. Not interesting to use.
-- XXX: not enough, a priori `s` is any set!

variable {n : ‚Ñï‚àû} {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [CompleteSpace E]
-- XXX: generalise to any field ùïú which is ‚Ñù or ‚ÑÇ

-- C^n functions on E: warm-up case (only one chart); full definition in SmoothManifoldsWithCorners
def contDiffPregroupoidWarmup : Pregroupoid E := {
  property := fun f s ‚Ü¶ ContDiffOn ‚Ñù n f s
  comp := fun {f g} {u v} hf hg _ _ _ ‚Ü¶ hg.comp' hf
  id_mem := contDiffOn_id
  locality := fun _ h ‚Ü¶ contDiffOn_of_locally_contDiffOn h
  congr := by intro f g u _ congr hf; exact (contDiffOn_congr congr).mpr hf
}

-- test this works: this is a good pregroupoid -> no, it doesn't, my assumptions are still too weak!
lemma contDiffPregroupoidGoodWarmup : GoodPregroupoid E where
  -- TODO: fix copy-paste!
  property := fun f s ‚Ü¶ ContDiffOn ‚Ñù n f s
  comp := fun {f g} {u v} hf hg _ _ _ ‚Ü¶ hg.comp' hf
  id_mem := contDiffOn_id
  locality := fun _ h ‚Ü¶ contDiffOn_of_locally_contDiffOn h
  congr := by intro f g u _ congr hf; exact (contDiffOn_congr congr).mpr hf
  --toPregroupoid := contDiffPregroupoidWarmup E
  inverse := by
    intro f g s t hf hinv
    have : ContDiffOn ‚Ñù n f s := hf
    show ContDiffOn ‚Ñù n g t
    sorry

-- FIXME: this is getting close; make it match exactly!
structure BetterPregroupoid (H : Type*) [TopologicalSpace H]
  [NormedAddCommGroup H] [NormedSpace ‚Ñù H]
  extends Pregroupoid H where
  -- If `f ‚àà P` defines a homeomorphism `s ‚Üí t` with inverse `g`, then `g ‚àà P` also.
  -- For instance, if `f` is a local homeo at `x`, we're good.
  inverse : ‚àÄ {f g s t x}, ‚àÄ {f' : H ‚âÉL[‚Ñù] H}, x ‚àà s ‚Üí IsOpen s ‚Üí property f s ‚Üí
    /- HasFDerivAt (ùïú := ‚Ñù) f f' x ‚Üí-/ -- TODO: this is not accepted by Lean!
    InvOn g f s t ‚Üí property g t

-- this is the key lemma I need to showing that C^n maps define a better pregroupoid
-- only done in the affine case, FIXME generalise
-- FIXME: not entirely true; I get that g is ContDiff in *some* nhd of x, might be smaller than t!
-- we need to work over ‚Ñù or ‚ÑÇ, otherwise `toLocalInverse` doesn't apply
lemma Iwant {f g : E ‚Üí E} {s t : Set E} {x : E} {f' : E ‚âÉL[‚Ñù] E} (hinv : InvOn g f s t)
    (hf : ContDiffAt ‚Ñù n f x) (hf' : HasFDerivAt (ùïú := ‚Ñù) f f' x) (hn : 1 ‚â§ n) :
    ContDiffOn ‚Ñù n g t := by
  let r := hf.to_localInverse (f' := f') hf' hn -- ContDiffAt ‚Ñù n (hf.localInverse hf' hn) (f x)
  sorry

lemma contDiffPregroupoidBetterWarmup (hn : 1 ‚â§ n) {x : E} : BetterPregroupoid E where
  -- TODO: fix copy-paste!
  property := fun f s ‚Ü¶ ContDiffOn ‚Ñù n f s
  comp := fun {f g} {u v} hf hg _ _ _ ‚Ü¶ hg.comp' hf
  id_mem := contDiffOn_id
  locality := fun _ h ‚Ü¶ contDiffOn_of_locally_contDiffOn h
  congr := by intro f g u _ congr hf; exact (contDiffOn_congr congr).mpr hf
  inverse := by
    intro f g s t x f' hx hs hf hinv
    have : ContDiffOn ‚Ñù n f s := hf
    show ContDiffOn ‚Ñù n g t
    -- TODO: add this to the groupoid assumptions...
    have : HasFDerivAt (ùïú := ‚Ñù) f f' x := sorry
    exact Iwant hinv (hf.contDiffAt (hs.mem_nhds hx)) this hn

/- my vision for the general IFT/general shape should go like this:
    - consider a "good pregroupoid" P: inverses should exist;
      basically, we put all the necessary properties so the inverse by the IFT is also in P
    - let G be the groupoid associated to P
    - suppose f ‚àà P is differentiable at x with invertible differential,
      construct a local inverse (I have this already)
    - categorical statement of the IFT on H, over any good pregroupoid P
      if f : H ‚Üí H, f ‚àà P with differential df_x invertible,
      yields f.isLocalStructomorphWithin s x for some s
    - conceptual statement of the IFT, over any suitable pregroupoid:
        pull up this property over charts using ChartedSpace.LiftPropOn
    - perhaps: can I characterise, over any suitable pregroupoid, this as sth like
        f:M ‚Üí M' (ove the same model I) is a local structo for G iff f and f' are in P
      generalising `isLocalStructomorphOn_contDiffGroupoid_iff` to all categories
  specialise to specific categories: C^n and ùïú-analytic ones, show they satisfy this.

‚àÄ x, f':..., f with df_x=f'
if f is contDiff at x with invertible differential,
g is the IFT inverse, then the inverse is also in P

perhaps generalise: LocalHomeomorph.contDiffAt_symm
if f is a local homeo, ContDiffAt x and df_x is an inverse, we're good

  the framework works for any C^k, also for analytic functions, just the same -/

end Pregroupoids

/-! Inverse function theorem for manifolds. -/
section IFT
namespace ContMDiffAt
variable {f : M ‚Üí N} {x : M} {f' : TangentSpace I x ‚âÉL[‚Ñù] TangentSpace J (f x)} [CompleteSpace E]

/-- Given a `ContMDiff` function over `ùïÇ` (which is `‚Ñù` or `‚ÑÇ`) with an invertible
derivative at `x`, returns a `LocalHomeomorph` with `to_fun = f` and `x ‚àà source`. -/
noncomputable def toLocalHomeomorph {n : ‚Ñï‚àû} [I.Boundaryless] [J.Boundaryless]
    (hf : ContMDiffAt I J n f x) (hf' : HasMFDerivAt I J f x f') (hn : 1 ‚â§ n) : LocalHomeomorph M N := by
  -- This follows from the analogous statement on charts.
  -- Consider the charts œÜ and œà on `M` resp. `N` around `x` and `f x`, respectively,
  -- and the local coordinate representation `f_loc` of `f` w.r.t. these charts.
  let œÜ := extChartAt I x
  let œà := extChartAt J (f x)
  let f_loc := œà ‚àò f ‚àò œÜ.invFun
  -- `f_loc` maps `U` to `V`; these are open sets (at least morally).
  let U := œÜ '' (œÜ.source ‚à© f ‚Åª¬π' œà.source)
  let V := œà '' (f '' œÜ.source ‚à© œà.source)
  -- have : MapsTo f_loc U V := by
  --   intro x hx
  --   rcases hx with ‚ü®x', hx', hx'x‚ü©
  --   have : œÜ.invFun (œÜ x') = x' := œÜ.left_inv (mem_of_mem_inter_left hx')
  --   have : f_loc x = (œà ‚àò f) x' := calc f_loc x
  --     _ = (œà ‚àò f ‚àò œÜ.invFun) (œÜ x') := by rw [hx'x]
  --     _ = (œà ‚àò f) (œÜ.invFun (œÜ x')) := rfl
  --     _ = (œà ‚àò f) x' := by rw [this]
  --   --have : f x' ‚àà (f '' œÜ.source ‚à© œà.source) := by aesop
  --   aesop
  -- openness of U and V were obvious for just charts; it's not as obvious here
  -- for instance, a priori we only know `f` is continuous *at x*, not *near* `x`
  -- XXX: I'll see if we need this
  -- have : IsOpen U := sorry
  -- have : IsOpen V := sorry
  -- have : U ‚äÜ œÜ.target := sorry
  -- have : V ‚äÜ œà.target := sorry

  -- By definition, `f_loc` is `C^1` at `x' := œÜ x`. (At least, if `M` is boundaryless.)
  set x' := œÜ x
  have : ContDiffWithinAt ‚Ñù n f_loc (range I) x' := ((contMDiffAt_iff I J).mp hf).2
  have : ContDiffAt ‚Ñù n f_loc (œÜ x) := by rw [I.range_eq_univ] at this; exact this
  -- As shown before, `(df_loc)_œÜ x is also a linear isomorphism.
  have df_loc : E ‚âÉL[‚Ñù] E' := differential_in_charts_iso I J f' hf'
  let temp := differential_in_charts_iso_coe I J (chartAt H x) (chartAt H (f x)) f' hf'
  -- this should be obvious/easy - I did this already on a different branch
  have hdf'loc : HasFDerivAt (ùïú := ‚Ñù) f_loc df_loc x' := sorry

  -- By the Inverse Function Theorem on normed spaces, there's a local homeomorphism
  -- to `toFun = f_loc` and `x' ‚àà source`.
  let f_loc' := this.toLocalHomeomorph f_loc hdf'loc hn
  -- Composing with the inverse charts yields the local homeomorphism we want.
  -- (If M and N are boundaryless, that is: otherwise, we'd have to work harder.)
  let œÜ' := (chartAt H x).trans I.toHomeomorph.toLocalHomeomorph
  let œà' := (chartAt H (f x)).trans J.toHomeomorph.toLocalHomeomorph
  -- have : œÜ'.toFun = œÜ.toFun := rfl
  -- have : œà'.toFun = œà.toFun := rfl
  exact œÜ' ‚â´‚Çï f_loc' ‚â´‚Çï œà'.symm

-- TODO: sanity-check that I got the directions right?
-- @[simp]
-- theorem toLocalHomeomorph_coe {n : ‚Ñï‚àû} [I.Boundaryless] [J.Boundaryless]
--     (hf : ContMDiffAt I J n f x) (hf' : HasMFDerivAt I J f x f') (hn : 1 ‚â§ n) :
--     (hf.toLocalHomeomorph I J hf' hn : M ‚Üí N) = f :=
--   rfl
end ContMDiffAt

-- do I want counterparts of mem_toLocalHomeomorph_source, image_mem_toLocalHomeomorph_target also?

-- XXX: good name for this?
variable {X Y : Type*} {f f' : X ‚Üí Y} {g g' : Y ‚Üí X} {s : Set X} {t : Set Y} in
lemma InvOn.eqOn_inverse_of_eqOn (h : InvOn g f s t) (h' : InvOn g' f' s t) (heq : EqOn f f' s)
    (hg : MapsTo g t s) : EqOn g g' t := by
  intro y hy
  -- We have y = f x = f' x for x := g y ‚àà s, hence can apply our assumptions.
  set x := g y
  rw [‚Üê (h.2 hy), heq (hg hy)]
  exact (h'.1 (hg hy)).symm

-- xxx: why is my variant better?
variable {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] (e : LocalHomeomorph X Y) in
lemma LocalHomeomorph.restr_target' {s : Set X} (hs : IsOpen s) :
    (e.restr s).target = e '' (e.source ‚à© s) := by
  rw [‚Üê (e.restr s).image_source_eq_target, e.restr_source s, hs.interior_eq, e.restr_apply]

variable {X Y : Type*} {s : Set X} {f : X ‚Üí Y} {g : Y ‚Üí X} in
lemma InvOn.mapsTo_image (hinv : InvOn g f s (f '' s)) : MapsTo g (f '' s) s := by
  rintro y ‚ü®x, hxs, hxy‚ü©
  rw [‚Üê hxy]
  exact mem_of_eq_of_mem (hinv.1 hxs) hxs

/-- If `f : H ‚Üí H` is a local structomorphism at `x` relative to `s` and has a local inverse `g`,
  then `g` is a local structomorphism at `f x` relative to `f '' x`. -/
-- no differentiability here! wouldn't make sense either :-)
lemma StructureGroupoid.localInverse_isLocalStructomorphWithin {f : H ‚Üí H} {s : Set H} {x : H}
    {G : StructureGroupoid H} [ClosedUnderRestriction G] (hf : G.IsLocalStructomorphWithinAt f s x)
    (hs : IsOpen s) {g : H ‚Üí H} (hinv : InvOn g f s (f '' s)) (hgx : g (f x) = x) :
    G.IsLocalStructomorphWithinAt g (f '' s) (f x) := by
  intro hfx
  -- `hgx` is required so this is true: need to exclude the case x ‚àâ s, but f x ‚àà f'' s.
  have hxs : x ‚àà s := by
    rcases hfx with ‚ü®x', hx's, hx'y‚ü©
    have : x = x' := by rw [(hinv.1 hx's).symm, hx'y, hgx]
    exact mem_of_eq_of_mem this hx's
  rcases hf hxs with ‚ü®e, heg, heq, hxsource‚ü©
  -- XXX: `heq` and `restr_target` disagree about order of sets,
  -- so need to rewrite by inter_comm, here and below.
  have e'source : (e.restr s).symm.source = e '' (e.source ‚à© s) := by
    rw [(e.restr s).symm_source, e.restr_target' hs]
  rw [inter_comm] at e'source
  have image_eq : e '' (e.source ‚à© s) = f '' (e.source ‚à© s) := by
    rw [inter_comm]; exact image_congr heq.symm
  refine ‚ü®(e.restr s).symm, G.symm (closedUnderRestriction' heg hs), ?_, ?_‚ü©
  ¬∑ intro y hy
    rw [e'source] at hy
    -- write y = e x = f x for some x ‚àà e.source ‚à© s
    rcases mem_of_mem_inter_right hy with ‚ü®x, hx, hxy‚ü©
    have : f x = y := by rw [heq hx]; exact hxy
    have hy' : y ‚àà f '' (s ‚à© e.source) := this ‚ñ∏ mem_image_of_mem f hx
    -- Now, it's a general lemma about two-sided inverses.
    have hinv' : InvOn g f (s ‚à© e.source) (f '' (s ‚à© e.source)) :=
      hinv.mono (inter_subset_left s e.source) (image_subset _ (inter_subset_left _ _))
    have aux : InvOn (e.restr s).symm (e.restr s) (s ‚à© e.source) (f '' (s ‚à© e.source)) := by
      have : f '' (s ‚à© e.source) = e '' (s ‚à© e.source) := image_congr heq
      rw [this]
      have : (e.restr s).source = s ‚à© e.source := by
        rw [inter_comm]
        let r := hs.interior_eq ‚ñ∏ e.restr_source s
        exact r
      rw [‚Üê e'source, ‚Üê this]
      exact (e.restr s).invOn
    exact (InvOn.eqOn_inverse_of_eqOn hinv' aux heq) (InvOn.mapsTo_image hinv') hy'
  ¬∑ show f x ‚àà (e.restr s).symm.source
    rw [(e.restr s).symm_source, e.restr_target' hs]
    rw [image_eq]
    apply mem_image_of_mem f (mem_inter hxsource hxs)

/-- If `f : M ‚Üí N` is a local `G`-structomorphism, so is its inverse. -/
-- This is the global version of the previous lemma.
lemma aux (f : LocalHomeomorph M N) (G : StructureGroupoid H) [ClosedUnderRestriction G] -- needed?!
    (hf : ChartedSpace.LiftPropOn G.IsLocalStructomorphWithinAt f f.source) :
    ChartedSpace.LiftPropOn G.IsLocalStructomorphWithinAt f.symm f.symm.source := by
  intro y hy
  let x := f.symm y
  rcases hf x (f.map_target hy) with ‚ü®_, h2‚ü©
  -- *Essentially*, this reduces to the local statement shown before.
  -- Need to check a number of details though:
  --   - local reps of f and f.symm are mutually inverse (use f.invOn plus extra argument)
  --   - the inverse map g_loc maps x to x
  --   - possibly some more things I didn't check yet
  -- Introduce notation to make the goal readable.
  let s := G.localInverse_isLocalStructomorphWithin h2
  set f_loc := (chartAt H (f x)) ‚àò f ‚àò (chartAt H x).symm with eq
  set g_loc := (chartAt H x) ‚àò f.symm ‚àò (chartAt H (f x)).symm
  set x' := (chartAt H x) x
  set U := (chartAt H x).symm ‚Åª¬π' f.source
  -- Details to prove. TODO!
  -- XXX: I might need to tweak this, by restricting to a smaller set,
  -- so f.source and chart domains play nicely with each other: in essence, use trans instead of ‚àò
  have aux1 : IsOpen U := sorry -- need chartAt H x.source contains f.source or so; then it's easy
  have aux2 : InvOn g_loc f_loc U (f_loc '' U) := by
    refine ‚ü®?_, sorry‚ü© -- other sorry the same
    ¬∑ intro y hy
      let x'' := (chartAt H x).symm y
      have : x'' ‚àà f.source := sorry -- from hx
      calc g_loc (f_loc y)
        _ = ((chartAt H x) ‚àò f.symm ‚àò (chartAt H (f x)).symm ‚àò (chartAt H (f x)) ‚àò f ‚àò (chartAt H x).symm) y := rfl
        -- x'' ‚àà f.source by hypothesis hx, so f x'' ‚àà f.target
        _ = ((chartAt H x) ‚àò f.symm ‚àò (chartAt H (f x)).symm ‚àò (chartAt H (f x)) ‚àò f) x'' := rfl
        -- cancel middle two charts: xxx need f x'' nice enough
        _ = ((chartAt H x) ‚àò f.symm ‚àò f) x'' := sorry
        -- cancel, as in f.target
        _ = (chartAt H x) x'' := sorry
        _ = ((chartAt H x) ‚àò (chartAt H x).symm) y := rfl
        _ = y := sorry -- cancel again: somehow, assume x lies in the chart source/target whatever
  have aux3 : g_loc (f_loc x') = x' := sorry -- if x ‚àà U, this follows from aux2
  -- This is the local statement from the previous lemma: now lift back to a global statement.
  let s := s aux1 aux2 aux3
  refine ‚ü®f.continuous_invFun y hy, ?_‚ü©
  ¬∑ sorry -- is s, up to change of notation??!!

-- Corollary: if `f` in the IFT is a local structomorphism, so is the local inverse.
-- XXX: can I write this more nicely, not with such exploding terms?
lemma aux_cor (f : LocalHomeomorph M N) (G : StructureGroupoid H) [ClosedUnderRestriction G]
    -- suppose f has a local inverse per the IFT. TODO: pare down these assumptions!
    {n : ‚Ñï‚àû} [I.Boundaryless] [J.Boundaryless] [CompleteSpace E] {x : M}
    (hfdiff : ContMDiffAt I J n f x) {f' : TangentSpace I x ‚âÉL[‚Ñù] TangentSpace J (f x)}
    (hf' : HasMFDerivAt I J f x f') (hn : 1 ‚â§ n)
    -- and f is a local structo wrt G
    (hf : ChartedSpace.LiftPropOn G.IsLocalStructomorphWithinAt f f.source) :
    ChartedSpace.LiftPropOn G.IsLocalStructomorphWithinAt (hfdiff.toLocalHomeomorph I J hf' hn).symm
      (hfdiff.toLocalHomeomorph I J hf' hn).symm.source := by
  set r := hfdiff.toLocalHomeomorph I J hf' hn
  let s := aux f G hf
  -- missing piece: hfdiff.toLocalHomeomorph produces the inverse
  have : r.symm = f.symm := sorry
  rw [this]
  exact s

-- step 2, separately in each category
-- if f is C^k, analytic, etc. and df_x is invertible, then f_loc is a local structo within thingy
-- StructureGroupoid.IsLocalStructomorphWithinAt
-- this has been shown for C^n already, just quote it!

-- step 4, specific: if f is C^k at x, then f_loc is C^k, hence also g_loc
--> in the smooth case, get a diffeo between things (right phrasing touches the local diffeo q.)

end IFT

variable {f : M ‚Üí N} {x : M}
-- Suppose G consists of C¬π maps, i.e. G\leq contDiffGroupoid n.
/-- Suppose `G` consists of `C^1` maps. Suppose `f:M ‚Üí N` is `C^1` at `x` and
  the differential $df_x$ is a linear isomorphism.
  Then `x` and `f x` admit neighbourhoods `U ‚äÜ M` and `V ‚äÜ N`, respectively such that
  `f` is a structomorphism between `U` and `V`. -/
theorem IFT_manifolds [CompleteSpace E] [HasGroupoid M (contDiffGroupoid 1 I)] [I.Boundaryless]
    (G : StructureGroupoid H) [HasGroupoid M G]
    (hf : ContMDiffAt I J 1 f x) {f' : TangentSpace I x ‚âÉL[‚Ñù] TangentSpace J (f x)}
    (hf' : HasMFDerivAt I J f x f') :
    -- TODO: state the correct statement: h.toFun and f "are the same"
    ‚àÉ U : Opens M, ‚àÉ V : Opens N, ‚àÉ h : Structomorph G U V, True /-(‚àÄ x : U ‚Üí h x = f x.1-/ := by
  -- part 1: bookkeeping on the manifolds
  -- Consider the charts œÜ and œà on `M` resp. `N` around `x` and `f x`, respectively.
  let œÜ := extChartAt I x
  let œà := extChartAt J (f x)
  -- Consider the local coordinate representation `f_loc` of `f` w.r.t. these charts.
  let f_loc := œà ‚àò f ‚àò œÜ.invFun
  let U := œÜ '' (œÜ.source ‚à© f ‚Åª¬π' œà.source)
  let V := œà '' (f '' œÜ.source ‚à© œà.source)
  -- Check: `U` and `V` are open and `f_loc` maps `U` to `V`.
  -- have : U ‚äÜ œÜ.target := sorry -- will see when I need these!
  -- have : V ‚äÜ œà.target := sorry
  -- clear for charts; not as obvious for extended charts
  have : IsOpen U := sorry
  have : IsOpen V := sorry
  have : MapsTo f_loc U V := by
    intro x hx
    rcases hx with ‚ü®x', hx', hx'x‚ü©
    have : œÜ.invFun (œÜ x') = x' := œÜ.left_inv (mem_of_mem_inter_left hx')
    have : f_loc x = (œà ‚àò f) x' := calc f_loc x
      _ = (œà ‚àò f ‚àò œÜ.invFun) (œÜ x') := by rw [hx'x]
      _ = (œà ‚àò f) (œÜ.invFun (œÜ x')) := rfl
      _ = (œà ‚àò f) x' := by rw [this]
    --have : f x' ‚àà (f '' œÜ.source ‚à© œà.source) := by aesop
    aesop
  -- By definition, `f_loc` is `C^1` at `x' := œÜ x`.
  set x' := œÜ x
  have : ContDiffWithinAt ‚Ñù 1 f_loc (range I) x' := ((contMDiffAt_iff I J).mp hf).2
  have : ContDiffAt ‚Ñù 1 f_loc (œÜ x) := by rw [I.range_eq_univ] at this; exact this
  -- As shown before, `(df_loc)_œÜ x is also a linear isomorphism.
  have df_loc : E ‚âÉL[‚Ñù] E' := differential_in_charts_iso I J f' hf'
  let temp := differential_in_charts_iso_coe I J (chartAt H x) (chartAt H (f x)) f' hf'
  -- have temp' : ((differential_in_charts_iso I J f' hf').toLinearEquiv).toAddHom.toFun = (fderiv ‚Ñù f_loc x') := temp
  -- have temp'' : (df_loc.toLinearEquiv).toAddHom.toFun = (fderiv ‚Ñù f_loc x') := sorry -- not the same temp'
  -- TODO: different lemmas don't match; both expressions should be `fderiv ‚Ñù f_loc x'`
  obtain ‚ü®der, part2‚ü© := this.differentiableAt (by rfl)
  have mismatch : der = df_loc := by sorry
  have hdf'loc : HasFDerivAt (ùïú := ‚Ñù) f_loc df_loc x' := by rw [‚Üê mismatch]; exact part2

  -- By the Inverse Function Theorem on normed spaces, there are neighbourhoods U' and V' of x' and
  -- œà(f x)=f_loc x' and a C¬π function g_loc:V' \to U' such that f_loc and g_loc are inverses.
  let r := this.toLocalHomeomorph f_loc hdf'loc (by rfl)
  let U' := r.source
  let V' := r.target
  have aux : x' ‚àà U' := this.mem_toLocalHomeomorph_source hdf'loc (le_refl 1)
  have aux : f_loc x' ‚àà V' := this.image_mem_toLocalHomeomorph_target hdf'loc (le_refl 1)

  let g_loc := this.localInverse hdf'loc (by rfl)
  let gloc_diff := this.to_localInverse hdf'loc (by rfl)
  -- have : ContDiffAt ‚Ñù 1 g_loc (f_loc x') := gloc_diff
  -- xxx: is this missing API to argue r and g_loc are the same? I'll see!

  -- Shrinking U' and V' jointly if necessary, we may assume U'\subset U and V'\subset V.
  -- Skipping this for the moment; the details are slightly annoying.
  have : U' ‚äÜ U := sorry
  have : V' ‚äÜ V := sorry

  -- These yield open subsets `U` and `V` containing `x` and `f x`, respectively,
  let U := œÜ ‚Åª¬π' U'
  let V := œà ‚Åª¬π' V'
  have : IsOpen U := sorry
  have : x ‚àà U := sorry
  have : IsOpen V := sorry
  have : f x ‚àà V := sorry
  -- and a local inverse g of f.
  let g := œÜ.invFun ‚àò g_loc ‚àò œà
  have : MapsTo g V U := sorry -- check!

  -- We compute f = \psi^{-1}\circ\psi \tilde{f}\circ\phi^{-1}\circ\phi = \psi^{-1}\circ \tilde{f}\circ\phi on U. Hence, we deduce g\circ f=id on U and f\circ g =id_V.
  -- g is C¬π, since in the charts \phi and \psi, the local coordinate representation is \tilde{g},
  -- which is C¬π by definition.

  sorry
