/-
Copyright (c) 2020 Fox Thomson. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Fox Thomson, Markus Himmel
-/
import Mathlib.Data.Nat.Bitwise
import Mathlib.SetTheory.Game.Birthday
import Mathlib.SetTheory.Game.Impartial

#align_import set_theory.game.nim from "leanprover-community/mathlib"@"92ca63f0fb391a9ca5f22d2409a6080e786d99f7"

/-!
# Nim and the Sprague-Grundy theorem

This file contains the definition for nim for any ordinal `o`. In the game of `nim o‚ÇÅ` both players
may move to `nim o‚ÇÇ` for any `o‚ÇÇ < o‚ÇÅ`.
We also define a Grundy value for an impartial game `G` and prove the Sprague-Grundy theorem, that
`G` is equivalent to `nim (grundyValue G)`.
Finally, we compute the sum of finite Grundy numbers: if `G` and `H` have Grundy values `n` and `m`,
where `n` and `m` are natural numbers, then `G + H` has the Grundy value `n xor m`.

## Implementation details

The pen-and-paper definition of nim defines the possible moves of `nim o` to be `Set.Iio o`.
However, this definition does not work for us because it would make the type of nim
`ordinal.{u} ‚Üí pgame.{u + 1}`, which would make it impossible for us to state the Sprague-Grundy
theorem, since that requires the type of `nim` to be `ordinal.{u} ‚Üí pgame.{u}`. For this reason, we
instead use `o.out.Œ±` for the possible moves. You can use `to_left_moves_nim` and
`to_right_moves_nim` to convert an ordinal less than `o` into a left or right move of `nim o`, and
vice versa.
-/


noncomputable section

universe u

open scoped PGame

namespace PGame

-- Uses `noncomputable!` to avoid `rec_fn_macro only allowed in meta definitions` VM error
/-- The definition of single-heap nim, which can be viewed as a pile of stones where each player can
  take a positive number of stones from it on their turn. -/
noncomputable def nim : Ordinal.{u} ‚Üí PGame.{u}
  | o‚ÇÅ =>
    let f o‚ÇÇ :=
      have _ : Ordinal.typein o‚ÇÅ.out.r o‚ÇÇ < o‚ÇÅ := Ordinal.typein_lt_self o‚ÇÇ
      nim (Ordinal.typein o‚ÇÅ.out.r o‚ÇÇ)
    ‚ü®o‚ÇÅ.out.Œ±, o‚ÇÅ.out.Œ±, f, f‚ü©
termination_by nim o => o
#align pgame.nim PGame.nim

open Ordinal

theorem nim_def (o : Ordinal) :
    have : IsWellOrder (Quotient.out o).Œ± (¬∑ < ¬∑) := inferInstance
    nim o =
      PGame.mk o.out.Œ± o.out.Œ± (fun o‚ÇÇ => nim (Ordinal.typein (¬∑ < ¬∑) o‚ÇÇ)) fun o‚ÇÇ =>
        nim (Ordinal.typein (¬∑ < ¬∑) o‚ÇÇ) := by
  rw [nim]; rfl
  -- ‚ä¢ let_fun this := (_ : IsWellOrder (Quotient.out o).Œ± fun x x_1 => x < x_1);
            -- üéâ no goals
#align pgame.nim_def PGame.nim_def

theorem leftMoves_nim (o : Ordinal) : (nim o).LeftMoves = o.out.Œ± := by rw [nim_def]; rfl
                                                                        -- ‚ä¢ LeftMoves (mk (Quotient.out o).Œ± (Quotient.out o).Œ± (fun o‚ÇÇ => nim (typein ( ‚Ä¶
                                                                                      -- üéâ no goals
#align pgame.left_moves_nim PGame.leftMoves_nim

theorem rightMoves_nim (o : Ordinal) : (nim o).RightMoves = o.out.Œ± := by rw [nim_def]; rfl
                                                                          -- ‚ä¢ RightMoves (mk (Quotient.out o).Œ± (Quotient.out o).Œ± (fun o‚ÇÇ => nim (typein  ‚Ä¶
                                                                                        -- üéâ no goals
#align pgame.right_moves_nim PGame.rightMoves_nim

theorem moveLeft_nim_hEq (o : Ordinal) :
    have : IsWellOrder (Quotient.out o).Œ± (¬∑ < ¬∑) := inferInstance
    HEq (nim o).moveLeft fun i : o.out.Œ± => nim (typein (¬∑ < ¬∑) i) := by rw [nim_def]; rfl
                                                                         -- ‚ä¢ let_fun this := (_ : IsWellOrder (Quotient.out o).Œ± fun x x_1 => x < x_1);
                                                                                       -- üéâ no goals
#align pgame.move_left_nim_heq PGame.moveLeft_nim_hEq

theorem moveRight_nim_hEq (o : Ordinal) :
    have : IsWellOrder (Quotient.out o).Œ± (¬∑ < ¬∑) := inferInstance
    HEq (nim o).moveRight fun i : o.out.Œ± => nim (typein (¬∑ < ¬∑) i) := by rw [nim_def]; rfl
                                                                          -- ‚ä¢ let_fun this := (_ : IsWellOrder (Quotient.out o).Œ± fun x x_1 => x < x_1);
                                                                                        -- üéâ no goals
#align pgame.move_right_nim_heq PGame.moveRight_nim_hEq

/-- Turns an ordinal less than `o` into a left move for `nim o` and viceversa. -/
noncomputable def toLeftMovesNim {o : Ordinal} : Set.Iio o ‚âÉ (nim o).LeftMoves :=
  (enumIsoOut o).toEquiv.trans (Equiv.cast (leftMoves_nim o).symm)
#align pgame.to_left_moves_nim PGame.toLeftMovesNim

/-- Turns an ordinal less than `o` into a right move for `nim o` and viceversa. -/
noncomputable def toRightMovesNim {o : Ordinal} : Set.Iio o ‚âÉ (nim o).RightMoves :=
  (enumIsoOut o).toEquiv.trans (Equiv.cast (rightMoves_nim o).symm)
#align pgame.to_right_moves_nim PGame.toRightMovesNim

@[simp]
theorem toLeftMovesNim_symm_lt {o : Ordinal} (i : (nim o).LeftMoves) :
    ‚Üë(toLeftMovesNim.symm i) < o :=
  (toLeftMovesNim.symm i).prop
#align pgame.to_left_moves_nim_symm_lt PGame.toLeftMovesNim_symm_lt

@[simp]
theorem toRightMovesNim_symm_lt {o : Ordinal} (i : (nim o).RightMoves) :
    ‚Üë(toRightMovesNim.symm i) < o :=
  (toRightMovesNim.symm i).prop
#align pgame.to_right_moves_nim_symm_lt PGame.toRightMovesNim_symm_lt

@[simp]
theorem moveLeft_nim' {o : Ordinal.{u}} (i) :
    (nim o).moveLeft i = nim (toLeftMovesNim.symm i).val :=
  (congr_heq (moveLeft_nim_hEq o).symm (cast_heq _ i)).symm
#align pgame.move_left_nim' PGame.moveLeft_nim'

theorem moveLeft_nim {o : Ordinal} (i) : (nim o).moveLeft (toLeftMovesNim i) = nim i := by simp
                                                                                           -- üéâ no goals
#align pgame.move_left_nim PGame.moveLeft_nim

@[simp]
theorem moveRight_nim' {o : Ordinal} (i) : (nim o).moveRight i = nim (toRightMovesNim.symm i).val :=
  (congr_heq (moveRight_nim_hEq o).symm (cast_heq _ i)).symm
#align pgame.move_right_nim' PGame.moveRight_nim'

theorem moveRight_nim {o : Ordinal} (i) : (nim o).moveRight (toRightMovesNim i) = nim i := by simp
                                                                                              -- üéâ no goals
#align pgame.move_right_nim PGame.moveRight_nim

/-- A recursion principle for left moves of a nim game. -/
@[elab_as_elim]
def leftMovesNimRecOn {o : Ordinal} {P : (nim o).LeftMoves ‚Üí Sort*} (i : (nim o).LeftMoves)
    (H : ‚àÄ a (H : a < o), P <| toLeftMovesNim ‚ü®a, H‚ü©) : P i := by
  rw [‚Üê toLeftMovesNim.apply_symm_apply i]; apply H
  -- ‚ä¢ P (‚ÜëtoLeftMovesNim (‚ÜëtoLeftMovesNim.symm i))
                                            -- üéâ no goals
#align pgame.left_moves_nim_rec_on PGame.leftMovesNimRecOn

/-- A recursion principle for right moves of a nim game. -/
@[elab_as_elim]
def rightMovesNimRecOn {o : Ordinal} {P : (nim o).RightMoves ‚Üí Sort*} (i : (nim o).RightMoves)
    (H : ‚àÄ a (H : a < o), P <| toRightMovesNim ‚ü®a, H‚ü©) : P i := by
  rw [‚Üê toRightMovesNim.apply_symm_apply i]; apply H
  -- ‚ä¢ P (‚ÜëtoRightMovesNim (‚ÜëtoRightMovesNim.symm i))
                                             -- üéâ no goals
#align pgame.right_moves_nim_rec_on PGame.rightMovesNimRecOn

instance isEmpty_nim_zero_leftMoves : IsEmpty (nim 0).LeftMoves := by
  rw [nim_def]
  -- ‚ä¢ IsEmpty (LeftMoves (mk (Quotient.out 0).Œ± (Quotient.out 0).Œ± (fun o‚ÇÇ => nim  ‚Ä¶
  exact Ordinal.isEmpty_out_zero
  -- üéâ no goals
#align pgame.is_empty_nim_zero_left_moves PGame.isEmpty_nim_zero_leftMoves

instance isEmpty_nim_zero_rightMoves : IsEmpty (nim 0).RightMoves := by
  rw [nim_def]
  -- ‚ä¢ IsEmpty (RightMoves (mk (Quotient.out 0).Œ± (Quotient.out 0).Œ± (fun o‚ÇÇ => nim ‚Ä¶
  exact Ordinal.isEmpty_out_zero
  -- üéâ no goals
#align pgame.is_empty_nim_zero_right_moves PGame.isEmpty_nim_zero_rightMoves

/-- `nim 0` has exactly the same moves as `0`. -/
def nimZeroRelabelling : nim 0 ‚â°r 0 :=
  Relabelling.isEmpty _
#align pgame.nim_zero_relabelling PGame.nimZeroRelabelling

theorem nim_zero_equiv : nim 0 ‚âà 0 :=
  Equiv.isEmpty _
#align pgame.nim_zero_equiv PGame.nim_zero_equiv

noncomputable instance uniqueNimOneLeftMoves : Unique (nim 1).LeftMoves :=
  (Equiv.cast <| leftMoves_nim 1).unique
#align pgame.unique_nim_one_left_moves PGame.uniqueNimOneLeftMoves

noncomputable instance uniqueNimOneRightMoves : Unique (nim 1).RightMoves :=
  (Equiv.cast <| rightMoves_nim 1).unique
#align pgame.unique_nim_one_right_moves PGame.uniqueNimOneRightMoves

@[simp]
theorem default_nim_one_leftMoves_eq :
    (default : (nim 1).LeftMoves) = @toLeftMovesNim 1 ‚ü®0, Set.mem_Iio.mpr zero_lt_one‚ü© :=
  rfl
#align pgame.default_nim_one_left_moves_eq PGame.default_nim_one_leftMoves_eq

@[simp]
theorem default_nim_one_rightMoves_eq :
    (default : (nim 1).RightMoves) = @toRightMovesNim 1 ‚ü®0, Set.mem_Iio.mpr zero_lt_one‚ü© :=
  rfl
#align pgame.default_nim_one_right_moves_eq PGame.default_nim_one_rightMoves_eq

@[simp]
theorem toLeftMovesNim_one_symm (i) :
    (@toLeftMovesNim 1).symm i = ‚ü®0, Set.mem_Iio.mpr zero_lt_one‚ü© := by simp
                                                                        -- üéâ no goals
#align pgame.to_left_moves_nim_one_symm PGame.toLeftMovesNim_one_symm

@[simp]
theorem toRightMovesNim_one_symm (i) :
    (@toRightMovesNim 1).symm i = ‚ü®0, Set.mem_Iio.mpr zero_lt_one‚ü© := by simp
                                                                         -- üéâ no goals
#align pgame.to_right_moves_nim_one_symm PGame.toRightMovesNim_one_symm

theorem nim_one_moveLeft (x) : (nim 1).moveLeft x = nim 0 := by simp
                                                                -- üéâ no goals
#align pgame.nim_one_move_left PGame.nim_one_moveLeft

theorem nim_one_moveRight (x) : (nim 1).moveRight x = nim 0 := by simp
                                                                  -- üéâ no goals
#align pgame.nim_one_move_right PGame.nim_one_moveRight

/-- `nim 1` has exactly the same moves as `star`. -/
def nimOneRelabelling : nim 1 ‚â°r star := by
  rw [nim_def]
  -- ‚ä¢ (mk (Quotient.out 1).Œ± (Quotient.out 1).Œ± (fun o‚ÇÇ => nim (typein (fun x x_1  ‚Ä¶
  refine' ‚ü®_, _, fun i => _, fun j => _‚ü©
  any_goals dsimp; apply Equiv.equivOfUnique
  -- ‚ä¢ moveLeft (mk (Quotient.out 1).Œ± (Quotient.out 1).Œ± (fun o‚ÇÇ => nim (typein (f ‚Ä¶
  all_goals simp; exact nimZeroRelabelling
  -- üéâ no goals
#align pgame.nim_one_relabelling PGame.nimOneRelabelling

theorem nim_one_equiv : nim 1 ‚âà star :=
  nimOneRelabelling.equiv
#align pgame.nim_one_equiv PGame.nim_one_equiv

@[simp]
theorem nim_birthday (o : Ordinal) : (nim o).birthday = o := by
  induction' o using Ordinal.induction with o IH
  -- ‚ä¢ birthday (nim o) = o
  rw [nim_def, birthday_def]
  -- ‚ä¢ max (lsub fun i => birthday (moveLeft (mk (Quotient.out o).Œ± (Quotient.out o ‚Ä¶
  dsimp
  -- ‚ä¢ max (lsub fun i => birthday (nim (typein (fun x x_1 => x < x_1) i))) (lsub f ‚Ä¶
  rw [max_eq_right le_rfl]
  -- ‚ä¢ (lsub fun i => birthday (nim (typein (fun x x_1 => x < x_1) i))) = o
  convert lsub_typein o with i
  -- ‚ä¢ birthday (nim (typein (fun x x_1 => x < x_1) i)) = typein (fun x x_1 => x <  ‚Ä¶
  exact IH _ (typein_lt_self i)
  -- üéâ no goals
#align pgame.nim_birthday PGame.nim_birthday

@[simp]
theorem neg_nim (o : Ordinal) : -nim o = nim o := by
  induction' o using Ordinal.induction with o IH
  -- ‚ä¢ -nim o = nim o
  rw [nim_def]; dsimp; congr <;> funext i <;> exact IH _ (Ordinal.typein_lt_self i)
  -- ‚ä¢ (-mk (Quotient.out o).Œ± (Quotient.out o).Œ± (fun o‚ÇÇ => nim (typein (fun x x_1 ‚Ä¶
                -- ‚ä¢ (mk (Quotient.out o).Œ± (Quotient.out o).Œ± (fun j => -nim (typein (fun x x_1  ‚Ä¶
                       -- ‚ä¢ (fun j => -nim (typein (fun x x_1 => x < x_1) j)) = fun o‚ÇÇ => nim (typein (f ‚Ä¶
                                 -- ‚ä¢ -nim (typein (fun x x_1 => x < x_1) i) = nim (typein (fun x x_1 => x < x_1) i)
                                 -- ‚ä¢ -nim (typein (fun x x_1 => x < x_1) i) = nim (typein (fun x x_1 => x < x_1) i)
                                              -- üéâ no goals
                                              -- üéâ no goals
#align pgame.neg_nim PGame.neg_nim

instance nim_impartial (o : Ordinal) : Impartial (nim o) := by
  induction' o using Ordinal.induction with o IH
  -- ‚ä¢ Impartial (nim o)
  rw [impartial_def, neg_nim]
  -- ‚ä¢ nim o ‚âà nim o ‚àß (‚àÄ (i : LeftMoves (nim o)), Impartial (moveLeft (nim o) i))  ‚Ä¶
  refine' ‚ü®equiv_rfl, fun i => _, fun i => _‚ü© <;> simpa using IH _ (typein_lt_self _)
  -- ‚ä¢ Impartial (moveLeft (nim o) i)
                                                  -- üéâ no goals
                                                  -- üéâ no goals
#align pgame.nim_impartial PGame.nim_impartial

theorem nim_fuzzy_zero_of_ne_zero {o : Ordinal} (ho : o ‚â† 0) : nim o ‚Äñ 0 := by
  rw [Impartial.fuzzy_zero_iff_lf, nim_def, lf_zero_le]
  -- ‚ä¢ ‚àÉ j, moveRight (mk (Quotient.out o).Œ± (Quotient.out o).Œ± (fun o‚ÇÇ => nim (typ ‚Ä¶
  rw [‚Üê Ordinal.pos_iff_ne_zero] at ho
  -- ‚ä¢ ‚àÉ j, moveRight (mk (Quotient.out o).Œ± (Quotient.out o).Œ± (fun o‚ÇÇ => nim (typ ‚Ä¶
  exact ‚ü®(Ordinal.principalSegOut ho).top, by simp‚ü©
  -- üéâ no goals
#align pgame.nim_fuzzy_zero_of_ne_zero PGame.nim_fuzzy_zero_of_ne_zero

@[simp]
theorem nim_add_equiv_zero_iff (o‚ÇÅ o‚ÇÇ : Ordinal) : (nim o‚ÇÅ + nim o‚ÇÇ ‚âà 0) ‚Üî o‚ÇÅ = o‚ÇÇ := by
  constructor
  -- ‚ä¢ nim o‚ÇÅ + nim o‚ÇÇ ‚âà 0 ‚Üí o‚ÇÅ = o‚ÇÇ
  ¬∑ refine' not_imp_not.1 fun hne : _ ‚â† _ => (Impartial.not_equiv_zero_iff (nim o‚ÇÅ + nim o‚ÇÇ)).2 _
    -- ‚ä¢ nim o‚ÇÅ + nim o‚ÇÇ ‚Äñ 0
    wlog h : o‚ÇÅ < o‚ÇÇ
    -- ‚ä¢ nim o‚ÇÅ + nim o‚ÇÇ ‚Äñ 0
    ¬∑ exact (fuzzy_congr_left add_comm_equiv).1 (this _ _ hne.symm (hne.lt_or_lt.resolve_left h))
      -- üéâ no goals
    rw [Impartial.fuzzy_zero_iff_gf, zero_lf_le, nim_def o‚ÇÇ]
    -- ‚ä¢ ‚àÉ i, 0 ‚â§ moveLeft (nim o‚ÇÅ + mk (Quotient.out o‚ÇÇ).Œ± (Quotient.out o‚ÇÇ).Œ± (fun  ‚Ä¶
    refine' ‚ü®toLeftMovesAdd (Sum.inr _), _‚ü©
    -- ‚ä¢ LeftMoves (mk (Quotient.out o‚ÇÇ).Œ± (Quotient.out o‚ÇÇ).Œ± (fun o‚ÇÇ_1 => nim (type ‚Ä¶
    ¬∑ exact (Ordinal.principalSegOut h).top
      -- üéâ no goals
    ¬∑ -- Porting note: squeezed simp
      simpa only [Ordinal.typein_top, Ordinal.type_lt, PGame.add_moveLeft_inr, PGame.moveLeft_mk]
        using (Impartial.add_self (nim o‚ÇÅ)).2
  ¬∑ rintro rfl
    -- ‚ä¢ nim o‚ÇÅ + nim o‚ÇÅ ‚âà 0
    exact Impartial.add_self (nim o‚ÇÅ)
    -- üéâ no goals
#align pgame.nim_add_equiv_zero_iff PGame.nim_add_equiv_zero_iff

@[simp]
theorem nim_add_fuzzy_zero_iff {o‚ÇÅ o‚ÇÇ : Ordinal} : nim o‚ÇÅ + nim o‚ÇÇ ‚Äñ 0 ‚Üî o‚ÇÅ ‚â† o‚ÇÇ := by
  rw [iff_not_comm, Impartial.not_fuzzy_zero_iff, nim_add_equiv_zero_iff]
  -- üéâ no goals
#align pgame.nim_add_fuzzy_zero_iff PGame.nim_add_fuzzy_zero_iff

@[simp]
theorem nim_equiv_iff_eq {o‚ÇÅ o‚ÇÇ : Ordinal} : (nim o‚ÇÅ ‚âà nim o‚ÇÇ) ‚Üî o‚ÇÅ = o‚ÇÇ := by
  rw [Impartial.equiv_iff_add_equiv_zero, nim_add_equiv_zero_iff]
  -- üéâ no goals
#align pgame.nim_equiv_iff_eq PGame.nim_equiv_iff_eq

/-- The Grundy value of an impartial game, the ordinal which corresponds to the game of nim that the
 game is equivalent to -/
noncomputable def grundyValue : ‚àÄ _ : PGame.{u}, Ordinal.{u}
  | G => Ordinal.mex.{u, u} fun i => grundyValue (G.moveLeft i)
termination_by grundyValue G => G
decreasing_by pgame_wf_tac
              -- üéâ no goals
#align pgame.grundy_value PGame.grundyValue

theorem grundyValue_eq_mex_left (G : PGame) :
    grundyValue G = Ordinal.mex.{u, u} fun i => grundyValue (G.moveLeft i) := by rw [grundyValue]
                                                                                 -- üéâ no goals
#align pgame.grundy_value_eq_mex_left PGame.grundyValue_eq_mex_left

/-- The Sprague-Grundy theorem which states that every impartial game is equivalent to a game of
 nim, namely the game of nim corresponding to the games Grundy value -/
theorem equiv_nim_grundyValue : ‚àÄ (G : PGame.{u}) [G.Impartial], G ‚âà nim (grundyValue G)
  | G => by
    rw [Impartial.equiv_iff_add_equiv_zero, ‚Üê Impartial.forall_leftMoves_fuzzy_iff_equiv_zero]
    -- ‚ä¢ ‚àÄ (i : LeftMoves (x‚úù + nim (grundyValue x‚úù))), moveLeft (x‚úù + nim (grundyVal ‚Ä¶
    intro i
    -- ‚ä¢ moveLeft (x‚úù + nim (grundyValue x‚úù)) i ‚Äñ 0
    apply leftMoves_add_cases i
    -- ‚ä¢ ‚àÄ (i : LeftMoves x‚úù), moveLeft (x‚úù + nim (grundyValue x‚úù)) (‚ÜëtoLeftMovesAdd  ‚Ä¶
    ¬∑ intro i‚ÇÅ
      -- ‚ä¢ moveLeft (x‚úù + nim (grundyValue x‚úù)) (‚ÜëtoLeftMovesAdd (Sum.inl i‚ÇÅ)) ‚Äñ 0
      rw [add_moveLeft_inl]
      -- ‚ä¢ moveLeft x‚úù i‚ÇÅ + nim (grundyValue x‚úù) ‚Äñ 0
      apply
        (fuzzy_congr_left (add_congr_left (Equiv.symm (equiv_nim_grundyValue (G.moveLeft i‚ÇÅ))))).1
      rw [nim_add_fuzzy_zero_iff]
      -- ‚ä¢ grundyValue (moveLeft G i‚ÇÅ) ‚â† grundyValue x‚úù
      intro heq
      -- ‚ä¢ False
      rw [eq_comm, grundyValue_eq_mex_left G] at heq
      -- ‚ä¢ False
      -- Porting note: added universe annotation, argument
      have h := Ordinal.ne_mex.{u, u} (fun i ‚Ü¶ grundyValue (moveLeft G i))
      -- ‚ä¢ False
      rw [heq] at h
      -- ‚ä¢ False
      exact (h i‚ÇÅ).irrefl
      -- üéâ no goals
    ¬∑ intro i‚ÇÇ
      -- ‚ä¢ moveLeft (x‚úù + nim (grundyValue x‚úù)) (‚ÜëtoLeftMovesAdd (Sum.inr i‚ÇÇ)) ‚Äñ 0
      rw [add_moveLeft_inr, ‚Üê Impartial.exists_left_move_equiv_iff_fuzzy_zero]
      -- ‚ä¢ ‚àÉ i, moveLeft (x‚úù + moveLeft (nim (grundyValue x‚úù)) i‚ÇÇ) i ‚âà 0
      revert i‚ÇÇ
      -- ‚ä¢ ‚àÄ (i‚ÇÇ : LeftMoves (nim (grundyValue x‚úù))), ‚àÉ i, moveLeft (x‚úù + moveLeft (nim ‚Ä¶
      rw [nim_def]
      -- ‚ä¢ ‚àÄ (i‚ÇÇ : LeftMoves (mk (Quotient.out (grundyValue x‚úù)).Œ± (Quotient.out (grund ‚Ä¶
      intro i‚ÇÇ
      -- ‚ä¢ ‚àÉ i, moveLeft (x‚úù + moveLeft (mk (Quotient.out (grundyValue x‚úù)).Œ± (Quotient ‚Ä¶
      have h' :
        ‚àÉ i : G.LeftMoves,
          grundyValue (G.moveLeft i) = Ordinal.typein (Quotient.out (grundyValue G)).r i‚ÇÇ := by
        revert i‚ÇÇ
        rw [grundyValue_eq_mex_left]
        intro i‚ÇÇ
        have hnotin : _ ‚àâ _ := fun hin =>
          (le_not_le_of_lt (Ordinal.typein_lt_self i‚ÇÇ)).2 (csInf_le' hin)
        simpa using hnotin
      cases' h' with i hi
      -- ‚ä¢ ‚àÉ i, moveLeft (x‚úù + moveLeft (mk (Quotient.out (grundyValue x‚úù)).Œ± (Quotient ‚Ä¶
      use toLeftMovesAdd (Sum.inl i)
      -- ‚ä¢ moveLeft (x‚úù + moveLeft (mk (Quotient.out (grundyValue x‚úù)).Œ± (Quotient.out  ‚Ä¶
      rw [add_moveLeft_inl, moveLeft_mk]
      -- ‚ä¢ moveLeft x‚úù i + nim (typein (fun x x_1 => x < x_1) i‚ÇÇ) ‚âà 0
      apply Equiv.trans (add_congr_left (equiv_nim_grundyValue (G.moveLeft i)))
      -- ‚ä¢ nim (grundyValue (moveLeft G i)) + nim (typein (fun x x_1 => x < x_1) i‚ÇÇ) ‚âà 0
      simpa only [hi] using Impartial.add_self (nim (grundyValue (G.moveLeft i)))
      -- üéâ no goals
termination_by equiv_nim_grundyValue G _ => G
decreasing_by pgame_wf_tac
              -- üéâ no goals
              -- üéâ no goals
#align pgame.equiv_nim_grundy_value PGame.equiv_nim_grundyValue

theorem grundyValue_eq_iff_equiv_nim {G : PGame} [G.Impartial] {o : Ordinal} :
    grundyValue G = o ‚Üî (G ‚âà nim o) :=
  ‚ü®by rintro rfl; exact equiv_nim_grundyValue G,
      -- ‚ä¢ G ‚âà nim (grundyValue G)
                  -- üéâ no goals
   by intro h; rw [‚Üê nim_equiv_iff_eq]; exact Equiv.trans (Equiv.symm (equiv_nim_grundyValue G)) h‚ü©
      -- ‚ä¢ grundyValue G = o
               -- ‚ä¢ nim (grundyValue G) ‚âà nim o
                                        -- üéâ no goals
#align pgame.grundy_value_eq_iff_equiv_nim PGame.grundyValue_eq_iff_equiv_nim

@[simp]
theorem nim_grundyValue (o : Ordinal.{u}) : grundyValue (nim o) = o :=
  grundyValue_eq_iff_equiv_nim.2 PGame.equiv_rfl
#align pgame.nim_grundy_value PGame.nim_grundyValue

theorem grundyValue_eq_iff_equiv (G H : PGame) [G.Impartial] [H.Impartial] :
    grundyValue G = grundyValue H ‚Üî (G ‚âà H) :=
  grundyValue_eq_iff_equiv_nim.trans (equiv_congr_left.1 (equiv_nim_grundyValue H) _).symm
#align pgame.grundy_value_eq_iff_equiv PGame.grundyValue_eq_iff_equiv

@[simp]
theorem grundyValue_zero : grundyValue 0 = 0 :=
  grundyValue_eq_iff_equiv_nim.2 (Equiv.symm nim_zero_equiv)
#align pgame.grundy_value_zero PGame.grundyValue_zero

theorem grundyValue_iff_equiv_zero (G : PGame) [G.Impartial] : grundyValue G = 0 ‚Üî (G ‚âà 0) := by
  rw [‚Üê grundyValue_eq_iff_equiv, grundyValue_zero]
  -- üéâ no goals
#align pgame.grundy_value_iff_equiv_zero PGame.grundyValue_iff_equiv_zero

@[simp]
theorem grundyValue_star : grundyValue star = 1 :=
  grundyValue_eq_iff_equiv_nim.2 (Equiv.symm nim_one_equiv)
#align pgame.grundy_value_star PGame.grundyValue_star

@[simp]
theorem grundyValue_neg (G : PGame) [G.Impartial] : grundyValue (-G) = grundyValue G := by
  rw [grundyValue_eq_iff_equiv_nim, neg_equiv_iff, neg_nim, ‚Üê grundyValue_eq_iff_equiv_nim]
  -- üéâ no goals
#align pgame.grundy_value_neg PGame.grundyValue_neg

theorem grundyValue_eq_mex_right :
    ‚àÄ (G : PGame) [G.Impartial],
      grundyValue G = Ordinal.mex.{u, u} fun i => grundyValue (G.moveRight i)
   | ‚ü®l, r, L, R‚ü©, _ => by
    rw [‚Üê grundyValue_neg, grundyValue_eq_mex_left]
    -- ‚ä¢ (mex fun i => grundyValue (moveLeft (-mk l r L R) i)) = mex fun i => grundyV ‚Ä¶
    congr
    -- ‚ä¢ (fun i => grundyValue (moveLeft (-mk l r L R) i)) = fun i => grundyValue (mo ‚Ä¶
    ext i
    -- ‚ä¢ grundyValue (moveLeft (-mk l r L R) i) = grundyValue (moveRight (mk l r L R) ‚Ä¶
    haveI : (R i).Impartial := @Impartial.moveRight_impartial ‚ü®l, r, L, R‚ü© _ i
    -- ‚ä¢ grundyValue (moveLeft (-mk l r L R) i) = grundyValue (moveRight (mk l r L R) ‚Ä¶
    apply grundyValue_neg
    -- üéâ no goals
#align pgame.grundy_value_eq_mex_right PGame.grundyValue_eq_mex_right

-- Todo: this actually generalizes to all ordinals, by defining `Ordinal.lxor` as the pairwise
-- `Nat.lxor'` of base `œâ` Cantor normal forms.
/-- The Grundy value of the sum of two nim games with natural numbers of piles equals their bitwise
xor. -/
@[simp]
theorem grundyValue_nim_add_nim (n m : ‚Ñï) :
    grundyValue (nim.{u} n + nim.{u} m) = Nat.lxor' n m := by
  -- We do strong induction on both variables.
  induction' n using Nat.strong_induction_on with n hn generalizing m
  -- ‚ä¢ grundyValue (nim ‚Üën + nim ‚Üëm) = ‚Üë(Nat.lxor' n m)
  induction' m using Nat.strong_induction_on with m hm
  -- ‚ä¢ grundyValue (nim ‚Üën + nim ‚Üëm) = ‚Üë(Nat.lxor' n m)
  rw [grundyValue_eq_mex_left]
  -- ‚ä¢ (mex fun i => grundyValue (moveLeft (nim ‚Üën + nim ‚Üëm) i)) = ‚Üë(Nat.lxor' n m)
  refine (Ordinal.mex_le_of_ne.{u, u} fun i => ?_).antisymm
    (Ordinal.le_mex_of_forall fun ou hu => ?_)
  -- The Grundy value `Nat.lxor' n m` can't be reached by left moves.
  ¬∑ apply leftMoves_add_cases i <;>
    -- ‚ä¢ ‚àÄ (i : LeftMoves (nim ‚Üën)), grundyValue (moveLeft (nim ‚Üën + nim ‚Üëm) (‚ÜëtoLeft ‚Ä¶
      ¬∑ -- A left move leaves us with a Grundy value of `Nat.lxor' k m` for `k < n`, or
        -- `Nat.lxor' n k` for `k < m`.
        refine' fun a => leftMovesNimRecOn a fun ok hk => _
        -- ‚ä¢ grundyValue (moveLeft (nim ‚Üën + nim ‚Üëm) (‚ÜëtoLeftMovesAdd (Sum.inl (‚ÜëtoLeftMo ‚Ä¶
        -- ‚ä¢ grundyValue (moveLeft (nim ‚Üën + nim ‚Üëm) (‚ÜëtoLeftMovesAdd (Sum.inr (‚ÜëtoLeftMo ‚Ä¶
        -- ‚ä¢ grundyValue (moveLeft (nim ‚Üën + nim ‚Üëm) (‚ÜëtoLeftMovesAdd (Sum.inl (‚ÜëtoLeftMo ‚Ä¶
        obtain ‚ü®k, rfl‚ü© := Ordinal.lt_omega.1 (hk.trans (Ordinal.nat_lt_omega _))
        -- ‚ä¢ grundyValue (nim ‚Üëk + nim ‚Üëm) ‚â† ‚Üë(Nat.lxor' n m)
        -- ‚ä¢ grundyValue (moveLeft (nim ‚Üën + nim ‚Üëm) (‚ÜëtoLeftMovesAdd (Sum.inr (‚ÜëtoLeftMo ‚Ä¶
        simp only [add_moveLeft_inl, add_moveLeft_inr, moveLeft_nim', Equiv.symm_apply_apply]
        -- ‚ä¢ grundyValue (nim ‚Üëk + nim ‚Üëm) ‚â† ‚Üë(Nat.lxor' n m)
        -- ‚ä¢ grundyValue (nim ‚Üën + nim ‚Üëk) ‚â† ‚Üë(Nat.lxor' n m)
        -- The inequality follows from injectivity.
        rw [nat_cast_lt] at hk
        -- ‚ä¢ grundyValue (nim ‚Üën + nim ‚Üëk) ‚â† ‚Üë(Nat.lxor' n m)
        -- ‚ä¢ k = n
        first
        -- ‚ä¢ k = n
        | rw [hn _ hk]
        | rw [hm _ hk]
        refine' fun h => hk.ne _
        -- ‚ä¢ k = m
        rw [Ordinal.nat_cast_inj] at h
        -- ‚ä¢ k = m
        first
        | rwa [Nat.lxor'_left_inj] at h
        | rwa [Nat.lxor'_right_inj] at h
  -- Every other smaller Grundy value can be reached by left moves.
  ¬∑ -- If `u < Nat.lxor' m n`, then either `Nat.lxor' u n < m` or `Nat.lxor' u m < n`.
    obtain ‚ü®u, rfl‚ü© := Ordinal.lt_omega.1 (hu.trans (Ordinal.nat_lt_omega _))
    -- ‚ä¢ ‚àÉ i, grundyValue (moveLeft (nim ‚Üën + nim ‚Üëm) i) = ‚Üëu
    replace hu := Ordinal.nat_cast_lt.1 hu
    -- ‚ä¢ ‚àÉ i, grundyValue (moveLeft (nim ‚Üën + nim ‚Üëm) i) = ‚Üëu
    cases' Nat.lt_lxor'_cases hu with h h
    -- ‚ä¢ ‚àÉ i, grundyValue (moveLeft (nim ‚Üën + nim ‚Üëm) i) = ‚Üëu
    -- In the first case, reducing the `m` pile to `Nat.lxor' u n` gives the desired Grundy value.
    ¬∑ refine' ‚ü®toLeftMovesAdd (Sum.inl <| toLeftMovesNim ‚ü®_, Ordinal.nat_cast_lt.2 h‚ü©), _‚ü©
      -- ‚ä¢ grundyValue (moveLeft (nim ‚Üën + nim ‚Üëm) (‚ÜëtoLeftMovesAdd (Sum.inl (‚ÜëtoLeftMo ‚Ä¶
      simp [Nat.lxor_cancel_right, hn _ h]
      -- üéâ no goals
    -- In the second case, reducing the `n` pile to `Nat.lxor' u m` gives the desired Grundy value.
    ¬∑ refine' ‚ü®toLeftMovesAdd (Sum.inr <| toLeftMovesNim ‚ü®_, Ordinal.nat_cast_lt.2 h‚ü©), _‚ü©
      -- ‚ä¢ grundyValue (moveLeft (nim ‚Üën + nim ‚Üëm) (‚ÜëtoLeftMovesAdd (Sum.inr (‚ÜëtoLeftMo ‚Ä¶
      have : n.lxor' (u.lxor' n) = u; rw [Nat.lxor'_comm u, Nat.lxor'_cancel_left]
      -- ‚ä¢ Nat.lxor' n (Nat.lxor' u n) = u
                                      -- ‚ä¢ grundyValue (moveLeft (nim ‚Üën + nim ‚Üëm) (‚ÜëtoLeftMovesAdd (Sum.inr (‚ÜëtoLeftMo ‚Ä¶
      simpa [hm _ h] using this
      -- üéâ no goals
#align pgame.grundy_value_nim_add_nim PGame.grundyValue_nim_add_nim

theorem nim_add_nim_equiv {n m : ‚Ñï} : nim n + nim m ‚âà nim (Nat.lxor' n m) := by
  rw [‚Üê grundyValue_eq_iff_equiv_nim, grundyValue_nim_add_nim]
  -- üéâ no goals
#align pgame.nim_add_nim_equiv PGame.nim_add_nim_equiv

theorem grundyValue_add (G H : PGame) [G.Impartial] [H.Impartial] {n m : ‚Ñï} (hG : grundyValue G = n)
    (hH : grundyValue H = m) : grundyValue (G + H) = Nat.lxor' n m := by
  rw [‚Üê nim_grundyValue (Nat.lxor' n m), grundyValue_eq_iff_equiv]
  -- ‚ä¢ G + H ‚âà nim ‚Üë(Nat.lxor' n m)
  refine' Equiv.trans _ nim_add_nim_equiv
  -- ‚ä¢ G + H ‚âà nim ‚Üën + nim ‚Üëm
  convert add_congr (equiv_nim_grundyValue G) (equiv_nim_grundyValue H) <;> simp only [hG, hH]
  -- ‚ä¢ ‚Üën = grundyValue G
                                                                            -- üéâ no goals
                                                                            -- üéâ no goals
#align pgame.grundy_value_add PGame.grundyValue_add

end PGame
