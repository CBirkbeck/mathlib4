/-
Copyright (c) 2021 Ya√´l Dillies, Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Ya√´l Dillies, Bhavik Mehta, Hu·ª≥nh Tr·∫ßn Khanh, Stuart Presnell
-/
import Mathlib.Algebra.BigOperators.Basic
import Mathlib.Data.Finset.Sym
import Mathlib.Data.Fintype.Sum

#align_import data.sym.card from "leanprover-community/mathlib"@"0bd2ea37bcba5769e14866170f251c9bc64e35d7"

/-!
# Stars and bars

In this file, we prove (in `Sym.card_sym_eq_multichoose`) that the function `multichoose n k`
defined in `Data/Nat/Choose/Basic` counts the number of multisets of cardinality `k` over an
alphabet of cardinality `n`. In conjunction with `Nat.multichoose_eq` proved in
`Data/Nat/Choose/Basic`, which shows that `multichoose n k = choose (n + k - 1) k`,
this is central to the "stars and bars" technique in combinatorics, where we switch between
counting multisets of size `k` over an alphabet of size `n` to counting strings of `k` elements
("stars") separated by `n-1` dividers ("bars").

## Informal statement

Many problems in mathematics are of the form of (or can be reduced to) putting `k` indistinguishable
objects into `n` distinguishable boxes; for example, the problem of finding natural numbers
`x1, ..., xn` whose sum is `k`. This is equivalent to forming a multiset of cardinality `k` from
an alphabet of cardinality `n` -- for each box `i ‚àà [1, n]` the multiset contains as many copies
of `i` as there are items in the `i`th box.

The "stars and bars" technique arises from another way of presenting the same problem. Instead of
putting `k` items into `n` boxes, we take a row of `k` items (the "stars") and separate them by
inserting `n-1` dividers (the "bars").  For example, the pattern `*|||**|*|` exhibits 4 items
distributed into 6 boxes -- note that any box, including the first and last, may be empty.
Such arrangements of `k` stars and `n-1` bars are in 1-1 correspondence with multisets of size `k`
over an alphabet of size `n`, and are counted by `choose (n + k - 1) k`.

Note that this problem is one component of Gian-Carlo Rota's "Twelvefold Way"
https://en.wikipedia.org/wiki/Twelvefold_way

## Formal statement

Here we generalise the alphabet to an arbitrary fintype `Œ±`, and we use `Sym Œ± k` as the type of
multisets of size `k` over `Œ±`. Thus the statement that these are counted by `multichoose` is:
`Sym.card_sym_eq_multichoose : card (Sym Œ± k) = multichoose (card Œ±) k`
while the "stars and bars" technique gives
`Sym.card_sym_eq_choose : card (Sym Œ± k) = choose (card Œ± + k - 1) k`


## Tags

stars and bars, multichoose
-/


open Finset Fintype Function Sum Nat

variable {Œ± Œ≤ : Type*}

namespace Sym

section Sym

variable (Œ±) (n : ‚Ñï)

/-- Over `Fin (n + 1)`, the multisets of size `k + 1` containing `0` are equivalent to those of size
`k`, as demonstrated by respectively erasing or appending `0`. -/
protected def e1 {n k : ‚Ñï} : { s : Sym (Fin (n + 1)) (k + 1) // ‚Üë0 ‚àà s } ‚âÉ Sym (Fin n.succ) k where
  toFun s := s.1.erase 0 s.2
  invFun s := ‚ü®cons 0 s, mem_cons_self 0 s‚ü©
  left_inv s := by simp
                   -- üéâ no goals
  right_inv s := by simp
                    -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align sym.E1 Sym.e1

/-- The multisets of size `k` over `Fin n+2` not containing `0`
are equivalent to those of size `k` over `Fin n+1`,
as demonstrated by respectively decrementing or incrementing every element of the multiset.
-/
protected def e2 {n k : ‚Ñï} : { s : Sym (Fin n.succ.succ) k // ‚Üë0 ‚àâ s } ‚âÉ Sym (Fin n.succ) k where
  toFun s := map (Fin.predAbove 0) s.1
  invFun s :=
    ‚ü®map (Fin.succAbove 0) s,
      (mt mem_map.1) (not_exists.2 fun t => not_and.2 fun _ => Fin.succAbove_ne _ t)‚ü©
  left_inv s := by
    ext1
    -- ‚ä¢ ‚Üë((fun s => { val := map (Fin.succAbove 0) s, property := (_ : ¬¨0 ‚àà map (Fin ‚Ä¶
    simp only [map_map]
    -- ‚ä¢ map (Fin.succAbove 0 ‚àò Fin.predAbove 0) ‚Üës = ‚Üës
    refine (Sym.map_congr fun v hv ‚Ü¶ ?_).trans (map_id' _)
    -- ‚ä¢ (Fin.succAbove 0 ‚àò Fin.predAbove 0) v = v
    exact Fin.succAbove_predAbove (ne_of_mem_of_not_mem hv s.2)
    -- üéâ no goals
  right_inv s := by
    simp only [map_map, comp_apply, ‚Üê Fin.castSucc_zero, Fin.predAbove_succAbove, map_id']
    -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align sym.E2 Sym.e2

-- porting note: use eqn compiler instead of `pincerRecursion` to make cases more readable
theorem card_sym_fin_eq_multichoose : ‚àÄ n k : ‚Ñï, card (Sym (Fin n) k) = multichoose n k
  | n, 0 => by simp
               -- üéâ no goals
  | 0, k + 1 => by rw [multichoose_zero_succ]; exact card_eq_zero
                   -- ‚ä¢ Fintype.card (Sym (Fin 0) (k + 1)) = 0
                                               -- üéâ no goals
  | 1, k + 1 => by simp
                   -- üéâ no goals
  | n + 2, k + 1 => by
    rw [multichoose_succ_succ, ‚Üê card_sym_fin_eq_multichoose (n + 1) (k + 1),
      ‚Üê card_sym_fin_eq_multichoose (n + 2) k, add_comm (Fintype.card _), ‚Üê card_sum]
    refine Fintype.card_congr (Equiv.symm ?_)
    -- ‚ä¢ Sym (Fin (n + 2)) k ‚äï Sym (Fin (n + 1)) (k + 1) ‚âÉ Sym (Fin (n + 2)) (k + 1)
    apply (Sym.e1.symm.sumCongr Sym.e2.symm).trans
    -- ‚ä¢ { s // 0 ‚àà s } ‚äï { s // ¬¨0 ‚àà s } ‚âÉ Sym (Fin (n + 2)) (k + 1)
    apply Equiv.sumCompl
    -- üéâ no goals
  termination_by card_sym_fin_eq_multichoose n k => n + k
#align sym.card_sym_fin_eq_multichoose Sym.card_sym_fin_eq_multichoose

/-- For any fintype `Œ±` of cardinality `n`, `card (Sym Œ± k) = multichoose (card Œ±) k`. -/
theorem card_sym_eq_multichoose (Œ± : Type*) (k : ‚Ñï) [Fintype Œ±] [Fintype (Sym Œ± k)] :
    card (Sym Œ± k) = multichoose (card Œ±) k := by
  rw [‚Üê card_sym_fin_eq_multichoose]
  -- ‚ä¢ Fintype.card (Sym Œ± k) = Fintype.card (Sym (Fin (Fintype.card Œ±)) k)
  exact card_congr (equivCongr (equivFin Œ±))
  -- üéâ no goals
#align sym.card_sym_eq_multichoose Sym.card_sym_eq_multichoose

/-- The *stars and bars* lemma: the cardinality of `Sym Œ± k` is equal to
`Nat.choose (card Œ± + k - 1) k`. -/
theorem card_sym_eq_choose {Œ± : Type*} [Fintype Œ±] (k : ‚Ñï) [Fintype (Sym Œ± k)] :
    card (Sym Œ± k) = (card Œ± + k - 1).choose k := by
  rw [card_sym_eq_multichoose, Nat.multichoose_eq]
  -- üéâ no goals
#align sym.card_sym_eq_choose Sym.card_sym_eq_choose

end Sym

end Sym

namespace Sym2

variable [DecidableEq Œ±]

/-- The `diag` of `s : Finset Œ±` is sent on a finset of `Sym2 Œ±` of card `s.card`. -/
theorem card_image_diag (s : Finset Œ±) : (s.diag.image Quotient.mk').card = s.card := by
  rw [card_image_of_injOn, diag_card]
  -- ‚ä¢ Set.InjOn Quotient.mk' ‚Üë(Finset.diag s)
  rintro ‚ü®x‚ÇÄ, x‚ÇÅ‚ü© hx _ _ h
  -- ‚ä¢ (x‚ÇÄ, x‚ÇÅ) = x‚ÇÇ‚úù
  cases Quotient.eq'.1 h
  -- ‚ä¢ (x‚ÇÄ, x‚ÇÅ) = (x‚ÇÄ, x‚ÇÅ)
  ¬∑ rfl
    -- üéâ no goals
  ¬∑ simp only [mem_coe, mem_diag] at hx
    -- ‚ä¢ (x‚ÇÄ, x‚ÇÅ) = (x‚ÇÅ, x‚ÇÄ)
    rw [hx.2]
    -- üéâ no goals
#align sym2.card_image_diag Sym2.card_image_diag

theorem two_mul_card_image_offDiag (s : Finset Œ±) :
    2 * (s.offDiag.image Quotient.mk').card = s.offDiag.card := by
  rw [card_eq_sum_card_image (Quotient.mk' : Œ± √ó Œ± ‚Üí _), sum_const_nat (Quotient.ind' _), mul_comm]
  -- ‚ä¢ ‚àÄ (a : Œ± √ó Œ±), Quotient.mk'' a ‚àà image Quotient.mk' (offDiag s) ‚Üí Finset.car ‚Ä¶
  rintro ‚ü®x, y‚ü© hxy
  -- ‚ä¢ Finset.card (filter (fun x_1 => Quotient.mk' x_1 = Quotient.mk'' (x, y)) (of ‚Ä¶
  simp_rw [mem_image, mem_offDiag] at hxy
  -- ‚ä¢ Finset.card (filter (fun x_1 => Quotient.mk' x_1 = Quotient.mk'' (x, y)) (of ‚Ä¶
  obtain ‚ü®a, ‚ü®ha‚ÇÅ, ha‚ÇÇ, ha‚ü©, h‚ü© := hxy
  -- ‚ä¢ Finset.card (filter (fun x_1 => Quotient.mk' x_1 = Quotient.mk'' (x, y)) (of ‚Ä¶
  replace h := Quotient.eq.1 h
  -- ‚ä¢ Finset.card (filter (fun x_1 => Quotient.mk' x_1 = Quotient.mk'' (x, y)) (of ‚Ä¶
  obtain ‚ü®hx, hy, hxy‚ü© : x ‚àà s ‚àß y ‚àà s ‚àß x ‚â† y := by
    cases h <;> refine' ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, _‚ü© <;> [exact ha; exact ha.symm]
  have hxy' : y ‚â† x := hxy.symm
  -- ‚ä¢ Finset.card (filter (fun x_1 => Quotient.mk' x_1 = Quotient.mk'' (x, y)) (of ‚Ä¶
  have : (s.offDiag.filter fun z => ‚ü¶z‚üß = ‚ü¶(x, y)‚üß) = ({(x, y), (y, x)} : Finset _) := by
    ext ‚ü®x‚ÇÅ, y‚ÇÅ‚ü©
    rw [mem_filter, mem_insert, mem_singleton, Sym2.eq_iff, Prod.mk.inj_iff, Prod.mk.inj_iff,
      and_iff_right_iff_imp]
    -- `hxy'` is used in `exact`
    rintro (‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©) <;> rw [mem_offDiag] <;> exact ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©
  dsimp [Quotient.mk', Quotient.mk''_eq_mk] -- Porting note: Added `dsimp`
  -- ‚ä¢ Finset.card (filter (fun x_1 => Quotient.mk (Rel.setoid Œ±) x_1 = Quotient.mk ‚Ä¶
  rw [this, card_insert_of_not_mem, card_singleton]
  -- ‚ä¢ ¬¨(x, y) ‚àà {(y, x)}
  simp only [not_and, Prod.mk.inj_iff, mem_singleton]
  -- ‚ä¢ x = y ‚Üí ¬¨y = x
  exact fun _ => hxy'
  -- üéâ no goals
#align sym2.two_mul_card_image_off_diag Sym2.two_mul_card_image_offDiag

/-- The `offDiag` of `s : Finset Œ±` is sent on a finset of `Sym2 Œ±` of card `s.offDiag.card / 2`.
This is because every element `‚ü¶(x, y)‚üß` of `Sym2 Œ±` not on the diagonal comes from exactly two
pairs: `(x, y)` and `(y, x)`. -/
theorem card_image_offDiag (s : Finset Œ±) :
    (s.offDiag.image Quotient.mk').card = s.card.choose 2 := by
  rw [Nat.choose_two_right, mul_tsub, mul_one, ‚Üê offDiag_card,
    Nat.div_eq_of_eq_mul_right zero_lt_two (two_mul_card_image_offDiag s).symm]
#align sym2.card_image_off_diag Sym2.card_image_offDiag

theorem card_subtype_diag [Fintype Œ±] : card { a : Sym2 Œ± // a.IsDiag } = card Œ± := by
  convert card_image_diag (univ : Finset Œ±)
  -- ‚ä¢ Fintype.card { a // IsDiag a } = Finset.card (image Quotient.mk' (Finset.dia ‚Ä¶
  simp_rw [Quotient.mk', ‚Üê Quotient.mk''_eq_mk] -- Porting note: Added `simp_rw`
  -- ‚ä¢ Fintype.card { a // IsDiag a } = Finset.card (image (fun a => Quotient.mk''  ‚Ä¶
  rw [Fintype.card_of_subtype, ‚Üê filter_image_quotient_mk''_isDiag]
  -- ‚ä¢ ‚àÄ (x : Sym2 Œ±), x ‚àà filter IsDiag (image Quotient.mk'' (univ √óÀ¢ univ)) ‚Üî IsD ‚Ä¶
  rintro x
  -- ‚ä¢ x ‚àà filter IsDiag (image Quotient.mk'' (univ √óÀ¢ univ)) ‚Üî IsDiag x
  rw [mem_filter, univ_product_univ, mem_image]
  -- ‚ä¢ (‚àÉ a, a ‚àà univ ‚àß Quotient.mk'' a = x) ‚àß IsDiag x ‚Üî IsDiag x
  obtain ‚ü®a, ha‚ü© := Quotient.exists_rep x
  -- ‚ä¢ (‚àÉ a, a ‚àà univ ‚àß Quotient.mk'' a = x) ‚àß IsDiag x ‚Üî IsDiag x
  exact and_iff_right ‚ü®a, mem_univ _, ha‚ü©
  -- üéâ no goals
#align sym2.card_subtype_diag Sym2.card_subtype_diag

theorem card_subtype_not_diag [Fintype Œ±] :
    card { a : Sym2 Œ± // ¬¨a.IsDiag } = (card Œ±).choose 2 := by
  convert card_image_offDiag (univ : Finset Œ±)
  -- ‚ä¢ Fintype.card { a // ¬¨IsDiag a } = Finset.card (image Quotient.mk' (offDiag u ‚Ä¶
  simp_rw [Quotient.mk', ‚Üê Quotient.mk''_eq_mk] -- Porting note: Added `simp_rw`
  -- ‚ä¢ Fintype.card { a // ¬¨IsDiag a } = Finset.card (image (fun a => Quotient.mk'' ‚Ä¶
  rw [Fintype.card_of_subtype, ‚Üê filter_image_quotient_mk''_not_isDiag]
  -- ‚ä¢ ‚àÄ (x : Sym2 Œ±), x ‚àà filter (fun a => ¬¨IsDiag a) (image Quotient.mk'' (univ √ó ‚Ä¶
  rintro x
  -- ‚ä¢ x ‚àà filter (fun a => ¬¨IsDiag a) (image Quotient.mk'' (univ √óÀ¢ univ)) ‚Üî ¬¨IsDi ‚Ä¶
  rw [mem_filter, univ_product_univ, mem_image]
  -- ‚ä¢ (‚àÉ a, a ‚àà univ ‚àß Quotient.mk'' a = x) ‚àß ¬¨IsDiag x ‚Üî ¬¨IsDiag x
  obtain ‚ü®a, ha‚ü© := Quotient.exists_rep x
  -- ‚ä¢ (‚àÉ a, a ‚àà univ ‚àß Quotient.mk'' a = x) ‚àß ¬¨IsDiag x ‚Üî ¬¨IsDiag x
  exact and_iff_right ‚ü®a, mem_univ _, ha‚ü©
  -- üéâ no goals
#align sym2.card_subtype_not_diag Sym2.card_subtype_not_diag

/-- Finset **stars and bars** for the case `n = 2`. -/
theorem _root_.Finset.card_sym2 (s : Finset Œ±) : s.sym2.card = s.card * (s.card + 1) / 2 := by
  rw [‚Üê image_diag_union_image_offDiag, card_union_eq, Sym2.card_image_diag,
    Sym2.card_image_offDiag, Nat.choose_two_right, add_comm, ‚Üê Nat.triangle_succ, Nat.succ_sub_one,
    mul_comm]
  rw [disjoint_left]
  -- ‚ä¢ ‚àÄ ‚¶Éa : Quotient (Rel.setoid Œ±)‚¶Ñ, a ‚àà image Quotient.mk' (Finset.diag s) ‚Üí ¬¨a ‚Ä¶
  rintro m ha hb
  -- ‚ä¢ False
  rw [mem_image] at ha hb
  -- ‚ä¢ False
  obtain ‚ü®‚ü®a, ha, rfl‚ü©, ‚ü®b, hb, hab‚ü©‚ü© := ha, hb
  -- ‚ä¢ False
  refine' not_isDiag_mk'_of_mem_offDiag hb _
  -- ‚ä¢ IsDiag (Quotient.mk (Rel.setoid Œ±) b)
  dsimp [Quotient.mk'] at hab -- Porting note: Added `dsimp`
  -- ‚ä¢ IsDiag (Quotient.mk (Rel.setoid Œ±) b)
  rw [hab]
  -- ‚ä¢ IsDiag (Quotient.mk (Rel.setoid Œ±) a)
  exact isDiag_mk'_of_mem_diag ha
  -- üéâ no goals
#align finset.card_sym2 Finset.card_sym2

/-- Type **stars and bars** for the case `n = 2`. -/
protected theorem card [Fintype Œ±] : card (Sym2 Œ±) = card Œ± * (card Œ± + 1) / 2 :=
  Finset.card_sym2 _
#align sym2.card Sym2.card

end Sym2
