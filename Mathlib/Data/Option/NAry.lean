/-
Copyright (c) 2022 Ya√´l Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Ya√´l Dillies
-/
import Mathlib.Data.Option.Basic

#align_import data.option.n_ary from "leanprover-community/mathlib"@"995b47e555f1b6297c7cf16855f1023e355219fb"

/-!
# Binary map of options

This file defines the binary map of `Option`. This is mostly useful to define pointwise operations
on intervals.

## Main declarations

* `Option.map‚ÇÇ`: Binary map of options.

## Notes

This file is very similar to the n-ary section of `Mathlib.Data.Set.Basic`, to
`Mathlib.Data.Finset.NAry` and to `Mathlib.Order.Filter.NAry`. Please keep them in sync.
(porting note - only some of these may exist right now!)

We do not define `Option.map‚ÇÉ` as its only purpose so far would be to prove properties of
`Option.map‚ÇÇ` and casing already fulfills this task.
-/

set_option autoImplicit true


open Function

namespace Option

variable {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {a : Option Œ±} {b : Option Œ≤} {c : Option Œ≥}

/-- The image of a binary function `f : Œ± ‚Üí Œ≤ ‚Üí Œ≥` as a function `Option Œ± ‚Üí Option Œ≤ ‚Üí Option Œ≥`.
Mathematically this should be thought of as the image of the corresponding function `Œ± √ó Œ≤ ‚Üí Œ≥`. -/
def map‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (a : Option Œ±) (b : Option Œ≤) : Option Œ≥ :=
  a.bind fun a => b.map <| f a
#align option.map‚ÇÇ Option.map‚ÇÇ

/-- `Option.map‚ÇÇ` in terms of monadic operations. Note that this can't be taken as the definition
because of the lack of universe polymorphism. -/
theorem map‚ÇÇ_def {Œ± Œ≤ Œ≥ : Type _} (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (a : Option Œ±) (b : Option Œ≤) :
    map‚ÇÇ f a b = f <$> a <*> b :=
  by cases a <;> rfl
     -- ‚ä¢ map‚ÇÇ f none b = Seq.seq (f <$> none) fun x => b
                 -- üéâ no goals
                 -- üéâ no goals
#align option.map‚ÇÇ_def Option.map‚ÇÇ_def

-- porting note: In Lean3, was `@[simp]` but now `simp` can prove it
theorem map‚ÇÇ_some_some (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (a : Œ±) (b : Œ≤) : map‚ÇÇ f (some a) (some b) = f a b := rfl
#align option.map‚ÇÇ_some_some Option.map‚ÇÇ_some_some

theorem map‚ÇÇ_coe_coe (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (a : Œ±) (b : Œ≤) : map‚ÇÇ f a b = f a b := rfl
#align option.map‚ÇÇ_coe_coe Option.map‚ÇÇ_coe_coe

@[simp]
theorem map‚ÇÇ_none_left (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (b : Option Œ≤) : map‚ÇÇ f none b = none := rfl
#align option.map‚ÇÇ_none_left Option.map‚ÇÇ_none_left

@[simp]
theorem map‚ÇÇ_none_right (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (a : Option Œ±) : map‚ÇÇ f a none = none := by cases a <;> rfl
                                                                                    -- ‚ä¢ map‚ÇÇ f none none = none
                                                                                                -- üéâ no goals
                                                                                                -- üéâ no goals
#align option.map‚ÇÇ_none_right Option.map‚ÇÇ_none_right

@[simp]
theorem map‚ÇÇ_coe_left (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (a : Œ±) (b : Option Œ≤) : map‚ÇÇ f a b = b.map fun b => f a b :=
  rfl
#align option.map‚ÇÇ_coe_left Option.map‚ÇÇ_coe_left

-- porting note: This proof was `rfl` in Lean3, but now is not.
@[simp]
theorem map‚ÇÇ_coe_right (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (a : Option Œ±) (b : Œ≤) : map‚ÇÇ f a b = a.map fun a => f a b :=
  by cases a <;> rfl
     -- ‚ä¢ map‚ÇÇ f none (some b) = Option.map (fun a => f a b) none
                 -- üéâ no goals
                 -- üéâ no goals
#align option.map‚ÇÇ_coe_right Option.map‚ÇÇ_coe_right

-- porting note: Removed the `@[simp]` tag as membership of an `Option` is no-longer simp-normal.
theorem mem_map‚ÇÇ_iff {c : Œ≥} : c ‚àà map‚ÇÇ f a b ‚Üî ‚àÉ a' b', a' ‚àà a ‚àß b' ‚àà b ‚àß f a' b' = c :=
  by simp [map‚ÇÇ]
     -- üéâ no goals
#align option.mem_map‚ÇÇ_iff Option.mem_map‚ÇÇ_iff

@[simp]
theorem map‚ÇÇ_eq_none_iff : map‚ÇÇ f a b = none ‚Üî a = none ‚à® b = none :=
  by cases a <;> cases b <;> simp
     -- ‚ä¢ map‚ÇÇ f none b = none ‚Üî none = none ‚à® b = none
                 -- ‚ä¢ map‚ÇÇ f none none = none ‚Üî none = none ‚à® none = none
                 -- ‚ä¢ map‚ÇÇ f (some val‚úù) none = none ‚Üî some val‚úù = none ‚à® none = none
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
#align option.map‚ÇÇ_eq_none_iff Option.map‚ÇÇ_eq_none_iff

theorem map‚ÇÇ_swap (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (a : Option Œ±) (b : Option Œ≤) :
    map‚ÇÇ f a b = map‚ÇÇ (fun a b => f b a) b a := by cases a <;> cases b <;> rfl
                                                   -- ‚ä¢ map‚ÇÇ f none b = map‚ÇÇ (fun a b => f b a) b none
                                                               -- ‚ä¢ map‚ÇÇ f none none = map‚ÇÇ (fun a b => f b a) none none
                                                               -- ‚ä¢ map‚ÇÇ f (some val‚úù) none = map‚ÇÇ (fun a b => f b a) none (some val‚úù)
                                                                           -- üéâ no goals
                                                                           -- üéâ no goals
                                                                           -- üéâ no goals
                                                                           -- üéâ no goals
#align option.map‚ÇÇ_swap Option.map‚ÇÇ_swap

theorem map_map‚ÇÇ (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (g : Œ≥ ‚Üí Œ¥) :
    (map‚ÇÇ f a b).map g = map‚ÇÇ (fun a b => g (f a b)) a b := by cases a <;> cases b <;> rfl
                                                               -- ‚ä¢ Option.map g (map‚ÇÇ f none b) = map‚ÇÇ (fun a b => g (f a b)) none b
                                                                           -- ‚ä¢ Option.map g (map‚ÇÇ f none none) = map‚ÇÇ (fun a b => g (f a b)) none none
                                                                           -- ‚ä¢ Option.map g (map‚ÇÇ f (some val‚úù) none) = map‚ÇÇ (fun a b => g (f a b)) (some v ‚Ä¶
                                                                                       -- üéâ no goals
                                                                                       -- üéâ no goals
                                                                                       -- üéâ no goals
                                                                                       -- üéâ no goals
#align option.map_map‚ÇÇ Option.map_map‚ÇÇ

theorem map‚ÇÇ_map_left (f : Œ≥ ‚Üí Œ≤ ‚Üí Œ¥) (g : Œ± ‚Üí Œ≥) :
    map‚ÇÇ f (a.map g) b = map‚ÇÇ (fun a b => f (g a) b) a b := by cases a <;> rfl
                                                               -- ‚ä¢ map‚ÇÇ f (Option.map g none) b = map‚ÇÇ (fun a b => f (g a) b) none b
                                                                           -- üéâ no goals
                                                                           -- üéâ no goals
#align option.map‚ÇÇ_map_left Option.map‚ÇÇ_map_left

theorem map‚ÇÇ_map_right (f : Œ± ‚Üí Œ≥ ‚Üí Œ¥) (g : Œ≤ ‚Üí Œ≥) :
    map‚ÇÇ f a (b.map g) = map‚ÇÇ (fun a b => f a (g b)) a b := by cases b <;> rfl
                                                               -- ‚ä¢ map‚ÇÇ f a (Option.map g none) = map‚ÇÇ (fun a b => f a (g b)) a none
                                                                           -- üéâ no goals
                                                                           -- üéâ no goals
#align option.map‚ÇÇ_map_right Option.map‚ÇÇ_map_right

@[simp]
theorem map‚ÇÇ_curry (f : Œ± √ó Œ≤ ‚Üí Œ≥) (a : Option Œ±) (b : Option Œ≤) :
    map‚ÇÇ (curry f) a b = Option.map f (map‚ÇÇ Prod.mk a b) := (map_map‚ÇÇ _ _).symm
#align option.map‚ÇÇ_curry Option.map‚ÇÇ_curry

@[simp]
theorem map_uncurry (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (x : Option (Œ± √ó Œ≤)) :
    x.map (uncurry f) = map‚ÇÇ f (x.map Prod.fst) (x.map Prod.snd) := by cases x <;> rfl
                                                                       -- ‚ä¢ Option.map (uncurry f) none = map‚ÇÇ f (Option.map Prod.fst none) (Option.map  ‚Ä¶
                                                                                   -- üéâ no goals
                                                                                   -- üéâ no goals
#align option.map_uncurry Option.map_uncurry

/-!
### Algebraic replacement rules

A collection of lemmas to transfer associativity, commutativity, distributivity, ... of operations
to the associativity, commutativity, distributivity, ... of `Option.map‚ÇÇ` of those operations.
The proof pattern is `map‚ÇÇ_lemma operation_lemma`. For example, `map‚ÇÇ_comm mul_comm` proves that
`map‚ÇÇ (*) a b = map‚ÇÇ (*) g f` in a `CommSemigroup`.
-/

theorem map‚ÇÇ_assoc {f : Œ¥ ‚Üí Œ≥ ‚Üí Œµ} {g : Œ± ‚Üí Œ≤ ‚Üí Œ¥} {f' : Œ± ‚Üí Œµ' ‚Üí Œµ} {g' : Œ≤ ‚Üí Œ≥ ‚Üí Œµ'}
    (h_assoc : ‚àÄ a b c, f (g a b) c = f' a (g' b c)) :
    map‚ÇÇ f (map‚ÇÇ g a b) c = map‚ÇÇ f' a (map‚ÇÇ g' b c) :=
  by cases a <;> cases b <;> cases c <;> simp [h_assoc]
     -- ‚ä¢ map‚ÇÇ f (map‚ÇÇ g none b) c = map‚ÇÇ f' none (map‚ÇÇ g' b c)
                 -- ‚ä¢ map‚ÇÇ f (map‚ÇÇ g none none) c = map‚ÇÇ f' none (map‚ÇÇ g' none c)
                 -- ‚ä¢ map‚ÇÇ f (map‚ÇÇ g (some val‚úù) none) c = map‚ÇÇ f' (some val‚úù) (map‚ÇÇ g' none c)
                             -- ‚ä¢ map‚ÇÇ f (map‚ÇÇ g none none) none = map‚ÇÇ f' none (map‚ÇÇ g' none none)
                             -- ‚ä¢ map‚ÇÇ f (map‚ÇÇ g none (some val‚úù)) none = map‚ÇÇ f' none (map‚ÇÇ g' (some val‚úù) no ‚Ä¶
                             -- ‚ä¢ map‚ÇÇ f (map‚ÇÇ g (some val‚úù) none) none = map‚ÇÇ f' (some val‚úù) (map‚ÇÇ g' none no ‚Ä¶
                             -- ‚ä¢ map‚ÇÇ f (map‚ÇÇ g (some val‚úù¬π) (some val‚úù)) none = map‚ÇÇ f' (some val‚úù¬π) (map‚ÇÇ g ‚Ä¶
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
#align option.map‚ÇÇ_assoc Option.map‚ÇÇ_assoc

theorem map‚ÇÇ_comm {g : Œ≤ ‚Üí Œ± ‚Üí Œ≥} (h_comm : ‚àÄ a b, f a b = g b a) : map‚ÇÇ f a b = map‚ÇÇ g b a :=
  by cases a <;> cases b <;> simp [h_comm]
     -- ‚ä¢ map‚ÇÇ f none b = map‚ÇÇ g b none
                 -- ‚ä¢ map‚ÇÇ f none none = map‚ÇÇ g none none
                 -- ‚ä¢ map‚ÇÇ f (some val‚úù) none = map‚ÇÇ g none (some val‚úù)
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
#align option.map‚ÇÇ_comm Option.map‚ÇÇ_comm

theorem map‚ÇÇ_left_comm {f : Œ± ‚Üí Œ¥ ‚Üí Œµ} {g : Œ≤ ‚Üí Œ≥ ‚Üí Œ¥} {f' : Œ± ‚Üí Œ≥ ‚Üí Œ¥'} {g' : Œ≤ ‚Üí Œ¥' ‚Üí Œµ}
    (h_left_comm : ‚àÄ a b c, f a (g b c) = g' b (f' a c)) :
    map‚ÇÇ f a (map‚ÇÇ g b c) = map‚ÇÇ g' b (map‚ÇÇ f' a c) :=
  by cases a <;> cases b <;> cases c <;> simp [h_left_comm]
     -- ‚ä¢ map‚ÇÇ f none (map‚ÇÇ g b c) = map‚ÇÇ g' b (map‚ÇÇ f' none c)
                 -- ‚ä¢ map‚ÇÇ f none (map‚ÇÇ g none c) = map‚ÇÇ g' none (map‚ÇÇ f' none c)
                 -- ‚ä¢ map‚ÇÇ f (some val‚úù) (map‚ÇÇ g none c) = map‚ÇÇ g' none (map‚ÇÇ f' (some val‚úù) c)
                             -- ‚ä¢ map‚ÇÇ f none (map‚ÇÇ g none none) = map‚ÇÇ g' none (map‚ÇÇ f' none none)
                             -- ‚ä¢ map‚ÇÇ f none (map‚ÇÇ g (some val‚úù) none) = map‚ÇÇ g' (some val‚úù) (map‚ÇÇ f' none no ‚Ä¶
                             -- ‚ä¢ map‚ÇÇ f (some val‚úù) (map‚ÇÇ g none none) = map‚ÇÇ g' none (map‚ÇÇ f' (some val‚úù) no ‚Ä¶
                             -- ‚ä¢ map‚ÇÇ f (some val‚úù¬π) (map‚ÇÇ g (some val‚úù) none) = map‚ÇÇ g' (some val‚úù) (map‚ÇÇ f' ‚Ä¶
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
#align option.map‚ÇÇ_left_comm Option.map‚ÇÇ_left_comm

theorem map‚ÇÇ_right_comm {f : Œ¥ ‚Üí Œ≥ ‚Üí Œµ} {g : Œ± ‚Üí Œ≤ ‚Üí Œ¥} {f' : Œ± ‚Üí Œ≥ ‚Üí Œ¥'} {g' : Œ¥' ‚Üí Œ≤ ‚Üí Œµ}
    (h_right_comm : ‚àÄ a b c, f (g a b) c = g' (f' a c) b) :
    map‚ÇÇ f (map‚ÇÇ g a b) c = map‚ÇÇ g' (map‚ÇÇ f' a c) b :=
  by cases a <;> cases b <;> cases c <;> simp [h_right_comm]
     -- ‚ä¢ map‚ÇÇ f (map‚ÇÇ g none b) c = map‚ÇÇ g' (map‚ÇÇ f' none c) b
                 -- ‚ä¢ map‚ÇÇ f (map‚ÇÇ g none none) c = map‚ÇÇ g' (map‚ÇÇ f' none c) none
                 -- ‚ä¢ map‚ÇÇ f (map‚ÇÇ g (some val‚úù) none) c = map‚ÇÇ g' (map‚ÇÇ f' (some val‚úù) c) none
                             -- ‚ä¢ map‚ÇÇ f (map‚ÇÇ g none none) none = map‚ÇÇ g' (map‚ÇÇ f' none none) none
                             -- ‚ä¢ map‚ÇÇ f (map‚ÇÇ g none (some val‚úù)) none = map‚ÇÇ g' (map‚ÇÇ f' none none) (some va ‚Ä¶
                             -- ‚ä¢ map‚ÇÇ f (map‚ÇÇ g (some val‚úù) none) none = map‚ÇÇ g' (map‚ÇÇ f' (some val‚úù) none) n ‚Ä¶
                             -- ‚ä¢ map‚ÇÇ f (map‚ÇÇ g (some val‚úù¬π) (some val‚úù)) none = map‚ÇÇ g' (map‚ÇÇ f' (some val‚úù¬π ‚Ä¶
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
                                         -- üéâ no goals
#align option.map‚ÇÇ_right_comm Option.map‚ÇÇ_right_comm

theorem map_map‚ÇÇ_distrib {g : Œ≥ ‚Üí Œ¥} {f' : Œ±' ‚Üí Œ≤' ‚Üí Œ¥} {g‚ÇÅ : Œ± ‚Üí Œ±'} {g‚ÇÇ : Œ≤ ‚Üí Œ≤'}
    (h_distrib : ‚àÄ a b, g (f a b) = f' (g‚ÇÅ a) (g‚ÇÇ b)) :
    (map‚ÇÇ f a b).map g = map‚ÇÇ f' (a.map g‚ÇÅ) (b.map g‚ÇÇ) :=
  by cases a <;> cases b <;> simp [h_distrib]
     -- ‚ä¢ Option.map g (map‚ÇÇ f none b) = map‚ÇÇ f' (Option.map g‚ÇÅ none) (Option.map g‚ÇÇ b)
                 -- ‚ä¢ Option.map g (map‚ÇÇ f none none) = map‚ÇÇ f' (Option.map g‚ÇÅ none) (Option.map g ‚Ä¶
                 -- ‚ä¢ Option.map g (map‚ÇÇ f (some val‚úù) none) = map‚ÇÇ f' (Option.map g‚ÇÅ (some val‚úù)) ‚Ä¶
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
#align option.map_map‚ÇÇ_distrib Option.map_map‚ÇÇ_distrib

/-!
The following symmetric restatement are needed because unification has a hard time figuring all the
functions if you symmetrize on the spot. This is also how the other n-ary APIs do it.
-/

/-- Symmetric statement to `Option.map‚ÇÇ_map_left_comm`. -/
theorem map_map‚ÇÇ_distrib_left {g : Œ≥ ‚Üí Œ¥} {f' : Œ±' ‚Üí Œ≤ ‚Üí Œ¥} {g' : Œ± ‚Üí Œ±'}
    (h_distrib : ‚àÄ a b, g (f a b) = f' (g' a) b) :
    (map‚ÇÇ f a b).map g = map‚ÇÇ f' (a.map g') b := by cases a <;> cases b <;> simp [h_distrib]
                                                    -- ‚ä¢ Option.map g (map‚ÇÇ f none b) = map‚ÇÇ f' (Option.map g' none) b
                                                                -- ‚ä¢ Option.map g (map‚ÇÇ f none none) = map‚ÇÇ f' (Option.map g' none) none
                                                                -- ‚ä¢ Option.map g (map‚ÇÇ f (some val‚úù) none) = map‚ÇÇ f' (Option.map g' (some val‚úù)) ‚Ä¶
                                                                            -- üéâ no goals
                                                                            -- üéâ no goals
                                                                            -- üéâ no goals
                                                                            -- üéâ no goals
#align option.map_map‚ÇÇ_distrib_left Option.map_map‚ÇÇ_distrib_left

/-- Symmetric statement to `Option.map_map‚ÇÇ_right_comm`. -/
theorem map_map‚ÇÇ_distrib_right {g : Œ≥ ‚Üí Œ¥} {f' : Œ± ‚Üí Œ≤' ‚Üí Œ¥} {g' : Œ≤ ‚Üí Œ≤'}
    (h_distrib : ‚àÄ a b, g (f a b) = f' a (g' b)) : (map‚ÇÇ f a b).map g = map‚ÇÇ f' a (b.map g') :=
  by cases a <;> cases b <;> simp [h_distrib]
     -- ‚ä¢ Option.map g (map‚ÇÇ f none b) = map‚ÇÇ f' none (Option.map g' b)
                 -- ‚ä¢ Option.map g (map‚ÇÇ f none none) = map‚ÇÇ f' none (Option.map g' none)
                 -- ‚ä¢ Option.map g (map‚ÇÇ f (some val‚úù) none) = map‚ÇÇ f' (some val‚úù) (Option.map g'  ‚Ä¶
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
#align option.map_map‚ÇÇ_distrib_right Option.map_map‚ÇÇ_distrib_right

/-- Symmetric statement to `Option.map_map‚ÇÇ_distrib_left`. -/
theorem map‚ÇÇ_map_left_comm {f : Œ±' ‚Üí Œ≤ ‚Üí Œ≥} {g : Œ± ‚Üí Œ±'} {f' : Œ± ‚Üí Œ≤ ‚Üí Œ¥} {g' : Œ¥ ‚Üí Œ≥}
    (h_left_comm : ‚àÄ a b, f (g a) b = g' (f' a b)) : map‚ÇÇ f (a.map g) b = (map‚ÇÇ f' a b).map g' :=
  by cases a <;> cases b <;> simp [h_left_comm]
     -- ‚ä¢ map‚ÇÇ f (Option.map g none) b = Option.map g' (map‚ÇÇ f' none b)
                 -- ‚ä¢ map‚ÇÇ f (Option.map g none) none = Option.map g' (map‚ÇÇ f' none none)
                 -- ‚ä¢ map‚ÇÇ f (Option.map g (some val‚úù)) none = Option.map g' (map‚ÇÇ f' (some val‚úù)  ‚Ä¶
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
#align option.map‚ÇÇ_map_left_comm Option.map‚ÇÇ_map_left_comm

/-- Symmetric statement to `Option.map_map‚ÇÇ_distrib_right`. -/
theorem map_map‚ÇÇ_right_comm {f : Œ± ‚Üí Œ≤' ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≤'} {f' : Œ± ‚Üí Œ≤ ‚Üí Œ¥} {g' : Œ¥ ‚Üí Œ≥}
    (h_right_comm : ‚àÄ a b, f a (g b) = g' (f' a b)) : map‚ÇÇ f a (b.map g) = (map‚ÇÇ f' a b).map g' :=
  by cases a <;> cases b <;> simp [h_right_comm]
     -- ‚ä¢ map‚ÇÇ f none (Option.map g b) = Option.map g' (map‚ÇÇ f' none b)
                 -- ‚ä¢ map‚ÇÇ f none (Option.map g none) = Option.map g' (map‚ÇÇ f' none none)
                 -- ‚ä¢ map‚ÇÇ f (some val‚úù) (Option.map g none) = Option.map g' (map‚ÇÇ f' (some val‚úù)  ‚Ä¶
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
#align option.map_map‚ÇÇ_right_comm Option.map_map‚ÇÇ_right_comm

theorem map_map‚ÇÇ_antidistrib {g : Œ≥ ‚Üí Œ¥} {f' : Œ≤' ‚Üí Œ±' ‚Üí Œ¥} {g‚ÇÅ : Œ≤ ‚Üí Œ≤'} {g‚ÇÇ : Œ± ‚Üí Œ±'}
    (h_antidistrib : ‚àÄ a b, g (f a b) = f' (g‚ÇÅ b) (g‚ÇÇ a)) :
    (map‚ÇÇ f a b).map g = map‚ÇÇ f' (b.map g‚ÇÅ) (a.map g‚ÇÇ) :=
  by cases a <;> cases b <;> simp [h_antidistrib]
     -- ‚ä¢ Option.map g (map‚ÇÇ f none b) = map‚ÇÇ f' (Option.map g‚ÇÅ b) (Option.map g‚ÇÇ none)
                 -- ‚ä¢ Option.map g (map‚ÇÇ f none none) = map‚ÇÇ f' (Option.map g‚ÇÅ none) (Option.map g ‚Ä¶
                 -- ‚ä¢ Option.map g (map‚ÇÇ f (some val‚úù) none) = map‚ÇÇ f' (Option.map g‚ÇÅ none) (Optio ‚Ä¶
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
#align option.map_map‚ÇÇ_antidistrib Option.map_map‚ÇÇ_antidistrib

/-- Symmetric statement to `Option.map‚ÇÇ_map_left_anticomm`. -/
theorem map_map‚ÇÇ_antidistrib_left {g : Œ≥ ‚Üí Œ¥} {f' : Œ≤' ‚Üí Œ± ‚Üí Œ¥} {g' : Œ≤ ‚Üí Œ≤'}
    (h_antidistrib : ‚àÄ a b, g (f a b) = f' (g' b) a) :
    (map‚ÇÇ f a b).map g = map‚ÇÇ f' (b.map g') a :=
  by cases a <;> cases b <;> simp [h_antidistrib]
     -- ‚ä¢ Option.map g (map‚ÇÇ f none b) = map‚ÇÇ f' (Option.map g' b) none
                 -- ‚ä¢ Option.map g (map‚ÇÇ f none none) = map‚ÇÇ f' (Option.map g' none) none
                 -- ‚ä¢ Option.map g (map‚ÇÇ f (some val‚úù) none) = map‚ÇÇ f' (Option.map g' none) (some  ‚Ä¶
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
#align option.map_map‚ÇÇ_antidistrib_left Option.map_map‚ÇÇ_antidistrib_left

/-- Symmetric statement to `Option.map_map‚ÇÇ_right_anticomm`. -/
theorem map_map‚ÇÇ_antidistrib_right {g : Œ≥ ‚Üí Œ¥} {f' : Œ≤ ‚Üí Œ±' ‚Üí Œ¥} {g' : Œ± ‚Üí Œ±'}
    (h_antidistrib : ‚àÄ a b, g (f a b) = f' b (g' a)) : (map‚ÇÇ f a b).map g = map‚ÇÇ f' b (a.map g') :=
  by cases a <;> cases b <;> simp [h_antidistrib]
     -- ‚ä¢ Option.map g (map‚ÇÇ f none b) = map‚ÇÇ f' b (Option.map g' none)
                 -- ‚ä¢ Option.map g (map‚ÇÇ f none none) = map‚ÇÇ f' none (Option.map g' none)
                 -- ‚ä¢ Option.map g (map‚ÇÇ f (some val‚úù) none) = map‚ÇÇ f' none (Option.map g' (some v ‚Ä¶
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
                             -- üéâ no goals
#align option.map_map‚ÇÇ_antidistrib_right Option.map_map‚ÇÇ_antidistrib_right

/-- Symmetric statement to `Option.map_map‚ÇÇ_antidistrib_left`. -/
theorem map‚ÇÇ_map_left_anticomm {f : Œ±' ‚Üí Œ≤ ‚Üí Œ≥} {g : Œ± ‚Üí Œ±'} {f' : Œ≤ ‚Üí Œ± ‚Üí Œ¥} {g' : Œ¥ ‚Üí Œ≥}
    (h_left_anticomm : ‚àÄ a b, f (g a) b = g' (f' b a)) :
    map‚ÇÇ f (a.map g) b = (map‚ÇÇ f' b a).map g' := by cases a <;> cases b <;> simp [h_left_anticomm]
                                                    -- ‚ä¢ map‚ÇÇ f (Option.map g none) b = Option.map g' (map‚ÇÇ f' b none)
                                                                -- ‚ä¢ map‚ÇÇ f (Option.map g none) none = Option.map g' (map‚ÇÇ f' none none)
                                                                -- ‚ä¢ map‚ÇÇ f (Option.map g (some val‚úù)) none = Option.map g' (map‚ÇÇ f' none (some v ‚Ä¶
                                                                            -- üéâ no goals
                                                                            -- üéâ no goals
                                                                            -- üéâ no goals
                                                                            -- üéâ no goals
#align option.map‚ÇÇ_map_left_anticomm Option.map‚ÇÇ_map_left_anticomm

/-- Symmetric statement to `Option.map_map‚ÇÇ_antidistrib_right`. -/
theorem map_map‚ÇÇ_right_anticomm {f : Œ± ‚Üí Œ≤' ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≤'} {f' : Œ≤ ‚Üí Œ± ‚Üí Œ¥} {g' : Œ¥ ‚Üí Œ≥}
    (h_right_anticomm : ‚àÄ a b, f a (g b) = g' (f' b a)) :
    map‚ÇÇ f a (b.map g) = (map‚ÇÇ f' b a).map g' := by cases a <;> cases b <;> simp [h_right_anticomm]
                                                    -- ‚ä¢ map‚ÇÇ f none (Option.map g b) = Option.map g' (map‚ÇÇ f' b none)
                                                                -- ‚ä¢ map‚ÇÇ f none (Option.map g none) = Option.map g' (map‚ÇÇ f' none none)
                                                                -- ‚ä¢ map‚ÇÇ f (some val‚úù) (Option.map g none) = Option.map g' (map‚ÇÇ f' none (some v ‚Ä¶
                                                                            -- üéâ no goals
                                                                            -- üéâ no goals
                                                                            -- üéâ no goals
                                                                            -- üéâ no goals
#align option.map_map‚ÇÇ_right_anticomm Option.map_map‚ÇÇ_right_anticomm

/-- If `a` is a left identity for a binary operation `f`, then `some a` is a left identity for
`Option.map‚ÇÇ f`. -/
lemma map‚ÇÇ_left_identity {f : Œ± ‚Üí Œ≤ ‚Üí Œ≤} {a : Œ±} (h : ‚àÄ b, f a b = b) (o : Option Œ≤) :
    map‚ÇÇ f (some a) o = o := by
  cases o; exacts [rfl, congr_arg some (h _)]
  -- ‚ä¢ map‚ÇÇ f (some a) none = none
           -- üéâ no goals
#align option.map‚ÇÇ_left_identity Option.map‚ÇÇ_left_identity

/-- If `b` is a right identity for a binary operation `f`, then `some b` is a right identity for
`Option.map‚ÇÇ f`. -/
lemma map‚ÇÇ_right_identity {f : Œ± ‚Üí Œ≤ ‚Üí Œ±} {b : Œ≤} (h : ‚àÄ a, f a b = a) (o : Option Œ±) :
    map‚ÇÇ f o (some b) = o := by
  simp [h, map‚ÇÇ]
  -- üéâ no goals
#align option.map‚ÇÇ_right_identity Option.map‚ÇÇ_right_identity

end Option
