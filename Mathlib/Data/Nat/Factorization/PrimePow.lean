/-
Copyright (c) 2022 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta
-/
import Mathlib.Algebra.IsPrimePow
import Mathlib.Data.Nat.Factorization.Basic

#align_import data.nat.factorization.prime_pow from "leanprover-community/mathlib"@"6ca1a09bc9aa75824bf97388c9e3b441fc4ccf3f"

/-!
# Prime powers and factorizations

This file deals with factorizations of prime powers.
-/


variable {R : Type*} [CommMonoidWithZero R] (n p : R) (k : ‚Ñï)

theorem IsPrimePow.minFac_pow_factorization_eq {n : ‚Ñï} (hn : IsPrimePow n) :
    n.minFac ^ n.factorization n.minFac = n := by
  obtain ‚ü®p, k, hp, hk, rfl‚ü© := hn
  -- ‚ä¢ Nat.minFac (p ^ k) ^ ‚Üë(Nat.factorization (p ^ k)) (Nat.minFac (p ^ k)) = p ^ k
  rw [‚Üê Nat.prime_iff] at hp
  -- ‚ä¢ Nat.minFac (p ^ k) ^ ‚Üë(Nat.factorization (p ^ k)) (Nat.minFac (p ^ k)) = p ^ k
  rw [hp.pow_minFac hk.ne', hp.factorization_pow, Finsupp.single_eq_same]
  -- üéâ no goals
#align is_prime_pow.min_fac_pow_factorization_eq IsPrimePow.minFac_pow_factorization_eq

theorem isPrimePow_of_minFac_pow_factorization_eq {n : ‚Ñï}
    (h : n.minFac ^ n.factorization n.minFac = n) (hn : n ‚â† 1) : IsPrimePow n := by
  rcases eq_or_ne n 0 with (rfl | hn')
  -- ‚ä¢ IsPrimePow 0
  ¬∑ simp_all
    -- üéâ no goals
  refine' ‚ü®_, _, (Nat.minFac_prime hn).prime, _, h‚ü©
  -- ‚ä¢ 0 < ‚Üë(Nat.factorization n) (Nat.minFac n)
  rw [pos_iff_ne_zero, ‚Üê Finsupp.mem_support_iff, Nat.factor_iff_mem_factorization,
    Nat.mem_factors_iff_dvd hn' (Nat.minFac_prime hn)]
  apply Nat.minFac_dvd
  -- üéâ no goals
#align is_prime_pow_of_min_fac_pow_factorization_eq isPrimePow_of_minFac_pow_factorization_eq

theorem isPrimePow_iff_minFac_pow_factorization_eq {n : ‚Ñï} (hn : n ‚â† 1) :
    IsPrimePow n ‚Üî n.minFac ^ n.factorization n.minFac = n :=
  ‚ü®fun h => h.minFac_pow_factorization_eq, fun h => isPrimePow_of_minFac_pow_factorization_eq h hn‚ü©
#align is_prime_pow_iff_min_fac_pow_factorization_eq isPrimePow_iff_minFac_pow_factorization_eq

theorem isPrimePow_iff_factorization_eq_single {n : ‚Ñï} :
    IsPrimePow n ‚Üî ‚àÉ p k : ‚Ñï, 0 < k ‚àß n.factorization = Finsupp.single p k := by
  rw [isPrimePow_nat_iff]
  -- ‚ä¢ (‚àÉ p k, Nat.Prime p ‚àß 0 < k ‚àß p ^ k = n) ‚Üî ‚àÉ p k, 0 < k ‚àß Nat.factorization  ‚Ä¶
  refine' exists‚ÇÇ_congr fun p k => _
  -- ‚ä¢ Nat.Prime p ‚àß 0 < k ‚àß p ^ k = n ‚Üî 0 < k ‚àß Nat.factorization n = Finsupp.sing ‚Ä¶
  constructor
  -- ‚ä¢ Nat.Prime p ‚àß 0 < k ‚àß p ^ k = n ‚Üí 0 < k ‚àß Nat.factorization n = Finsupp.sing ‚Ä¶
  ¬∑ rintro ‚ü®hp, hk, hn‚ü©
    -- ‚ä¢ 0 < k ‚àß Nat.factorization n = Finsupp.single p k
    exact ‚ü®hk, by rw [‚Üê hn, Nat.Prime.factorization_pow hp]‚ü©
    -- üéâ no goals
  ¬∑ rintro ‚ü®hk, hn‚ü©
    -- ‚ä¢ Nat.Prime p ‚àß 0 < k ‚àß p ^ k = n
    have hn0 : n ‚â† 0 := by
      rintro rfl
      simp_all only [Finsupp.single_eq_zero, eq_comm, Nat.factorization_zero, hk.ne']
    rw [Nat.eq_pow_of_factorization_eq_single hn0 hn]
    -- ‚ä¢ Nat.Prime p ‚àß 0 < k ‚àß p ^ k = p ^ k
    exact
      ‚ü®Nat.prime_of_mem_factorization (by simp [hn, hk.ne'] : p ‚àà n.factorization.support), hk, rfl‚ü©
#align is_prime_pow_iff_factorization_eq_single isPrimePow_iff_factorization_eq_single

theorem isPrimePow_iff_card_support_factorization_eq_one {n : ‚Ñï} :
    IsPrimePow n ‚Üî n.factorization.support.card = 1 := by
  simp_rw [isPrimePow_iff_factorization_eq_single, Finsupp.card_support_eq_one', exists_prop,
    pos_iff_ne_zero]
#align is_prime_pow_iff_card_support_factorization_eq_one isPrimePow_iff_card_support_factorization_eq_one

theorem IsPrimePow.exists_ord_compl_eq_one {n : ‚Ñï} (h : IsPrimePow n) :
    ‚àÉ p : ‚Ñï, p.Prime ‚àß ord_compl[p] n = 1 := by
  rcases eq_or_ne n 0 with (rfl | hn0); ¬∑ cases not_isPrimePow_zero h
  -- ‚ä¢ ‚àÉ p, Nat.Prime p ‚àß 0 / p ^ ‚Üë(Nat.factorization 0) p = 1
                                          -- üéâ no goals
  rcases isPrimePow_iff_factorization_eq_single.mp h with ‚ü®p, k, hk0, h1‚ü©
  -- ‚ä¢ ‚àÉ p, Nat.Prime p ‚àß n / p ^ ‚Üë(Nat.factorization n) p = 1
  rcases em' p.Prime with (pp | pp)
  -- ‚ä¢ ‚àÉ p, Nat.Prime p ‚àß n / p ^ ‚Üë(Nat.factorization n) p = 1
  ¬∑ refine' absurd _ hk0.ne'
    -- ‚ä¢ k = 0
    simp [‚Üê Nat.factorization_eq_zero_of_non_prime n pp, h1]
    -- üéâ no goals
  refine' ‚ü®p, pp, _‚ü©
  -- ‚ä¢ n / p ^ ‚Üë(Nat.factorization n) p = 1
  refine' Nat.eq_of_factorization_eq (Nat.ord_compl_pos p hn0).ne' (by simp) fun q => _
  -- ‚ä¢ ‚Üë(Nat.factorization (n / p ^ ‚Üë(Nat.factorization n) p)) q = ‚Üë(Nat.factorizat ‚Ä¶
  rw [Nat.factorization_ord_compl n p, h1]
  -- ‚ä¢ ‚Üë(Finsupp.erase p (Finsupp.single p k)) q = ‚Üë(Nat.factorization 1) q
  simp
  -- üéâ no goals
#align is_prime_pow.exists_ord_compl_eq_one IsPrimePow.exists_ord_compl_eq_one

theorem exists_ord_compl_eq_one_iff_isPrimePow {n : ‚Ñï} (hn : n ‚â† 1) :
    IsPrimePow n ‚Üî ‚àÉ p : ‚Ñï, p.Prime ‚àß ord_compl[p] n = 1 := by
  refine' ‚ü®fun h => IsPrimePow.exists_ord_compl_eq_one h, fun h => _‚ü©
  -- ‚ä¢ IsPrimePow n
  rcases h with ‚ü®p, pp, h‚ü©
  -- ‚ä¢ IsPrimePow n
  rw [isPrimePow_nat_iff]
  -- ‚ä¢ ‚àÉ p k, Nat.Prime p ‚àß 0 < k ‚àß p ^ k = n
  rw [‚Üê Nat.eq_of_dvd_of_div_eq_one (Nat.ord_proj_dvd n p) h] at hn ‚ä¢
  -- ‚ä¢ ‚àÉ p_1 k, Nat.Prime p_1 ‚àß 0 < k ‚àß p_1 ^ k = p ^ ‚Üë(Nat.factorization n) p
  refine' ‚ü®p, n.factorization p, pp, _, by simp‚ü©
  -- ‚ä¢ 0 < ‚Üë(Nat.factorization n) p
  contrapose! hn
  -- ‚ä¢ p ^ ‚Üë(Nat.factorization n) p = 1
  simp [le_zero_iff.1 hn]
  -- üéâ no goals
#align exists_ord_compl_eq_one_iff_is_prime_pow exists_ord_compl_eq_one_iff_isPrimePow

/-- An equivalent definition for prime powers: `n` is a prime power iff there is a unique prime
dividing it. -/
theorem isPrimePow_iff_unique_prime_dvd {n : ‚Ñï} : IsPrimePow n ‚Üî ‚àÉ! p : ‚Ñï, p.Prime ‚àß p ‚à£ n := by
  rw [isPrimePow_nat_iff]
  -- ‚ä¢ (‚àÉ p k, Nat.Prime p ‚àß 0 < k ‚àß p ^ k = n) ‚Üî ‚àÉ! p, Nat.Prime p ‚àß p ‚à£ n
  constructor
  -- ‚ä¢ (‚àÉ p k, Nat.Prime p ‚àß 0 < k ‚àß p ^ k = n) ‚Üí ‚àÉ! p, Nat.Prime p ‚àß p ‚à£ n
  ¬∑ rintro ‚ü®p, k, hp, hk, rfl‚ü©
    -- ‚ä¢ ‚àÉ! p_1, Nat.Prime p_1 ‚àß p_1 ‚à£ p ^ k
    refine' ‚ü®p, ‚ü®hp, dvd_pow_self _ hk.ne'‚ü©, _‚ü©
    -- ‚ä¢ ‚àÄ (y : ‚Ñï), (fun p_1 => Nat.Prime p_1 ‚àß p_1 ‚à£ p ^ k) y ‚Üí y = p
    rintro q ‚ü®hq, hq'‚ü©
    -- ‚ä¢ q = p
    exact (Nat.prime_dvd_prime_iff_eq hq hp).1 (hq.dvd_of_dvd_pow hq')
    -- üéâ no goals
  rintro ‚ü®p, ‚ü®hp, hn‚ü©, hq‚ü©
  -- ‚ä¢ ‚àÉ p k, Nat.Prime p ‚àß 0 < k ‚àß p ^ k = n
  rcases eq_or_ne n 0 with (rfl | hn‚ÇÄ)
  -- ‚ä¢ ‚àÉ p k, Nat.Prime p ‚àß 0 < k ‚àß p ^ k = 0
  ¬∑ cases (hq 2 ‚ü®Nat.prime_two, dvd_zero 2‚ü©).trans (hq 3 ‚ü®Nat.prime_three, dvd_zero 3‚ü©).symm
    -- üéâ no goals
  refine' ‚ü®p, n.factorization p, hp, hp.factorization_pos_of_dvd hn‚ÇÄ hn, _‚ü©
  -- ‚ä¢ p ^ ‚Üë(Nat.factorization n) p = n
  simp only [and_imp] at hq
  -- ‚ä¢ p ^ ‚Üë(Nat.factorization n) p = n
  apply Nat.dvd_antisymm (Nat.ord_proj_dvd _ _)
  -- ‚ä¢ n ‚à£ p ^ ‚Üë(Nat.factorization n) p
  -- We need to show n ‚à£ p ^ n.factorization p
  apply Nat.dvd_of_factors_subperm hn‚ÇÄ
  -- ‚ä¢ Nat.factors n <+~ Nat.factors (p ^ ‚Üë(Nat.factorization n) p)
  rw [hp.factors_pow, List.subperm_ext_iff]
  -- ‚ä¢ ‚àÄ (x : ‚Ñï), x ‚àà Nat.factors n ‚Üí List.count x (Nat.factors n) ‚â§ List.count x ( ‚Ä¶
  intro q hq'
  -- ‚ä¢ List.count q (Nat.factors n) ‚â§ List.count q (List.replicate (‚Üë(Nat.factoriza ‚Ä¶
  rw [Nat.mem_factors hn‚ÇÄ] at hq'
  -- ‚ä¢ List.count q (Nat.factors n) ‚â§ List.count q (List.replicate (‚Üë(Nat.factoriza ‚Ä¶
  cases hq _ hq'.1 hq'.2
  -- ‚ä¢ List.count p (Nat.factors n) ‚â§ List.count p (List.replicate (‚Üë(Nat.factoriza ‚Ä¶
  simp
  -- üéâ no goals
#align is_prime_pow_iff_unique_prime_dvd isPrimePow_iff_unique_prime_dvd

theorem isPrimePow_pow_iff {n k : ‚Ñï} (hk : k ‚â† 0) : IsPrimePow (n ^ k) ‚Üî IsPrimePow n := by
  simp only [isPrimePow_iff_unique_prime_dvd]
  -- ‚ä¢ (‚àÉ! p, Nat.Prime p ‚àß p ‚à£ n ^ k) ‚Üî ‚àÉ! p, Nat.Prime p ‚àß p ‚à£ n
  apply exists_unique_congr
  -- ‚ä¢ ‚àÄ (a : ‚Ñï), Nat.Prime a ‚àß a ‚à£ n ^ k ‚Üî Nat.Prime a ‚àß a ‚à£ n
  simp only [and_congr_right_iff]
  -- ‚ä¢ ‚àÄ (a : ‚Ñï), Nat.Prime a ‚Üí (a ‚à£ n ^ k ‚Üî a ‚à£ n)
  intro p hp
  -- ‚ä¢ p ‚à£ n ^ k ‚Üî p ‚à£ n
  exact ‚ü®hp.dvd_of_dvd_pow, fun t => t.trans (dvd_pow_self _ hk)‚ü©
  -- üéâ no goals
#align is_prime_pow_pow_iff isPrimePow_pow_iff

theorem Nat.coprime.isPrimePow_dvd_mul {n a b : ‚Ñï} (hab : Nat.coprime a b) (hn : IsPrimePow n) :
    n ‚à£ a * b ‚Üî n ‚à£ a ‚à® n ‚à£ b := by
  rcases eq_or_ne a 0 with (rfl | ha)
  -- ‚ä¢ n ‚à£ 0 * b ‚Üî n ‚à£ 0 ‚à® n ‚à£ b
  ¬∑ simp only [Nat.coprime_zero_left] at hab
    -- ‚ä¢ n ‚à£ 0 * b ‚Üî n ‚à£ 0 ‚à® n ‚à£ b
    simp [hab, Finset.filter_singleton, not_isPrimePow_one]
    -- üéâ no goals
  rcases eq_or_ne b 0 with (rfl | hb)
  -- ‚ä¢ n ‚à£ a * 0 ‚Üî n ‚à£ a ‚à® n ‚à£ 0
  ¬∑ simp only [Nat.coprime_zero_right] at hab
    -- ‚ä¢ n ‚à£ a * 0 ‚Üî n ‚à£ a ‚à® n ‚à£ 0
    simp [hab, Finset.filter_singleton, not_isPrimePow_one]
    -- üéâ no goals
  refine'
    ‚ü®_, fun h =>
      Or.elim h (fun i => i.trans ((@dvd_mul_right a b a hab).mpr (dvd_refl a)))
          fun i => i.trans ((@dvd_mul_left a b b hab.symm).mpr (dvd_refl b))‚ü©
  obtain ‚ü®p, k, hp, _, rfl‚ü© := (isPrimePow_nat_iff _).1 hn
  -- ‚ä¢ p ^ k ‚à£ a * b ‚Üí p ^ k ‚à£ a ‚à® p ^ k ‚à£ b
  simp only [hp.pow_dvd_iff_le_factorization (mul_ne_zero ha hb), Nat.factorization_mul ha hb,
    hp.pow_dvd_iff_le_factorization ha, hp.pow_dvd_iff_le_factorization hb, Pi.add_apply,
    Finsupp.coe_add]
  have : a.factorization p = 0 ‚à® b.factorization p = 0 := by
    rw [‚Üê Finsupp.not_mem_support_iff, ‚Üê Finsupp.not_mem_support_iff, ‚Üê not_and_or, ‚Üê
      Finset.mem_inter]
    intro t -- porting note: used to be `exact` below, but the definition of `‚àà` has changed.
    simpa using (Nat.factorization_disjoint_of_coprime hab).le_bot t
  cases' this with h h <;> simp [h, imp_or]
  -- ‚ä¢ k ‚â§ ‚Üë(factorization a) p + ‚Üë(factorization b) p ‚Üí k ‚â§ ‚Üë(factorization a) p ‚à® ‚Ä¶
                           -- üéâ no goals
                           -- üéâ no goals
#align nat.coprime.is_prime_pow_dvd_mul Nat.coprime.isPrimePow_dvd_mul

theorem Nat.mul_divisors_filter_prime_pow {a b : ‚Ñï} (hab : a.coprime b) :
    (a * b).divisors.filter IsPrimePow = (a.divisors ‚à™ b.divisors).filter IsPrimePow := by
  rcases eq_or_ne a 0 with (rfl | ha)
  -- ‚ä¢ Finset.filter IsPrimePow (divisors (0 * b)) = Finset.filter IsPrimePow (divi ‚Ä¶
  ¬∑ simp only [Nat.coprime_zero_left] at hab
    -- ‚ä¢ Finset.filter IsPrimePow (divisors (0 * b)) = Finset.filter IsPrimePow (divi ‚Ä¶
    simp [hab, Finset.filter_singleton, not_isPrimePow_one]
    -- üéâ no goals
  rcases eq_or_ne b 0 with (rfl | hb)
  -- ‚ä¢ Finset.filter IsPrimePow (divisors (a * 0)) = Finset.filter IsPrimePow (divi ‚Ä¶
  ¬∑ simp only [Nat.coprime_zero_right] at hab
    -- ‚ä¢ Finset.filter IsPrimePow (divisors (a * 0)) = Finset.filter IsPrimePow (divi ‚Ä¶
    simp [hab, Finset.filter_singleton, not_isPrimePow_one]
    -- üéâ no goals
  ext n
  -- ‚ä¢ n ‚àà Finset.filter IsPrimePow (divisors (a * b)) ‚Üî n ‚àà Finset.filter IsPrimeP ‚Ä¶
  simp only [ha, hb, Finset.mem_union, Finset.mem_filter, Nat.mul_eq_zero, and_true_iff, Ne.def,
    and_congr_left_iff, not_false_iff, Nat.mem_divisors, or_self_iff]
  apply hab.isPrimePow_dvd_mul
  -- üéâ no goals
#align nat.mul_divisors_filter_prime_pow Nat.mul_divisors_filter_prime_pow
