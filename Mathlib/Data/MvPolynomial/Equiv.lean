/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Johan Commelin, Mario Carneiro
-/
import Mathlib.Data.MvPolynomial.Rename
import Mathlib.Data.Polynomial.AlgebraMap
import Mathlib.Data.MvPolynomial.Variables
import Mathlib.Data.Finsupp.Fin
import Mathlib.Logic.Equiv.Fin
import Mathlib.Algebra.BigOperators.Fin

#align_import data.mv_polynomial.equiv from "leanprover-community/mathlib"@"2f5b500a507264de86d666a5f87ddb976e2d8de4"

/-!
# Equivalences between polynomial rings

This file establishes a number of equivalences between polynomial rings,
based on equivalences between the underlying types.

## Notation

As in other polynomial files, we typically use the notation:

+ `œÉ : Type*` (indexing the variables)

+ `R : Type*` `[CommSemiring R]` (the coefficients)

+ `s : œÉ ‚Üí‚ÇÄ ‚Ñï`, a function from `œÉ` to `‚Ñï` which is zero away from a finite set.
This will give rise to a monomial in `MvPolynomial œÉ R` which mathematicians might call `X^s`

+ `a : R`

+ `i : œÉ`, with corresponding monomial `X i`, often denoted `X_i` by mathematicians

+ `p : MvPolynomial œÉ R`

## Tags

equivalence, isomorphism, morphism, ring hom, hom

-/


noncomputable section

open BigOperators Polynomial Set Function Finsupp AddMonoidAlgebra

universe u v w x

variable {R : Type u} {S‚ÇÅ : Type v} {S‚ÇÇ : Type w} {S‚ÇÉ : Type x}

namespace MvPolynomial

variable {œÉ : Type*} {a a' a‚ÇÅ a‚ÇÇ : R} {e : ‚Ñï} {s : œÉ ‚Üí‚ÇÄ ‚Ñï}

section Equiv

variable (R) [CommSemiring R]

/-- The ring isomorphism between multivariable polynomials in a single variable and
polynomials over the ground ring.
-/
@[simps]
def pUnitAlgEquiv : MvPolynomial PUnit R ‚âÉ‚Çê[R] R[X] where
  toFun := eval‚ÇÇ Polynomial.C fun _ => Polynomial.X
  invFun := Polynomial.eval‚ÇÇ MvPolynomial.C (X PUnit.unit)
  left_inv := by
    let f : R[X] ‚Üí+* MvPolynomial PUnit R := Polynomial.eval‚ÇÇRingHom MvPolynomial.C (X PUnit.unit)
    -- ‚ä¢ LeftInverse (Polynomial.eval‚ÇÇ C (X PUnit.unit)) (eval‚ÇÇ Polynomial.C fun x => ‚Ä¶
    let g : MvPolynomial PUnit R ‚Üí+* R[X] := eval‚ÇÇHom Polynomial.C fun _ => Polynomial.X
    -- ‚ä¢ LeftInverse (Polynomial.eval‚ÇÇ C (X PUnit.unit)) (eval‚ÇÇ Polynomial.C fun x => ‚Ä¶
    show ‚àÄ p, f.comp g p = p
    -- ‚ä¢ ‚àÄ (p : MvPolynomial PUnit R), ‚Üë(RingHom.comp f g) p = p
    apply is_id
    -- ‚ä¢ RingHom.comp (RingHom.comp f g) C = C
    ¬∑ ext a
      -- ‚ä¢ coeff m‚úù (‚Üë(RingHom.comp (RingHom.comp f g) C) a) = coeff m‚úù (‚ÜëC a)
      dsimp
      -- ‚ä¢ coeff m‚úù (Polynomial.eval‚ÇÇ C (X PUnit.unit) (eval‚ÇÇ Polynomial.C (fun x => Po ‚Ä¶
      rw [eval‚ÇÇ_C, Polynomial.eval‚ÇÇ_C]
      -- üéâ no goals
    ¬∑ rintro ‚ü®‚ü©
      -- ‚ä¢ ‚Üë(RingHom.comp f g) (X PUnit.unit) = X PUnit.unit
      dsimp
      -- ‚ä¢ Polynomial.eval‚ÇÇ C (X PUnit.unit) (eval‚ÇÇ Polynomial.C (fun x => Polynomial.X ‚Ä¶
      rw [eval‚ÇÇ_X, Polynomial.eval‚ÇÇ_X]
      -- üéâ no goals
  right_inv p :=
    Polynomial.induction_on p (fun a => by rw [Polynomial.eval‚ÇÇ_C, MvPolynomial.eval‚ÇÇ_C])
                                           -- üéâ no goals
    (fun p q hp hq => by rw [Polynomial.eval‚ÇÇ_add, MvPolynomial.eval‚ÇÇ_add, hp, hq]) fun p n _ => by
                         -- üéâ no goals
      rw [Polynomial.eval‚ÇÇ_mul, Polynomial.eval‚ÇÇ_pow, Polynomial.eval‚ÇÇ_X, Polynomial.eval‚ÇÇ_C,
        eval‚ÇÇ_mul, eval‚ÇÇ_C, eval‚ÇÇ_pow, eval‚ÇÇ_X]
  map_mul' _ _ := eval‚ÇÇ_mul _ _
  map_add' _ _ := eval‚ÇÇ_add _ _
  commutes' _ := eval‚ÇÇ_C _ _ _
#align mv_polynomial.punit_alg_equiv MvPolynomial.pUnitAlgEquiv

section Map

variable {R} (œÉ)

/-- If `e : A ‚âÉ+* B` is an isomorphism of rings, then so is `map e`. -/
@[simps apply]
def mapEquiv [CommSemiring S‚ÇÅ] [CommSemiring S‚ÇÇ] (e : S‚ÇÅ ‚âÉ+* S‚ÇÇ) :
    MvPolynomial œÉ S‚ÇÅ ‚âÉ+* MvPolynomial œÉ S‚ÇÇ :=
  { map (e : S‚ÇÅ ‚Üí+* S‚ÇÇ) with
    toFun := map (e : S‚ÇÅ ‚Üí+* S‚ÇÇ)
    invFun := map (e.symm : S‚ÇÇ ‚Üí+* S‚ÇÅ)
    left_inv := map_leftInverse e.left_inv
    right_inv := map_rightInverse e.right_inv }
#align mv_polynomial.map_equiv MvPolynomial.mapEquiv

@[simp]
theorem mapEquiv_refl : mapEquiv œÉ (RingEquiv.refl R) = RingEquiv.refl _ :=
  RingEquiv.ext map_id
#align mv_polynomial.map_equiv_refl MvPolynomial.mapEquiv_refl

@[simp]
theorem mapEquiv_symm [CommSemiring S‚ÇÅ] [CommSemiring S‚ÇÇ] (e : S‚ÇÅ ‚âÉ+* S‚ÇÇ) :
    (mapEquiv œÉ e).symm = mapEquiv œÉ e.symm :=
  rfl
#align mv_polynomial.map_equiv_symm MvPolynomial.mapEquiv_symm

@[simp]
theorem mapEquiv_trans [CommSemiring S‚ÇÅ] [CommSemiring S‚ÇÇ] [CommSemiring S‚ÇÉ] (e : S‚ÇÅ ‚âÉ+* S‚ÇÇ)
    (f : S‚ÇÇ ‚âÉ+* S‚ÇÉ) : (mapEquiv œÉ e).trans (mapEquiv œÉ f) = mapEquiv œÉ (e.trans f) :=
  RingEquiv.ext fun p => by
    simp only [RingEquiv.coe_trans, comp_apply, mapEquiv_apply, RingEquiv.coe_ringHom_trans,
      map_map]
#align mv_polynomial.map_equiv_trans MvPolynomial.mapEquiv_trans

variable {A‚ÇÅ A‚ÇÇ A‚ÇÉ : Type*} [CommSemiring A‚ÇÅ] [CommSemiring A‚ÇÇ] [CommSemiring A‚ÇÉ]

variable [Algebra R A‚ÇÅ] [Algebra R A‚ÇÇ] [Algebra R A‚ÇÉ]

/-- If `e : A ‚âÉ‚Çê[R] B` is an isomorphism of `R`-algebras, then so is `map e`. -/
@[simps apply]
def mapAlgEquiv (e : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ) : MvPolynomial œÉ A‚ÇÅ ‚âÉ‚Çê[R] MvPolynomial œÉ A‚ÇÇ :=
  { mapAlgHom (e : A‚ÇÅ ‚Üí‚Çê[R] A‚ÇÇ), mapEquiv œÉ (e : A‚ÇÅ ‚âÉ+* A‚ÇÇ) with toFun := map (e : A‚ÇÅ ‚Üí+* A‚ÇÇ) }
#align mv_polynomial.map_alg_equiv MvPolynomial.mapAlgEquiv

@[simp]
theorem mapAlgEquiv_refl : mapAlgEquiv œÉ (AlgEquiv.refl : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÅ) = AlgEquiv.refl :=
  AlgEquiv.ext map_id
#align mv_polynomial.map_alg_equiv_refl MvPolynomial.mapAlgEquiv_refl

@[simp]
theorem mapAlgEquiv_symm (e : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ) : (mapAlgEquiv œÉ e).symm = mapAlgEquiv œÉ e.symm :=
  rfl
#align mv_polynomial.map_alg_equiv_symm MvPolynomial.mapAlgEquiv_symm

@[simp]
theorem mapAlgEquiv_trans (e : A‚ÇÅ ‚âÉ‚Çê[R] A‚ÇÇ) (f : A‚ÇÇ ‚âÉ‚Çê[R] A‚ÇÉ) :
    (mapAlgEquiv œÉ e).trans (mapAlgEquiv œÉ f) = mapAlgEquiv œÉ (e.trans f) := by
  ext
  -- ‚ä¢ coeff m‚úù (‚Üë(AlgEquiv.trans (mapAlgEquiv œÉ e) (mapAlgEquiv œÉ f)) a‚úù) = coeff  ‚Ä¶
  simp only [AlgEquiv.trans_apply, mapAlgEquiv_apply, map_map]
  -- ‚ä¢ coeff m‚úù (‚Üë(map (RingHom.comp ‚Üëf ‚Üëe)) a‚úù) = coeff m‚úù (‚Üë(map ‚Üë(AlgEquiv.trans ‚Ä¶
  rfl
  -- üéâ no goals
#align mv_polynomial.map_alg_equiv_trans MvPolynomial.mapAlgEquiv_trans

end Map

section

variable (S‚ÇÅ S‚ÇÇ S‚ÇÉ)

/-- The function from multivariable polynomials in a sum of two types,
to multivariable polynomials in one of the types,
with coefficients in multivariable polynomials in the other type.

See `sumRingEquiv` for the ring isomorphism.
-/
def sumToIter : MvPolynomial (Sum S‚ÇÅ S‚ÇÇ) R ‚Üí+* MvPolynomial S‚ÇÅ (MvPolynomial S‚ÇÇ R) :=
  eval‚ÇÇHom (C.comp C) fun bc => Sum.recOn bc X (C ‚àò X)
#align mv_polynomial.sum_to_iter MvPolynomial.sumToIter

@[simp]
theorem sumToIter_C (a : R) : sumToIter R S‚ÇÅ S‚ÇÇ (C a) = C (C a) :=
  eval‚ÇÇ_C _ _ a
set_option linter.uppercaseLean3 false in
#align mv_polynomial.sum_to_iter_C MvPolynomial.sumToIter_C

@[simp]
theorem sumToIter_Xl (b : S‚ÇÅ) : sumToIter R S‚ÇÅ S‚ÇÇ (X (Sum.inl b)) = X b :=
  eval‚ÇÇ_X _ _ (Sum.inl b)
set_option linter.uppercaseLean3 false in
#align mv_polynomial.sum_to_iter_Xl MvPolynomial.sumToIter_Xl

@[simp]
theorem sumToIter_Xr (c : S‚ÇÇ) : sumToIter R S‚ÇÅ S‚ÇÇ (X (Sum.inr c)) = C (X c) :=
  eval‚ÇÇ_X _ _ (Sum.inr c)
set_option linter.uppercaseLean3 false in
#align mv_polynomial.sum_to_iter_Xr MvPolynomial.sumToIter_Xr

/-- The function from multivariable polynomials in one type,
with coefficients in multivariable polynomials in another type,
to multivariable polynomials in the sum of the two types.

See `sumRingEquiv` for the ring isomorphism.
-/
def iterToSum : MvPolynomial S‚ÇÅ (MvPolynomial S‚ÇÇ R) ‚Üí+* MvPolynomial (Sum S‚ÇÅ S‚ÇÇ) R :=
  eval‚ÇÇHom (eval‚ÇÇHom C (X ‚àò Sum.inr)) (X ‚àò Sum.inl)
#align mv_polynomial.iter_to_sum MvPolynomial.iterToSum

theorem iterToSum_C_C (a : R) : iterToSum R S‚ÇÅ S‚ÇÇ (C (C a)) = C a :=
  Eq.trans (eval‚ÇÇ_C _ _ (C a)) (eval‚ÇÇ_C _ _ _)
set_option linter.uppercaseLean3 false in
#align mv_polynomial.iter_to_sum_C_C MvPolynomial.iterToSum_C_C

theorem iterToSum_X (b : S‚ÇÅ) : iterToSum R S‚ÇÅ S‚ÇÇ (X b) = X (Sum.inl b) :=
  eval‚ÇÇ_X _ _ _
set_option linter.uppercaseLean3 false in
#align mv_polynomial.iter_to_sum_X MvPolynomial.iterToSum_X

theorem iterToSum_C_X (c : S‚ÇÇ) : iterToSum R S‚ÇÅ S‚ÇÇ (C (X c)) = X (Sum.inr c) :=
  Eq.trans (eval‚ÇÇ_C _ _ (X c)) (eval‚ÇÇ_X _ _ _)
set_option linter.uppercaseLean3 false in
#align mv_polynomial.iter_to_sum_C_X MvPolynomial.iterToSum_C_X

variable (œÉ)

/-- The algebra isomorphism between multivariable polynomials in no variables
and the ground ring. -/
@[simps!]
def isEmptyAlgEquiv [he : IsEmpty œÉ] : MvPolynomial œÉ R ‚âÉ‚Çê[R] R :=
  AlgEquiv.ofAlgHom (aeval (IsEmpty.elim he)) (Algebra.ofId _ _)
    (by
      ext
      -- ‚ä¢ ‚Üë(AlgHom.comp (aeval fun a => IsEmpty.elim he a) (Algebra.ofId R (MvPolynomi ‚Ä¶
      simp [Algebra.ofId_apply, algebraMap_eq])
      -- üéâ no goals
    (by
      ext i m
      -- ‚ä¢ coeff m (‚Üë(AlgHom.comp (Algebra.ofId R (MvPolynomial œÉ R)) (aeval fun a => I ‚Ä¶
      exact IsEmpty.elim' he i)
      -- üéâ no goals
#align mv_polynomial.is_empty_alg_equiv MvPolynomial.isEmptyAlgEquiv

/-- The ring isomorphism between multivariable polynomials in no variables
and the ground ring. -/
@[simps!]
def isEmptyRingEquiv [IsEmpty œÉ] : MvPolynomial œÉ R ‚âÉ+* R :=
  (isEmptyAlgEquiv R œÉ).toRingEquiv
#align mv_polynomial.is_empty_ring_equiv MvPolynomial.isEmptyRingEquiv

variable {œÉ}

/-- A helper function for `sumRingEquiv`. -/
@[simps]
def mvPolynomialEquivMvPolynomial [CommSemiring S‚ÇÉ] (f : MvPolynomial S‚ÇÅ R ‚Üí+* MvPolynomial S‚ÇÇ S‚ÇÉ)
    (g : MvPolynomial S‚ÇÇ S‚ÇÉ ‚Üí+* MvPolynomial S‚ÇÅ R) (hfgC : (f.comp g).comp C = C)
    (hfgX : ‚àÄ n, f (g (X n)) = X n) (hgfC : (g.comp f).comp C = C) (hgfX : ‚àÄ n, g (f (X n)) = X n) :
    MvPolynomial S‚ÇÅ R ‚âÉ+* MvPolynomial S‚ÇÇ S‚ÇÉ
    where
  toFun := f
  invFun := g
  left_inv := is_id (RingHom.comp _ _) hgfC hgfX
  right_inv := is_id (RingHom.comp _ _) hfgC hfgX
  map_mul' := f.map_mul
  map_add' := f.map_add
#align mv_polynomial.mv_polynomial_equiv_mv_polynomial MvPolynomial.mvPolynomialEquivMvPolynomial

/-- The ring isomorphism between multivariable polynomials in a sum of two types,
and multivariable polynomials in one of the types,
with coefficients in multivariable polynomials in the other type.
-/
def sumRingEquiv : MvPolynomial (Sum S‚ÇÅ S‚ÇÇ) R ‚âÉ+* MvPolynomial S‚ÇÅ (MvPolynomial S‚ÇÇ R) := by
  apply mvPolynomialEquivMvPolynomial R (Sum S‚ÇÅ S‚ÇÇ) _ _ (sumToIter R S‚ÇÅ S‚ÇÇ) (iterToSum R S‚ÇÅ S‚ÇÇ)
  ¬∑ refine RingHom.ext (hom_eq_hom _ _ ?hC ?hX)
    -- ‚ä¢ RingHom.comp (RingHom.comp (RingHom.comp (sumToIter R S‚ÇÅ S‚ÇÇ) (iterToSum R S‚ÇÅ ‚Ä¶
    case hC => ext1; simp only [RingHom.comp_apply, iterToSum_C_C, sumToIter_C]
    -- ‚ä¢ ‚àÄ (n : S‚ÇÇ), ‚Üë(RingHom.comp (RingHom.comp (sumToIter R S‚ÇÅ S‚ÇÇ) (iterToSum R S‚ÇÅ ‚Ä¶
    -- üéâ no goals
    case hX => intro; simp only [RingHom.comp_apply, iterToSum_C_X, sumToIter_Xr]
    -- üéâ no goals
    -- üéâ no goals
  ¬∑ simp [iterToSum_X, sumToIter_Xl]
    -- üéâ no goals
  ¬∑ ext1; simp only [RingHom.comp_apply, sumToIter_C, iterToSum_C_C]
    -- ‚ä¢ ‚Üë(RingHom.comp (RingHom.comp (iterToSum R S‚ÇÅ S‚ÇÇ) (sumToIter R S‚ÇÅ S‚ÇÇ)) C) x‚úù  ‚Ä¶
          -- üéâ no goals
  ¬∑ rintro ‚ü®‚ü© <;> simp only [sumToIter_Xl, iterToSum_X, sumToIter_Xr, iterToSum_C_X]
    -- ‚ä¢ ‚Üë(iterToSum R S‚ÇÅ S‚ÇÇ) (‚Üë(sumToIter R S‚ÇÅ S‚ÇÇ) (X (Sum.inl val‚úù))) = X (Sum.inl  ‚Ä¶
                  -- üéâ no goals
                  -- üéâ no goals
#align mv_polynomial.sum_ring_equiv MvPolynomial.sumRingEquiv

/-- The algebra isomorphism between multivariable polynomials in a sum of two types,
and multivariable polynomials in one of the types,
with coefficients in multivariable polynomials in the other type.
-/
def sumAlgEquiv : MvPolynomial (Sum S‚ÇÅ S‚ÇÇ) R ‚âÉ‚Çê[R] MvPolynomial S‚ÇÅ (MvPolynomial S‚ÇÇ R) :=
  { sumRingEquiv R S‚ÇÅ S‚ÇÇ with
    commutes' := by
      intro r
      -- ‚ä¢ Equiv.toFun src‚úù.toEquiv (‚Üë(algebraMap R (MvPolynomial (S‚ÇÅ ‚äï S‚ÇÇ) R)) r) = ‚Üë( ‚Ä¶
      have A : algebraMap R (MvPolynomial S‚ÇÅ (MvPolynomial S‚ÇÇ R)) r = (C (C r) : _) := by rfl
      -- ‚ä¢ Equiv.toFun src‚úù.toEquiv (‚Üë(algebraMap R (MvPolynomial (S‚ÇÅ ‚äï S‚ÇÇ) R)) r) = ‚Üë( ‚Ä¶
      have B : algebraMap R (MvPolynomial (Sum S‚ÇÅ S‚ÇÇ) R) r = C r := by rfl
      -- ‚ä¢ Equiv.toFun src‚úù.toEquiv (‚Üë(algebraMap R (MvPolynomial (S‚ÇÅ ‚äï S‚ÇÇ) R)) r) = ‚Üë( ‚Ä¶
      simp only [sumRingEquiv, mvPolynomialEquivMvPolynomial, Equiv.toFun_as_coe_apply,
        Equiv.coe_fn_mk, B, sumToIter_C, A] }
#align mv_polynomial.sum_alg_equiv MvPolynomial.sumAlgEquiv

section

-- this speeds up typeclass search in the lemma below
attribute [local instance] IsScalarTower.right

/-- The algebra isomorphism between multivariable polynomials in `Option S‚ÇÅ` and
polynomials with coefficients in `MvPolynomial S‚ÇÅ R`.
-/
@[simps!]
def optionEquivLeft : MvPolynomial (Option S‚ÇÅ) R ‚âÉ‚Çê[R] Polynomial (MvPolynomial S‚ÇÅ R) :=
  AlgEquiv.ofAlgHom (MvPolynomial.aeval fun o => o.elim Polynomial.X fun s => Polynomial.C (X s))
    (Polynomial.aevalTower (MvPolynomial.rename some) (X none))
    (by ext : 2 <;> simp [‚Üê Polynomial.C_eq_algebraMap]) (by ext i : 2; cases i <;> simp)
        -- ‚ä¢ ‚Üë(AlgHom.comp (AlgHom.comp (aeval fun o => Option.elim o Polynomial.X fun s  ‚Ä¶
                    -- üéâ no goals
                    -- üéâ no goals
                                                             -- ‚ä¢ coeff m‚úù (‚Üë(AlgHom.comp (Polynomial.aevalTower (rename Option.some) (X none) ‚Ä¶
                                                                        -- ‚ä¢ coeff m‚úù (‚Üë(AlgHom.comp (Polynomial.aevalTower (rename Option.some) (X none) ‚Ä¶
                                                                                    -- üéâ no goals
                                                                                    -- üéâ no goals
#align mv_polynomial.option_equiv_left MvPolynomial.optionEquivLeft

end

/-- The algebra isomorphism between multivariable polynomials in `Option S‚ÇÅ` and
multivariable polynomials with coefficients in polynomials.
-/
def optionEquivRight : MvPolynomial (Option S‚ÇÅ) R ‚âÉ‚Çê[R] MvPolynomial S‚ÇÅ R[X] :=
  AlgEquiv.ofAlgHom (MvPolynomial.aeval fun o => o.elim (C Polynomial.X) X)
    (MvPolynomial.aevalTower (Polynomial.aeval (X none)) fun i => X (Option.some i))
    (by
      ext : 2 <;>
      -- ‚ä¢ ‚Üë(AlgHom.comp (AlgHom.comp (aeval fun o => Option.elim o (‚ÜëC Polynomial.X) X ‚Ä¶
        simp only [MvPolynomial.algebraMap_eq, Option.elim, AlgHom.coe_comp, AlgHom.id_comp,
          IsScalarTower.coe_toAlgHom', comp_apply, aevalTower_C, Polynomial.aeval_X, aeval_X,
          Option.elim', aevalTower_X, AlgHom.coe_id, id.def, eq_self_iff_true, imp_true_iff])
    (by
      ext ‚ü®i‚ü© : 2 <;>
      -- ‚ä¢ coeff m‚úù (‚Üë(AlgHom.comp (aevalTower (Polynomial.aeval (X none)) fun i => X ( ‚Ä¶
        simp only [Option.elim, AlgHom.coe_comp, comp_apply, aeval_X, aevalTower_C,
          Polynomial.aeval_X, AlgHom.coe_id, id.def, aevalTower_X])
#align mv_polynomial.option_equiv_right MvPolynomial.optionEquivRight

variable (n : ‚Ñï)

/-- The algebra isomorphism between multivariable polynomials in `Fin (n + 1)` and
polynomials over multivariable polynomials in `Fin n`.
-/
def finSuccEquiv : MvPolynomial (Fin (n + 1)) R ‚âÉ‚Çê[R] Polynomial (MvPolynomial (Fin n) R) :=
  (renameEquiv R (_root_.finSuccEquiv n)).trans (optionEquivLeft R (Fin n))
#align mv_polynomial.fin_succ_equiv MvPolynomial.finSuccEquiv

theorem finSuccEquiv_eq :
    (finSuccEquiv R n : MvPolynomial (Fin (n + 1)) R ‚Üí+* Polynomial (MvPolynomial (Fin n) R)) =
      eval‚ÇÇHom (Polynomial.C.comp (C : R ‚Üí+* MvPolynomial (Fin n) R)) fun i : Fin (n + 1) =>
        Fin.cases Polynomial.X (fun k => Polynomial.C (X k)) i := by
  ext i : 2
  -- ‚ä¢ ‚Üë(RingHom.comp (‚Üë(finSuccEquiv R n)) C) i = ‚Üë(RingHom.comp (eval‚ÇÇHom (RingHo ‚Ä¶
  ¬∑ simp only [finSuccEquiv, optionEquivLeft_apply, aeval_C, AlgEquiv.coe_trans, RingHom.coe_coe,
      coe_eval‚ÇÇHom, comp_apply, renameEquiv_apply, eval‚ÇÇ_C, RingHom.coe_comp, rename_C]
    rfl
    -- üéâ no goals
  ¬∑ refine' Fin.cases _ _ i <;> simp [finSuccEquiv]
    -- ‚ä¢ Polynomial.coeff (‚Üë‚Üë(finSuccEquiv R n) (X 0)) n‚úù = Polynomial.coeff (‚Üë(eval‚ÇÇ ‚Ä¶
                                -- üéâ no goals
                                -- üéâ no goals
#align mv_polynomial.fin_succ_equiv_eq MvPolynomial.finSuccEquiv_eq

@[simp]
theorem finSuccEquiv_apply (p : MvPolynomial (Fin (n + 1)) R) :
    finSuccEquiv R n p =
      eval‚ÇÇHom (Polynomial.C.comp (C : R ‚Üí+* MvPolynomial (Fin n) R))
        (fun i : Fin (n + 1) => Fin.cases Polynomial.X (fun k => Polynomial.C (X k)) i) p := by
  rw [‚Üê finSuccEquiv_eq, RingHom.coe_coe]
  -- üéâ no goals
#align mv_polynomial.fin_succ_equiv_apply MvPolynomial.finSuccEquiv_apply

theorem finSuccEquiv_comp_C_eq_C {R : Type u} [CommSemiring R] (n : ‚Ñï) :
    (‚Üë(MvPolynomial.finSuccEquiv R n).symm : Polynomial (MvPolynomial (Fin n) R) ‚Üí+* _).comp
        (Polynomial.C.comp MvPolynomial.C) =
      (MvPolynomial.C : R ‚Üí+* MvPolynomial (Fin n.succ) R) := by
  refine' RingHom.ext fun x => _
  -- ‚ä¢ ‚Üë(RingHom.comp (‚Üë(AlgEquiv.symm (finSuccEquiv R n))) (RingHom.comp Polynomia ‚Ä¶
  rw [RingHom.comp_apply]
  -- ‚ä¢ ‚Üë‚Üë(AlgEquiv.symm (finSuccEquiv R n)) (‚Üë(RingHom.comp Polynomial.C C) x) = ‚ÜëC x
  refine'
    (MvPolynomial.finSuccEquiv R n).injective
      (Trans.trans ((MvPolynomial.finSuccEquiv R n).apply_symm_apply _) _)
  simp only [MvPolynomial.finSuccEquiv_apply, MvPolynomial.eval‚ÇÇHom_C]
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align mv_polynomial.fin_succ_equiv_comp_C_eq_C MvPolynomial.finSuccEquiv_comp_C_eq_C

variable {n} {R}

theorem finSuccEquiv_X_zero : finSuccEquiv R n (X 0) = Polynomial.X := by simp
                                                                          -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align mv_polynomial.fin_succ_equiv_X_zero MvPolynomial.finSuccEquiv_X_zero

theorem finSuccEquiv_X_succ {j : Fin n} : finSuccEquiv R n (X j.succ) = Polynomial.C (X j) := by
  simp
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align mv_polynomial.fin_succ_equiv_X_succ MvPolynomial.finSuccEquiv_X_succ

/-- The coefficient of `m` in the `i`-th coefficient of `finSuccEquiv R n f` equals the
    coefficient of `Finsupp.cons i m` in `f`. -/
theorem finSuccEquiv_coeff_coeff (m : Fin n ‚Üí‚ÇÄ ‚Ñï) (f : MvPolynomial (Fin (n + 1)) R) (i : ‚Ñï) :
    coeff m (Polynomial.coeff (finSuccEquiv R n f) i) = coeff (m.cons i) f := by
  induction' f using MvPolynomial.induction_on' with j r p q hp hq generalizing i m
  -- ‚ä¢ coeff m (Polynomial.coeff (‚Üë(finSuccEquiv R n) (‚Üë(monomial j) r)) i) = coeff ‚Ä¶
  swap
  -- ‚ä¢ coeff m (Polynomial.coeff (‚Üë(finSuccEquiv R n) (p + q)) i) = coeff (cons i m ‚Ä¶
  ¬∑ simp only [(finSuccEquiv R n).map_add, Polynomial.coeff_add, coeff_add, hp, hq]
    -- üéâ no goals
  simp only [finSuccEquiv_apply, coe_eval‚ÇÇHom, eval‚ÇÇ_monomial, RingHom.coe_comp, prod_pow,
    Polynomial.coeff_C_mul, coeff_C_mul, coeff_monomial, Fin.prod_univ_succ, Fin.cases_zero,
    Fin.cases_succ, ‚Üê map_prod, ‚Üê RingHom.map_pow, Function.comp_apply]
  rw [‚Üê mul_boole, mul_comm (Polynomial.X ^ j 0), Polynomial.coeff_C_mul_X_pow]; congr 1
  -- ‚ä¢ r * coeff m (if i = ‚Üëj 0 then ‚àè x : Fin n, X x ^ ‚Üëj (Fin.succ x) else 0) = r ‚Ä¶
                                                                                 -- ‚ä¢ coeff m (if i = ‚Üëj 0 then ‚àè x : Fin n, X x ^ ‚Üëj (Fin.succ x) else 0) = if j  ‚Ä¶
  obtain rfl | hjmi := eq_or_ne j (m.cons i)
  -- ‚ä¢ coeff m (if i = ‚Üë(cons i m) 0 then ‚àè x : Fin n, X x ^ ‚Üë(cons i m) (Fin.succ  ‚Ä¶
  ¬∑ simpa only [cons_zero, cons_succ, if_pos rfl, monomial_eq, C_1, one_mul, prod_pow] using
      coeff_monomial m m (1 : R)
  ¬∑ simp only [hjmi, if_false]
    -- ‚ä¢ coeff m (if i = ‚Üëj 0 then ‚àè x : Fin n, X x ^ ‚Üëj (Fin.succ x) else 0) = 0
    obtain hij | rfl := ne_or_eq i (j 0)
    -- ‚ä¢ coeff m (if i = ‚Üëj 0 then ‚àè x : Fin n, X x ^ ‚Üëj (Fin.succ x) else 0) = 0
    ¬∑ simp only [hij, if_false, coeff_zero]
      -- üéâ no goals
    simp only [eq_self_iff_true, if_true]
    -- ‚ä¢ coeff m (‚àè x : Fin n, X x ^ ‚Üëj (Fin.succ x)) = 0
    have hmj : m ‚â† j.tail := by
      rintro rfl
      rw [cons_tail] at hjmi
      contradiction
    simpa only [monomial_eq, C_1, one_mul, prod_pow, Finsupp.tail_apply, if_neg hmj.symm] using
      coeff_monomial m j.tail (1 : R)
#align mv_polynomial.fin_succ_equiv_coeff_coeff MvPolynomial.finSuccEquiv_coeff_coeff

theorem eval_eq_eval_mv_eval' (s : Fin n ‚Üí R) (y : R) (f : MvPolynomial (Fin (n + 1)) R) :
    eval (Fin.cons y s : Fin (n + 1) ‚Üí R) f =
      Polynomial.eval y (Polynomial.map (eval s) (finSuccEquiv R n f)) := by
  -- turn this into a def `Polynomial.mapAlgHom`
  let œÜ : (MvPolynomial (Fin n) R)[X] ‚Üí‚Çê[R] R[X] :=
    { Polynomial.mapRingHom (eval s) with
      commutes' := fun r => by
        convert Polynomial.map_C (eval s)
        exact (eval_C _).symm }
  show
    aeval (Fin.cons y s : Fin (n + 1) ‚Üí R) f =
      (Polynomial.aeval y).comp (œÜ.comp (finSuccEquiv R n).toAlgHom) f
  congr 2
  -- ‚ä¢ aeval (Fin.cons y s) = AlgHom.comp (Polynomial.aeval y) (AlgHom.comp œÜ ‚Üë(fin ‚Ä¶
  apply MvPolynomial.algHom_ext
  -- ‚ä¢ ‚àÄ (i : Fin (n + 1)), ‚Üë(aeval (Fin.cons y s)) (X i) = ‚Üë(AlgHom.comp (Polynomi ‚Ä¶
  rw [Fin.forall_fin_succ]
  -- ‚ä¢ ‚Üë(aeval (Fin.cons y s)) (X 0) = ‚Üë(AlgHom.comp (Polynomial.aeval y) (AlgHom.c ‚Ä¶
  simp only [aeval_X, Fin.cons_zero, AlgEquiv.toAlgHom_eq_coe, AlgHom.coe_comp,
    Polynomial.coe_aeval_eq_eval, Polynomial.map_C, AlgHom.coe_mk, RingHom.toFun_eq_coe,
    Polynomial.coe_mapRingHom, comp_apply, finSuccEquiv_apply, eval‚ÇÇHom_X',
    Fin.cases_zero, Polynomial.map_X, Polynomial.eval_X, Fin.cons_succ,
    Fin.cases_succ, eval_X, Polynomial.eval_C,
    RingHom.coe_mk, MonoidHom.coe_coe, AlgHom.coe_coe, implies_true, and_self,
    RingHom.toMonoidHom_eq_coe]
#align mv_polynomial.eval_eq_eval_mv_eval' MvPolynomial.eval_eq_eval_mv_eval'

theorem coeff_eval_eq_eval_coeff (s' : Fin n ‚Üí R) (f : Polynomial (MvPolynomial (Fin n) R))
    (i : ‚Ñï) : Polynomial.coeff (Polynomial.map (eval s') f) i = eval s' (Polynomial.coeff f i) := by
  simp only [Polynomial.coeff_map]
  -- üéâ no goals
#align mv_polynomial.coeff_eval_eq_eval_coeff MvPolynomial.coeff_eval_eq_eval_coeff

theorem support_coeff_finSuccEquiv {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} {m : Fin n ‚Üí‚ÇÄ ‚Ñï} :
    m ‚àà (Polynomial.coeff ((finSuccEquiv R n) f) i).support ‚Üî Finsupp.cons i m ‚àà f.support := by
  apply Iff.intro
  -- ‚ä¢ m ‚àà support (Polynomial.coeff (‚Üë(finSuccEquiv R n) f) i) ‚Üí cons i m ‚àà suppor ‚Ä¶
  ¬∑ intro h
    -- ‚ä¢ cons i m ‚àà support f
    simpa [‚Üê finSuccEquiv_coeff_coeff] using h
    -- üéâ no goals
  ¬∑ intro h
    -- ‚ä¢ m ‚àà support (Polynomial.coeff (‚Üë(finSuccEquiv R n) f) i)
    simpa [mem_support_iff, ‚Üê finSuccEquiv_coeff_coeff m f i] using h
    -- üéâ no goals
#align mv_polynomial.support_coeff_fin_succ_equiv MvPolynomial.support_coeff_finSuccEquiv

theorem finSuccEquiv_support (f : MvPolynomial (Fin (n + 1)) R) :
    (finSuccEquiv R n f).support = Finset.image (fun m : Fin (n + 1) ‚Üí‚ÇÄ ‚Ñï => m 0) f.support := by
  ext i
  -- ‚ä¢ i ‚àà Polynomial.support (‚Üë(finSuccEquiv R n) f) ‚Üî i ‚àà Finset.image (fun m =>  ‚Ä¶
  rw [Polynomial.mem_support_iff, Finset.mem_image, nonzero_iff_exists]
  -- ‚ä¢ (‚àÉ a, ‚Üë(Polynomial.coeff (‚Üë(finSuccEquiv R n) f) i) a ‚â† 0) ‚Üî ‚àÉ a, a ‚àà suppor ‚Ä¶
  constructor
  -- ‚ä¢ (‚àÉ a, ‚Üë(Polynomial.coeff (‚Üë(finSuccEquiv R n) f) i) a ‚â† 0) ‚Üí ‚àÉ a, a ‚àà suppor ‚Ä¶
  ¬∑ rintro ‚ü®m, hm‚ü©
    -- ‚ä¢ ‚àÉ a, a ‚àà support f ‚àß ‚Üëa 0 = i
    refine' ‚ü®cons i m, _, cons_zero _ _‚ü©
    -- ‚ä¢ cons i m ‚àà support f
    rw [‚Üê support_coeff_finSuccEquiv]
    -- ‚ä¢ m ‚àà support (Polynomial.coeff (‚Üë(finSuccEquiv R n) f) i)
    simpa using hm
    -- üéâ no goals
  ¬∑ rintro ‚ü®m, h, rfl‚ü©
    -- ‚ä¢ ‚àÉ a, ‚Üë(Polynomial.coeff (‚Üë(finSuccEquiv R n) f) (‚Üëm 0)) a ‚â† 0
    refine' ‚ü®tail m, _‚ü©
    -- ‚ä¢ ‚Üë(Polynomial.coeff (‚Üë(finSuccEquiv R n) f) (‚Üëm 0)) (tail m) ‚â† 0
    rwa [‚Üê coeff, ‚Üê mem_support_iff, support_coeff_finSuccEquiv, cons_tail]
    -- üéâ no goals
#align mv_polynomial.fin_succ_equiv_support MvPolynomial.finSuccEquiv_support

theorem finSuccEquiv_support' {f : MvPolynomial (Fin (n + 1)) R} {i : ‚Ñï} :
    Finset.image (Finsupp.cons i) (Polynomial.coeff ((finSuccEquiv R n) f) i).support =
      f.support.filter fun m => m 0 = i := by
  ext m
  -- ‚ä¢ m ‚àà Finset.image (cons i) (support (Polynomial.coeff (‚Üë(finSuccEquiv R n) f) ‚Ä¶
  rw [Finset.mem_filter, Finset.mem_image, mem_support_iff]
  -- ‚ä¢ (‚àÉ a, a ‚àà support (Polynomial.coeff (‚Üë(finSuccEquiv R n) f) i) ‚àß cons i a =  ‚Ä¶
  conv_lhs =>
    congr
    ext
    rw [mem_support_iff, finSuccEquiv_coeff_coeff, Ne.def]
  constructor
  -- ‚ä¢ (‚àÉ x, ¬¨coeff (cons i x) f = 0 ‚àß cons i x = m) ‚Üí coeff m f ‚â† 0 ‚àß ‚Üëm 0 = i
  ¬∑ rintro ‚ü®m', ‚ü®h, hm'‚ü©‚ü©
    -- ‚ä¢ coeff m f ‚â† 0 ‚àß ‚Üëm 0 = i
    simp only [‚Üê hm']
    -- ‚ä¢ coeff (cons i m') f ‚â† 0 ‚àß ‚Üë(cons i m') 0 = i
    exact ‚ü®h, by rw [cons_zero]‚ü©
    -- üéâ no goals
  ¬∑ intro h
    -- ‚ä¢ ‚àÉ x, ¬¨coeff (cons i x) f = 0 ‚àß cons i x = m
    use tail m
    -- ‚ä¢ ¬¨coeff (cons i (tail m)) f = 0 ‚àß cons i (tail m) = m
    rw [‚Üê h.2, cons_tail]
    -- ‚ä¢ ¬¨coeff m f = 0 ‚àß m = m
    simp [h.1]
    -- üéâ no goals
#align mv_polynomial.fin_succ_equiv_support' MvPolynomial.finSuccEquiv_support'

theorem support_finSuccEquiv_nonempty {f : MvPolynomial (Fin (n + 1)) R} (h : f ‚â† 0) :
    (finSuccEquiv R n f).support.Nonempty := by
  simp only [Finset.nonempty_iff_ne_empty, Ne, Polynomial.support_eq_empty]
  -- ‚ä¢ ¬¨‚Üë(finSuccEquiv R n) f = 0
  refine fun c => h ?_
  -- ‚ä¢ f = 0
  let ii := (finSuccEquiv R n).symm
  -- ‚ä¢ f = 0
  calc
    f = ii (finSuccEquiv R n f) := by
      simpa only [‚Üê AlgEquiv.invFun_eq_symm] using ((finSuccEquiv R n).left_inv f).symm
    _ = ii 0 := by rw [c]
    _ = 0 := by simp
#align mv_polynomial.support_fin_succ_equiv_nonempty MvPolynomial.support_finSuccEquiv_nonempty

theorem degree_finSuccEquiv {f : MvPolynomial (Fin (n + 1)) R} (h : f ‚â† 0) :
    (finSuccEquiv R n f).degree = degreeOf 0 f := by
  -- TODO: these should be lemmas
  have h‚ÇÄ : ‚àÄ {Œ± Œ≤ : Type _} (f : Œ± ‚Üí Œ≤), (fun x => x) ‚àò f = f := fun f => rfl
  -- ‚ä¢ degree (‚Üë(finSuccEquiv R n) f) = ‚Üë(degreeOf 0 f)
  have h‚ÇÅ : ‚àÄ {Œ± Œ≤ : Type _} (f : Œ± ‚Üí Œ≤), f ‚àò (fun x => x) = f := fun f => rfl
  -- ‚ä¢ degree (‚Üë(finSuccEquiv R n) f) = ‚Üë(degreeOf 0 f)
  have h‚ÇÇ : WithBot.some = Nat.cast := rfl
  -- ‚ä¢ degree (‚Üë(finSuccEquiv R n) f) = ‚Üë(degreeOf 0 f)

  have h' : ((finSuccEquiv R n f).support.sup fun x => x) = degreeOf 0 f := by
    rw [degreeOf_eq_sup, finSuccEquiv_support f, Finset.sup_image, h‚ÇÄ]
  rw [Polynomial.degree, ‚Üê h', ‚Üê h‚ÇÇ, Finset.coe_sup_of_nonempty (support_finSuccEquiv_nonempty h),
    Finset.max_eq_sup_coe, h‚ÇÅ]
#align mv_polynomial.degree_fin_succ_equiv MvPolynomial.degree_finSuccEquiv

theorem natDegree_finSuccEquiv (f : MvPolynomial (Fin (n + 1)) R) :
    (finSuccEquiv R n f).natDegree = degreeOf 0 f := by
  by_cases c : f = 0
  -- ‚ä¢ natDegree (‚Üë(finSuccEquiv R n) f) = degreeOf 0 f
  ¬∑ rw [c, (finSuccEquiv R n).map_zero, Polynomial.natDegree_zero, degreeOf_zero]
    -- üéâ no goals
  ¬∑ rw [Polynomial.natDegree, degree_finSuccEquiv (by simpa only [Ne.def] )]
    -- ‚ä¢ WithBot.unbot' 0 ‚Üë(degreeOf 0 f) = degreeOf 0 f
    erw [WithBot.unbot'_coe]
    -- ‚ä¢ ‚Üë(degreeOf 0 f) = degreeOf 0 f
    simp
    -- üéâ no goals
#align mv_polynomial.nat_degree_fin_succ_equiv MvPolynomial.natDegree_finSuccEquiv

theorem degreeOf_coeff_finSuccEquiv (p : MvPolynomial (Fin (n + 1)) R) (j : Fin n) (i : ‚Ñï) :
    degreeOf j (Polynomial.coeff (finSuccEquiv R n p) i) ‚â§ degreeOf j.succ p := by
  rw [degreeOf_eq_sup, degreeOf_eq_sup, Finset.sup_le_iff]
  -- ‚ä¢ ‚àÄ (b : Fin n ‚Üí‚ÇÄ ‚Ñï), b ‚àà support (Polynomial.coeff (‚Üë(finSuccEquiv R n) p) i) ‚Ä¶
  intro m hm
  -- ‚ä¢ ‚Üëm j ‚â§ Finset.sup (support p) fun m => ‚Üëm (Fin.succ j)
  rw [‚Üê Finsupp.cons_succ j i m]
  -- ‚ä¢ ‚Üë(cons i m) (Fin.succ j) ‚â§ Finset.sup (support p) fun m => ‚Üëm (Fin.succ j)
  exact Finset.le_sup
    (f := fun (g : Fin (Nat.succ n) ‚Üí‚ÇÄ ‚Ñï) => g (Fin.succ j))
    (support_coeff_finSuccEquiv.1 hm)
#align mv_polynomial.degree_of_coeff_fin_succ_equiv MvPolynomial.degreeOf_coeff_finSuccEquiv

end

end Equiv

end MvPolynomial
