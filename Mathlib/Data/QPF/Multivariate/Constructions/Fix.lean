/-
Copyright (c) 2018 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, Simon Hudon
-/
import Mathlib.Data.PFunctor.Multivariate.W
import Mathlib.Data.QPF.Multivariate.Basic

#align_import data.qpf.multivariate.constructions.fix from "leanprover-community/mathlib"@"28aa996fc6fb4317f0083c4e6daf79878d81be33"

/-!
# The initial algebra of a multivariate qpf is again a qpf.

For an `(n+1)`-ary QPF `F (Œ±‚ÇÄ,..,Œ±‚Çô)`, we take the least fixed point of `F` with
regards to its last argument `Œ±‚Çô`. The result is an `n`-ary functor: `Fix F (Œ±‚ÇÄ,..,Œ±‚Çô‚Çã‚ÇÅ)`.
Making `Fix F` into a functor allows us to take the fixed point, compose with other functors
and take a fixed point again.

## Main definitions

 * `Fix.mk`     - constructor
 * `Fix.dest`    - destructor
 * `Fix.rec`    - recursor: basis for defining functions by structural recursion on `Fix F Œ±`
 * `Fix.drec`   - dependent recursor: generalization of `Fix.rec` where
                  the result type of the function is allowed to depend on the `Fix F Œ±` value
 * `Fix.rec_eq` - defining equation for `recursor`
 * `Fix.ind`    - induction principle for `Fix F Œ±`

## Implementation notes

For `F` a `QPF`, we define `Fix F Œ±` in terms of the W-type of the polynomial functor `P` of `F`.
We define the relation `WEquiv` and take its quotient as the definition of `Fix F Œ±`.

See [avigad-carneiro-hudon2019] for more details.

## Reference

 * Jeremy Avigad, Mario M. Carneiro and Simon Hudon.
   [*Data Types as Quotients of Polynomial Functors*][avigad-carneiro-hudon2019]
-/


universe u v

namespace MvQPF

open TypeVec

open MvFunctor (LiftP LiftR)

open MvFunctor

variable {n : ‚Ñï} {F : TypeVec.{u} (n + 1) ‚Üí Type u} [MvFunctor F] [q : MvQPF F]


/-- `recF` is used as a basis for defining the recursor on `Fix F Œ±`. `recF`
traverses recursively the W-type generated by `q.P` using a function on `F`
as a recursive step -/
def recF {Œ± : TypeVec n} {Œ≤ : Type _} (g : F (Œ±.append1 Œ≤) ‚Üí Œ≤) : q.P.W Œ± ‚Üí Œ≤ :=
  q.P.wRec fun a f' _f rec => g (abs ‚ü®a, splitFun f' rec‚ü©)
set_option linter.uppercaseLean3 false in
#align mvqpf.recF MvQPF.recF

theorem recF_eq {Œ± : TypeVec n} {Œ≤ : Type _} (g : F (Œ±.append1 Œ≤) ‚Üí Œ≤) (a : q.P.A)
    (f' : q.P.drop.B a ‚üπ Œ±) (f : q.P.last.B a ‚Üí q.P.W Œ±) :
    recF g (q.P.wMk a f' f) = g (abs ‚ü®a, splitFun f' (recF g ‚àò f)‚ü©) := by
  rw [recF, MvPFunctor.wRec_eq]; rfl
  -- ‚ä¢ g (abs { fst := a, snd := splitFun f' fun i => MvPFunctor.wRec (P F) (fun a  ‚Ä¶
                                 -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align mvqpf.recF_eq MvQPF.recF_eq

theorem recF_eq' {Œ± : TypeVec n} {Œ≤ : Type _} (g : F (Œ±.append1 Œ≤) ‚Üí Œ≤) (x : q.P.W Œ±) :
    recF g x = g (abs (appendFun id (recF g) <$$> q.P.wDest' x)) := by
  apply q.P.w_cases _ x
  -- ‚ä¢ ‚àÄ (a : (P F).A) (f' : MvPFunctor.B (MvPFunctor.drop (P F)) a ‚üπ Œ±) (f : PFunc ‚Ä¶
  intro a f' f
  -- ‚ä¢ recF g (MvPFunctor.wMk (P F) a f' f) = g (abs ((TypeVec.id ::: recF g) <$$>  ‚Ä¶
  rw [recF_eq, q.P.wDest'_wMk, MvPFunctor.map_eq, appendFun_comp_splitFun, TypeVec.id_comp]
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align mvqpf.recF_eq' MvQPF.recF_eq'

/-- Equivalence relation on W-types that represent the same `Fix F`
value -/
inductive WEquiv {Œ± : TypeVec n} : q.P.W Œ± ‚Üí q.P.W Œ± ‚Üí Prop
  | ind (a : q.P.A) (f' : q.P.drop.B a ‚üπ Œ±) (f‚ÇÄ f‚ÇÅ : q.P.last.B a ‚Üí q.P.W Œ±) :
    (‚àÄ x, WEquiv (f‚ÇÄ x) (f‚ÇÅ x)) ‚Üí WEquiv (q.P.wMk a f' f‚ÇÄ) (q.P.wMk a f' f‚ÇÅ)
  | abs (a‚ÇÄ : q.P.A) (f'‚ÇÄ : q.P.drop.B a‚ÇÄ ‚üπ Œ±) (f‚ÇÄ : q.P.last.B a‚ÇÄ ‚Üí q.P.W Œ±) (a‚ÇÅ : q.P.A)
    (f'‚ÇÅ : q.P.drop.B a‚ÇÅ ‚üπ Œ±) (f‚ÇÅ : q.P.last.B a‚ÇÅ ‚Üí q.P.W Œ±) :
    abs ‚ü®a‚ÇÄ, q.P.appendContents f'‚ÇÄ f‚ÇÄ‚ü© = abs ‚ü®a‚ÇÅ, q.P.appendContents f'‚ÇÅ f‚ÇÅ‚ü© ‚Üí
      WEquiv (q.P.wMk a‚ÇÄ f'‚ÇÄ f‚ÇÄ) (q.P.wMk a‚ÇÅ f'‚ÇÅ f‚ÇÅ)
  | trans (u v w : q.P.W Œ±) : WEquiv u v ‚Üí WEquiv v w ‚Üí WEquiv u w
set_option linter.uppercaseLean3 false in
#align mvqpf.Wequiv MvQPF.WEquiv

theorem recF_eq_of_wEquiv (Œ± : TypeVec n) {Œ≤ : Type _} (u : F (Œ±.append1 Œ≤) ‚Üí Œ≤) (x y : q.P.W Œ±) :
    WEquiv x y ‚Üí recF u x = recF u y := by
  apply q.P.w_cases _ x
  -- ‚ä¢ ‚àÄ (a : (P F).A) (f' : MvPFunctor.B (MvPFunctor.drop (P F)) a ‚üπ Œ±) (f : PFunc ‚Ä¶
  intro a‚ÇÄ f'‚ÇÄ f‚ÇÄ
  -- ‚ä¢ WEquiv (MvPFunctor.wMk (P F) a‚ÇÄ f'‚ÇÄ f‚ÇÄ) y ‚Üí recF u (MvPFunctor.wMk (P F) a‚ÇÄ  ‚Ä¶
  apply q.P.w_cases _ y
  -- ‚ä¢ ‚àÄ (a : (P F).A) (f' : MvPFunctor.B (MvPFunctor.drop (P F)) a ‚üπ Œ±) (f : PFunc ‚Ä¶
  intro a‚ÇÅ f'‚ÇÅ f‚ÇÅ
  -- ‚ä¢ WEquiv (MvPFunctor.wMk (P F) a‚ÇÄ f'‚ÇÄ f‚ÇÄ) (MvPFunctor.wMk (P F) a‚ÇÅ f'‚ÇÅ f‚ÇÅ) ‚Üí r ‚Ä¶
  intro h
  -- ‚ä¢ recF u (MvPFunctor.wMk (P F) a‚ÇÄ f'‚ÇÄ f‚ÇÄ) = recF u (MvPFunctor.wMk (P F) a‚ÇÅ f' ‚Ä¶
  -- porting note: induction on h doesn't work.
  refine' @WEquiv.recOn _ _ _ _ _ (Œª a a' _ => recF u a = recF u a') _ _ h _ _ _
  ¬∑ intros a f' f‚ÇÄ f‚ÇÅ _h ih; simp only [recF_eq, Function.comp]
    -- ‚ä¢ recF u (MvPFunctor.wMk (P F) a f' f‚ÇÄ) = recF u (MvPFunctor.wMk (P F) a f' f‚ÇÅ)
                             -- ‚ä¢ u (abs { fst := a, snd := splitFun f' fun x => recF u (f‚ÇÄ x) }) = u (abs { f ‚Ä¶
    congr; funext; congr; funext; apply ih
    -- ‚ä¢ (splitFun f' fun x => recF u (f‚ÇÄ x)) = splitFun f' fun x => recF u (f‚ÇÅ x)
           -- ‚ä¢ splitFun f' (fun x => recF u (f‚ÇÄ x)) x‚úù¬π x‚úù = splitFun f' (fun x => recF u ( ‚Ä¶
                   -- ‚ä¢ (fun x => recF u (f‚ÇÄ x)) = fun x => recF u (f‚ÇÅ x)
                          -- ‚ä¢ recF u (f‚ÇÄ x‚úù) = recF u (f‚ÇÅ x‚úù)
                                  -- üéâ no goals
  ¬∑ intros a‚ÇÄ f'‚ÇÄ f‚ÇÄ a‚ÇÅ f'‚ÇÅ f‚ÇÅ h; simp only [recF_eq', abs_map, MvPFunctor.wDest'_wMk, h]
    -- ‚ä¢ recF u (MvPFunctor.wMk (P F) a‚ÇÄ f'‚ÇÄ f‚ÇÄ) = recF u (MvPFunctor.wMk (P F) a‚ÇÅ f' ‚Ä¶
                                  -- üéâ no goals
  ¬∑ intros x y z _e‚ÇÅ _e‚ÇÇ ih‚ÇÅ ih‚ÇÇ; exact Eq.trans ih‚ÇÅ ih‚ÇÇ
    -- ‚ä¢ recF u x = recF u z
                                  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align mvqpf.recF_eq_of_Wequiv MvQPF.recF_eq_of_wEquiv

theorem wEquiv.abs' {Œ± : TypeVec n} (x y : q.P.W Œ±)
                    (h : MvQPF.abs (q.P.wDest' x ) = MvQPF.abs (q.P.wDest' y)) :
    WEquiv x y := by
  revert h
  -- ‚ä¢ abs (MvPFunctor.wDest' (P F) x) = abs (MvPFunctor.wDest' (P F) y) ‚Üí WEquiv x y
  apply q.P.w_cases _ x
  -- ‚ä¢ ‚àÄ (a : (P F).A) (f' : MvPFunctor.B (MvPFunctor.drop (P F)) a ‚üπ Œ±) (f : PFunc ‚Ä¶
  intro a‚ÇÄ f'‚ÇÄ f‚ÇÄ
  -- ‚ä¢ abs (MvPFunctor.wDest' (P F) (MvPFunctor.wMk (P F) a‚ÇÄ f'‚ÇÄ f‚ÇÄ)) = abs (MvPFun ‚Ä¶
  apply q.P.w_cases _ y
  -- ‚ä¢ ‚àÄ (a : (P F).A) (f' : MvPFunctor.B (MvPFunctor.drop (P F)) a ‚üπ Œ±) (f : PFunc ‚Ä¶
  intro a‚ÇÅ f'‚ÇÅ f‚ÇÅ
  -- ‚ä¢ abs (MvPFunctor.wDest' (P F) (MvPFunctor.wMk (P F) a‚ÇÄ f'‚ÇÄ f‚ÇÄ)) = abs (MvPFun ‚Ä¶
  apply WEquiv.abs
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align mvqpf.Wequiv.abs' MvQPF.wEquiv.abs'

theorem wEquiv.refl {Œ± : TypeVec n} (x : q.P.W Œ±) : WEquiv x x := by
  apply q.P.w_cases _ x; intro a f' f; exact WEquiv.abs a f' f a f' f rfl
  -- ‚ä¢ ‚àÄ (a : (P F).A) (f' : MvPFunctor.B (MvPFunctor.drop (P F)) a ‚üπ Œ±) (f : PFunc ‚Ä¶
                         -- ‚ä¢ WEquiv (MvPFunctor.wMk (P F) a f' f) (MvPFunctor.wMk (P F) a f' f)
                                       -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align mvqpf.Wequiv.refl MvQPF.wEquiv.refl

theorem wEquiv.symm {Œ± : TypeVec n} (x y : q.P.W Œ±) : WEquiv x y ‚Üí WEquiv y x := by
  intro h; induction h
  -- ‚ä¢ WEquiv y x
  case ind a f' f‚ÇÄ f‚ÇÅ _h ih => exact WEquiv.ind _ _ _ _ ih
  -- ‚ä¢ WEquiv (MvPFunctor.wMk (P F) a‚ÇÅ‚úù f'‚ÇÅ‚úù f‚ÇÅ‚úù) (MvPFunctor.wMk (P F) a‚ÇÄ‚úù f'‚ÇÄ‚úù f‚ÇÄ‚úù)
  -- üéâ no goals
  case abs a‚ÇÄ f'‚ÇÄ f‚ÇÄ a‚ÇÅ f'‚ÇÅ f‚ÇÅ h => exact WEquiv.abs _ _ _ _ _ _ h.symm
  -- ‚ä¢ WEquiv w‚úù u‚úù
  -- üéâ no goals
  case trans x y z _e‚ÇÅ _e‚ÇÇ ih‚ÇÅ ih‚ÇÇ => exact MvQPF.WEquiv.trans _ _ _ ih‚ÇÇ ih‚ÇÅ
  -- üéâ no goals
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align mvqpf.Wequiv.symm MvQPF.wEquiv.symm

/-- maps every element of the W type to a canonical representative -/
def wrepr {Œ± : TypeVec n} : q.P.W Œ± ‚Üí q.P.W Œ± :=
  recF (q.P.wMk' ‚àò repr)
set_option linter.uppercaseLean3 false in
#align mvqpf.Wrepr MvQPF.wrepr

theorem wrepr_wMk {Œ± : TypeVec n} (a : q.P.A) (f' : q.P.drop.B a ‚üπ Œ±)
    (f : q.P.last.B a ‚Üí q.P.W Œ±) :
    wrepr (q.P.wMk a f' f) =
      q.P.wMk' (repr (abs (appendFun id wrepr <$$> ‚ü®a, q.P.appendContents f' f‚ü©))) :=
  by rw [wrepr, recF_eq', q.P.wDest'_wMk]; rfl
     -- ‚ä¢ (MvPFunctor.wMk' (P F) ‚àò repr) (abs ((TypeVec.id ::: recF (MvPFunctor.wMk' ( ‚Ä¶
                                           -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align mvqpf.Wrepr_W_mk MvQPF.wrepr_wMk

theorem wrepr_equiv {Œ± : TypeVec n} (x : q.P.W Œ±) : WEquiv (wrepr x) x := by
  apply q.P.w_ind _ x; intro a f' f ih
  -- ‚ä¢ ‚àÄ (a : (P F).A) (f' : MvPFunctor.B (MvPFunctor.drop (P F)) a ‚üπ Œ±) (f : PFunc ‚Ä¶
                       -- ‚ä¢ WEquiv (wrepr (MvPFunctor.wMk (P F) a f' f)) (MvPFunctor.wMk (P F) a f' f)
  apply WEquiv.trans _ (q.P.wMk' (appendFun id wrepr <$$> ‚ü®a, q.P.appendContents f' f‚ü©))
  -- ‚ä¢ WEquiv (wrepr (MvPFunctor.wMk (P F) a f' f)) (MvPFunctor.wMk' (P F) ((TypeVe ‚Ä¶
  ¬∑ apply wEquiv.abs'
    -- ‚ä¢ abs (MvPFunctor.wDest' (P F) (wrepr (MvPFunctor.wMk (P F) a f' f))) = abs (M ‚Ä¶
    rw [wrepr_wMk, q.P.wDest'_wMk', q.P.wDest'_wMk', abs_repr]
    -- üéâ no goals
  rw [q.P.map_eq, MvPFunctor.wMk', appendFun_comp_splitFun, id_comp]
  -- ‚ä¢ WEquiv
  apply WEquiv.ind; exact ih
  -- ‚ä¢ ‚àÄ (x : PFunctor.B (MvPFunctor.last (P F)) a), WEquiv (lastFun (splitFun f' ( ‚Ä¶
                    -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align mvqpf.Wrepr_equiv MvQPF.wrepr_equiv

theorem wEquiv_map {Œ± Œ≤ : TypeVec n} (g : Œ± ‚üπ Œ≤) (x y : q.P.W Œ±) :
    WEquiv x y ‚Üí WEquiv (g <$$> x) (g <$$> y) := by
  intro h; induction h
  -- ‚ä¢ WEquiv (g <$$> x) (g <$$> y)
  case ind a f' f‚ÇÄ f‚ÇÅ h ih => rw [q.P.w_map_wMk, q.P.w_map_wMk]; apply WEquiv.ind; exact ih
  -- ‚ä¢ WEquiv (g <$$> MvPFunctor.wMk (P F) a‚ÇÄ‚úù f'‚ÇÄ‚úù f‚ÇÄ‚úù) (g <$$> MvPFunctor.wMk (P  ‚Ä¶
  -- üéâ no goals
  case
    abs a‚ÇÄ f'‚ÇÄ f‚ÇÄ a‚ÇÅ f'‚ÇÅ f‚ÇÅ h =>
    rw [q.P.w_map_wMk, q.P.w_map_wMk]; apply WEquiv.abs
    show
      abs (q.P.objAppend1 a‚ÇÄ (g ‚äö f'‚ÇÄ) fun x => q.P.wMap g (f‚ÇÄ x)) =
        abs (q.P.objAppend1 a‚ÇÅ (g ‚äö f'‚ÇÅ) fun x => q.P.wMap g (f‚ÇÅ x))
    rw [‚Üê q.P.map_objAppend1, ‚Üê q.P.map_objAppend1, abs_map, abs_map, h]
  case trans x y z _ _ ih‚ÇÅ ih‚ÇÇ => apply MvQPF.WEquiv.trans; apply ih‚ÇÅ; apply ih‚ÇÇ
  -- üéâ no goals
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align mvqpf.Wequiv_map MvQPF.wEquiv_map

/-- Define the fixed point as the quotient of trees under the equivalence relation.
-/
def wSetoid (Œ± : TypeVec n) : Setoid (q.P.W Œ±) :=
  ‚ü®WEquiv, @wEquiv.refl _ _ _ _ _, @wEquiv.symm _ _ _ _ _, @WEquiv.trans _ _ _ _ _‚ü©
set_option linter.uppercaseLean3 false in
#align mvqpf.W_setoid MvQPF.wSetoid

attribute [local instance] wSetoid

/-- Least fixed point of functor F. The result is a functor with one fewer parameters
than the input. For `F a b c` a ternary functor, `Fix F` is a binary functor such that

```lean
Fix F a b = F a b (Fix F a b)
```
-/
def Fix {n : ‚Ñï} (F : TypeVec (n + 1) ‚Üí Type*) [MvFunctor F] [q : MvQPF F] (Œ± : TypeVec n) :=
  Quotient (wSetoid Œ± : Setoid (q.P.W Œ±))
#align mvqpf.fix MvQPF.Fix

--attribute [nolint has_nonempty_instance] Fix

/-- `Fix F` is a functor -/
def Fix.map {Œ± Œ≤ : TypeVec n} (g : Œ± ‚üπ Œ≤) : Fix F Œ± ‚Üí Fix F Œ≤ :=
  Quotient.lift (fun x : q.P.W Œ± => ‚ü¶q.P.wMap g x‚üß) fun _a _b h => Quot.sound (wEquiv_map _ _ _ h)
#align mvqpf.fix.map MvQPF.Fix.map

instance Fix.mvfunctor : MvFunctor (Fix F) where map := @Fix.map _ _ _ _
#align mvqpf.fix.mvfunctor MvQPF.Fix.mvfunctor

variable {Œ± : TypeVec.{u} n}

/-- Recursor for `Fix F` -/
def Fix.rec {Œ≤ : Type u} (g : F (Œ± ::: Œ≤) ‚Üí Œ≤) : Fix F Œ± ‚Üí Œ≤ :=
  Quot.lift (recF g) (recF_eq_of_wEquiv Œ± g)
#align mvqpf.fix.rec MvQPF.Fix.rec

/-- Access W-type underlying `Fix F`  -/
def fixToW : Fix F Œ± ‚Üí q.P.W Œ± :=
  Quotient.lift wrepr (recF_eq_of_wEquiv Œ± fun x => q.P.wMk' (repr x))
set_option linter.uppercaseLean3 false in
#align mvqpf.fix_to_W MvQPF.fixToW

/-- Constructor for `Fix F` -/
def Fix.mk (x : F (append1 Œ± (Fix F Œ±))) : Fix F Œ± :=
  Quot.mk _ (q.P.wMk' (appendFun id fixToW <$$> repr x))
#align mvqpf.fix.mk MvQPF.Fix.mk

/-- Destructor for `Fix F` -/
def Fix.dest : Fix F Œ± ‚Üí F (append1 Œ± (Fix F Œ±)) :=
  Fix.rec (MvFunctor.map (appendFun id Fix.mk))
#align mvqpf.fix.dest MvQPF.Fix.dest

theorem Fix.rec_eq {Œ≤ : Type u} (g : F (append1 Œ± Œ≤) ‚Üí Œ≤) (x : F (append1 Œ± (Fix F Œ±))) :
    Fix.rec g (Fix.mk x) = g (appendFun id (Fix.rec g) <$$> x) := by
  have : recF g ‚àò fixToW = Fix.rec g := by
    apply funext
    apply Quotient.ind
    intro x
    apply recF_eq_of_wEquiv
    apply wrepr_equiv
  conv =>
    lhs
    rw [Fix.rec, Fix.mk]
    dsimp
  cases' h : repr x with a f
  -- ‚ä¢ recF g (MvPFunctor.wMk' (P F) ((TypeVec.id ::: fixToW) <$$> { fst := a, snd  ‚Ä¶
  rw [MvPFunctor.map_eq, recF_eq', ‚Üê MvPFunctor.map_eq, MvPFunctor.wDest'_wMk']
  -- ‚ä¢ g (abs ((TypeVec.id ::: recF g) <$$> (TypeVec.id ::: fixToW) <$$> { fst := a ‚Ä¶
  rw [‚Üê MvPFunctor.comp_map, abs_map, ‚Üê h, abs_repr, ‚Üê appendFun_comp, id_comp, this]
  -- üéâ no goals
#align mvqpf.fix.rec_eq MvQPF.Fix.rec_eq

theorem Fix.ind_aux (a : q.P.A) (f' : q.P.drop.B a ‚üπ Œ±) (f : q.P.last.B a ‚Üí q.P.W Œ±) :
    Fix.mk (abs ‚ü®a, q.P.appendContents f' fun x => ‚ü¶f x‚üß‚ü©) = ‚ü¶q.P.wMk a f' f‚üß := by
  have : Fix.mk (abs ‚ü®a, q.P.appendContents f' fun x => ‚ü¶f x‚üß‚ü©) = ‚ü¶wrepr (q.P.wMk a f' f)‚üß := by
    apply Quot.sound; apply wEquiv.abs'
    rw [MvPFunctor.wDest'_wMk', abs_map, abs_repr, ‚Üê abs_map, MvPFunctor.map_eq]
    conv =>
      rhs
      rw [wrepr_wMk, q.P.wDest'_wMk', abs_repr, MvPFunctor.map_eq]
    congr 2; rw [MvPFunctor.appendContents, MvPFunctor.appendContents]
    rw [appendFun, appendFun, ‚Üê splitFun_comp, ‚Üê splitFun_comp]
    rfl
  rw [this]
  -- ‚ä¢ Quotient.mk (wSetoid Œ±) (wrepr (MvPFunctor.wMk (P F) a f' f)) = Quotient.mk  ‚Ä¶
  apply Quot.sound
  -- ‚ä¢ Setoid.r (wrepr (MvPFunctor.wMk (P F) a f' f)) (MvPFunctor.wMk (P F) a f' f)
  apply wrepr_equiv
  -- üéâ no goals
#align mvqpf.fix.ind_aux MvQPF.Fix.ind_aux

theorem Fix.ind_rec {Œ≤ : Type _} (g‚ÇÅ g‚ÇÇ : Fix F Œ± ‚Üí Œ≤)
    (h :
      ‚àÄ x : F (append1 Œ± (Fix F Œ±)),
        appendFun id g‚ÇÅ <$$> x = appendFun id g‚ÇÇ <$$> x ‚Üí g‚ÇÅ (Fix.mk x) = g‚ÇÇ (Fix.mk x)) :
    ‚àÄ x, g‚ÇÅ x = g‚ÇÇ x := by
  apply Quot.ind
  -- ‚ä¢ ‚àÄ (a : MvPFunctor.W (P F) Œ±), g‚ÇÅ (Quot.mk Setoid.r a) = g‚ÇÇ (Quot.mk Setoid.r ‚Ä¶
  intro x
  -- ‚ä¢ g‚ÇÅ (Quot.mk Setoid.r x) = g‚ÇÇ (Quot.mk Setoid.r x)
  apply q.P.w_ind _ x
  -- ‚ä¢ ‚àÄ (a : (P F).A) (f' : MvPFunctor.B (MvPFunctor.drop (P F)) a ‚üπ Œ±) (f : PFunc ‚Ä¶
  intro a f' f ih
  -- ‚ä¢ g‚ÇÅ (Quot.mk Setoid.r (MvPFunctor.wMk (P F) a f' f)) = g‚ÇÇ (Quot.mk Setoid.r ( ‚Ä¶
  show g‚ÇÅ ‚ü¶q.P.wMk a f' f‚üß = g‚ÇÇ ‚ü¶q.P.wMk a f' f‚üß
  -- ‚ä¢ g‚ÇÅ (Quotient.mk (wSetoid Œ±) (MvPFunctor.wMk (P F) a f' f)) = g‚ÇÇ (Quotient.mk ‚Ä¶
  rw [‚Üê Fix.ind_aux a f' f]
  -- ‚ä¢ g‚ÇÅ (mk (abs { fst := a, snd := MvPFunctor.appendContents (P F) f' fun x => Q ‚Ä¶
  apply h
  -- ‚ä¢ (TypeVec.id ::: g‚ÇÅ) <$$> abs { fst := a, snd := MvPFunctor.appendContents (P ‚Ä¶
  rw [‚Üê abs_map, ‚Üê abs_map, MvPFunctor.map_eq, MvPFunctor.map_eq]
  -- ‚ä¢ abs { fst := a, snd := (TypeVec.id ::: g‚ÇÅ) ‚äö MvPFunctor.appendContents (P F) ‚Ä¶
  congr 2
  -- ‚ä¢ ((TypeVec.id ::: g‚ÇÅ) ‚äö MvPFunctor.appendContents (P F) f' fun x => Quotient. ‚Ä¶
  rw [MvPFunctor.appendContents, appendFun, appendFun, ‚Üê splitFun_comp, ‚Üê splitFun_comp]
  -- ‚ä¢ splitFun (TypeVec.id ‚äö f') (g‚ÇÅ ‚àò fun x => Quotient.mk (wSetoid Œ±) (f x)) = s ‚Ä¶
  have : (g‚ÇÅ ‚àò fun x => ‚ü¶f x‚üß) = g‚ÇÇ ‚àò fun x => ‚ü¶f x‚üß := by
    ext x
    exact ih x
  rw [this]
  -- üéâ no goals
#align mvqpf.fix.ind_rec MvQPF.Fix.ind_rec

theorem Fix.rec_unique {Œ≤ : Type _} (g : F (append1 Œ± Œ≤) ‚Üí Œ≤) (h : Fix F Œ± ‚Üí Œ≤)
    (hyp : ‚àÄ x, h (Fix.mk x) = g (appendFun id h <$$> x)) : Fix.rec g = h := by
  ext x
  -- ‚ä¢ rec g x = h x
  apply Fix.ind_rec
  -- ‚ä¢ ‚àÄ (x : F (Œ± ::: Fix F Œ±)), (TypeVec.id ::: rec g) <$$> x = (TypeVec.id ::: f ‚Ä¶
  intro x hyp'
  -- ‚ä¢ rec g (mk x) = h (mk x)
  rw [hyp, ‚Üê hyp', Fix.rec_eq]
  -- üéâ no goals
#align mvqpf.fix.rec_unique MvQPF.Fix.rec_unique

theorem Fix.mk_dest (x : Fix F Œ±) : Fix.mk (Fix.dest x) = x := by
  change (Fix.mk ‚àò Fix.dest) x = x
  -- ‚ä¢ (mk ‚àò dest) x = x
  apply Fix.ind_rec
  -- ‚ä¢ ‚àÄ (x : F (Œ± ::: Fix F Œ±)), (TypeVec.id ::: mk ‚àò dest) <$$> x = (TypeVec.id : ‚Ä¶
  intro x; dsimp
  -- ‚ä¢ (TypeVec.id ::: mk ‚àò dest) <$$> x = (TypeVec.id ::: fun x => x) <$$> x ‚Üí (mk ‚Ä¶
           -- ‚ä¢ (TypeVec.id ::: mk ‚àò dest) <$$> x = (TypeVec.id ::: fun x => x) <$$> x ‚Üí mk  ‚Ä¶
  rw [Fix.dest, Fix.rec_eq, ‚Üê comp_map, ‚Üê appendFun_comp, id_comp]
  -- ‚ä¢ (TypeVec.id ::: mk ‚àò rec (MvFunctor.map (TypeVec.id ::: mk))) <$$> x = (Type ‚Ä¶
  intro h; rw [h]
  -- ‚ä¢ mk ((TypeVec.id ::: mk ‚àò rec (MvFunctor.map (TypeVec.id ::: mk))) <$$> x) =  ‚Ä¶
           -- ‚ä¢ mk ((TypeVec.id ::: fun x => x) <$$> x) = mk x
  show Fix.mk (appendFun id id <$$> x) = Fix.mk x
  -- ‚ä¢ mk ((TypeVec.id ::: _root_.id) <$$> x) = mk x
  rw [appendFun_id_id, MvFunctor.id_map]
  -- üéâ no goals
#align mvqpf.fix.mk_dest MvQPF.Fix.mk_dest

theorem Fix.dest_mk (x : F (append1 Œ± (Fix F Œ±))) : Fix.dest (Fix.mk x) = x := by
  unfold Fix.dest
  -- ‚ä¢ rec (MvFunctor.map (TypeVec.id ::: mk)) (mk x) = x
  rw [Fix.rec_eq, ‚Üê Fix.dest, ‚Üê comp_map]
  -- ‚ä¢ ((TypeVec.id ::: mk) ‚äö (TypeVec.id ::: dest)) <$$> x = x
  conv =>
    rhs
    rw [‚Üê MvFunctor.id_map x]
  rw [‚Üê appendFun_comp, id_comp]
  -- ‚ä¢ (TypeVec.id ::: mk ‚àò dest) <$$> x = TypeVec.id <$$> x
  have : Fix.mk ‚àò Fix.dest = _root_.id := by
    ext (x : Fix F Œ±)
    apply Fix.mk_dest
  rw [this, appendFun_id_id]
  -- üéâ no goals
#align mvqpf.fix.dest_mk MvQPF.Fix.dest_mk

theorem Fix.ind {Œ± : TypeVec n} (p : Fix F Œ± ‚Üí Prop)
    (h : ‚àÄ x : F (Œ±.append1 (Fix F Œ±)), LiftP (PredLast Œ± p) x ‚Üí p (Fix.mk x)) : ‚àÄ x, p x := by
  apply Quot.ind
  -- ‚ä¢ ‚àÄ (a : MvPFunctor.W (P F) Œ±), p (Quot.mk Setoid.r a)
  intro x
  -- ‚ä¢ p (Quot.mk Setoid.r x)
  apply q.P.w_ind _ x; intro a f' f ih
  -- ‚ä¢ ‚àÄ (a : (P F).A) (f' : MvPFunctor.B (MvPFunctor.drop (P F)) a ‚üπ Œ±) (f : PFunc ‚Ä¶
                       -- ‚ä¢ p (Quot.mk Setoid.r (MvPFunctor.wMk (P F) a f' f))
  change p ‚ü¶q.P.wMk a f' f‚üß
  -- ‚ä¢ p (Quotient.mk (wSetoid Œ±) (MvPFunctor.wMk (P F) a f' f))
  rw [‚Üê Fix.ind_aux a f' f]
  -- ‚ä¢ p (mk (abs { fst := a, snd := MvPFunctor.appendContents (P F) f' fun x => Qu ‚Ä¶
  apply h
  -- ‚ä¢ LiftP (PredLast Œ± p) (abs { fst := a, snd := MvPFunctor.appendContents (P F) ‚Ä¶
  rw [MvQPF.liftP_iff]
  -- ‚ä¢ ‚àÉ a_1 f_1, abs { fst := a, snd := MvPFunctor.appendContents (P F) f' fun x = ‚Ä¶
  refine' ‚ü®_, _, rfl, _‚ü©
  -- ‚ä¢ ‚àÄ (i : Fin2 (n + 1)) (j : MvPFunctor.B (P F) a i), PredLast Œ± p (MvPFunctor. ‚Ä¶
  intro i j
  -- ‚ä¢ PredLast Œ± p (MvPFunctor.appendContents (P F) f' (fun x => Quotient.mk (wSet ‚Ä¶
  cases i
  -- ‚ä¢ PredLast Œ± p (MvPFunctor.appendContents (P F) f' (fun x => Quotient.mk (wSet ‚Ä¶
  ¬∑ apply ih
    -- üéâ no goals
  ¬∑ trivial
    -- üéâ no goals
#align mvqpf.fix.ind MvQPF.Fix.ind

instance mvqpfFix : MvQPF (Fix F) where
  P := q.P.wp
  abs Œ± := Quot.mk WEquiv Œ±
  repr Œ± := fixToW Œ±
  abs_repr := by
    intro Œ±
    -- ‚ä¢ ‚àÄ (x : Fix F Œ±), (fun {Œ±} Œ±_1 => Quot.mk WEquiv Œ±_1) ((fun {Œ±} Œ±_1 => fixToW ‚Ä¶
    apply Quot.ind
    -- ‚ä¢ ‚àÄ (a : MvPFunctor.W (P F) Œ±), (fun {Œ±} Œ±_1 => Quot.mk WEquiv Œ±_1) ((fun {Œ±}  ‚Ä¶
    intro a
    -- ‚ä¢ (fun {Œ±} Œ±_1 => Quot.mk WEquiv Œ±_1) ((fun {Œ±} Œ±_1 => fixToW Œ±_1) (Quot.mk Se ‚Ä¶
    apply Quot.sound
    -- ‚ä¢ WEquiv ((fun {Œ±} Œ±_1 => fixToW Œ±_1) (Quot.mk Setoid.r a)) a
    apply wrepr_equiv
    -- üéâ no goals
  abs_map := by
    intro Œ± Œ≤ g x;
    -- ‚ä¢ (fun {Œ±} Œ±_1 => Quot.mk WEquiv Œ±_1) (g <$$> x) = g <$$> (fun {Œ±} Œ±_1 => Quot ‚Ä¶
    conv =>
      rhs
      dsimp [MvFunctor.map]
#align mvqpf.mvqpf_fix MvQPF.mvqpfFix

/-- Dependent recursor for `fix F` -/
def Fix.drec {Œ≤ : Fix F Œ± ‚Üí Type u}
    (g : ‚àÄ x : F (Œ± ::: Sigma Œ≤), Œ≤ (Fix.mk <| (id ::: Sigma.fst) <$$> x)) (x : Fix F Œ±) : Œ≤ x :=
  let y := @Fix.rec _ F _ _ Œ± (Sigma Œ≤) (fun i => ‚ü®_, g i‚ü©) x
  have : x = y.1 := by
    symm
    -- ‚ä¢ y.fst = x
    dsimp
    -- ‚ä¢ (rec (fun i => { fst := mk ((TypeVec.id ::: Sigma.fst) <$$> i), snd := g i } ‚Ä¶
    apply Fix.ind_rec _ id _ x
    -- ‚ä¢ ‚àÄ (x : F (Œ± ::: Fix F Œ±)), (TypeVec.id ::: fun x => (rec (fun i => { fst :=  ‚Ä¶
    intro x' ih
    -- ‚ä¢ (rec (fun i => { fst := mk ((TypeVec.id ::: Sigma.fst) <$$> i), snd := g i } ‚Ä¶
    rw [Fix.rec_eq]
    -- ‚ä¢ { fst := mk ((TypeVec.id ::: Sigma.fst) <$$> (TypeVec.id ::: rec fun i => {  ‚Ä¶
    dsimp
    -- ‚ä¢ mk ((TypeVec.id ::: Sigma.fst) <$$> (TypeVec.id ::: rec fun i => { fst := mk ‚Ä¶
    simp [appendFun_id_id] at ih
    -- ‚ä¢ mk ((TypeVec.id ::: Sigma.fst) <$$> (TypeVec.id ::: rec fun i => { fst := mk ‚Ä¶
    congr
    -- ‚ä¢ (TypeVec.id ::: Sigma.fst) <$$> (TypeVec.id ::: rec fun i => { fst := mk ((T ‚Ä¶
    conv =>
      rhs
      rw [‚Üê ih]
    rw [MvFunctor.map_map, ‚Üê appendFun_comp, id_comp]
    -- ‚ä¢ (TypeVec.id ::: Sigma.fst ‚àò rec fun i => { fst := mk ((TypeVec.id ::: Sigma. ‚Ä¶
    simp only [Function.comp]
    -- üéâ no goals
  cast (by rw [this]) y.2
           -- üéâ no goals
#align mvqpf.fix.drec MvQPF.Fix.drec

end MvQPF
