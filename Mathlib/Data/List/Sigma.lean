/-
Copyright (c) 2018 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, Sean Leather
-/
import Mathlib.Data.List.Range
import Mathlib.Data.List.Perm

#align_import data.list.sigma from "leanprover-community/mathlib"@"f808feb6c18afddb25e66a71d317643cf7fb5fbb"

/-!
# Utilities for lists of sigmas

This file includes several ways of interacting with `List (Sigma Œ≤)`, treated as a key-value store.

If `Œ± : Type*` and `Œ≤ : Œ± ‚Üí Type*`, then we regard `s : Sigma Œ≤` as having key `s.1 : Œ±` and value
`s.2 : Œ≤ s.1`. Hence, `List (Sigma Œ≤)` behaves like a key-value store.

## Main Definitions

- `List.keys` extracts the list of keys.
- `List.NodupKeys` determines if the store has duplicate keys.
- `List.lookup`/`lookup_all` accesses the value(s) of a particular key.
- `List.kreplace` replaces the first value with a given key by a given value.
- `List.kerase` removes a value.
- `List.kinsert` inserts a value.
- `List.kunion` computes the union of two stores.
- `List.kextract` returns a value with a given key and the rest of the values.
-/


universe u v

namespace List

variable {Œ± : Type u} {Œ≤ : Œ± ‚Üí Type v} {l l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)}

/-! ### `keys` -/


/-- List of keys from a list of key-value pairs -/
def keys : List (Sigma Œ≤) ‚Üí List Œ± :=
  map Sigma.fst
#align list.keys List.keys

@[simp]
theorem keys_nil : @keys Œ± Œ≤ [] = [] :=
  rfl
#align list.keys_nil List.keys_nil

@[simp]
theorem keys_cons {s} {l : List (Sigma Œ≤)} : (s :: l).keys = s.1 :: l.keys :=
  rfl
#align list.keys_cons List.keys_cons

theorem mem_keys_of_mem {s : Sigma Œ≤} {l : List (Sigma Œ≤)} : s ‚àà l ‚Üí s.1 ‚àà l.keys :=
  mem_map_of_mem Sigma.fst
#align list.mem_keys_of_mem List.mem_keys_of_mem

theorem exists_of_mem_keys {a} {l : List (Sigma Œ≤)} (h : a ‚àà l.keys) :
    ‚àÉ b : Œ≤ a, Sigma.mk a b ‚àà l :=
  let ‚ü®‚ü®_, b'‚ü©, m, e‚ü© := exists_of_mem_map h
  Eq.recOn e (Exists.intro b' m)
#align list.exists_of_mem_keys List.exists_of_mem_keys

theorem mem_keys {a} {l : List (Sigma Œ≤)} : a ‚àà l.keys ‚Üî ‚àÉ b : Œ≤ a, Sigma.mk a b ‚àà l :=
  ‚ü®exists_of_mem_keys, fun ‚ü®_, h‚ü© => mem_keys_of_mem h‚ü©
#align list.mem_keys List.mem_keys

theorem not_mem_keys {a} {l : List (Sigma Œ≤)} : a ‚àâ l.keys ‚Üî ‚àÄ b : Œ≤ a, Sigma.mk a b ‚àâ l :=
  (not_congr mem_keys).trans not_exists
#align list.not_mem_keys List.not_mem_keys

theorem not_eq_key {a} {l : List (Sigma Œ≤)} : a ‚àâ l.keys ‚Üî ‚àÄ s : Sigma Œ≤, s ‚àà l ‚Üí a ‚â† s.1 :=
  Iff.intro (fun h‚ÇÅ s h‚ÇÇ e => absurd (mem_keys_of_mem h‚ÇÇ) (by rwa [e] at h‚ÇÅ)) fun f h‚ÇÅ =>
                                                              -- üéâ no goals
    let ‚ü®b, h‚ÇÇ‚ü© := exists_of_mem_keys h‚ÇÅ
    f _ h‚ÇÇ rfl
#align list.not_eq_key List.not_eq_key

/-! ### `NodupKeys` -/


/-- Determines whether the store uses a key several times. -/
def NodupKeys (l : List (Sigma Œ≤)) : Prop :=
  l.keys.Nodup
#align list.nodupkeys List.NodupKeys

theorem nodupKeys_iff_pairwise {l} : NodupKeys l ‚Üî Pairwise (fun s s' : Sigma Œ≤ => s.1 ‚â† s'.1) l :=
  pairwise_map
#align list.nodupkeys_iff_pairwise List.nodupKeys_iff_pairwise

theorem NodupKeys.pairwise_ne {l} (h : NodupKeys l) :
    Pairwise (fun s s' : Sigma Œ≤ => s.1 ‚â† s'.1) l :=
  nodupKeys_iff_pairwise.1 h
#align list.nodupkeys.pairwise_ne List.NodupKeys.pairwise_ne

@[simp]
theorem nodupKeys_nil : @NodupKeys Œ± Œ≤ [] :=
  Pairwise.nil
#align list.nodupkeys_nil List.nodupKeys_nil

@[simp]
theorem nodupKeys_cons {s : Sigma Œ≤} {l : List (Sigma Œ≤)} :
    NodupKeys (s :: l) ‚Üî s.1 ‚àâ l.keys ‚àß NodupKeys l := by simp [keys, NodupKeys]
                                                          -- üéâ no goals
#align list.nodupkeys_cons List.nodupKeys_cons

theorem not_mem_keys_of_nodupKeys_cons {s : Sigma Œ≤} {l : List (Sigma Œ≤)} (h : NodupKeys (s :: l)) :
    s.1 ‚àâ l.keys :=
  (nodupKeys_cons.1 h).1
#align list.not_mem_keys_of_nodupkeys_cons List.not_mem_keys_of_nodupKeys_cons

theorem nodupKeys_of_nodupKeys_cons {s : Sigma Œ≤} {l : List (Sigma Œ≤)} (h : NodupKeys (s :: l)) :
    NodupKeys l :=
  (nodupKeys_cons.1 h).2
#align list.nodupkeys_of_nodupkeys_cons List.nodupKeys_of_nodupKeys_cons

theorem NodupKeys.eq_of_fst_eq {l : List (Sigma Œ≤)} (nd : NodupKeys l) {s s' : Sigma Œ≤} (h : s ‚àà l)
    (h' : s' ‚àà l) : s.1 = s'.1 ‚Üí s = s' :=
  @Pairwise.forall_of_forall _ (fun s s' : Sigma Œ≤ => s.1 = s'.1 ‚Üí s = s') _
    (fun _ _ H h => (H h.symm).symm) (fun _ _ _ => rfl)
    ((nodupKeys_iff_pairwise.1 nd).imp fun h h' => (h h').elim) _ h _ h'
#align list.nodupkeys.eq_of_fst_eq List.NodupKeys.eq_of_fst_eq

theorem NodupKeys.eq_of_mk_mem {a : Œ±} {b b' : Œ≤ a} {l : List (Sigma Œ≤)} (nd : NodupKeys l)
    (h : Sigma.mk a b ‚àà l) (h' : Sigma.mk a b' ‚àà l) : b = b' := by
  cases nd.eq_of_fst_eq h h' rfl; rfl
  -- ‚ä¢ b = b
                                  -- üéâ no goals
#align list.nodupkeys.eq_of_mk_mem List.NodupKeys.eq_of_mk_mem

theorem nodupKeys_singleton (s : Sigma Œ≤) : NodupKeys [s] :=
  nodup_singleton _
#align list.nodupkeys_singleton List.nodupKeys_singleton

theorem NodupKeys.sublist {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)} (h : l‚ÇÅ <+ l‚ÇÇ) : NodupKeys l‚ÇÇ ‚Üí NodupKeys l‚ÇÅ :=
  Nodup.sublist <| h.map _
#align list.nodupkeys.sublist List.NodupKeys.sublist

protected theorem NodupKeys.nodup {l : List (Sigma Œ≤)} : NodupKeys l ‚Üí Nodup l :=
  Nodup.of_map _
#align list.nodupkeys.nodup List.NodupKeys.nodup

theorem perm_nodupKeys {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)} (h : l‚ÇÅ ~ l‚ÇÇ) : NodupKeys l‚ÇÅ ‚Üî NodupKeys l‚ÇÇ :=
  (h.map _).nodup_iff
#align list.perm_nodupkeys List.perm_nodupKeys

theorem nodupKeys_join {L : List (List (Sigma Œ≤))} :
    NodupKeys (join L) ‚Üî (‚àÄ l ‚àà L, NodupKeys l) ‚àß Pairwise Disjoint (L.map keys) := by
  rw [nodupKeys_iff_pairwise, pairwise_join, pairwise_map]
  -- ‚ä¢ (‚àÄ (l : List (Sigma Œ≤)), l ‚àà L ‚Üí Pairwise (fun s s' => s.fst ‚â† s'.fst) l) ‚àß  ‚Ä¶
  refine' and_congr (ball_congr fun l _ => by simp [nodupKeys_iff_pairwise]) _
  -- ‚ä¢ Pairwise (fun l‚ÇÅ l‚ÇÇ => ‚àÄ (x : Sigma Œ≤), x ‚àà l‚ÇÅ ‚Üí ‚àÄ (y : Sigma Œ≤), y ‚àà l‚ÇÇ ‚Üí x ‚Ä¶
  apply iff_of_eq; congr with (l‚ÇÅ l‚ÇÇ)
  -- ‚ä¢ Pairwise (fun l‚ÇÅ l‚ÇÇ => ‚àÄ (x : Sigma Œ≤), x ‚àà l‚ÇÅ ‚Üí ‚àÄ (y : Sigma Œ≤), y ‚àà l‚ÇÇ ‚Üí x ‚Ä¶
                   -- ‚ä¢ (‚àÄ (x : Sigma Œ≤), x ‚àà l‚ÇÅ ‚Üí ‚àÄ (y : Sigma Œ≤), y ‚àà l‚ÇÇ ‚Üí x.fst ‚â† y.fst) ‚Üî Disjoi ‚Ä¶
  simp [keys, disjoint_iff_ne]
  -- üéâ no goals
#align list.nodupkeys_join List.nodupKeys_join

theorem nodup_enum_map_fst (l : List Œ±) : (l.enum.map Prod.fst).Nodup := by simp [List.nodup_range]
                                                                            -- üéâ no goals
#align list.nodup_enum_map_fst List.nodup_enum_map_fst

theorem mem_ext {l‚ÇÄ l‚ÇÅ : List (Sigma Œ≤)} (nd‚ÇÄ : l‚ÇÄ.Nodup) (nd‚ÇÅ : l‚ÇÅ.Nodup)
    (h : ‚àÄ x, x ‚àà l‚ÇÄ ‚Üî x ‚àà l‚ÇÅ) : l‚ÇÄ ~ l‚ÇÅ :=
  (perm_ext nd‚ÇÄ nd‚ÇÅ).2 h
#align list.mem_ext List.mem_ext

variable [DecidableEq Œ±]

/-! ### `dlookup` -/


--Porting note: renaming to `dlookup` since `lookup` already exists
/-- `dlookup a l` is the first value in `l` corresponding to the key `a`,
  or `none` if no such element exists. -/
def dlookup (a : Œ±) : List (Sigma Œ≤) ‚Üí Option (Œ≤ a)
  | [] => none
  | ‚ü®a', b‚ü© :: l => if h : a' = a then some (Eq.recOn h b) else dlookup a l
#align list.lookup List.dlookup

@[simp]
theorem dlookup_nil (a : Œ±) : dlookup a [] = @none (Œ≤ a) :=
  rfl
#align list.lookup_nil List.dlookup_nil

@[simp]
theorem dlookup_cons_eq (l) (a : Œ±) (b : Œ≤ a) : dlookup a (‚ü®a, b‚ü© :: l) = some b :=
  dif_pos rfl
#align list.lookup_cons_eq List.dlookup_cons_eq

@[simp]
theorem dlookup_cons_ne (l) {a} : ‚àÄ s : Sigma Œ≤, a ‚â† s.1 ‚Üí dlookup a (s :: l) = dlookup a l
  | ‚ü®_, _‚ü©, h => dif_neg h.symm
#align list.lookup_cons_ne List.dlookup_cons_ne

theorem dlookup_isSome {a : Œ±} : ‚àÄ {l : List (Sigma Œ≤)}, (dlookup a l).isSome ‚Üî a ‚àà l.keys
  | [] => by simp
             -- üéâ no goals
  | ‚ü®a', b‚ü© :: l => by
    by_cases h : a = a'
    -- ‚ä¢ Option.isSome (dlookup a ({ fst := a', snd := b } :: l)) = true ‚Üî a ‚àà keys ( ‚Ä¶
    ¬∑ subst a'
      -- ‚ä¢ Option.isSome (dlookup a ({ fst := a, snd := b } :: l)) = true ‚Üî a ‚àà keys ({ ‚Ä¶
      simp
      -- üéâ no goals
    ¬∑ simp [h, dlookup_isSome]
      -- üéâ no goals
#align list.lookup_is_some List.dlookup_isSome

theorem dlookup_eq_none {a : Œ±} {l : List (Sigma Œ≤)} : dlookup a l = none ‚Üî a ‚àâ l.keys := by
  simp [‚Üê dlookup_isSome, Option.isNone_iff_eq_none]
  -- üéâ no goals
#align list.lookup_eq_none List.dlookup_eq_none

theorem of_mem_dlookup {a : Œ±} {b : Œ≤ a} :
    ‚àÄ {l : List (Sigma Œ≤)}, b ‚àà dlookup a l ‚Üí Sigma.mk a b ‚àà l
  | ‚ü®a', b'‚ü© :: l, H => by
    by_cases h : a = a'
    -- ‚ä¢ { fst := a, snd := b } ‚àà { fst := a', snd := b' } :: l
    ¬∑ subst a'
      -- ‚ä¢ { fst := a, snd := b } ‚àà { fst := a, snd := b' } :: l
      simp at H
      -- ‚ä¢ { fst := a, snd := b } ‚àà { fst := a, snd := b' } :: l
      simp [H]
      -- üéâ no goals
    ¬∑ simp only [ne_eq, h, not_false_iff, dlookup_cons_ne] at H
      -- ‚ä¢ { fst := a, snd := b } ‚àà { fst := a', snd := b' } :: l
      simp [of_mem_dlookup H]
      -- üéâ no goals
#align list.of_mem_lookup List.of_mem_dlookup

theorem mem_dlookup {a} {b : Œ≤ a} {l : List (Sigma Œ≤)} (nd : l.NodupKeys) (h : Sigma.mk a b ‚àà l) :
    b ‚àà dlookup a l := by
  cases' Option.isSome_iff_exists.mp (dlookup_isSome.mpr (mem_keys_of_mem h)) with b' h'
  -- ‚ä¢ b ‚àà dlookup a l
  cases nd.eq_of_mk_mem h (of_mem_dlookup h')
  -- ‚ä¢ b ‚àà dlookup a l
  exact h'
  -- üéâ no goals
#align list.mem_lookup List.mem_dlookup

theorem map_dlookup_eq_find (a : Œ±) :
    ‚àÄ l : List (Sigma Œ≤), (dlookup a l).map (Sigma.mk a) = find? (fun s => a = s.1) l
  | [] => rfl
  | ‚ü®a', b'‚ü© :: l => by
    by_cases h : a = a'
    -- ‚ä¢ Option.map (Sigma.mk a) (dlookup a ({ fst := a', snd := b' } :: l)) = find?  ‚Ä¶
    ¬∑ subst a'
      -- ‚ä¢ Option.map (Sigma.mk a) (dlookup a ({ fst := a, snd := b' } :: l)) = find? ( ‚Ä¶
      simp
      -- üéâ no goals
    ¬∑ simp [h]
      -- ‚ä¢ Option.map (Sigma.mk a) (dlookup a l) = find? (fun s => decide (a = s.fst)) l
      exact map_dlookup_eq_find a l
      -- üéâ no goals
#align list.map_lookup_eq_find List.map_dlookup_eq_find

theorem mem_dlookup_iff {a : Œ±} {b : Œ≤ a} {l : List (Sigma Œ≤)} (nd : l.NodupKeys) :
    b ‚àà dlookup a l ‚Üî Sigma.mk a b ‚àà l :=
  ‚ü®of_mem_dlookup, mem_dlookup nd‚ü©
#align list.mem_lookup_iff List.mem_dlookup_iff

theorem perm_dlookup (a : Œ±) {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)} (nd‚ÇÅ : l‚ÇÅ.NodupKeys) (nd‚ÇÇ : l‚ÇÇ.NodupKeys)
    (p : l‚ÇÅ ~ l‚ÇÇ) : dlookup a l‚ÇÅ = dlookup a l‚ÇÇ := by
  ext b; simp only [mem_dlookup_iff nd‚ÇÅ, mem_dlookup_iff nd‚ÇÇ]; exact p.mem_iff
  -- ‚ä¢ b ‚àà dlookup a l‚ÇÅ ‚Üî b ‚àà dlookup a l‚ÇÇ
         -- ‚ä¢ { fst := a, snd := b } ‚àà l‚ÇÅ ‚Üî { fst := a, snd := b } ‚àà l‚ÇÇ
                                                               -- üéâ no goals
#align list.perm_lookup List.perm_dlookup

theorem lookup_ext {l‚ÇÄ l‚ÇÅ : List (Sigma Œ≤)} (nd‚ÇÄ : l‚ÇÄ.NodupKeys) (nd‚ÇÅ : l‚ÇÅ.NodupKeys)
    (h : ‚àÄ x y, y ‚àà l‚ÇÄ.dlookup x ‚Üî y ‚àà l‚ÇÅ.dlookup x) : l‚ÇÄ ~ l‚ÇÅ :=
  mem_ext nd‚ÇÄ.nodup nd‚ÇÅ.nodup fun ‚ü®a, b‚ü© => by
    rw [‚Üê mem_dlookup_iff, ‚Üê mem_dlookup_iff, h] <;> assumption
    -- ‚ä¢ NodupKeys l‚ÇÅ
                                                     -- üéâ no goals
                                                     -- üéâ no goals
#align list.lookup_ext List.lookup_ext

/-! ### `lookupAll` -/


/-- `lookup_all a l` is the list of all values in `l` corresponding to the key `a`. -/
def lookupAll (a : Œ±) : List (Sigma Œ≤) ‚Üí List (Œ≤ a)
  | [] => []
  | ‚ü®a', b‚ü© :: l => if h : a' = a then Eq.recOn h b :: lookupAll a l else lookupAll a l
#align list.lookup_all List.lookupAll

@[simp]
theorem lookupAll_nil (a : Œ±) : lookupAll a [] = @nil (Œ≤ a) :=
  rfl
#align list.lookup_all_nil List.lookupAll_nil

@[simp]
theorem lookupAll_cons_eq (l) (a : Œ±) (b : Œ≤ a) : lookupAll a (‚ü®a, b‚ü© :: l) = b :: lookupAll a l :=
  dif_pos rfl
#align list.lookup_all_cons_eq List.lookupAll_cons_eq

@[simp]
theorem lookupAll_cons_ne (l) {a} : ‚àÄ s : Sigma Œ≤, a ‚â† s.1 ‚Üí lookupAll a (s :: l) = lookupAll a l
  | ‚ü®_, _‚ü©, h => dif_neg h.symm
#align list.lookup_all_cons_ne List.lookupAll_cons_ne

theorem lookupAll_eq_nil {a : Œ±} :
    ‚àÄ {l : List (Sigma Œ≤)}, lookupAll a l = [] ‚Üî ‚àÄ b : Œ≤ a, Sigma.mk a b ‚àâ l
  | [] => by simp
             -- üéâ no goals
  | ‚ü®a', b‚ü© :: l => by
    by_cases h : a = a'
    -- ‚ä¢ lookupAll a ({ fst := a', snd := b } :: l) = [] ‚Üî ‚àÄ (b_1 : Œ≤ a), ¬¨{ fst := a ‚Ä¶
    ¬∑ subst a'
      -- ‚ä¢ lookupAll a ({ fst := a, snd := b } :: l) = [] ‚Üî ‚àÄ (b_1 : Œ≤ a), ¬¨{ fst := a, ‚Ä¶
      simp
      -- üéâ no goals
    ¬∑ simp [h, lookupAll_eq_nil]
      -- üéâ no goals
#align list.lookup_all_eq_nil List.lookupAll_eq_nil

theorem head?_lookupAll (a : Œ±) : ‚àÄ l : List (Sigma Œ≤), head? (lookupAll a l) = dlookup a l
  | [] => by simp
             -- üéâ no goals
  | ‚ü®a', b‚ü© :: l => by
    by_cases h : a = a'
    -- ‚ä¢ head? (lookupAll a ({ fst := a', snd := b } :: l)) = dlookup a ({ fst := a', ‚Ä¶
    ¬∑ subst h; simp
      -- ‚ä¢ head? (lookupAll a ({ fst := a, snd := b } :: l)) = dlookup a ({ fst := a, s ‚Ä¶
               -- üéâ no goals
    ¬∑ rw [lookupAll_cons_ne, dlookup_cons_ne, head?_lookupAll a l] <;> assumption
      -- ‚ä¢ a ‚â† { fst := a', snd := b }.fst
                                                                       -- üéâ no goals
                                                                       -- üéâ no goals
#align list.head_lookup_all List.head?_lookupAll

theorem mem_lookupAll {a : Œ±} {b : Œ≤ a} :
    ‚àÄ {l : List (Sigma Œ≤)}, b ‚àà lookupAll a l ‚Üî Sigma.mk a b ‚àà l
  | [] => by simp
             -- üéâ no goals
  | ‚ü®a', b'‚ü© :: l => by
    by_cases h : a = a'
    -- ‚ä¢ b ‚àà lookupAll a ({ fst := a', snd := b' } :: l) ‚Üî { fst := a, snd := b } ‚àà { ‚Ä¶
    ¬∑ subst h
      -- ‚ä¢ b ‚àà lookupAll a ({ fst := a, snd := b' } :: l) ‚Üî { fst := a, snd := b } ‚àà {  ‚Ä¶
      simp [*, mem_lookupAll]
      -- üéâ no goals
    ¬∑ simp [*, mem_lookupAll]
      -- üéâ no goals
#align list.mem_lookup_all List.mem_lookupAll

theorem lookupAll_sublist (a : Œ±) : ‚àÄ l : List (Sigma Œ≤), (lookupAll a l).map (Sigma.mk a) <+ l
  | [] => by simp
             -- üéâ no goals
  | ‚ü®a', b'‚ü© :: l => by
    by_cases h : a = a'
    -- ‚ä¢ map (Sigma.mk a) (lookupAll a ({ fst := a', snd := b' } :: l)) <+ { fst := a ‚Ä¶
    ¬∑ subst h
      -- ‚ä¢ map (Sigma.mk a) (lookupAll a ({ fst := a, snd := b' } :: l)) <+ { fst := a, ‚Ä¶
      simp only [ne_eq, not_true, lookupAll_cons_eq, List.map]
      -- ‚ä¢ { fst := a, snd := b' } :: map (Sigma.mk a) (lookupAll a l) <+ { fst := a, s ‚Ä¶
      exact (lookupAll_sublist a l).cons‚ÇÇ _
      -- üéâ no goals
    ¬∑ simp only [ne_eq, h, not_false_iff, lookupAll_cons_ne]
      -- ‚ä¢ map (Sigma.mk a) (lookupAll a l) <+ { fst := a', snd := b' } :: l
      exact (lookupAll_sublist a l).cons _
      -- üéâ no goals
#align list.lookup_all_sublist List.lookupAll_sublist

theorem lookupAll_length_le_one (a : Œ±) {l : List (Sigma Œ≤)} (h : l.NodupKeys) :
    length (lookupAll a l) ‚â§ 1 := by
  have := Nodup.sublist ((lookupAll_sublist a l).map _) h
  -- ‚ä¢ length (lookupAll a l) ‚â§ 1
  rw [map_map] at this
  -- ‚ä¢ length (lookupAll a l) ‚â§ 1
  rwa [‚Üê nodup_replicate, ‚Üê map_const]
  -- üéâ no goals
#align list.lookup_all_length_le_one List.lookupAll_length_le_one

theorem lookupAll_eq_dlookup (a : Œ±) {l : List (Sigma Œ≤)} (h : l.NodupKeys) :
    lookupAll a l = (dlookup a l).toList := by
  rw [‚Üê head?_lookupAll]
  -- ‚ä¢ lookupAll a l = Option.toList (head? (lookupAll a l))
  have h1 := lookupAll_length_le_one a h; revert h1
  -- ‚ä¢ lookupAll a l = Option.toList (head? (lookupAll a l))
                                          -- ‚ä¢ length (lookupAll a l) ‚â§ 1 ‚Üí lookupAll a l = Option.toList (head? (lookupAll ‚Ä¶
  rcases lookupAll a l with (_ | ‚ü®b, _ | ‚ü®c, l‚ü©‚ü©) <;> intro h1 <;> try rfl
                                                      -- ‚ä¢ [] = Option.toList (head? [])
                                                      -- ‚ä¢ [b] = Option.toList (head? [b])
                                                      -- ‚ä¢ b :: c :: l = Option.toList (head? (b :: c :: l))
                                                                   -- üéâ no goals
                                                                   -- üéâ no goals
                                                                   -- ‚ä¢ b :: c :: l = Option.toList (head? (b :: c :: l))
  exact absurd h1 (by simp)
  -- üéâ no goals
#align list.lookup_all_eq_lookup List.lookupAll_eq_dlookup

theorem lookupAll_nodup (a : Œ±) {l : List (Sigma Œ≤)} (h : l.NodupKeys) : (lookupAll a l).Nodup :=
  by (rw [lookupAll_eq_dlookup a h]; apply Option.toList_nodup)
      -- ‚ä¢ Nodup (Option.toList (dlookup a l))
                                     -- üéâ no goals
#align list.lookup_all_nodup List.lookupAll_nodup

theorem perm_lookupAll (a : Œ±) {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)} (nd‚ÇÅ : l‚ÇÅ.NodupKeys) (nd‚ÇÇ : l‚ÇÇ.NodupKeys)
    (p : l‚ÇÅ ~ l‚ÇÇ) : lookupAll a l‚ÇÅ = lookupAll a l‚ÇÇ := by
  simp [lookupAll_eq_dlookup, nd‚ÇÅ, nd‚ÇÇ, perm_dlookup a nd‚ÇÅ nd‚ÇÇ p]
  -- üéâ no goals
#align list.perm_lookup_all List.perm_lookupAll

/-! ### `kreplace` -/


/-- Replaces the first value with key `a` by `b`. -/
def kreplace (a : Œ±) (b : Œ≤ a) : List (Sigma Œ≤) ‚Üí List (Sigma Œ≤) :=
  lookmap fun s => if a = s.1 then some ‚ü®a, b‚ü© else none
#align list.kreplace List.kreplace

theorem kreplace_of_forall_not (a : Œ±) (b : Œ≤ a) {l : List (Sigma Œ≤)}
    (H : ‚àÄ b : Œ≤ a, Sigma.mk a b ‚àâ l) : kreplace a b l = l :=
  lookmap_of_forall_not _ <| by
    rintro ‚ü®a', b'‚ü© h; dsimp; split_ifs
    -- ‚ä¢ (if a = { fst := a', snd := b' }.fst then some { fst := a, snd := b } else n ‚Ä¶
                       -- ‚ä¢ (if a = a' then some { fst := a, snd := b } else none) = none
                              -- ‚ä¢ False
    ¬∑ subst a'
      -- ‚ä¢ False
      exact H _ h
      -- üéâ no goals
    ¬∑ rfl
      -- üéâ no goals
#align list.kreplace_of_forall_not List.kreplace_of_forall_not

theorem kreplace_self {a : Œ±} {b : Œ≤ a} {l : List (Sigma Œ≤)} (nd : NodupKeys l)
    (h : Sigma.mk a b ‚àà l) : kreplace a b l = l := by
  refine' (lookmap_congr _).trans (lookmap_id' (Option.guard fun (s : Sigma Œ≤) => a = s.1) _ _)
  -- ‚ä¢ ‚àÄ (a_1 : Sigma Œ≤), a_1 ‚àà l ‚Üí (if a = a_1.fst then some { fst := a, snd := b  ‚Ä¶
  ¬∑ rintro ‚ü®a', b'‚ü© h'
    -- ‚ä¢ (if a = { fst := a', snd := b' }.fst then some { fst := a, snd := b } else n ‚Ä¶
    dsimp [Option.guard]
    -- ‚ä¢ (if a = a' then some { fst := a, snd := b } else none) = if a = a' then some ‚Ä¶
    split_ifs
    -- ‚ä¢ some { fst := a, snd := b } = some { fst := a', snd := b' }
    ¬∑ subst a'
      -- ‚ä¢ some { fst := a, snd := b } = some { fst := a, snd := b' }
      simp [nd.eq_of_mk_mem h h']
      -- üéâ no goals
    ¬∑ rfl
      -- üéâ no goals
  ¬∑ rintro ‚ü®a‚ÇÅ, b‚ÇÅ‚ü© ‚ü®a‚ÇÇ, b‚ÇÇ‚ü©
    -- ‚ä¢ { fst := a‚ÇÇ, snd := b‚ÇÇ } ‚àà Option.guard (fun s => a = s.fst) { fst := a‚ÇÅ, sn ‚Ä¶
    dsimp [Option.guard]
    -- ‚ä¢ ({ fst := a‚ÇÇ, snd := b‚ÇÇ } ‚àà if a = a‚ÇÅ then some { fst := a‚ÇÅ, snd := b‚ÇÅ } els ‚Ä¶
    split_ifs
    -- ‚ä¢ { fst := a‚ÇÇ, snd := b‚ÇÇ } ‚àà some { fst := a‚ÇÅ, snd := b‚ÇÅ } ‚Üí { fst := a‚ÇÅ, snd  ‚Ä¶
    ¬∑ simp
      -- üéâ no goals
    ¬∑ rintro ‚ü®‚ü©
      -- üéâ no goals
#align list.kreplace_self List.kreplace_self

theorem keys_kreplace (a : Œ±) (b : Œ≤ a) : ‚àÄ l : List (Sigma Œ≤), (kreplace a b l).keys = l.keys :=
  lookmap_map_eq _ _ <| by
    rintro ‚ü®a‚ÇÅ, b‚ÇÇ‚ü© ‚ü®a‚ÇÇ, b‚ÇÇ‚ü©
    -- ‚ä¢ ({ fst := a‚ÇÇ, snd := b‚ÇÇ } ‚àà if a = { fst := a‚ÇÅ, snd := b‚ÇÇ‚úù }.fst then some { ‚Ä¶
    dsimp
    -- ‚ä¢ ({ fst := a‚ÇÇ, snd := b‚ÇÇ } ‚àà if a = a‚ÇÅ then some { fst := a, snd := b } else  ‚Ä¶
    split_ifs with h <;> simp (config := { contextual := true }) [h]
    -- ‚ä¢ { fst := a‚ÇÇ, snd := b‚ÇÇ } ‚àà some { fst := a, snd := b } ‚Üí a‚ÇÅ = a‚ÇÇ
                         -- üéâ no goals
                         -- üéâ no goals
#align list.keys_kreplace List.keys_kreplace

theorem kreplace_nodupKeys (a : Œ±) (b : Œ≤ a) {l : List (Sigma Œ≤)} :
    (kreplace a b l).NodupKeys ‚Üî l.NodupKeys := by simp [NodupKeys, keys_kreplace]
                                                   -- üéâ no goals
#align list.kreplace_nodupkeys List.kreplace_nodupKeys

theorem Perm.kreplace {a : Œ±} {b : Œ≤ a} {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)} (nd : l‚ÇÅ.NodupKeys) :
    l‚ÇÅ ~ l‚ÇÇ ‚Üí kreplace a b l‚ÇÅ ~ kreplace a b l‚ÇÇ :=
  perm_lookmap _ <| by
    refine' nd.pairwise_ne.imp _
    -- ‚ä¢ ‚àÄ {a_1 b_1 : Sigma Œ≤}, a_1.fst ‚â† b_1.fst ‚Üí ‚àÄ (c : Sigma Œ≤), (c ‚àà if a = a_1. ‚Ä¶
    intro x y h z h‚ÇÅ w h‚ÇÇ
    -- ‚ä¢ x = y ‚àß z = w
    split_ifs at h‚ÇÅ h‚ÇÇ with h_2 h_1 <;> cases h‚ÇÅ <;> cases h‚ÇÇ
                                        -- ‚ä¢ x = y ‚àß { fst := a, snd := b } = w
                                        -- ‚ä¢ x = y ‚àß { fst := a, snd := b } = w
                                        -- üéâ no goals
                                        -- üéâ no goals
                                                     -- ‚ä¢ x = y ‚àß { fst := a, snd := b } = { fst := a, snd := b }
                                                     -- üéâ no goals
    exact (h (h_2.symm.trans h_1)).elim
    -- üéâ no goals
#align list.perm.kreplace List.Perm.kreplace

/-! ### `kerase` -/


/-- Remove the first pair with the key `a`. -/
def kerase (a : Œ±) : List (Sigma Œ≤) ‚Üí List (Sigma Œ≤) :=
  eraseP fun s => a = s.1
#align list.kerase List.kerase

--Porting note: removing @[simp], `simp` can prove it
theorem kerase_nil {a} : @kerase _ Œ≤ _ a [] = [] :=
  rfl
#align list.kerase_nil List.kerase_nil

@[simp]
theorem kerase_cons_eq {a} {s : Sigma Œ≤} {l : List (Sigma Œ≤)} (h : a = s.1) :
    kerase a (s :: l) = l := by simp [kerase, h]
                                -- üéâ no goals
#align list.kerase_cons_eq List.kerase_cons_eq

@[simp]
theorem kerase_cons_ne {a} {s : Sigma Œ≤} {l : List (Sigma Œ≤)} (h : a ‚â† s.1) :
    kerase a (s :: l) = s :: kerase a l := by simp [kerase, h]
                                              -- üéâ no goals
#align list.kerase_cons_ne List.kerase_cons_ne

@[simp]
theorem kerase_of_not_mem_keys {a} {l : List (Sigma Œ≤)} (h : a ‚àâ l.keys) : kerase a l = l := by
  induction' l with _ _ ih <;> [rfl; (simp [not_or] at h; simp [h.1, ih h.2])]
  -- üéâ no goals
#align list.kerase_of_not_mem_keys List.kerase_of_not_mem_keys

theorem kerase_sublist (a : Œ±) (l : List (Sigma Œ≤)) : kerase a l <+ l :=
  eraseP_sublist _
#align list.kerase_sublist List.kerase_sublist

theorem kerase_keys_subset (a) (l : List (Sigma Œ≤)) : (kerase a l).keys ‚äÜ l.keys :=
  ((kerase_sublist a l).map _).subset
#align list.kerase_keys_subset List.kerase_keys_subset

theorem mem_keys_of_mem_keys_kerase {a‚ÇÅ a‚ÇÇ} {l : List (Sigma Œ≤)} :
    a‚ÇÅ ‚àà (kerase a‚ÇÇ l).keys ‚Üí a‚ÇÅ ‚àà l.keys :=
  @kerase_keys_subset _ _ _ _ _ _
#align list.mem_keys_of_mem_keys_kerase List.mem_keys_of_mem_keys_kerase

theorem exists_of_kerase {a : Œ±} {l : List (Sigma Œ≤)} (h : a ‚àà l.keys) :
    ‚àÉ (b : Œ≤ a) (l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)),
      a ‚àâ l‚ÇÅ.keys ‚àß l = l‚ÇÅ ++ ‚ü®a, b‚ü© :: l‚ÇÇ ‚àß kerase a l = l‚ÇÅ ++ l‚ÇÇ := by
  induction l with
  | nil => cases h
  | cons hd tl ih =>
    by_cases e : a = hd.1
    ¬∑ subst e
      exact ‚ü®hd.2, [], tl, by simp, by cases hd; rfl, by simp‚ü©
    ¬∑ simp at h
      cases' h with h h
      exact absurd h e
      rcases ih h with ‚ü®b, tl‚ÇÅ, tl‚ÇÇ, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©
      exact ‚ü®b, hd :: tl‚ÇÅ, tl‚ÇÇ, not_mem_cons_of_ne_of_not_mem e h‚ÇÅ, by (rw [h‚ÇÇ]; rfl), by
            simp [e, h‚ÇÉ]‚ü©
#align list.exists_of_kerase List.exists_of_kerase

@[simp]
theorem mem_keys_kerase_of_ne {a‚ÇÅ a‚ÇÇ} {l : List (Sigma Œ≤)} (h : a‚ÇÅ ‚â† a‚ÇÇ) :
    a‚ÇÅ ‚àà (kerase a‚ÇÇ l).keys ‚Üî a‚ÇÅ ‚àà l.keys :=
  (Iff.intro mem_keys_of_mem_keys_kerase) fun p =>
    if q : a‚ÇÇ ‚àà l.keys then
      match l, kerase a‚ÇÇ l, exists_of_kerase q, p with
      | _, _, ‚ü®_, _, _, _, rfl, rfl‚ü©, p => by simpa [keys, h] using p
                                              -- üéâ no goals
    else by simp [q, p]
            -- üéâ no goals
#align list.mem_keys_kerase_of_ne List.mem_keys_kerase_of_ne

theorem keys_kerase {a} {l : List (Sigma Œ≤)} : (kerase a l).keys = l.keys.erase a := by
  rw [keys, kerase, erase_eq_eraseP, eraseP_map]; dsimp [Function.comp]
  -- ‚ä¢ map Sigma.fst (eraseP (fun s => decide (a = s.fst)) l) = map Sigma.fst (eras ‚Ä¶
                                                  -- üéâ no goals
#align list.keys_kerase List.keys_kerase

theorem kerase_kerase {a a'} {l : List (Sigma Œ≤)} :
    (kerase a' l).kerase a = (kerase a l).kerase a' := by
  by_cases h : a = a'
  -- ‚ä¢ kerase a (kerase a' l) = kerase a' (kerase a l)
  ¬∑ subst a'; rfl
    -- ‚ä¢ kerase a (kerase a l) = kerase a (kerase a l)
              -- üéâ no goals
  induction' l with x xs
  -- ‚ä¢ kerase a (kerase a' []) = kerase a' (kerase a [])
  ¬∑ rfl
    -- üéâ no goals
  ¬∑ by_cases a' = x.1
    -- ‚ä¢ kerase a (kerase a' (x :: xs)) = kerase a' (kerase a (x :: xs))
    -- ‚ä¢ kerase a (kerase a' (x :: xs)) = kerase a' (kerase a (x :: xs))
    ¬∑ subst a'
      -- ‚ä¢ kerase a (kerase x.fst (x :: xs)) = kerase x.fst (kerase a (x :: xs))
      simp [kerase_cons_ne h, kerase_cons_eq rfl]
      -- üéâ no goals
    by_cases h' : a = x.1
    -- ‚ä¢ kerase a (kerase a' (x :: xs)) = kerase a' (kerase a (x :: xs))
    ¬∑ subst a
      -- ‚ä¢ kerase x.fst (kerase a' (x :: xs)) = kerase a' (kerase x.fst (x :: xs))
      simp [kerase_cons_eq rfl, kerase_cons_ne (Ne.symm h)]
      -- üéâ no goals
    ¬∑ simp [kerase_cons_ne, *]
      -- üéâ no goals
#align list.kerase_kerase List.kerase_kerase

theorem NodupKeys.kerase (a : Œ±) : NodupKeys l ‚Üí (kerase a l).NodupKeys :=
  NodupKeys.sublist <| kerase_sublist _ _
#align list.nodupkeys.kerase List.NodupKeys.kerase

theorem Perm.kerase {a : Œ±} {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)} (nd : l‚ÇÅ.NodupKeys) :
    l‚ÇÅ ~ l‚ÇÇ ‚Üí kerase a l‚ÇÅ ~ kerase a l‚ÇÇ :=
  Perm.erasep _ <| (nodupKeys_iff_pairwise.1 nd).imp <| by rintro x y h rfl; exact h
                                                           -- ‚ä¢ x.fst = y.fst ‚Üí False
                                                                             -- üéâ no goals
#align list.perm.kerase List.Perm.kerase

@[simp]
theorem not_mem_keys_kerase (a) {l : List (Sigma Œ≤)} (nd : l.NodupKeys) :
    a ‚àâ (kerase a l).keys := by
  induction l with
  | nil => simp
  | cons hd tl ih =>
    simp at nd
    by_cases h : a = hd.1
    ¬∑ subst h
      simp [nd.1]
    ¬∑ simp [h, ih nd.2]
#align list.not_mem_keys_kerase List.not_mem_keys_kerase

@[simp]
theorem dlookup_kerase (a) {l : List (Sigma Œ≤)} (nd : l.NodupKeys) :
    dlookup a (kerase a l) = none :=
  dlookup_eq_none.mpr (not_mem_keys_kerase a nd)
#align list.lookup_kerase List.dlookup_kerase

@[simp]
theorem dlookup_kerase_ne {a a'} {l : List (Sigma Œ≤)} (h : a ‚â† a') :
    dlookup a (kerase a' l) = dlookup a l := by
  induction l with
  | nil => rfl
  | cons hd tl ih =>
    cases' hd with ah bh
    by_cases h‚ÇÅ : a = ah <;> by_cases h‚ÇÇ : a' = ah
    ¬∑ substs h‚ÇÅ h‚ÇÇ
      cases Ne.irrefl h
    ¬∑ subst h‚ÇÅ
      simp [h‚ÇÇ]
    ¬∑ subst h‚ÇÇ
      simp [h]
    ¬∑ simp [h‚ÇÅ, h‚ÇÇ, ih]
#align list.lookup_kerase_ne List.dlookup_kerase_ne

theorem kerase_append_left {a} :
    ‚àÄ {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)}, a ‚àà l‚ÇÅ.keys ‚Üí kerase a (l‚ÇÅ ++ l‚ÇÇ) = kerase a l‚ÇÅ ++ l‚ÇÇ
  | [], _, h => by cases h
                   -- üéâ no goals
  | s :: l‚ÇÅ, l‚ÇÇ, h‚ÇÅ => by
    if h‚ÇÇ : a = s.1 then simp [h‚ÇÇ]
    else simp at h‚ÇÅ; cases' h‚ÇÅ with h‚ÇÅ h‚ÇÅ <;> [exact absurd h‚ÇÅ h‚ÇÇ; simp [h‚ÇÇ, kerase_append_left h‚ÇÅ]]
#align list.kerase_append_left List.kerase_append_left

theorem kerase_append_right {a} :
    ‚àÄ {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)}, a ‚àâ l‚ÇÅ.keys ‚Üí kerase a (l‚ÇÅ ++ l‚ÇÇ) = l‚ÇÅ ++ kerase a l‚ÇÇ
  | [], _, _ => rfl
  | _ :: l‚ÇÅ, l‚ÇÇ, h => by simp [not_or] at h; simp [h.1, kerase_append_right h.2]
                         -- ‚ä¢ kerase a (head‚úù :: l‚ÇÅ ++ l‚ÇÇ) = head‚úù :: l‚ÇÅ ++ kerase a l‚ÇÇ
                                             -- üéâ no goals
#align list.kerase_append_right List.kerase_append_right

theorem kerase_comm (a‚ÇÅ a‚ÇÇ) (l : List (Sigma Œ≤)) :
    kerase a‚ÇÇ (kerase a‚ÇÅ l) = kerase a‚ÇÅ (kerase a‚ÇÇ l) :=
  if h : a‚ÇÅ = a‚ÇÇ then by simp [h]
                         -- üéâ no goals
  else
    if ha‚ÇÅ : a‚ÇÅ ‚àà l.keys then
      if ha‚ÇÇ : a‚ÇÇ ‚àà l.keys then
        match l, kerase a‚ÇÅ l, exists_of_kerase ha‚ÇÅ, ha‚ÇÇ with
        | _, _, ‚ü®b‚ÇÅ, l‚ÇÅ, l‚ÇÇ, a‚ÇÅ_nin_l‚ÇÅ, rfl, rfl‚ü©, _ =>
          if h' : a‚ÇÇ ‚àà l‚ÇÅ.keys then by
            simp [kerase_append_left h',
              kerase_append_right (mt (mem_keys_kerase_of_ne h).mp a‚ÇÅ_nin_l‚ÇÅ)]
          else by
            simp [kerase_append_right h', kerase_append_right a‚ÇÅ_nin_l‚ÇÅ,
              @kerase_cons_ne _ _ _ a‚ÇÇ ‚ü®a‚ÇÅ, b‚ÇÅ‚ü© _ (Ne.symm h)]
      else by simp [ha‚ÇÇ, mt mem_keys_of_mem_keys_kerase ha‚ÇÇ]
              -- üéâ no goals
    else by simp [ha‚ÇÅ, mt mem_keys_of_mem_keys_kerase ha‚ÇÅ]
            -- üéâ no goals
#align list.kerase_comm List.kerase_comm

theorem sizeOf_kerase {Œ±} {Œ≤ : Œ± ‚Üí Type*} [DecidableEq Œ±] [SizeOf (Sigma Œ≤)] (x : Œ±)
    (xs : List (Sigma Œ≤)) : SizeOf.sizeOf (List.kerase x xs) ‚â§ SizeOf.sizeOf xs :=by
  simp only [SizeOf.sizeOf, _sizeOf_1]
  -- ‚ä¢ rec 1 (fun head tail tail_ih => 1 + sizeOf head + tail_ih) (kerase x xs) ‚â§ r ‚Ä¶
  induction' xs with y ys
  -- ‚ä¢ rec 1 (fun head tail tail_ih => 1 + sizeOf head + tail_ih) (kerase x []) ‚â§ r ‚Ä¶
  ¬∑ simp
    -- üéâ no goals
  ¬∑ by_cases x = y.1 <;> simp [*]
    -- ‚ä¢ rec 1 (fun head tail tail_ih => 1 + sizeOf head + tail_ih) (kerase x (y :: y ‚Ä¶
    -- ‚ä¢ rec 1 (fun head tail tail_ih => 1 + sizeOf head + tail_ih) (kerase x (y :: y ‚Ä¶
                         -- üéâ no goals
                         -- üéâ no goals
#align list.sizeof_kerase List.sizeOf_kerase

/-! ### `kinsert` -/


/-- Insert the pair `‚ü®a, b‚ü©` and erase the first pair with the key `a`. -/
def kinsert (a : Œ±) (b : Œ≤ a) (l : List (Sigma Œ≤)) : List (Sigma Œ≤) :=
  ‚ü®a, b‚ü© :: kerase a l
#align list.kinsert List.kinsert

@[simp]
theorem kinsert_def {a} {b : Œ≤ a} {l : List (Sigma Œ≤)} : kinsert a b l = ‚ü®a, b‚ü© :: kerase a l :=
  rfl
#align list.kinsert_def List.kinsert_def

theorem mem_keys_kinsert {a a'} {b' : Œ≤ a'} {l : List (Sigma Œ≤)} :
    a ‚àà (kinsert a' b' l).keys ‚Üî a = a' ‚à® a ‚àà l.keys := by by_cases h : a = a' <;> simp [h]
                                                           -- ‚ä¢ a ‚àà keys (kinsert a' b' l) ‚Üî a = a' ‚à® a ‚àà keys l
                                                                                   -- üéâ no goals
                                                                                   -- üéâ no goals
#align list.mem_keys_kinsert List.mem_keys_kinsert

theorem kinsert_nodupKeys (a) (b : Œ≤ a) {l : List (Sigma Œ≤)} (nd : l.NodupKeys) :
    (kinsert a b l).NodupKeys :=
  nodupKeys_cons.mpr ‚ü®not_mem_keys_kerase a nd, nd.kerase a‚ü©
#align list.kinsert_nodupkeys List.kinsert_nodupKeys

theorem Perm.kinsert {a} {b : Œ≤ a} {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)} (nd‚ÇÅ : l‚ÇÅ.NodupKeys) (p : l‚ÇÅ ~ l‚ÇÇ) :
    kinsert a b l‚ÇÅ ~ kinsert a b l‚ÇÇ :=
  (p.kerase nd‚ÇÅ).cons _
#align list.perm.kinsert List.Perm.kinsert

theorem dlookup_kinsert {a} {b : Œ≤ a} (l : List (Sigma Œ≤)) :
    dlookup a (kinsert a b l) = some b := by
  simp only [kinsert, dlookup_cons_eq]
  -- üéâ no goals
#align list.lookup_kinsert List.dlookup_kinsert

theorem dlookup_kinsert_ne {a a'} {b' : Œ≤ a'} {l : List (Sigma Œ≤)} (h : a ‚â† a') :
    dlookup a (kinsert a' b' l) = dlookup a l := by simp [h]
                                                    -- üéâ no goals
#align list.lookup_kinsert_ne List.dlookup_kinsert_ne

/-! ### `kextract` -/


/-- Finds the first entry with a given key `a` and returns its value (as an `Option` because there
might be no entry with key `a`) alongside with the rest of the entries. -/
def kextract (a : Œ±) : List (Sigma Œ≤) ‚Üí Option (Œ≤ a) √ó List (Sigma Œ≤)
  | [] => (none, [])
  | s :: l =>
    if h : s.1 = a then (some (Eq.recOn h s.2), l)
    else
      let (b', l') := kextract a l
      (b', s :: l')
#align list.kextract List.kextract

@[simp]
theorem kextract_eq_dlookup_kerase (a : Œ±) :
    ‚àÄ l : List (Sigma Œ≤), kextract a l = (dlookup a l, kerase a l)
  | [] => rfl
  | ‚ü®a', b‚ü© :: l => by
    simp [kextract]; dsimp; split_ifs with h
    -- ‚ä¢ (if h : a' = a then (some ((_ : { fst := a', snd := b }.fst = a) ‚ñ∏ b), l) el ‚Ä¶
                     -- ‚ä¢ (if h : a' = a then (some ((_ : a' = a) ‚ñ∏ b), l) else ((kextract a l).fst, { ‚Ä¶
                            -- ‚ä¢ (some ((_ : a' = a) ‚ñ∏ b), l) = (dlookup a ({ fst := a', snd := b } :: l), ke ‚Ä¶
    ¬∑ subst a'
      -- ‚ä¢ (some ((_ : a = a) ‚ñ∏ b), l) = (dlookup a ({ fst := a, snd := b } :: l), kera ‚Ä¶
      simp [kerase]
      -- üéâ no goals
    ¬∑ simp [kextract, Ne.symm h, kextract_eq_dlookup_kerase a l, kerase]
      -- üéâ no goals
#align list.kextract_eq_lookup_kerase List.kextract_eq_dlookup_kerase

/-! ### `dedupKeys` -/


/-- Remove entries with duplicate keys from `l : List (Sigma Œ≤)`. -/
def dedupKeys : List (Sigma Œ≤) ‚Üí List (Sigma Œ≤) :=
  List.foldr (fun x => kinsert x.1 x.2) []
#align list.dedupkeys List.dedupKeys

theorem dedupKeys_cons {x : Sigma Œ≤} (l : List (Sigma Œ≤)) :
    dedupKeys (x :: l) = kinsert x.1 x.2 (dedupKeys l) :=
  rfl
#align list.dedupkeys_cons List.dedupKeys_cons


theorem nodupKeys_dedupKeys (l : List (Sigma Œ≤)) : NodupKeys (dedupKeys l) := by
  dsimp [dedupKeys]
  -- ‚ä¢ NodupKeys (foldr (fun x => kinsert x.fst x.snd) [] l)
  generalize hl : nil = l'
  -- ‚ä¢ NodupKeys (foldr (fun x => kinsert x.fst x.snd) l' l)
  have : NodupKeys l' := by
    rw [‚Üê hl]
    apply nodup_nil
  clear hl
  -- ‚ä¢ NodupKeys (foldr (fun x => kinsert x.fst x.snd) l' l)
  induction' l with x xs l_ih
  -- ‚ä¢ NodupKeys (foldr (fun x => kinsert x.fst x.snd) l' [])
  ¬∑ apply this
    -- üéâ no goals
  ¬∑ cases x
    -- ‚ä¢ NodupKeys (foldr (fun x => kinsert x.fst x.snd) l' ({ fst := fst‚úù, snd := sn ‚Ä¶
    simp [dedupKeys]
    -- ‚ä¢ ¬¨fst‚úù ‚àà keys (kerase fst‚úù (foldr (fun x => kinsert x.fst x.snd) l' xs)) ‚àß No ‚Ä¶
    constructor
    -- ‚ä¢ ¬¨fst‚úù ‚àà keys (kerase fst‚úù (foldr (fun x => kinsert x.fst x.snd) l' xs))
    ¬∑ simp [keys_kerase]
      -- ‚ä¢ ¬¨fst‚úù ‚àà List.erase (keys (foldr (fun x => kinsert x.fst x.snd) l' xs)) fst‚úù
      apply l_ih.not_mem_erase
      -- üéâ no goals
    ¬∑ exact l_ih.kerase _
      -- üéâ no goals
#align list.nodupkeys_dedupkeys List.nodupKeys_dedupKeys

theorem dlookup_dedupKeys (a : Œ±) (l : List (Sigma Œ≤)) : dlookup a (dedupKeys l) = dlookup a l := by
  induction' l with l_hd _ l_ih; rfl
  -- ‚ä¢ dlookup a (dedupKeys []) = dlookup a []
                                 -- ‚ä¢ dlookup a (dedupKeys (l_hd :: tail‚úù)) = dlookup a (l_hd :: tail‚úù)
  cases' l_hd with a' b
  -- ‚ä¢ dlookup a (dedupKeys ({ fst := a', snd := b } :: tail‚úù)) = dlookup a ({ fst  ‚Ä¶
  by_cases h : a = a'
  -- ‚ä¢ dlookup a (dedupKeys ({ fst := a', snd := b } :: tail‚úù)) = dlookup a ({ fst  ‚Ä¶
  ¬∑ subst a'
    -- ‚ä¢ dlookup a (dedupKeys ({ fst := a, snd := b } :: tail‚úù)) = dlookup a ({ fst : ‚Ä¶
    rw [dedupKeys_cons, dlookup_kinsert, dlookup_cons_eq]
    -- üéâ no goals
  ¬∑ rw [dedupKeys_cons, dlookup_kinsert_ne h, l_ih, dlookup_cons_ne]
    -- ‚ä¢ a ‚â† { fst := a', snd := b }.fst
    exact h
    -- üéâ no goals
#align list.lookup_dedupkeys List.dlookup_dedupKeys

theorem sizeOf_dedupKeys {Œ±} {Œ≤ : Œ± ‚Üí Type*} [DecidableEq Œ±] [SizeOf (Sigma Œ≤)]
    (xs : List (Sigma Œ≤)) : SizeOf.sizeOf (dedupKeys xs) ‚â§ SizeOf.sizeOf xs := by
  simp only [SizeOf.sizeOf, _sizeOf_1]
  -- ‚ä¢ rec 1 (fun head tail tail_ih => 1 + sizeOf head + tail_ih) (dedupKeys xs) ‚â§  ‚Ä¶
  induction' xs with x xs
  -- ‚ä¢ rec 1 (fun head tail tail_ih => 1 + sizeOf head + tail_ih) (dedupKeys []) ‚â§  ‚Ä¶
  ¬∑ simp [dedupKeys]
    -- üéâ no goals
  ¬∑ simp only [dedupKeys_cons, kinsert_def, add_le_add_iff_left, Sigma.eta]
    -- ‚ä¢ rec 1 (fun head tail tail_ih => 1 + sizeOf head + tail_ih) (kerase x.fst (de ‚Ä¶
    trans
    apply sizeOf_kerase
    -- ‚ä¢ sizeOf (dedupKeys xs) ‚â§ rec 1 (fun head tail tail_ih => 1 + sizeOf head + ta ‚Ä¶
    assumption
    -- üéâ no goals
#align list.sizeof_dedupkeys List.sizeOf_dedupKeys

/-! ### `kunion` -/


/-- `kunion l‚ÇÅ l‚ÇÇ` is the append to l‚ÇÅ of l‚ÇÇ after, for each key in l‚ÇÅ, the
first matching pair in l‚ÇÇ is erased. -/
def kunion : List (Sigma Œ≤) ‚Üí List (Sigma Œ≤) ‚Üí List (Sigma Œ≤)
  | [], l‚ÇÇ => l‚ÇÇ
  | s :: l‚ÇÅ, l‚ÇÇ => s :: kunion l‚ÇÅ (kerase s.1 l‚ÇÇ)
#align list.kunion List.kunion

@[simp]
theorem nil_kunion {l : List (Sigma Œ≤)} : kunion [] l = l :=
  rfl
#align list.nil_kunion List.nil_kunion

@[simp]
theorem kunion_nil : ‚àÄ {l : List (Sigma Œ≤)}, kunion l [] = l
  | [] => rfl
  | _ :: l => by rw [kunion, kerase_nil, kunion_nil]
                 -- üéâ no goals
#align list.kunion_nil List.kunion_nil

@[simp]
theorem kunion_cons {s} {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)} :
    kunion (s :: l‚ÇÅ) l‚ÇÇ = s :: kunion l‚ÇÅ (kerase s.1 l‚ÇÇ) :=
  rfl
#align list.kunion_cons List.kunion_cons

@[simp]
theorem mem_keys_kunion {a} {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)} :
    a ‚àà (kunion l‚ÇÅ l‚ÇÇ).keys ‚Üî a ‚àà l‚ÇÅ.keys ‚à® a ‚àà l‚ÇÇ.keys := by
  induction l‚ÇÅ generalizing l‚ÇÇ with
  | nil => simp
  | cons s l‚ÇÅ ih => by_cases h : a = s.1 <;> [simp [h]; simp [h, ih]]
#align list.mem_keys_kunion List.mem_keys_kunion

@[simp]
theorem kunion_kerase {a} :
    ‚àÄ {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)}, kunion (kerase a l‚ÇÅ) (kerase a l‚ÇÇ) = kerase a (kunion l‚ÇÅ l‚ÇÇ)
  | [], _ => rfl
  | s :: _, l => by by_cases h : a = s.1 <;> simp [h, kerase_comm a s.1 l, kunion_kerase]
                    -- ‚ä¢ kunion (kerase a (s :: tail‚úù)) (kerase a l) = kerase a (kunion (s :: tail‚úù) l)
                                             -- üéâ no goals
                                             -- üéâ no goals
#align list.kunion_kerase List.kunion_kerase

theorem NodupKeys.kunion (nd‚ÇÅ : l‚ÇÅ.NodupKeys) (nd‚ÇÇ : l‚ÇÇ.NodupKeys) : (kunion l‚ÇÅ l‚ÇÇ).NodupKeys := by
  induction l‚ÇÅ generalizing l‚ÇÇ with
  | nil => simp only [nil_kunion, nd‚ÇÇ]
  | cons s l‚ÇÅ ih =>
    simp at nd‚ÇÅ
    simp [not_or, nd‚ÇÅ.1, nd‚ÇÇ, ih nd‚ÇÅ.2 (nd‚ÇÇ.kerase s.1)]
#align list.nodupkeys.kunion List.NodupKeys.kunion

theorem Perm.kunion_right {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)} (p : l‚ÇÅ ~ l‚ÇÇ) (l) :
    kunion l‚ÇÅ l ~ kunion l‚ÇÇ l := by
  induction p generalizing l with
  | nil => rfl
  | cons hd _ ih =>
    simp [ih (List.kerase _ _), Perm.cons]
  | swap s‚ÇÅ s‚ÇÇ l => simp [kerase_comm, Perm.swap]
  | trans _ _ ih‚ÇÅ‚ÇÇ ih‚ÇÇ‚ÇÉ => exact Perm.trans (ih‚ÇÅ‚ÇÇ l) (ih‚ÇÇ‚ÇÉ l)
#align list.perm.kunion_right List.Perm.kunion_right

theorem Perm.kunion_left :
    ‚àÄ (l) {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)}, l‚ÇÅ.NodupKeys ‚Üí l‚ÇÅ ~ l‚ÇÇ ‚Üí kunion l l‚ÇÅ ~ kunion l l‚ÇÇ
  | [], _, _, _, p => p
  | s :: l, _, _, nd‚ÇÅ, p => ((p.kerase nd‚ÇÅ).kunion_left l <| nd‚ÇÅ.kerase s.1).cons s
#align list.perm.kunion_left List.Perm.kunion_left

theorem Perm.kunion {l‚ÇÅ l‚ÇÇ l‚ÇÉ l‚ÇÑ : List (Sigma Œ≤)} (nd‚ÇÉ : l‚ÇÉ.NodupKeys) (p‚ÇÅ‚ÇÇ : l‚ÇÅ ~ l‚ÇÇ)
    (p‚ÇÉ‚ÇÑ : l‚ÇÉ ~ l‚ÇÑ) : kunion l‚ÇÅ l‚ÇÉ ~ kunion l‚ÇÇ l‚ÇÑ :=
  (p‚ÇÅ‚ÇÇ.kunion_right l‚ÇÉ).trans (p‚ÇÉ‚ÇÑ.kunion_left l‚ÇÇ nd‚ÇÉ)
#align list.perm.kunion List.Perm.kunion

@[simp]
theorem dlookup_kunion_left {a} {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)} (h : a ‚àà l‚ÇÅ.keys) :
    dlookup a (kunion l‚ÇÅ l‚ÇÇ) = dlookup a l‚ÇÅ := by
  induction' l‚ÇÅ with s _ ih generalizing l‚ÇÇ <;> simp at h; cases' h with h h <;> cases' s with a'
  -- ‚ä¢ dlookup a (kunion [] l‚ÇÇ) = dlookup a []
                                                -- üéâ no goals
                                                -- ‚ä¢ dlookup a (kunion (s :: tail‚úù) l‚ÇÇ) = dlookup a (s :: tail‚úù)
                                                           -- ‚ä¢ dlookup a (kunion (s :: tail‚úù) l‚ÇÇ) = dlookup a (s :: tail‚úù)
                                                                                 -- ‚ä¢ dlookup a (kunion ({ fst := a', snd := snd‚úù } :: tail‚úù) l‚ÇÇ) = dlookup a ({ f ‚Ä¶
                                                                                 -- ‚ä¢ dlookup a (kunion ({ fst := a', snd := snd‚úù } :: tail‚úù) l‚ÇÇ) = dlookup a ({ f ‚Ä¶
  ¬∑ subst h
    -- ‚ä¢ dlookup a (kunion ({ fst := a, snd := snd‚úù } :: tail‚úù) l‚ÇÇ) = dlookup a ({ fs ‚Ä¶
    simp
    -- üéâ no goals
  ¬∑ rw [kunion_cons]
    -- ‚ä¢ dlookup a ({ fst := a', snd := snd‚úù } :: kunion tail‚úù (kerase { fst := a', s ‚Ä¶
    by_cases h' : a = a'
    -- ‚ä¢ dlookup a ({ fst := a', snd := snd‚úù } :: kunion tail‚úù (kerase { fst := a', s ‚Ä¶
    ¬∑ subst h'
      -- ‚ä¢ dlookup a ({ fst := a, snd := snd‚úù } :: kunion tail‚úù (kerase { fst := a, snd ‚Ä¶
      simp
      -- üéâ no goals
    ¬∑ simp [h', ih h]
      -- üéâ no goals
#align list.lookup_kunion_left List.dlookup_kunion_left

@[simp]
theorem dlookup_kunion_right {a} {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)} (h : a ‚àâ l‚ÇÅ.keys) :
    dlookup a (kunion l‚ÇÅ l‚ÇÇ) = dlookup a l‚ÇÇ := by
  induction l‚ÇÅ generalizing l‚ÇÇ with
  | nil => simp
  | cons _ _ ih => simp [not_or] at h; simp [h.1, ih h.2]
#align list.lookup_kunion_right List.dlookup_kunion_right

--Porting note: removing simp, LHS not in normal form, added new version
theorem mem_dlookup_kunion {a} {b : Œ≤ a} {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)} :
    b ‚àà dlookup a (kunion l‚ÇÅ l‚ÇÇ) ‚Üî b ‚àà dlookup a l‚ÇÅ ‚à® a ‚àâ l‚ÇÅ.keys ‚àß b ‚àà dlookup a l‚ÇÇ := by
  induction l‚ÇÅ generalizing l‚ÇÇ with
  | nil => simp
  | cons s _ ih =>
    cases' s with a'
    by_cases h‚ÇÅ : a = a'
    ¬∑ subst h‚ÇÅ
      simp
    ¬∑ let h‚ÇÇ := @ih (kerase a' l‚ÇÇ)
      simp [h‚ÇÅ] at h‚ÇÇ
      simp [h‚ÇÅ, h‚ÇÇ]
#align list.mem_lookup_kunion List.mem_dlookup_kunion

--Porting note: New theorem, alternative version of `mem_dlookup_kunion` for simp
@[simp]
theorem dlookup_kunion_eq_some {a} {b : Œ≤ a} {l‚ÇÅ l‚ÇÇ : List (Sigma Œ≤)} :
    dlookup a (kunion l‚ÇÅ l‚ÇÇ) = some b ‚Üî
      dlookup a l‚ÇÅ = some b ‚à® a ‚àâ l‚ÇÅ.keys ‚àß dlookup a l‚ÇÇ = some b :=
  mem_dlookup_kunion

theorem mem_dlookup_kunion_middle {a} {b : Œ≤ a} {l‚ÇÅ l‚ÇÇ l‚ÇÉ : List (Sigma Œ≤)}
    (h‚ÇÅ : b ‚àà dlookup a (kunion l‚ÇÅ l‚ÇÉ)) (h‚ÇÇ : a ‚àâ keys l‚ÇÇ) :
    b ‚àà dlookup a (kunion (kunion l‚ÇÅ l‚ÇÇ) l‚ÇÉ) :=
  match mem_dlookup_kunion.mp h‚ÇÅ with
  | Or.inl h => mem_dlookup_kunion.mpr (Or.inl (mem_dlookup_kunion.mpr (Or.inl h)))
  | Or.inr h => mem_dlookup_kunion.mpr <| Or.inr ‚ü®mt mem_keys_kunion.mp (not_or.mpr ‚ü®h.1, h‚ÇÇ‚ü©), h.2‚ü©
#align list.mem_lookup_kunion_middle List.mem_dlookup_kunion_middle

end List
