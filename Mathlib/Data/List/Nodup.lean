/-
Copyright (c) 2018 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, Kenny Lau
-/
import Mathlib.Data.List.Lattice
import Mathlib.Data.List.Pairwise
import Mathlib.Data.List.Forall2
import Mathlib.Data.Set.Pairwise.Basic

#align_import data.list.nodup from "leanprover-community/mathlib"@"c227d107bbada5d0d9d20287e3282c0a7f1651a0"

/-!
# Lists with no duplicates

`List.Nodup` is defined in `Data/List/Basic`. In this file we prove various properties of this
predicate.
-/


universe u v

open Nat Function

variable {Œ± : Type u} {Œ≤ : Type v} {l l‚ÇÅ l‚ÇÇ : List Œ±} {r : Œ± ‚Üí Œ± ‚Üí Prop} {a b : Œ±}

namespace List

@[simp]
theorem forall_mem_ne {a : Œ±} {l : List Œ±} : (‚àÄ a' : Œ±, a' ‚àà l ‚Üí ¬¨a = a') ‚Üî a ‚àâ l :=
  ‚ü®fun h m => h _ m rfl, fun h _ m e => h (e.symm ‚ñ∏ m)‚ü©
#align list.forall_mem_ne List.forall_mem_ne

@[simp]
theorem nodup_nil : @Nodup Œ± [] :=
  Pairwise.nil
#align list.nodup_nil List.nodup_nil

@[simp]
theorem nodup_cons {a : Œ±} {l : List Œ±} : Nodup (a :: l) ‚Üî a ‚àâ l ‚àß Nodup l := by
  simp only [Nodup, pairwise_cons, forall_mem_ne]
  -- üéâ no goals
#align list.nodup_cons List.nodup_cons

protected theorem Pairwise.nodup {l : List Œ±} {r : Œ± ‚Üí Œ± ‚Üí Prop} [IsIrrefl Œ± r] (h : Pairwise r l) :
    Nodup l :=
  h.imp ne_of_irrefl
#align list.pairwise.nodup List.Pairwise.nodup

theorem rel_nodup {r : Œ± ‚Üí Œ≤ ‚Üí Prop} (hr : Relator.BiUnique r) : (Forall‚ÇÇ r ‚áí (¬∑ ‚Üî ¬∑)) Nodup Nodup
  | _, _, Forall‚ÇÇ.nil => by simp only [nodup_nil]
                            -- üéâ no goals
  | _, _, Forall‚ÇÇ.cons hab h => by
    simpa only [nodup_cons] using
      Relator.rel_and (Relator.rel_not (rel_mem hr hab h)) (rel_nodup hr h)
#align list.rel_nodup List.rel_nodup

protected theorem Nodup.cons (ha : a ‚àâ l) (hl : Nodup l) : Nodup (a :: l) :=
  nodup_cons.2 ‚ü®ha, hl‚ü©
#align list.nodup.cons List.Nodup.cons

theorem nodup_singleton (a : Œ±) : Nodup [a] :=
  pairwise_singleton _ _
#align list.nodup_singleton List.nodup_singleton

theorem Nodup.of_cons (h : Nodup (a :: l)) : Nodup l :=
  (nodup_cons.1 h).2
#align list.nodup.of_cons List.Nodup.of_cons

theorem Nodup.not_mem (h : (a :: l).Nodup) : a ‚àâ l :=
  (nodup_cons.1 h).1
#align list.nodup.not_mem List.Nodup.not_mem

theorem not_nodup_cons_of_mem : a ‚àà l ‚Üí ¬¨Nodup (a :: l) :=
  imp_not_comm.1 Nodup.not_mem
#align list.not_nodup_cons_of_mem List.not_nodup_cons_of_mem

protected theorem Nodup.sublist : l‚ÇÅ <+ l‚ÇÇ ‚Üí Nodup l‚ÇÇ ‚Üí Nodup l‚ÇÅ :=
  Pairwise.sublist
#align list.nodup.sublist List.Nodup.sublist

theorem not_nodup_pair (a : Œ±) : ¬¨Nodup [a, a] :=
  not_nodup_cons_of_mem <| mem_singleton_self _
#align list.not_nodup_pair List.not_nodup_pair

theorem nodup_iff_sublist {l : List Œ±} : Nodup l ‚Üî ‚àÄ a, ¬¨[a, a] <+ l :=
  ‚ü®fun d a h => not_nodup_pair a (d.sublist h),
    by
      induction' l with a l IH <;> intro h; ¬∑ exact nodup_nil
      -- ‚ä¢ (‚àÄ (a : Œ±), ¬¨[a, a] <+ []) ‚Üí Nodup []
                                   -- ‚ä¢ Nodup []
                                   -- ‚ä¢ Nodup (a :: l)
                                              -- üéâ no goals
      exact (IH fun a s => h a <| sublist_cons_of_sublist _ s).cons fun al =>
        h a <| (singleton_sublist.2 al).cons_cons _‚ü©
#align list.nodup_iff_sublist List.nodup_iff_sublist

--Porting note: new theorem
theorem nodup_iff_injective_get {l : List Œ±} :
    Nodup l ‚Üî Function.Injective l.get :=
  pairwise_iff_get.trans
    ‚ü®fun h i j hg => by
      cases' i with i hi; cases' j with j hj
      -- ‚ä¢ { val := i, isLt := hi } = j
                          -- ‚ä¢ { val := i, isLt := hi } = { val := j, isLt := hj }
      rcases lt_trichotomy i j with (hij | rfl | hji)
      ¬∑ exact (h ‚ü®i, hi‚ü© ‚ü®j, hj‚ü© hij hg).elim
        -- üéâ no goals
      ¬∑ rfl
        -- üéâ no goals
      ¬∑ exact (h ‚ü®j, hj‚ü© ‚ü®i, hi‚ü© hji hg.symm).elim,
        -- üéâ no goals
      fun hinj i j hij h => Nat.ne_of_lt hij (Fin.veq_of_eq (hinj h))‚ü©

set_option linter.deprecated false in
@[deprecated nodup_iff_injective_get]
theorem nodup_iff_nthLe_inj {l : List Œ±} :
    Nodup l ‚Üî ‚àÄ i j h‚ÇÅ h‚ÇÇ, nthLe l i h‚ÇÅ = nthLe l j h‚ÇÇ ‚Üí i = j :=
  nodup_iff_injective_get.trans
    ‚ü®fun hinj _ _ _ _ h => congr_arg Fin.val (hinj h),
     fun hinj i j h => Fin.eq_of_veq (hinj i j i.2 j.2 h)‚ü©
#align list.nodup_iff_nth_le_inj List.nodup_iff_nthLe_inj

theorem Nodup.get_inj_iff {l : List Œ±} (h : Nodup l) {i j : Fin l.length} :
    l.get i = l.get j ‚Üî i = j :=
  (nodup_iff_injective_get.1 h).eq_iff

set_option linter.deprecated false in
@[deprecated Nodup.get_inj_iff]
theorem Nodup.nthLe_inj_iff {l : List Œ±} (h : Nodup l) {i j : ‚Ñï} (hi : i < l.length)
    (hj : j < l.length) : l.nthLe i hi = l.nthLe j hj ‚Üî i = j :=
  ‚ü®nodup_iff_nthLe_inj.mp h _ _ _ _, by simp (config := { contextual := true })‚ü©
                                        -- üéâ no goals
#align list.nodup.nth_le_inj_iff List.Nodup.nthLe_inj_iff

theorem nodup_iff_get?_ne_get? {l : List Œ±} :
    l.Nodup ‚Üî ‚àÄ i j : ‚Ñï, i < j ‚Üí j < l.length ‚Üí l.get? i ‚â† l.get? j := by
  rw [Nodup, pairwise_iff_get]
  -- ‚ä¢ (‚àÄ (i j : Fin (length l)), i < j ‚Üí get l i ‚â† get l j) ‚Üî ‚àÄ (i j : ‚Ñï), i < j ‚Üí ‚Ä¶
  constructor
  -- ‚ä¢ (‚àÄ (i j : Fin (length l)), i < j ‚Üí get l i ‚â† get l j) ‚Üí ‚àÄ (i j : ‚Ñï), i < j ‚Üí ‚Ä¶
  ¬∑ intro h i j hij hj
    -- ‚ä¢ get? l i ‚â† get? l j
    rw [get?_eq_get (lt_trans hij hj), get?_eq_get hj, Ne.def, Option.some_inj]
    -- ‚ä¢ ¬¨get l { val := i, isLt := (_ : i < length l) } = get l { val := j, isLt :=  ‚Ä¶
    exact h _ _ hij
    -- üéâ no goals
  ¬∑ intro h i j hij
    -- ‚ä¢ get l i ‚â† get l j
    rw [Ne.def, ‚Üê Option.some_inj, ‚Üê get?_eq_get, ‚Üê get?_eq_get]
    -- ‚ä¢ ¬¨get? l ‚Üëi = get? l ‚Üëj
    exact h i j hij j.2
    -- üéâ no goals
#align list.nodup_iff_nth_ne_nth List.nodup_iff_get?_ne_get?

theorem Nodup.ne_singleton_iff {l : List Œ±} (h : Nodup l) (x : Œ±) :
    l ‚â† [x] ‚Üî l = [] ‚à® ‚àÉ y ‚àà l, y ‚â† x := by
  induction' l with hd tl hl
  -- ‚ä¢ [] ‚â† [x] ‚Üî [] = [] ‚à® ‚àÉ y, y ‚àà [] ‚àß y ‚â† x
  ¬∑ simp
    -- üéâ no goals
  ¬∑ specialize hl h.of_cons
    -- ‚ä¢ hd :: tl ‚â† [x] ‚Üî hd :: tl = [] ‚à® ‚àÉ y, y ‚àà hd :: tl ‚àß y ‚â† x
    by_cases hx : tl = [x]
    -- ‚ä¢ hd :: tl ‚â† [x] ‚Üî hd :: tl = [] ‚à® ‚àÉ y, y ‚àà hd :: tl ‚àß y ‚â† x
    ¬∑ simpa [hx, and_comm, and_or_left] using h
      -- üéâ no goals
    ¬∑ rw [‚Üê Ne.def, hl] at hx
      -- ‚ä¢ hd :: tl ‚â† [x] ‚Üî hd :: tl = [] ‚à® ‚àÉ y, y ‚àà hd :: tl ‚àß y ‚â† x
      rcases hx with (rfl | ‚ü®y, hy, hx‚ü©)
      -- ‚ä¢ [hd] ‚â† [x] ‚Üî [hd] = [] ‚à® ‚àÉ y, y ‚àà [hd] ‚àß y ‚â† x
      ¬∑ simp
        -- üéâ no goals
      ¬∑ suffices ‚àÉ (y : Œ±) (_ : y ‚àà hd :: tl), y ‚â† x by simpa [ne_nil_of_mem hy]
        -- ‚ä¢ ‚àÉ y x_1, y ‚â† x
        exact ‚ü®y, mem_cons_of_mem _ hy, hx‚ü©
        -- üéâ no goals
#align list.nodup.ne_singleton_iff List.Nodup.ne_singleton_iff

theorem not_nodup_of_get_eq_of_ne (xs : List Œ±) (n m : Fin xs.length)
    (h : xs.get n = xs.get m) (hne : n ‚â† m) : ¬¨Nodup xs := by
  rw [nodup_iff_injective_get]
  -- ‚ä¢ ¬¨Injective (get xs)
  exact fun hinj => hne (hinj h)
  -- üéâ no goals

set_option linter.deprecated false in
@[deprecated not_nodup_of_get_eq_of_ne]
theorem nthLe_eq_of_ne_imp_not_nodup (xs : List Œ±) (n m : ‚Ñï) (hn : n < xs.length)
    (hm : m < xs.length) (h : xs.nthLe n hn = xs.nthLe m hm) (hne : n ‚â† m) : ¬¨Nodup xs := by
  rw [nodup_iff_nthLe_inj]
  -- ‚ä¢ ¬¨‚àÄ (i j : ‚Ñï) (h‚ÇÅ : i < length xs) (h‚ÇÇ : j < length xs), nthLe xs i h‚ÇÅ = nthL ‚Ä¶
  simp only [exists_prop, exists_and_right, not_forall]
  -- ‚ä¢ ‚àÉ x x_1, (‚àÉ x_2 x_3, nthLe xs x (_ : x < length xs) = nthLe xs x_1 (_ : x_1  ‚Ä¶
  exact ‚ü®n, m, ‚ü®hn, hm, h‚ü©, hne‚ü©
  -- üéâ no goals
#align list.nth_le_eq_of_ne_imp_not_nodup List.nthLe_eq_of_ne_imp_not_nodup

--Porting note: new theorem
theorem get_indexOf [DecidableEq Œ±] {l : List Œ±} (H : Nodup l) (i : Fin l.length) :
    indexOf (get l i) l = i :=
  suffices (‚ü®indexOf (get l i) l, indexOf_lt_length.2 (get_mem _ _ _)‚ü© : Fin l.length) = i
    from Fin.veq_of_eq this
  nodup_iff_injective_get.1 H (by simp)
                                  -- üéâ no goals

set_option linter.deprecated false in
@[simp, deprecated get_indexOf]
theorem nthLe_index_of [DecidableEq Œ±] {l : List Œ±} (H : Nodup l) (n h) :
    indexOf (nthLe l n h) l = n :=
  nodup_iff_nthLe_inj.1 H _ _ _ h <| indexOf_nthLe <| indexOf_lt_length.2 <| nthLe_mem _ _ _
#align list.nth_le_index_of List.nthLe_index_of

theorem nodup_iff_count_le_one [DecidableEq Œ±] {l : List Œ±} : Nodup l ‚Üî ‚àÄ a, count a l ‚â§ 1 :=
  nodup_iff_sublist.trans <|
    forall_congr' fun a =>
      have : replicate 2 a <+ l ‚Üî 1 < count a l := (le_count_iff_replicate_sublist ..).symm
      (not_congr this).trans not_lt
#align list.nodup_iff_count_le_one List.nodup_iff_count_le_one

theorem nodup_replicate (a : Œ±) : ‚àÄ {n : ‚Ñï}, Nodup (replicate n a) ‚Üî n ‚â§ 1
  | 0 => by simp [Nat.zero_le]
            -- üéâ no goals
  | 1 => by simp
            -- üéâ no goals
  | n + 2 =>
    iff_of_false
      (fun H => nodup_iff_sublist.1 H a ((replicate_sublist_replicate _).2 (Nat.le_add_left 2 n)))
      (not_le_of_lt <| Nat.le_add_left 2 n)
#align list.nodup_replicate List.nodup_replicate

@[simp]
theorem count_eq_one_of_mem [DecidableEq Œ±] {a : Œ±} {l : List Œ±} (d : Nodup l) (h : a ‚àà l) :
    count a l = 1 :=
  _root_.le_antisymm (nodup_iff_count_le_one.1 d a) (Nat.succ_le_of_lt (count_pos_iff_mem.2 h))
#align list.count_eq_one_of_mem List.count_eq_one_of_mem

theorem count_eq_of_nodup [DecidableEq Œ±] {a : Œ±} {l : List Œ±} (d : Nodup l) :
    count a l = if a ‚àà l then 1 else 0 := by
  split_ifs with h
  -- ‚ä¢ count a l = 1
  ¬∑ exact count_eq_one_of_mem d h
    -- üéâ no goals
  ¬∑ exact count_eq_zero_of_not_mem h
    -- üéâ no goals
#align list.count_eq_of_nodup List.count_eq_of_nodup

theorem Nodup.of_append_left : Nodup (l‚ÇÅ ++ l‚ÇÇ) ‚Üí Nodup l‚ÇÅ :=
  Nodup.sublist (sublist_append_left l‚ÇÅ l‚ÇÇ)
#align list.nodup.of_append_left List.Nodup.of_append_left

theorem Nodup.of_append_right : Nodup (l‚ÇÅ ++ l‚ÇÇ) ‚Üí Nodup l‚ÇÇ :=
  Nodup.sublist (sublist_append_right l‚ÇÅ l‚ÇÇ)
#align list.nodup.of_append_right List.Nodup.of_append_right

theorem nodup_append {l‚ÇÅ l‚ÇÇ : List Œ±} : Nodup (l‚ÇÅ ++ l‚ÇÇ) ‚Üî Nodup l‚ÇÅ ‚àß Nodup l‚ÇÇ ‚àß Disjoint l‚ÇÅ l‚ÇÇ :=
  by simp only [Nodup, pairwise_append, disjoint_iff_ne]
     -- üéâ no goals
#align list.nodup_append List.nodup_append

theorem disjoint_of_nodup_append {l‚ÇÅ l‚ÇÇ : List Œ±} (d : Nodup (l‚ÇÅ ++ l‚ÇÇ)) : Disjoint l‚ÇÅ l‚ÇÇ :=
  (nodup_append.1 d).2.2
#align list.disjoint_of_nodup_append List.disjoint_of_nodup_append

theorem Nodup.append (d‚ÇÅ : Nodup l‚ÇÅ) (d‚ÇÇ : Nodup l‚ÇÇ) (dj : Disjoint l‚ÇÅ l‚ÇÇ) : Nodup (l‚ÇÅ ++ l‚ÇÇ) :=
  nodup_append.2 ‚ü®d‚ÇÅ, d‚ÇÇ, dj‚ü©
#align list.nodup.append List.Nodup.append

theorem nodup_append_comm {l‚ÇÅ l‚ÇÇ : List Œ±} : Nodup (l‚ÇÅ ++ l‚ÇÇ) ‚Üî Nodup (l‚ÇÇ ++ l‚ÇÅ) := by
  simp only [nodup_append, and_left_comm, disjoint_comm]
  -- üéâ no goals
#align list.nodup_append_comm List.nodup_append_comm

theorem nodup_middle {a : Œ±} {l‚ÇÅ l‚ÇÇ : List Œ±} :
    Nodup (l‚ÇÅ ++ a :: l‚ÇÇ) ‚Üî Nodup (a :: (l‚ÇÅ ++ l‚ÇÇ)) := by
  simp only [nodup_append, not_or, and_left_comm, and_assoc, nodup_cons, mem_append,
    disjoint_cons_right]
#align list.nodup_middle List.nodup_middle

theorem Nodup.of_map (f : Œ± ‚Üí Œ≤) {l : List Œ±} : Nodup (map f l) ‚Üí Nodup l :=
  (Pairwise.of_map f) fun _ _ => mt <| congr_arg f
#align list.nodup.of_map List.Nodup.of_map‚Çì -- Porting note: different universe order

theorem Nodup.map_on {f : Œ± ‚Üí Œ≤} (H : ‚àÄ x ‚àà l, ‚àÄ y ‚àà l, f x = f y ‚Üí x = y) (d : Nodup l) :
    (map f l).Nodup :=
  Pairwise.map _ (fun a b ‚ü®ma, mb, n‚ü© e => n (H a ma b mb e)) (Pairwise.and_mem.1 d)
#align list.nodup.map_on List.Nodup.map_on‚Çì -- Porting note: different universe order

theorem inj_on_of_nodup_map {f : Œ± ‚Üí Œ≤} {l : List Œ±} (d : Nodup (map f l)) :
    ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà l ‚Üí ‚àÄ ‚¶Éy‚¶Ñ, y ‚àà l ‚Üí f x = f y ‚Üí x = y := by
  induction' l with hd tl ih
  -- ‚ä¢ ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà [] ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà [] ‚Üí f x = f y ‚Üí x = y
  ¬∑ simp
    -- üéâ no goals
  ¬∑ simp only [map, nodup_cons, mem_map, not_exists, not_and, ‚Üê Ne.def] at d
    -- ‚ä¢ ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà hd :: tl ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà hd :: tl ‚Üí f x = f y ‚Üí x = y
    simp only [mem_cons]
    -- ‚ä¢ ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x = hd ‚à® x ‚àà tl ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y = hd ‚à® y ‚àà tl ‚Üí f x = f y ‚Üí x = y
    rintro _ (rfl | h‚ÇÅ) _ (rfl | h‚ÇÇ) h‚ÇÉ
    ¬∑ rfl
      -- üéâ no goals
    ¬∑ apply (d.1 _ h‚ÇÇ h‚ÇÉ.symm).elim
      -- üéâ no goals
    ¬∑ apply (d.1 _ h‚ÇÅ h‚ÇÉ).elim
      -- üéâ no goals
    ¬∑ apply ih d.2 h‚ÇÅ h‚ÇÇ h‚ÇÉ
      -- üéâ no goals
#align list.inj_on_of_nodup_map List.inj_on_of_nodup_map

theorem nodup_map_iff_inj_on {f : Œ± ‚Üí Œ≤} {l : List Œ±} (d : Nodup l) :
    Nodup (map f l) ‚Üî ‚àÄ x ‚àà l, ‚àÄ y ‚àà l, f x = f y ‚Üí x = y :=
  ‚ü®inj_on_of_nodup_map, fun h => d.map_on h‚ü©
#align list.nodup_map_iff_inj_on List.nodup_map_iff_inj_on

protected theorem Nodup.map {f : Œ± ‚Üí Œ≤} (hf : Injective f) : Nodup l ‚Üí Nodup (map f l) :=
  Nodup.map_on fun _ _ _ _ h => hf h
#align list.nodup.map List.Nodup.map -- Porting note: different universe order

theorem nodup_map_iff {f : Œ± ‚Üí Œ≤} {l : List Œ±} (hf : Injective f) : Nodup (map f l) ‚Üî Nodup l :=
  ‚ü®Nodup.of_map _, Nodup.map hf‚ü©
#align list.nodup_map_iff List.nodup_map_iff

@[simp]
theorem nodup_attach {l : List Œ±} : Nodup (attach l) ‚Üî Nodup l :=
  ‚ü®fun h => attach_map_val l ‚ñ∏ h.map fun _ _ => Subtype.eq, fun h =>
    Nodup.of_map Subtype.val ((attach_map_val l).symm ‚ñ∏ h)‚ü©
#align list.nodup_attach List.nodup_attach

alias ‚ü®Nodup.of_attach, Nodup.attach‚ü© := nodup_attach
#align list.nodup.attach List.Nodup.attach
#align list.nodup.of_attach List.Nodup.of_attach

--Porting note: commented out
--attribute [protected] nodup.attach

theorem Nodup.pmap {p : Œ± ‚Üí Prop} {f : ‚àÄ a, p a ‚Üí Œ≤} {l : List Œ±} {H}
    (hf : ‚àÄ a ha b hb, f a ha = f b hb ‚Üí a = b) (h : Nodup l) : Nodup (pmap f l H) := by
  rw [pmap_eq_map_attach]
  -- ‚ä¢ Nodup (map (fun x => f ‚Üëx (_ : p ‚Üëx)) (List.attach l))
  exact h.attach.map fun ‚ü®a, ha‚ü© ‚ü®b, hb‚ü© h => by congr; exact hf a (H _ ha) b (H _ hb) h
  -- üéâ no goals
#align list.nodup.pmap List.Nodup.pmap

theorem Nodup.filter (p : Œ± ‚Üí Bool) {l} : Nodup l ‚Üí Nodup (filter p l) := by
  simpa using Pairwise.filter (fun a ‚Ü¶ p a)
  -- üéâ no goals
#align list.nodup.filter List.Nodup.filter

@[simp]
theorem nodup_reverse {l : List Œ±} : Nodup (reverse l) ‚Üî Nodup l :=
  pairwise_reverse.trans <| by simp only [Nodup, Ne.def, eq_comm]
                               -- üéâ no goals
#align list.nodup_reverse List.nodup_reverse

theorem Nodup.erase_eq_filter [DecidableEq Œ±] {l} (d : Nodup l) (a : Œ±) :
    l.erase a = l.filter (¬∑ ‚â† a) := by
  induction' d with b l m _ IH; ¬∑ rfl
  -- ‚ä¢ List.erase [] a = List.filter (fun x => decide (x ‚â† a)) []
                                  -- üéâ no goals
  by_cases h : b = a
  -- ‚ä¢ List.erase (b :: l) a = List.filter (fun x => decide (x ‚â† a)) (b :: l)
  ¬∑ subst h
    -- ‚ä¢ List.erase (b :: l) b = List.filter (fun x => decide (x ‚â† b)) (b :: l)
    rw [erase_cons_head, filter_cons_of_neg _ (by simp)]
    -- ‚ä¢ l = List.filter (fun x => decide (x ‚â† b)) l
    symm
    -- ‚ä¢ List.filter (fun x => decide (x ‚â† b)) l = l
    rw [filter_eq_self]
    -- ‚ä¢ ‚àÄ (a : Œ±), a ‚àà l ‚Üí decide (a ‚â† b) = true
    simpa [@eq_comm Œ±] using m
    -- üéâ no goals
  ¬∑ rw [erase_cons_tail _ h, filter_cons_of_pos, IH]
    -- ‚ä¢ decide (b ‚â† a) = true
    simp [h]
    -- üéâ no goals
#align list.nodup.erase_eq_filter List.Nodup.erase_eq_filter

theorem Nodup.erase [DecidableEq Œ±] (a : Œ±) : Nodup l ‚Üí Nodup (l.erase a) :=
  Nodup.sublist <| erase_sublist _ _
#align list.nodup.erase List.Nodup.erase

theorem Nodup.diff [DecidableEq Œ±] : l‚ÇÅ.Nodup ‚Üí (l‚ÇÅ.diff l‚ÇÇ).Nodup :=
  Nodup.sublist <| diff_sublist _ _
#align list.nodup.diff List.Nodup.diff

theorem Nodup.mem_erase_iff [DecidableEq Œ±] (d : Nodup l) : a ‚àà l.erase b ‚Üî a ‚â† b ‚àß a ‚àà l := by
  rw [d.erase_eq_filter, mem_filter, and_comm, decide_eq_true_iff]
  -- üéâ no goals
#align list.nodup.mem_erase_iff List.Nodup.mem_erase_iff

theorem Nodup.not_mem_erase [DecidableEq Œ±] (h : Nodup l) : a ‚àâ l.erase a := fun H =>
  (h.mem_erase_iff.1 H).1 rfl
#align list.nodup.not_mem_erase List.Nodup.not_mem_erase

theorem nodup_join {L : List (List Œ±)} :
    Nodup (join L) ‚Üî (‚àÄ l ‚àà L, Nodup l) ‚àß Pairwise Disjoint L := by
  simp only [Nodup, pairwise_join, disjoint_left.symm, forall_mem_ne]
  -- üéâ no goals
#align list.nodup_join List.nodup_join

theorem nodup_bind {l‚ÇÅ : List Œ±} {f : Œ± ‚Üí List Œ≤} :
    Nodup (l‚ÇÅ.bind f) ‚Üî
      (‚àÄ x ‚àà l‚ÇÅ, Nodup (f x)) ‚àß Pairwise (fun a b : Œ± => Disjoint (f a) (f b)) l‚ÇÅ := by
  simp only [List.bind, nodup_join, pairwise_map, and_comm, and_left_comm, mem_map, exists_imp,
      and_imp]
  rw [show (‚àÄ (l : List Œ≤) (x : Œ±), f x = l ‚Üí x ‚àà l‚ÇÅ ‚Üí Nodup l) ‚Üî ‚àÄ x : Œ±, x ‚àà l‚ÇÅ ‚Üí Nodup (f x)
      from forall_swap.trans <| forall_congr' fun _ => forall_eq']
#align list.nodup_bind List.nodup_bind

protected theorem Nodup.product {l‚ÇÇ : List Œ≤} (d‚ÇÅ : l‚ÇÅ.Nodup) (d‚ÇÇ : l‚ÇÇ.Nodup) :
    (l‚ÇÅ √óÀ¢ l‚ÇÇ).Nodup :=
  nodup_bind.2
    ‚ü®fun a _ => d‚ÇÇ.map <| LeftInverse.injective fun b => (rfl : (a, b).2 = b),
      d‚ÇÅ.imp fun {a‚ÇÅ a‚ÇÇ} n x h‚ÇÅ h‚ÇÇ => by
        rcases mem_map.1 h‚ÇÅ with ‚ü®b‚ÇÅ, _, rfl‚ü©
        -- ‚ä¢ False
        rcases mem_map.1 h‚ÇÇ with ‚ü®b‚ÇÇ, mb‚ÇÇ, ‚ü®‚ü©‚ü©
        -- ‚ä¢ False
        exact n rfl‚ü©
        -- üéâ no goals
#align list.nodup.product List.Nodup.product

theorem Nodup.sigma {œÉ : Œ± ‚Üí Type*} {l‚ÇÇ : ‚àÄ a , List (œÉ a)} (d‚ÇÅ : Nodup l‚ÇÅ)
    (d‚ÇÇ : ‚àÄ a , Nodup (l‚ÇÇ a)) : (l‚ÇÅ.sigma l‚ÇÇ).Nodup :=
  nodup_bind.2
    ‚ü®fun a _ => (d‚ÇÇ a).map fun b b' h => by injection h with _ h,
                                            -- üéâ no goals
      d‚ÇÅ.imp fun {a‚ÇÅ a‚ÇÇ} n x h‚ÇÅ h‚ÇÇ => by
        rcases mem_map.1 h‚ÇÅ with ‚ü®b‚ÇÅ, _, rfl‚ü©
        -- ‚ä¢ False
        rcases mem_map.1 h‚ÇÇ with ‚ü®b‚ÇÇ, mb‚ÇÇ, ‚ü®‚ü©‚ü©
        -- ‚ä¢ False
        exact n rfl‚ü©
        -- üéâ no goals
#align list.nodup.sigma List.Nodup.sigma

protected theorem Nodup.filterMap {f : Œ± ‚Üí Option Œ≤} (h : ‚àÄ a a' b, b ‚àà f a ‚Üí b ‚àà f a' ‚Üí a = a') :
    Nodup l ‚Üí Nodup (filterMap f l) :=
  (Pairwise.filter_map f) @fun a a' n b bm b' bm' e => n <| h a a' b' (by rw [‚Üê e]; exact bm) bm'
                                                                          -- ‚ä¢ b ‚àà f a
                                                                                    -- üéâ no goals
#align list.nodup.filter_map List.Nodup.filterMap

protected theorem Nodup.concat (h : a ‚àâ l) (h' : l.Nodup) : (l.concat a).Nodup := by
  rw [concat_eq_append]; exact h'.append (nodup_singleton _) (disjoint_singleton.2 h)
  -- ‚ä¢ Nodup (l ++ [a])
                         -- üéâ no goals
#align list.nodup.concat List.Nodup.concat

protected theorem Nodup.insert [DecidableEq Œ±] (h : l.Nodup) : (l.insert a).Nodup :=
  if h' : a ‚àà l then by rw [insert_of_mem h']; exact h
                        -- ‚ä¢ Nodup l
                                               -- üéâ no goals
  else by rw [insert_of_not_mem h', nodup_cons]; constructor <;> assumption
          -- ‚ä¢ ¬¨a ‚àà l ‚àß Nodup l
                                                 -- ‚ä¢ ¬¨a ‚àà l
                                                                 -- üéâ no goals
                                                                 -- üéâ no goals
#align list.nodup.insert List.Nodup.insert

theorem Nodup.union [DecidableEq Œ±] (l‚ÇÅ : List Œ±) (h : Nodup l‚ÇÇ) : (l‚ÇÅ ‚à™ l‚ÇÇ).Nodup := by
  induction' l‚ÇÅ with a l‚ÇÅ ih generalizing l‚ÇÇ
  -- ‚ä¢ Nodup ([] ‚à™ l‚ÇÇ)
  ¬∑ exact h
    -- üéâ no goals
  ¬∑ exact (ih h).insert
    -- üéâ no goals
#align list.nodup.union List.Nodup.union

theorem Nodup.inter [DecidableEq Œ±] (l‚ÇÇ : List Œ±) : Nodup l‚ÇÅ ‚Üí Nodup (l‚ÇÅ ‚à© l‚ÇÇ) :=
  Nodup.filter _
#align list.nodup.inter List.Nodup.inter

theorem Nodup.diff_eq_filter [DecidableEq Œ±] :
    ‚àÄ {l‚ÇÅ l‚ÇÇ : List Œ±} (_ : l‚ÇÅ.Nodup), l‚ÇÅ.diff l‚ÇÇ = l‚ÇÅ.filter (¬∑ ‚àâ l‚ÇÇ)
  | l‚ÇÅ, [], _ => by simp
                    -- üéâ no goals
  | l‚ÇÅ, a :: l‚ÇÇ, hl‚ÇÅ => by
    rw [diff_cons, (hl‚ÇÅ.erase _).diff_eq_filter, hl‚ÇÅ.erase_eq_filter, filter_filter]
    -- ‚ä¢ List.filter (fun a_1 => decide ((decide ¬¨a_1 ‚àà l‚ÇÇ) = true ‚àß decide (a_1 ‚â† a) ‚Ä¶
    simp only [decide_not, Bool.not_eq_true', decide_eq_false_iff_not, ne_eq, and_comm,
      Bool.decide_and, find?, mem_cons, not_or]
#align list.nodup.diff_eq_filter List.Nodup.diff_eq_filter

theorem Nodup.mem_diff_iff [DecidableEq Œ±] (hl‚ÇÅ : l‚ÇÅ.Nodup) : a ‚àà l‚ÇÅ.diff l‚ÇÇ ‚Üî a ‚àà l‚ÇÅ ‚àß a ‚àâ l‚ÇÇ := by
  rw [hl‚ÇÅ.diff_eq_filter, mem_filter, decide_eq_true_iff]
  -- üéâ no goals
#align list.nodup.mem_diff_iff List.Nodup.mem_diff_iff

protected theorem Nodup.set :
    ‚àÄ {l : List Œ±} {n : ‚Ñï} {a : Œ±} (_ : l.Nodup) (_ : a ‚àâ l), (l.set n a).Nodup
  | [], _, _, _, _ => nodup_nil
  | _ :: _, 0, _, hl, ha => nodup_cons.2 ‚ü®mt (mem_cons_of_mem _) ha, (nodup_cons.1 hl).2‚ü©
  | _ :: _, _ + 1, _, hl, ha =>
    nodup_cons.2
      ‚ü®fun h =>
        (mem_or_eq_of_mem_set h).elim (nodup_cons.1 hl).1 fun hba => ha (hba ‚ñ∏ mem_cons_self _ _),
        hl.of_cons.set (mt (mem_cons_of_mem _) ha)‚ü©
#align list.nodup.update_nth List.Nodup.set

theorem Nodup.map_update [DecidableEq Œ±] {l : List Œ±} (hl : l.Nodup) (f : Œ± ‚Üí Œ≤) (x : Œ±) (y : Œ≤) :
    l.map (Function.update f x y) =
      if x ‚àà l then (l.map f).set (l.indexOf x) y else l.map f := by
  induction' l with hd tl ihl; ¬∑ simp
  -- ‚ä¢ map (update f x y) [] = if x ‚àà [] then set (map f []) (indexOf x []) y else  ‚Ä¶
                                 -- üéâ no goals
  rw [nodup_cons] at hl
  -- ‚ä¢ map (update f x y) (hd :: tl) = if x ‚àà hd :: tl then set (map f (hd :: tl))  ‚Ä¶
  simp only [mem_cons, map, ihl hl.2]
  -- ‚ä¢ (update f x y hd :: if x ‚àà tl then set (map f tl) (indexOf x tl) y else map  ‚Ä¶
  by_cases H : hd = x
  -- ‚ä¢ (update f x y hd :: if x ‚àà tl then set (map f tl) (indexOf x tl) y else map  ‚Ä¶
  ¬∑ subst hd
    -- ‚ä¢ (update f x y x :: if x ‚àà tl then set (map f tl) (indexOf x tl) y else map f ‚Ä¶
    simp [set, hl.1]
    -- üéâ no goals
  ¬∑ simp [Ne.symm H, H, set, ‚Üê apply_ite (cons (f hd))]
    -- üéâ no goals
#align list.nodup.map_update List.Nodup.map_update

theorem Nodup.pairwise_of_forall_ne {l : List Œ±} {r : Œ± ‚Üí Œ± ‚Üí Prop} (hl : l.Nodup)
    (h : ‚àÄ a ‚àà l, ‚àÄ b ‚àà l, a ‚â† b ‚Üí r a b) : l.Pairwise r := by
  classical
    refine' pairwise_of_reflexive_on_dupl_of_forall_ne _ h
    intro x hx
    rw [nodup_iff_count_le_one] at hl
    exact absurd (hl x) hx.not_le
#align list.nodup.pairwise_of_forall_ne List.Nodup.pairwise_of_forall_ne

theorem Nodup.pairwise_of_set_pairwise {l : List Œ±} {r : Œ± ‚Üí Œ± ‚Üí Prop} (hl : l.Nodup)
    (h : { x | x ‚àà l }.Pairwise r) : l.Pairwise r :=
  hl.pairwise_of_forall_ne h
#align list.nodup.pairwise_of_set_pairwise List.Nodup.pairwise_of_set_pairwise

@[simp]
theorem Nodup.pairwise_coe [IsSymm Œ± r] (hl : l.Nodup)
    : { a | a ‚àà l }.Pairwise r ‚Üî l.Pairwise r := by
  induction' l with a l ih
  -- ‚ä¢ Set.Pairwise {a | a ‚àà []} r ‚Üî Pairwise r []
  ¬∑ simp
    -- üéâ no goals
  rw [List.nodup_cons] at hl
  -- ‚ä¢ Set.Pairwise {a_1 | a_1 ‚àà a :: l} r ‚Üî Pairwise r (a :: l)
  have : ‚àÄ b ‚àà l, ¬¨a = b ‚Üí r a b ‚Üî r a b := fun b hb =>
    imp_iff_right (ne_of_mem_of_not_mem hb hl.1).symm
  simp [Set.setOf_or, Set.pairwise_insert_of_symmetric (@symm_of _ r _), ih hl.2, and_comm,
    forall‚ÇÇ_congr this]
#align list.nodup.pairwise_coe List.Nodup.pairwise_coe

--Porting note: new theorem
theorem Nodup.take_eq_filter_mem [DecidableEq Œ±] :
    ‚àÄ {l : List Œ±} {n : ‚Ñï} (_ : l.Nodup), l.take n = l.filter (¬∑ ‚àà l.take n)
  | [], n, _ => by simp
                   -- üéâ no goals
  | b::l, 0, _ => by simp
                     -- üéâ no goals
  | b::l, n+1, hl => by
    rw [take_cons, Nodup.take_eq_filter_mem (Nodup.of_cons hl), List.filter_cons_of_pos _ (by simp)]
    -- ‚ä¢ b :: List.filter (fun x => decide (x ‚àà take n l)) l = b :: List.filter (fun  ‚Ä¶
    congr 1
    -- ‚ä¢ List.filter (fun x => decide (x ‚àà take n l)) l = List.filter (fun x => decid ‚Ä¶
    refine' List.filter_congr' _
    -- ‚ä¢ ‚àÄ (x : Œ±), x ‚àà l ‚Üí (decide (x ‚àà take n l) = true ‚Üî decide (x ‚àà b :: List.fil ‚Ä¶
    intro x hx
    -- ‚ä¢ decide (x ‚àà take n l) = true ‚Üî decide (x ‚àà b :: List.filter (fun x => decide ‚Ä¶
    have : x ‚â† b := fun h => (nodup_cons.1 hl).1 (h ‚ñ∏ hx)
    -- ‚ä¢ decide (x ‚àà take n l) = true ‚Üî decide (x ‚àà b :: List.filter (fun x => decide ‚Ä¶
    simp (config := {contextual := true}) [List.mem_filter, this, hx]
    -- üéâ no goals
end List

theorem Option.toList_nodup {Œ±} : ‚àÄ o : Option Œ±, o.toList.Nodup
  | none => List.nodup_nil
  | some x => List.nodup_singleton x
#align option.to_list_nodup Option.toList_nodup
