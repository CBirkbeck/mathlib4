/-
Copyright (c) 2015 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura, Jeremy Avigad, Mario Carneiro
-/
import Mathlib.Data.List.Dedup
import Mathlib.Data.List.Permutation
import Mathlib.Data.List.Range
import Mathlib.Data.Nat.Factorial.Basic

#align_import data.list.perm from "leanprover-community/mathlib"@"47adfab39a11a072db552f47594bf8ed2cf8a722"

/-!
# List Permutations

This file introduces the `List.Perm` relation, which is true if two lists are permutations of one
another.

## Notation

The notation `~` is used for permutation equivalence.
-/


open Nat

universe uu vv

namespace List

variable {Œ± : Type uu} {Œ≤ : Type vv} {l‚ÇÅ l‚ÇÇ : List Œ±}

/-- `Perm l‚ÇÅ l‚ÇÇ` or `l‚ÇÅ ~ l‚ÇÇ` asserts that `l‚ÇÅ` and `l‚ÇÇ` are permutations
  of each other. This is defined by induction using pairwise swaps. -/
inductive Perm : List Œ± ‚Üí List Œ± ‚Üí Prop
  | nil : Perm [] []
  | cons (x : Œ±) {l‚ÇÅ l‚ÇÇ : List Œ±} : Perm l‚ÇÅ l‚ÇÇ ‚Üí Perm (x :: l‚ÇÅ) (x :: l‚ÇÇ)
  | swap (x y : Œ±) (l : List Œ±) : Perm (y :: x :: l) (x :: y :: l)
  | trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : List Œ±} : Perm l‚ÇÅ l‚ÇÇ ‚Üí Perm l‚ÇÇ l‚ÇÉ ‚Üí Perm l‚ÇÅ l‚ÇÉ
#align list.perm List.Perm

open Perm (swap)

/-- `Perm l‚ÇÅ l‚ÇÇ` or `l‚ÇÅ ~ l‚ÇÇ` asserts that `l‚ÇÅ` and `l‚ÇÇ` are permutations
  of each other. This is defined by induction using pairwise swaps. -/
infixl:50 " ~ " => Perm

@[simp, refl]
protected theorem Perm.refl : ‚àÄ l : List Œ±, l ~ l
  | [] => Perm.nil
  | x :: xs => (Perm.refl xs).cons x
#align list.perm.refl List.Perm.refl

-- Porting note: used rec_on in mathlib3; lean4 eqn compiler still doesn't like it
@[symm]
protected theorem Perm.symm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : l‚ÇÇ ~ l‚ÇÅ :=
  p.rec
    .nil
    (fun x _ _ _ r‚ÇÅ => .cons x r‚ÇÅ)
    (fun x y l => .swap y x l)
    (fun _ _ r‚ÇÅ r‚ÇÇ => .trans r‚ÇÇ r‚ÇÅ)
#align list.perm.symm List.Perm.symm

theorem perm_comm {l‚ÇÅ l‚ÇÇ : List Œ±} : l‚ÇÅ ~ l‚ÇÇ ‚Üî l‚ÇÇ ~ l‚ÇÅ :=
  ‚ü®Perm.symm, Perm.symm‚ü©
#align list.perm_comm List.perm_comm

theorem Perm.swap' (x y : Œ±) {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : y :: x :: l‚ÇÅ ~ x :: y :: l‚ÇÇ :=
  (swap _ _ _).trans ((p.cons _).cons _)
#align list.perm.swap' List.Perm.swap'

attribute [trans] Perm.trans

theorem Perm.eqv (Œ±) : Equivalence (@Perm Œ±) :=
  ‚ü®Perm.refl, Perm.symm, Perm.trans‚ü©
#align list.perm.eqv List.Perm.eqv

--Porting note: new theorem
theorem Perm.of_eq (h : l‚ÇÅ = l‚ÇÇ) : l‚ÇÅ ~ l‚ÇÇ :=
  h ‚ñ∏ Perm.refl l‚ÇÅ

instance isSetoid (Œ±) : Setoid (List Œ±) :=
  Setoid.mk (@Perm Œ±) (Perm.eqv Œ±)
#align list.is_setoid List.isSetoid

-- Porting note: used rec_on in mathlib3; lean4 eqn compiler still doesn't like it
theorem Perm.mem_iff {a : Œ±} {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : a ‚àà l‚ÇÅ ‚Üî a ‚àà l‚ÇÇ :=
  p.rec
    Iff.rfl
    (fun _ _ _ _ hs => by simp only [mem_cons, hs])
                          -- üéâ no goals
    (fun _ _ _ => by simp only [mem_cons, or_left_comm])
                     -- üéâ no goals
    (fun _ _ => Iff.trans)
#align list.perm.mem_iff List.Perm.mem_iff

theorem Perm.subset {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : l‚ÇÅ ‚äÜ l‚ÇÇ :=
  fun _ => p.mem_iff.mp
#align list.perm.subset List.Perm.subset

theorem Perm.subset_congr_left {l‚ÇÅ l‚ÇÇ l‚ÇÉ : List Œ±} (h : l‚ÇÅ ~ l‚ÇÇ) : l‚ÇÅ ‚äÜ l‚ÇÉ ‚Üî l‚ÇÇ ‚äÜ l‚ÇÉ :=
  ‚ü®h.symm.subset.trans, h.subset.trans‚ü©
#align list.perm.subset_congr_left List.Perm.subset_congr_left

theorem Perm.subset_congr_right {l‚ÇÅ l‚ÇÇ l‚ÇÉ : List Œ±} (h : l‚ÇÅ ~ l‚ÇÇ) : l‚ÇÉ ‚äÜ l‚ÇÅ ‚Üî l‚ÇÉ ‚äÜ l‚ÇÇ :=
  ‚ü®fun h' => h'.trans h.subset, fun h' => h'.trans h.symm.subset‚ü©
#align list.perm.subset_congr_right List.Perm.subset_congr_right

theorem Perm.append_right {l‚ÇÅ l‚ÇÇ : List Œ±} (t‚ÇÅ : List Œ±) (p : l‚ÇÅ ~ l‚ÇÇ) : l‚ÇÅ ++ t‚ÇÅ ~ l‚ÇÇ ++ t‚ÇÅ :=
  p.rec
    (Perm.refl ([] ++ t‚ÇÅ))
    (fun x _ _ _ r‚ÇÅ => r‚ÇÅ.cons x)
    (fun x y _ => swap x y _)
    (fun _ _ r‚ÇÅ r‚ÇÇ => r‚ÇÅ.trans r‚ÇÇ)
#align list.perm.append_right List.Perm.append_right

theorem Perm.append_left {t‚ÇÅ t‚ÇÇ : List Œ±} : ‚àÄ l : List Œ±, t‚ÇÅ ~ t‚ÇÇ ‚Üí l ++ t‚ÇÅ ~ l ++ t‚ÇÇ
  | [], p => p
  | x :: xs, p => (p.append_left xs).cons x
#align list.perm.append_left List.Perm.append_left

theorem Perm.append {l‚ÇÅ l‚ÇÇ t‚ÇÅ t‚ÇÇ : List Œ±} (p‚ÇÅ : l‚ÇÅ ~ l‚ÇÇ) (p‚ÇÇ : t‚ÇÅ ~ t‚ÇÇ) : l‚ÇÅ ++ t‚ÇÅ ~ l‚ÇÇ ++ t‚ÇÇ :=
  (p‚ÇÅ.append_right t‚ÇÅ).trans (p‚ÇÇ.append_left l‚ÇÇ)
#align list.perm.append List.Perm.append

theorem Perm.append_cons (a : Œ±) {h‚ÇÅ h‚ÇÇ t‚ÇÅ t‚ÇÇ : List Œ±} (p‚ÇÅ : h‚ÇÅ ~ h‚ÇÇ) (p‚ÇÇ : t‚ÇÅ ~ t‚ÇÇ) :
    h‚ÇÅ ++ a :: t‚ÇÅ ~ h‚ÇÇ ++ a :: t‚ÇÇ :=
  p‚ÇÅ.append (p‚ÇÇ.cons a)
#align list.perm.append_cons List.Perm.append_cons

@[simp]
theorem perm_middle {a : Œ±} : ‚àÄ {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ ++ a :: l‚ÇÇ ~ a :: (l‚ÇÅ ++ l‚ÇÇ)
  | [], _ => Perm.refl _
  | b :: l‚ÇÅ, l‚ÇÇ => ((@perm_middle a l‚ÇÅ l‚ÇÇ).cons _).trans (swap a b _)
#align list.perm_middle List.perm_middle

@[simp]
theorem perm_append_singleton (a : Œ±) (l : List Œ±) : l ++ [a] ~ a :: l :=
  perm_middle.trans <| by rw [append_nil]
                          -- üéâ no goals
#align list.perm_append_singleton List.perm_append_singleton

theorem perm_append_comm : ‚àÄ {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ ++ l‚ÇÇ ~ l‚ÇÇ ++ l‚ÇÅ
  | [], l‚ÇÇ => by simp
                 -- üéâ no goals
  | a :: t, l‚ÇÇ => (perm_append_comm.cons _).trans perm_middle.symm
#align list.perm_append_comm List.perm_append_comm

theorem concat_perm (l : List Œ±) (a : Œ±) : concat l a ~ a :: l := by simp
                                                                     -- üéâ no goals
#align list.concat_perm List.concat_perm

theorem Perm.length_eq {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : length l‚ÇÅ = length l‚ÇÇ :=
  p.rec
    rfl
    (fun _x l‚ÇÅ l‚ÇÇ _p r => by simp [r])
                             -- üéâ no goals
    (fun _x _y l => by simp)
                       -- üéâ no goals
    (fun _p‚ÇÅ _p‚ÇÇ r‚ÇÅ r‚ÇÇ => Eq.trans r‚ÇÅ r‚ÇÇ)
#align list.perm.length_eq List.Perm.length_eq

theorem Perm.eq_nil {l : List Œ±} (p : l ~ []) : l = [] :=
  eq_nil_of_length_eq_zero p.length_eq
#align list.perm.eq_nil List.Perm.eq_nil

theorem Perm.nil_eq {l : List Œ±} (p : [] ~ l) : [] = l :=
  p.symm.eq_nil.symm
#align list.perm.nil_eq List.Perm.nil_eq

@[simp]
theorem perm_nil {l‚ÇÅ : List Œ±} : l‚ÇÅ ~ [] ‚Üî l‚ÇÅ = [] :=
  ‚ü®fun p => p.eq_nil, fun e => e ‚ñ∏ Perm.refl _‚ü©
#align list.perm_nil List.perm_nil

@[simp]
theorem nil_perm {l‚ÇÅ : List Œ±} : [] ~ l‚ÇÅ ‚Üî l‚ÇÅ = [] :=
  perm_comm.trans perm_nil
#align list.nil_perm List.nil_perm

theorem not_perm_nil_cons (x : Œ±) (l : List Œ±) : ¬¨[] ~ x :: l
  | p => by injection p.symm.eq_nil
            -- üéâ no goals
#align list.not_perm_nil_cons List.not_perm_nil_cons

@[simp]
theorem reverse_perm : ‚àÄ l : List Œ±, reverse l ~ l
  | [] => Perm.nil
  | a :: l => by
    rw [reverse_cons]
    -- ‚ä¢ reverse l ++ [a] ~ a :: l
    exact (perm_append_singleton _ _).trans ((reverse_perm l).cons a)
    -- üéâ no goals
#align list.reverse_perm List.reverse_perm

theorem perm_cons_append_cons {l l‚ÇÅ l‚ÇÇ : List Œ±} (a : Œ±) (p : l ~ l‚ÇÅ ++ l‚ÇÇ) :
    a :: l ~ l‚ÇÅ ++ a :: l‚ÇÇ :=
  (p.cons a).trans perm_middle.symm
#align list.perm_cons_append_cons List.perm_cons_append_cons

@[simp]
theorem perm_replicate {n : ‚Ñï} {a : Œ±} {l : List Œ±} :
    l ~ replicate n a ‚Üî l = replicate n a :=
  ‚ü®fun p => eq_replicate.2
    ‚ü®p.length_eq.trans <| length_replicate _ _, fun _b m => eq_of_mem_replicate <| p.subset m‚ü©,
    fun h => h ‚ñ∏ Perm.refl _‚ü©
#align list.perm_replicate List.perm_replicate

@[simp]
theorem replicate_perm {n : ‚Ñï} {a : Œ±} {l : List Œ±} :
    replicate n a ~ l ‚Üî replicate n a = l :=
  (perm_comm.trans perm_replicate).trans eq_comm
#align list.replicate_perm List.replicate_perm

@[simp]
theorem perm_singleton {a : Œ±} {l : List Œ±} : l ~ [a] ‚Üî l = [a] :=
  @perm_replicate Œ± 1 a l
#align list.perm_singleton List.perm_singleton

@[simp]
theorem singleton_perm {a : Œ±} {l : List Œ±} : [a] ~ l ‚Üî [a] = l :=
  @replicate_perm Œ± 1 a l
#align list.singleton_perm List.singleton_perm

alias ‚ü®Perm.eq_singleton, _‚ü© := perm_singleton
alias ‚ü®Perm.singleton_eq, _‚ü© := singleton_perm

theorem singleton_perm_singleton {a b : Œ±} : [a] ~ [b] ‚Üî a = b := by simp
                                                                     -- üéâ no goals
#align list.singleton_perm_singleton List.singleton_perm_singleton

theorem perm_cons_erase [DecidableEq Œ±] {a : Œ±} {l : List Œ±} (h : a ‚àà l) : l ~ a :: l.erase a :=
  let ‚ü®_l‚ÇÅ, _l‚ÇÇ, _, e‚ÇÅ, e‚ÇÇ‚ü© := exists_erase_eq h
  e‚ÇÇ.symm ‚ñ∏ e‚ÇÅ.symm ‚ñ∏ perm_middle
#align list.perm_cons_erase List.perm_cons_erase

@[elab_as_elim]
theorem perm_induction_on {P : List Œ± ‚Üí List Œ± ‚Üí Prop} {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) (h‚ÇÅ : P [] [])
    (h‚ÇÇ : ‚àÄ x l‚ÇÅ l‚ÇÇ, l‚ÇÅ ~ l‚ÇÇ ‚Üí P l‚ÇÅ l‚ÇÇ ‚Üí P (x :: l‚ÇÅ) (x :: l‚ÇÇ))
    (h‚ÇÉ : ‚àÄ x y l‚ÇÅ l‚ÇÇ, l‚ÇÅ ~ l‚ÇÇ ‚Üí P l‚ÇÅ l‚ÇÇ ‚Üí P (y :: x :: l‚ÇÅ) (x :: y :: l‚ÇÇ))
    (h‚ÇÑ : ‚àÄ l‚ÇÅ l‚ÇÇ l‚ÇÉ, l‚ÇÅ ~ l‚ÇÇ ‚Üí l‚ÇÇ ~ l‚ÇÉ ‚Üí P l‚ÇÅ l‚ÇÇ ‚Üí P l‚ÇÇ l‚ÇÉ ‚Üí P l‚ÇÅ l‚ÇÉ) : P l‚ÇÅ l‚ÇÇ :=
  have P_refl : ‚àÄ l, P l l := fun l => List.recOn l h‚ÇÅ fun x xs ih => h‚ÇÇ x xs xs (Perm.refl xs) ih
  p.rec h‚ÇÅ h‚ÇÇ (fun x y l => h‚ÇÉ x y l l (Perm.refl l) (P_refl l)) @h‚ÇÑ
#align list.perm_induction_on List.perm_induction_on‚Çì

-- Porting note: TODO figure out why invalid congr
-- @[congr]
theorem Perm.filterMap (f : Œ± ‚Üí Option Œ≤) {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) :
    filterMap f l‚ÇÅ ~ filterMap f l‚ÇÇ := by
  induction p with
  | nil => simp
  | cons x _p IH =>
    cases h : f x
      <;> simp [h, filterMap, IH, Perm.cons]
  | swap x y l‚ÇÇ =>
    cases hx : f x
      <;> cases hy : f y
        <;> simp [hx, hy, filterMap, swap]
  | trans _p‚ÇÅ _p‚ÇÇ IH‚ÇÅ IH‚ÇÇ =>
    exact IH‚ÇÅ.trans IH‚ÇÇ
#align list.perm.filter_map List.Perm.filterMap

-- Porting note: TODO figure out why invalid congr
-- @[congr]
theorem Perm.map (f : Œ± ‚Üí Œ≤) {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : map f l‚ÇÅ ~ map f l‚ÇÇ :=
  filterMap_eq_map f ‚ñ∏ p.filterMap _
#align list.perm.map List.Perm.map

theorem Perm.pmap {p : Œ± ‚Üí Prop} (f : ‚àÄ a, p a ‚Üí Œ≤) {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) {H‚ÇÅ H‚ÇÇ} :
    pmap f l‚ÇÅ H‚ÇÅ ~ pmap f l‚ÇÇ H‚ÇÇ := by
  induction p with
  | nil => simp
  | cons x _p IH => simp [IH, Perm.cons]
  | swap x y => simp [swap]
  | trans _p‚ÇÅ p‚ÇÇ IH‚ÇÅ IH‚ÇÇ =>
    refine' IH‚ÇÅ.trans IH‚ÇÇ
    exact fun a m => H‚ÇÇ a (p‚ÇÇ.subset m)
#align list.perm.pmap List.Perm.pmap

theorem Perm.filter (p : Œ± ‚Üí Bool) {l‚ÇÅ l‚ÇÇ : List Œ±} (s : l‚ÇÅ ~ l‚ÇÇ) :
    filter p l‚ÇÅ ~ filter p l‚ÇÇ := by rw [‚Üê filterMap_eq_filter]; apply s.filterMap _
                                    -- ‚ä¢ List.filterMap (Option.guard fun x => p x = true) l‚ÇÅ ~ List.filterMap (Optio ‚Ä¶
                                                                -- üéâ no goals
#align list.perm.filter List.Perm.filter

theorem filter_append_perm (p : Œ± ‚Üí Bool) (l : List Œ±) :
    filter p l ++ filter (fun x => ¬¨p x) l ~ l := by
  induction' l with x l ih
  -- ‚ä¢ filter p [] ++ filter (fun x => decide ¬¨p x = true) [] ~ []
  ¬∑ rfl
    -- üéâ no goals
  ¬∑ by_cases h : p x
    -- ‚ä¢ filter p (x :: l) ++ filter (fun x => decide ¬¨p x = true) (x :: l) ~ x :: l
    ¬∑ simp only [h, filter_cons_of_pos, filter_cons_of_neg, not_true, not_false_iff, cons_append]
      -- ‚ä¢ x :: (filter p l ++ filter (fun x => decide ¬¨p x = true) l) ~ x :: l
      exact ih.cons x
      -- üéâ no goals
    ¬∑ simp only [h, filter_cons_of_neg, not_false_iff, filter_cons_of_pos]
      -- ‚ä¢ filter p l ++ x :: filter (fun x => decide ¬¨p x = true) l ~ x :: l
      refine' Perm.trans _ (ih.cons x)
      -- ‚ä¢ filter p l ++ x :: filter (fun x => decide ¬¨p x = true) l ~ x :: (filter p l ‚Ä¶
      exact perm_append_comm.trans (perm_append_comm.cons _)
      -- üéâ no goals
#align list.filter_append_perm List.filter_append_perm

theorem exists_perm_sublist {l‚ÇÅ l‚ÇÇ l‚ÇÇ' : List Œ±} (s : l‚ÇÅ <+ l‚ÇÇ) (p : l‚ÇÇ ~ l‚ÇÇ') :
    ‚àÉ (l‚ÇÅ' : _) (_ : l‚ÇÅ' ~ l‚ÇÅ), l‚ÇÅ' <+ l‚ÇÇ' := by
  induction p generalizing l‚ÇÅ with
  | nil =>
    exact ‚ü®[], eq_nil_of_sublist_nil s ‚ñ∏ Perm.refl _, nil_sublist _‚ü©
  | cons x _ IH =>
    cases' s with _ _ _ s l‚ÇÅ _ _ s
    ¬∑ exact
        let ‚ü®l‚ÇÅ', p', s'‚ü© := IH s
        ‚ü®l‚ÇÅ', p', s'.cons _‚ü©
    ¬∑ exact
        let ‚ü®l‚ÇÅ', p', s'‚ü© := IH s
        ‚ü®x :: l‚ÇÅ', p'.cons x, s'.cons‚ÇÇ _‚ü©
  | swap x y _ =>
    cases' s with _ _ _ s l‚ÇÅ _ _ s <;> cases' s with _ _ _ s l‚ÇÅ _ _ s
    ¬∑ exact ‚ü®l‚ÇÅ, Perm.refl _, (s.cons _).cons _‚ü©
    ¬∑ exact ‚ü®x :: l‚ÇÅ, Perm.refl _, (s.cons _).cons‚ÇÇ _‚ü©
    ¬∑ exact ‚ü®y :: l‚ÇÅ, Perm.refl _, (s.cons‚ÇÇ _).cons _‚ü©
    ¬∑ exact ‚ü®x :: y :: l‚ÇÅ, Perm.swap _ _ _, (s.cons‚ÇÇ _).cons‚ÇÇ _‚ü©
  | trans _ _ IH‚ÇÅ IH‚ÇÇ =>
    exact
      let ‚ü®m‚ÇÅ, pm, sm‚ü© := IH‚ÇÅ s
      let ‚ü®r‚ÇÅ, pr, sr‚ü© := IH‚ÇÇ sm
      ‚ü®r‚ÇÅ, pr.trans pm, sr‚ü©
#align list.exists_perm_sublist List.exists_perm_sublist

theorem Perm.sizeOf_eq_sizeOf [SizeOf Œ±] {l‚ÇÅ l‚ÇÇ : List Œ±} (h : l‚ÇÅ ~ l‚ÇÇ) :
    sizeOf l‚ÇÅ = sizeOf l‚ÇÇ := by
  induction h with -- hd l‚ÇÅ l‚ÇÇ h‚ÇÅ‚ÇÇ h_sz‚ÇÅ‚ÇÇ a b l l‚ÇÅ l‚ÇÇ l‚ÇÉ h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ h_sz‚ÇÅ‚ÇÇ h_sz‚ÇÇ‚ÇÉ
  | nil => rfl
  | cons _ _ h_sz‚ÇÅ‚ÇÇ => simp [h_sz‚ÇÅ‚ÇÇ]
  | swap => simp [add_left_comm]
  | trans _ _ h_sz‚ÇÅ‚ÇÇ h_sz‚ÇÇ‚ÇÉ => simp [h_sz‚ÇÅ‚ÇÇ, h_sz‚ÇÇ‚ÇÉ]
#align list.perm.sizeof_eq_sizeof List.Perm.sizeOf_eq_sizeOf

section Rel

open Relator

variable {Œ≥ : Type*} {Œ¥ : Type*} {r : Œ± ‚Üí Œ≤ ‚Üí Prop} {p : Œ≥ ‚Üí Œ¥ ‚Üí Prop}

-- mathport name: ¬´expr ‚àòr ¬ª
local infixr:80 " ‚àòr " => Relation.Comp

theorem perm_comp_perm : (Perm ‚àòr Perm : List Œ± ‚Üí List Œ± ‚Üí Prop) = Perm := by
  funext a c; apply propext
  -- ‚ä¢ (Perm ‚àòr Perm) a c = (a ~ c)
              -- ‚ä¢ (Perm ‚àòr Perm) a c ‚Üî a ~ c
  constructor
  -- ‚ä¢ (Perm ‚àòr Perm) a c ‚Üí a ~ c
  ¬∑ exact fun ‚ü®b, hab, hba‚ü© => Perm.trans hab hba
    -- üéâ no goals
  ¬∑ exact fun h => ‚ü®a, Perm.refl a, h‚ü©
    -- üéâ no goals
#align list.perm_comp_perm List.perm_comp_perm

theorem perm_comp_forall‚ÇÇ {l u v} (hlu : Perm l u) (huv : Forall‚ÇÇ r u v) :
    (Forall‚ÇÇ r ‚àòr Perm) l v := by
  induction hlu generalizing v
  case nil => cases huv; exact ‚ü®[], Forall‚ÇÇ.nil, Perm.nil‚ü©
  -- üéâ no goals
  case cons a l u _hlu ih =>
    cases' huv with _ b _ v hab huv'
    rcases ih huv' with ‚ü®l‚ÇÇ, h‚ÇÅ‚ÇÇ, h‚ÇÇ‚ÇÉ‚ü©
    exact ‚ü®b :: l‚ÇÇ, Forall‚ÇÇ.cons hab h‚ÇÅ‚ÇÇ, h‚ÇÇ‚ÇÉ.cons _‚ü©
  case swap a‚ÇÅ a‚ÇÇ h‚ÇÇ‚ÇÉ =>
    cases' huv with _ b‚ÇÅ _ l‚ÇÇ h‚ÇÅ hr‚ÇÇ‚ÇÉ
    cases' hr‚ÇÇ‚ÇÉ with _ b‚ÇÇ _ l‚ÇÇ h‚ÇÇ h‚ÇÅ‚ÇÇ
    exact ‚ü®b‚ÇÇ :: b‚ÇÅ :: l‚ÇÇ, Forall‚ÇÇ.cons h‚ÇÇ (Forall‚ÇÇ.cons h‚ÇÅ h‚ÇÅ‚ÇÇ), Perm.swap _ _ _‚ü©
  case
    trans la‚ÇÅ la‚ÇÇ la‚ÇÉ _ _ ih‚ÇÅ ih‚ÇÇ =>
    rcases ih‚ÇÇ huv with ‚ü®lb‚ÇÇ, hab‚ÇÇ, h‚ÇÇ‚ÇÉ‚ü©
    rcases ih‚ÇÅ hab‚ÇÇ with ‚ü®lb‚ÇÅ, hab‚ÇÅ, h‚ÇÅ‚ÇÇ‚ü©
    exact ‚ü®lb‚ÇÅ, hab‚ÇÅ, Perm.trans h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ‚ü©
#align list.perm_comp_forall‚ÇÇ List.perm_comp_forall‚ÇÇ

theorem forall‚ÇÇ_comp_perm_eq_perm_comp_forall‚ÇÇ : Forall‚ÇÇ r ‚àòr Perm = Perm ‚àòr Forall‚ÇÇ r := by
  funext l‚ÇÅ l‚ÇÉ; apply propext
  -- ‚ä¢ (Forall‚ÇÇ r ‚àòr Perm) l‚ÇÅ l‚ÇÉ = (Perm ‚àòr Forall‚ÇÇ r) l‚ÇÅ l‚ÇÉ
                -- ‚ä¢ (Forall‚ÇÇ r ‚àòr Perm) l‚ÇÅ l‚ÇÉ ‚Üî (Perm ‚àòr Forall‚ÇÇ r) l‚ÇÅ l‚ÇÉ
  constructor
  -- ‚ä¢ (Forall‚ÇÇ r ‚àòr Perm) l‚ÇÅ l‚ÇÉ ‚Üí (Perm ‚àòr Forall‚ÇÇ r) l‚ÇÅ l‚ÇÉ
  ¬∑ intro h
    -- ‚ä¢ (Perm ‚àòr Forall‚ÇÇ r) l‚ÇÅ l‚ÇÉ
    rcases h with ‚ü®l‚ÇÇ, h‚ÇÅ‚ÇÇ, h‚ÇÇ‚ÇÉ‚ü©
    -- ‚ä¢ (Perm ‚àòr Forall‚ÇÇ r) l‚ÇÅ l‚ÇÉ
    have : Forall‚ÇÇ (flip r) l‚ÇÇ l‚ÇÅ := h‚ÇÅ‚ÇÇ.flip
    -- ‚ä¢ (Perm ‚àòr Forall‚ÇÇ r) l‚ÇÅ l‚ÇÉ
    rcases perm_comp_forall‚ÇÇ h‚ÇÇ‚ÇÉ.symm this with ‚ü®l', h‚ÇÅ, h‚ÇÇ‚ü©
    -- ‚ä¢ (Perm ‚àòr Forall‚ÇÇ r) l‚ÇÅ l‚ÇÉ
    exact ‚ü®l', h‚ÇÇ.symm, h‚ÇÅ.flip‚ü©
    -- üéâ no goals
  ¬∑ exact fun ‚ü®l‚ÇÇ, h‚ÇÅ‚ÇÇ, h‚ÇÇ‚ÇÉ‚ü© => perm_comp_forall‚ÇÇ h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ
    -- üéâ no goals
#align list.forall‚ÇÇ_comp_perm_eq_perm_comp_forall‚ÇÇ List.forall‚ÇÇ_comp_perm_eq_perm_comp_forall‚ÇÇ

theorem rel_perm_imp (hr : RightUnique r) : (Forall‚ÇÇ r ‚áí Forall‚ÇÇ r ‚áí (¬∑ ‚Üí ¬∑)) Perm Perm :=
  fun a b h‚ÇÅ c d h‚ÇÇ h =>
  have : (flip (Forall‚ÇÇ r) ‚àòr Perm ‚àòr Forall‚ÇÇ r) b d := ‚ü®a, h‚ÇÅ, c, h, h‚ÇÇ‚ü©
  have : ((flip (Forall‚ÇÇ r) ‚àòr Forall‚ÇÇ r) ‚àòr Perm) b d := by
    rwa [‚Üê forall‚ÇÇ_comp_perm_eq_perm_comp_forall‚ÇÇ, ‚Üê Relation.comp_assoc] at this
    -- üéâ no goals
  let ‚ü®b', ‚ü®c', hbc, hcb‚ü©, hbd‚ü© := this
  have : b' = b := right_unique_forall‚ÇÇ' hr hcb hbc
  this ‚ñ∏ hbd
#align list.rel_perm_imp List.rel_perm_imp

theorem rel_perm (hr : BiUnique r) : (Forall‚ÇÇ r ‚áí Forall‚ÇÇ r ‚áí (¬∑ ‚Üî ¬∑)) Perm Perm :=
  fun _a _b hab _c _d hcd =>
  Iff.intro (rel_perm_imp hr.2 hab hcd) (rel_perm_imp hr.left.flip hab.flip hcd.flip)
#align list.rel_perm List.rel_perm

end Rel

section Subperm


/-- `Subperm l‚ÇÅ l‚ÇÇ`, denoted `l‚ÇÅ <+~ l‚ÇÇ`, means that `l‚ÇÅ` is a sublist of
  a permutation of `l‚ÇÇ`. This is an analogue of `l‚ÇÅ ‚äÜ l‚ÇÇ` which respects
  multiplicities of elements, and is used for the `‚â§` relation on multisets. -/
def Subperm (l‚ÇÅ l‚ÇÇ : List Œ±) : Prop :=
  ‚àÉ (l : _) (_ : l ~ l‚ÇÅ), l <+ l‚ÇÇ
#align list.subperm List.Subperm

/-- `Subperm l‚ÇÅ l‚ÇÇ`, denoted `l‚ÇÅ <+~ l‚ÇÇ`, means that `l‚ÇÅ` is a sublist of
  a permutation of `l‚ÇÇ`. This is an analogue of `l‚ÇÅ ‚äÜ l‚ÇÇ` which respects
  multiplicities of elements, and is used for the `‚â§` relation on multisets. -/
infixl:50 " <+~ " => Subperm

theorem nil_subperm {l : List Œ±} : [] <+~ l :=
  ‚ü®[], Perm.nil, by simp‚ü©
                    -- üéâ no goals
#align list.nil_subperm List.nil_subperm

theorem Perm.subperm_left {l l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : l <+~ l‚ÇÅ ‚Üî l <+~ l‚ÇÇ :=
  suffices ‚àÄ {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ ~ l‚ÇÇ ‚Üí l <+~ l‚ÇÅ ‚Üí l <+~ l‚ÇÇ from ‚ü®this p, this p.symm‚ü©
  fun p ‚ü®_u, pu, su‚ü© =>
  let ‚ü®v, pv, sv‚ü© := exists_perm_sublist su p
  ‚ü®v, pv.trans pu, sv‚ü©
#align list.perm.subperm_left List.Perm.subperm_left

theorem Perm.subperm_right {l‚ÇÅ l‚ÇÇ l : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : l‚ÇÅ <+~ l ‚Üî l‚ÇÇ <+~ l :=
  ‚ü®fun ‚ü®u, pu, su‚ü© => ‚ü®u, pu.trans p, su‚ü©, fun ‚ü®u, pu, su‚ü© => ‚ü®u, pu.trans p.symm, su‚ü©‚ü©
#align list.perm.subperm_right List.Perm.subperm_right

theorem Sublist.subperm {l‚ÇÅ l‚ÇÇ : List Œ±} (s : l‚ÇÅ <+ l‚ÇÇ) : l‚ÇÅ <+~ l‚ÇÇ :=
  ‚ü®l‚ÇÅ, Perm.refl _, s‚ü©
#align list.sublist.subperm List.Sublist.subperm

theorem Perm.subperm {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : l‚ÇÅ <+~ l‚ÇÇ :=
  ‚ü®l‚ÇÇ, p.symm, Sublist.refl _‚ü©
#align list.perm.subperm List.Perm.subperm

@[refl]
theorem Subperm.refl (l : List Œ±) : l <+~ l :=
  (Perm.refl _).subperm
#align list.subperm.refl List.Subperm.refl

@[trans]
theorem Subperm.trans {l‚ÇÅ l‚ÇÇ l‚ÇÉ : List Œ±} : l‚ÇÅ <+~ l‚ÇÇ ‚Üí l‚ÇÇ <+~ l‚ÇÉ ‚Üí l‚ÇÅ <+~ l‚ÇÉ
  | s, ‚ü®_l‚ÇÇ', p‚ÇÇ, s‚ÇÇ‚ü© =>
    let ‚ü®l‚ÇÅ', p‚ÇÅ, s‚ÇÅ‚ü© := p‚ÇÇ.subperm_left.2 s
    ‚ü®l‚ÇÅ', p‚ÇÅ, s‚ÇÅ.trans s‚ÇÇ‚ü©
#align list.subperm.trans List.Subperm.trans

theorem Subperm.length_le {l‚ÇÅ l‚ÇÇ : List Œ±} : l‚ÇÅ <+~ l‚ÇÇ ‚Üí length l‚ÇÅ ‚â§ length l‚ÇÇ
  | ‚ü®_l, p, s‚ü© => p.length_eq ‚ñ∏ s.length_le
#align list.subperm.length_le List.Subperm.length_le

theorem Subperm.perm_of_length_le {l‚ÇÅ l‚ÇÇ : List Œ±} : l‚ÇÅ <+~ l‚ÇÇ ‚Üí length l‚ÇÇ ‚â§ length l‚ÇÅ ‚Üí l‚ÇÅ ~ l‚ÇÇ
  | ‚ü®_l, p, s‚ü©, h => (s.eq_of_length_le <| p.symm.length_eq ‚ñ∏ h) ‚ñ∏ p.symm
#align list.subperm.perm_of_length_le List.Subperm.perm_of_length_le

theorem Subperm.antisymm {l‚ÇÅ l‚ÇÇ : List Œ±} (h‚ÇÅ : l‚ÇÅ <+~ l‚ÇÇ) (h‚ÇÇ : l‚ÇÇ <+~ l‚ÇÅ) : l‚ÇÅ ~ l‚ÇÇ :=
  h‚ÇÅ.perm_of_length_le h‚ÇÇ.length_le
#align list.subperm.antisymm List.Subperm.antisymm

theorem Subperm.subset {l‚ÇÅ l‚ÇÇ : List Œ±} : l‚ÇÅ <+~ l‚ÇÇ ‚Üí l‚ÇÅ ‚äÜ l‚ÇÇ
  | ‚ü®_l, p, s‚ü© => Subset.trans p.symm.subset s.subset
#align list.subperm.subset List.Subperm.subset

theorem Subperm.filter (p : Œ± ‚Üí Bool) ‚¶Él l' : List Œ±‚¶Ñ (h : l <+~ l') :
    filter p l <+~ filter p l' := by
  obtain ‚ü®xs, hp, h‚ü© := h
  -- ‚ä¢ List.filter p l <+~ List.filter p l'
  exact ‚ü®_, hp.filter p, h.filter p‚ü©
  -- üéâ no goals
#align list.subperm.filter List.Subperm.filter

end Subperm

theorem Sublist.exists_perm_append : ‚àÄ {l‚ÇÅ l‚ÇÇ : List Œ±}, l‚ÇÅ <+ l‚ÇÇ ‚Üí ‚àÉ l, l‚ÇÇ ~ l‚ÇÅ ++ l
  | _, _, Sublist.slnil => ‚ü®nil, Perm.refl _‚ü©
  | _, _, Sublist.cons a s =>
    let ‚ü®l, p‚ü© := Sublist.exists_perm_append s
    ‚ü®a :: l, (p.cons a).trans perm_middle.symm‚ü©
  | _, _, Sublist.cons‚ÇÇ a s =>
    let ‚ü®l, p‚ü© := Sublist.exists_perm_append s
    ‚ü®l, p.cons a‚ü©
#align list.sublist.exists_perm_append List.Sublist.exists_perm_append

theorem Perm.countP_eq (p : Œ± ‚Üí Bool) {l‚ÇÅ l‚ÇÇ : List Œ±} (s : l‚ÇÅ ~ l‚ÇÇ) :
    countP p l‚ÇÅ = countP p l‚ÇÇ := by
  rw [countP_eq_length_filter, countP_eq_length_filter]; exact (s.filter _).length_eq
  -- ‚ä¢ length (List.filter p l‚ÇÅ) = length (List.filter p l‚ÇÇ)
                                                         -- üéâ no goals
#align list.perm.countp_eq List.Perm.countP_eq

theorem Subperm.countP_le (p : Œ± ‚Üí Bool) {l‚ÇÅ l‚ÇÇ : List Œ±} :
    l‚ÇÅ <+~ l‚ÇÇ ‚Üí countP p l‚ÇÅ ‚â§ countP p l‚ÇÇ
  | ‚ü®_l, p', s‚ü© => p'.countP_eq p ‚ñ∏ s.countP_le p
#align list.subperm.countp_le List.Subperm.countP_le

theorem Perm.countP_congr (s : l‚ÇÅ ~ l‚ÇÇ) {p p' : Œ± ‚Üí Bool}
    (hp : ‚àÄ x ‚àà l‚ÇÅ, p x = p' x) : l‚ÇÅ.countP p = l‚ÇÇ.countP p' := by
  rw [‚Üê s.countP_eq p']
  -- ‚ä¢ countP p l‚ÇÅ = countP p' l‚ÇÅ
  clear s
  -- ‚ä¢ countP p l‚ÇÅ = countP p' l‚ÇÅ
  induction' l‚ÇÅ with y s hs
  -- ‚ä¢ countP p [] = countP p' []
  ¬∑ rfl
    -- üéâ no goals
  ¬∑ simp only [mem_cons, forall_eq_or_imp] at hp
    -- ‚ä¢ countP p (y :: s) = countP p' (y :: s)
    simp only [countP_cons, hs hp.2, hp.1]
    -- üéâ no goals
#align list.perm.countp_congr List.Perm.countP_congr

theorem countP_eq_countP_filter_add (l : List Œ±) (p q : Œ± ‚Üí Bool) :
    l.countP p = (l.filter q).countP p + (l.filter fun a => ¬¨q a).countP p := by
  rw [‚Üê countP_append]
  -- ‚ä¢ countP p l = countP p (filter q l ++ filter (fun a => decide ¬¨q a = true) l)
  exact Perm.countP_eq _ (filter_append_perm _ _).symm
  -- üéâ no goals
#align list.countp_eq_countp_filter_add List.countP_eq_countP_filter_add

theorem Perm.count_eq [DecidableEq Œ±] {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) (a) :
    count a l‚ÇÅ = count a l‚ÇÇ :=
  p.countP_eq _
#align list.perm.count_eq List.Perm.count_eq

theorem Subperm.count_le [DecidableEq Œ±] {l‚ÇÅ l‚ÇÇ : List Œ±} (s : l‚ÇÅ <+~ l‚ÇÇ) (a) :
    count a l‚ÇÅ ‚â§ count a l‚ÇÇ :=
  s.countP_le _
#align list.subperm.count_le List.Subperm.count_le

theorem Perm.foldl_eq' {f : Œ≤ ‚Üí Œ± ‚Üí Œ≤} {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) :
    (‚àÄ x ‚àà l‚ÇÅ, ‚àÄ y ‚àà l‚ÇÅ, ‚àÄ (z), f (f z x) y = f (f z y) x) ‚Üí ‚àÄ b, foldl f b l‚ÇÅ = foldl f b l‚ÇÇ :=
  perm_induction_on p (fun _H b => rfl)
    (fun x t‚ÇÅ t‚ÇÇ _p r H b => r (fun x hx y hy => H _ (.tail _ hx) _ (.tail _ hy)) _)
    (fun x y t‚ÇÅ t‚ÇÇ _p r H b => by
      simp only [foldl]
      -- ‚ä¢ foldl f (f (f b y) x) t‚ÇÅ = foldl f (f (f b x) y) t‚ÇÇ
      rw [H x (.tail _ <| .head _) y (.head _)]
      -- ‚ä¢ foldl f (f (f b y) x) t‚ÇÅ = foldl f (f (f b y) x) t‚ÇÇ
      exact r (fun x hx y hy => H _ (.tail _ <| .tail _ hx) _ (.tail _ <| .tail _ hy)) _)
      -- üéâ no goals
    fun t‚ÇÅ t‚ÇÇ t‚ÇÉ p‚ÇÅ _p‚ÇÇ r‚ÇÅ r‚ÇÇ H b =>
    Eq.trans (r‚ÇÅ H b) (r‚ÇÇ (fun x hx y hy => H _ (p‚ÇÅ.symm.subset hx) _ (p‚ÇÅ.symm.subset hy)) b)
#align list.perm.foldl_eq' List.Perm.foldl_eq'

theorem Perm.foldl_eq {f : Œ≤ ‚Üí Œ± ‚Üí Œ≤} {l‚ÇÅ l‚ÇÇ : List Œ±} (rcomm : RightCommutative f) (p : l‚ÇÅ ~ l‚ÇÇ) :
    ‚àÄ b, foldl f b l‚ÇÅ = foldl f b l‚ÇÇ :=
  p.foldl_eq' fun x _hx y _hy z => rcomm z x y
#align list.perm.foldl_eq List.Perm.foldl_eq

theorem Perm.foldr_eq {f : Œ± ‚Üí Œ≤ ‚Üí Œ≤} {l‚ÇÅ l‚ÇÇ : List Œ±} (lcomm : LeftCommutative f) (p : l‚ÇÅ ~ l‚ÇÇ) :
    ‚àÄ b, foldr f b l‚ÇÅ = foldr f b l‚ÇÇ :=
  perm_induction_on p (fun b => rfl) (fun x t‚ÇÅ t‚ÇÇ _p r b => by simp; rw [r b])
                                                               -- ‚ä¢ f x (foldr f b t‚ÇÅ) = f x (foldr f b t‚ÇÇ)
                                                                     -- üéâ no goals
    (fun x y t‚ÇÅ t‚ÇÇ _p r b => by simp; rw [lcomm, r b]) fun t‚ÇÅ t‚ÇÇ t‚ÇÉ _p‚ÇÅ _p‚ÇÇ r‚ÇÅ r‚ÇÇ a =>
                                -- ‚ä¢ f y (f x (foldr f b t‚ÇÅ)) = f x (f y (foldr f b t‚ÇÇ))
                                      -- üéâ no goals
    Eq.trans (r‚ÇÅ a) (r‚ÇÇ a)
#align list.perm.foldr_eq List.Perm.foldr_eq

theorem Perm.rec_heq {Œ≤ : List Œ± ‚Üí Sort*} {f : ‚àÄ a l, Œ≤ l ‚Üí Œ≤ (a :: l)} {b : Œ≤ []} {l l' : List Œ±}
    (hl : Perm l l') (f_congr : ‚àÄ {a l l' b b'}, Perm l l' ‚Üí HEq b b' ‚Üí HEq (f a l b) (f a l' b'))
    (f_swap : ‚àÄ {a a' l b}, HEq (f a (a' :: l) (f a' l b)) (f a' (a :: l) (f a l b))) :
    HEq (@List.rec Œ± Œ≤ b f l) (@List.rec Œ± Œ≤ b f l') := by
  induction hl
  case nil => rfl
  -- üéâ no goals
  case cons a l l' h ih => exact f_congr h ih
  -- ‚ä¢ HEq (List.rec b f (y‚úù :: x‚úù :: l‚úù)) (List.rec b f (x‚úù :: y‚úù :: l‚úù))
  -- üéâ no goals
  case swap a a' l => exact f_swap
  -- ‚ä¢ HEq (List.rec b f l‚ÇÅ‚úù) (List.rec b f l‚ÇÉ‚úù)
  -- üéâ no goals
  case trans l‚ÇÅ l‚ÇÇ l‚ÇÉ _h‚ÇÅ _h‚ÇÇ ih‚ÇÅ ih‚ÇÇ => exact HEq.trans ih‚ÇÅ ih‚ÇÇ
  -- üéâ no goals
  -- üéâ no goals
#align list.perm.rec_heq List.Perm.rec_heq

section

variable {op : Œ± ‚Üí Œ± ‚Üí Œ±} [IA : IsAssociative Œ± op] [IC : IsCommutative Œ± op]

-- mathport name: op
local notation a " * " b => op a b

-- mathport name: foldl
local notation l " <*> " a => foldl op a l

theorem Perm.fold_op_eq {l‚ÇÅ l‚ÇÇ : List Œ±} {a : Œ±} (h : l‚ÇÅ ~ l‚ÇÇ) : (l‚ÇÅ <*> a) = l‚ÇÇ <*> a :=
  h.foldl_eq (right_comm _ IC.comm IA.assoc) _
#align list.perm.fold_op_eq List.Perm.fold_op_eq

end

section CommMonoid

/-- If elements of a list commute with each other, then their product does not
depend on the order of elements. -/
@[to_additive
      "If elements of a list additively commute with each other, then their sum does not
      depend on the order of elements."]
theorem Perm.prod_eq' [M : Monoid Œ±] {l‚ÇÅ l‚ÇÇ : List Œ±} (h : l‚ÇÅ ~ l‚ÇÇ) (hc : l‚ÇÅ.Pairwise Commute) :
    l‚ÇÅ.prod = l‚ÇÇ.prod := by
  refine h.foldl_eq' ?_ _
  -- ‚ä¢ ‚àÄ (x : Œ±), x ‚àà l‚ÇÅ ‚Üí ‚àÄ (y : Œ±), y ‚àà l‚ÇÅ ‚Üí ‚àÄ (z : Œ±), z * x * y = z * y * x
  apply Pairwise.forall_of_forall
  ¬∑ intro x y h z
    -- ‚ä¢ z * y * x = z * x * y
    exact (h z).symm
    -- üéâ no goals
  ¬∑ intros; rfl
    -- ‚ä¢ z‚úù * x‚úù * x‚úù = z‚úù * x‚úù * x‚úù
            -- üéâ no goals
  ¬∑ apply hc.imp
    -- ‚ä¢ ‚àÄ {a b : Œ±}, Commute a b ‚Üí ‚àÄ (z : Œ±), z * a * b = z * b * a
    intro a b h z
    -- ‚ä¢ z * a * b = z * b * a
    rw [mul_assoc z, mul_assoc z, h]
    -- üéâ no goals
#align list.perm.prod_eq' List.Perm.prod_eq'
#align list.perm.sum_eq' List.Perm.sum_eq'

variable [CommMonoid Œ±]

@[to_additive]
theorem Perm.prod_eq {l‚ÇÅ l‚ÇÇ : List Œ±} (h : Perm l‚ÇÅ l‚ÇÇ) : prod l‚ÇÅ = prod l‚ÇÇ :=
  h.fold_op_eq
#align list.perm.prod_eq List.Perm.prod_eq
#align list.perm.sum_eq List.Perm.sum_eq

@[to_additive]
theorem prod_reverse (l : List Œ±) : prod l.reverse = prod l :=
  (reverse_perm l).prod_eq
#align list.prod_reverse List.prod_reverse
#align list.sum_reverse List.sum_reverse

end CommMonoid

theorem perm_inv_core {a : Œ±} {l‚ÇÅ l‚ÇÇ r‚ÇÅ r‚ÇÇ : List Œ±} :
    l‚ÇÅ ++ a :: r‚ÇÅ ~ l‚ÇÇ ++ a :: r‚ÇÇ ‚Üí l‚ÇÅ ++ r‚ÇÅ ~ l‚ÇÇ ++ r‚ÇÇ := by
  generalize e‚ÇÅ : l‚ÇÅ ++ a :: r‚ÇÅ = s‚ÇÅ; generalize e‚ÇÇ : l‚ÇÇ ++ a :: r‚ÇÇ = s‚ÇÇ
  -- ‚ä¢ s‚ÇÅ ~ l‚ÇÇ ++ a :: r‚ÇÇ ‚Üí l‚ÇÅ ++ r‚ÇÅ ~ l‚ÇÇ ++ r‚ÇÇ
                                      -- ‚ä¢ s‚ÇÅ ~ s‚ÇÇ ‚Üí l‚ÇÅ ++ r‚ÇÅ ~ l‚ÇÇ ++ r‚ÇÇ
  intro p; revert l‚ÇÅ l‚ÇÇ r‚ÇÅ r‚ÇÇ e‚ÇÅ e‚ÇÇ; clear l‚ÇÅ l‚ÇÇ Œ≤
  -- ‚ä¢ l‚ÇÅ ++ r‚ÇÅ ~ l‚ÇÇ ++ r‚ÇÇ
           -- ‚ä¢ ‚àÄ {l‚ÇÅ l‚ÇÇ r‚ÇÅ r‚ÇÇ : List Œ±}, l‚ÇÅ ++ a :: r‚ÇÅ = s‚ÇÅ ‚Üí l‚ÇÇ ++ a :: r‚ÇÇ = s‚ÇÇ ‚Üí l‚ÇÅ ++ r‚ÇÅ ‚Ä¶
                                     -- ‚ä¢ ‚àÄ {l‚ÇÅ l‚ÇÇ r‚ÇÅ r‚ÇÇ : List Œ±}, l‚ÇÅ ++ a :: r‚ÇÅ = s‚ÇÅ ‚Üí l‚ÇÇ ++ a :: r‚ÇÇ = s‚ÇÇ ‚Üí l‚ÇÅ ++ r‚ÇÅ ‚Ä¶
  show ‚àÄ _ _ _ _, _
  -- ‚ä¢ ‚àÄ (x x_1 x_2 x_3 : List Œ±), x ++ a :: x_2 = s‚ÇÅ ‚Üí x_1 ++ a :: x_3 = s‚ÇÇ ‚Üí x ++ ‚Ä¶
  refine
      perm_induction_on p ?_ (fun x t‚ÇÅ t‚ÇÇ p IH => ?_) (fun x y t‚ÇÅ t‚ÇÇ p IH => ?_)
        fun t‚ÇÅ t‚ÇÇ t‚ÇÉ p‚ÇÅ p‚ÇÇ IH‚ÇÅ IH‚ÇÇ => ?_
    <;> intro l‚ÇÅ l‚ÇÇ r‚ÇÅ r‚ÇÇ e‚ÇÅ e‚ÇÇ
        -- ‚ä¢ l‚ÇÅ ++ r‚ÇÅ ~ l‚ÇÇ ++ r‚ÇÇ
        -- ‚ä¢ l‚ÇÅ ++ r‚ÇÅ ~ l‚ÇÇ ++ r‚ÇÇ
        -- ‚ä¢ l‚ÇÅ ++ r‚ÇÅ ~ l‚ÇÇ ++ r‚ÇÇ
        -- ‚ä¢ l‚ÇÅ ++ r‚ÇÅ ~ l‚ÇÇ ++ r‚ÇÇ
  ¬∑ apply (not_mem_nil a).elim
    -- ‚ä¢ a ‚àà []
    rw [‚Üê e‚ÇÅ]
    -- ‚ä¢ a ‚àà l‚ÇÅ ++ a :: r‚ÇÅ
    simp
    -- üéâ no goals
  ¬∑ cases' l‚ÇÅ with y l‚ÇÅ <;> cases' l‚ÇÇ with z l‚ÇÇ <;> dsimp at e‚ÇÅ e‚ÇÇ <;> injections <;> subst x
    -- ‚ä¢ [] ++ r‚ÇÅ ~ l‚ÇÇ ++ r‚ÇÇ
                            -- ‚ä¢ [] ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
                            -- ‚ä¢ y :: l‚ÇÅ ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
                                                    -- ‚ä¢ [] ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
                                                    -- ‚ä¢ [] ++ r‚ÇÅ ~ z :: l‚ÇÇ ++ r‚ÇÇ
                                                    -- ‚ä¢ y :: l‚ÇÅ ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
                                                    -- ‚ä¢ y :: l‚ÇÅ ++ r‚ÇÅ ~ z :: l‚ÇÇ ++ r‚ÇÇ
                                                                       -- ‚ä¢ [] ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
                                                                       -- ‚ä¢ [] ++ r‚ÇÅ ~ z :: l‚ÇÇ ++ r‚ÇÇ
                                                                       -- ‚ä¢ y :: l‚ÇÅ ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
                                                                       -- ‚ä¢ y :: l‚ÇÅ ++ r‚ÇÅ ~ z :: l‚ÇÇ ++ r‚ÇÇ
                                                                                      -- ‚ä¢ [] ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
                                                                                      -- ‚ä¢ [] ++ r‚ÇÅ ~ z :: l‚ÇÇ ++ r‚ÇÇ
                                                                                      -- ‚ä¢ y :: l‚ÇÅ ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
                                                                                      -- ‚ä¢ y :: l‚ÇÅ ++ r‚ÇÅ ~ z :: l‚ÇÇ ++ r‚ÇÇ
    ¬∑ substs t‚ÇÅ t‚ÇÇ
      -- ‚ä¢ [] ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
      exact p
      -- üéâ no goals
    ¬∑ substs z t‚ÇÅ t‚ÇÇ
      -- ‚ä¢ [] ++ r‚ÇÅ ~ a :: l‚ÇÇ ++ r‚ÇÇ
      exact p.trans perm_middle
      -- üéâ no goals
    ¬∑ substs y t‚ÇÅ t‚ÇÇ
      -- ‚ä¢ a :: l‚ÇÅ ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
      exact perm_middle.symm.trans p
      -- üéâ no goals
    ¬∑ substs z t‚ÇÅ t‚ÇÇ
      -- ‚ä¢ y :: l‚ÇÅ ++ r‚ÇÅ ~ y :: l‚ÇÇ ++ r‚ÇÇ
      exact (IH _ _ _ _ rfl rfl).cons y
      -- üéâ no goals
  ¬∑ rcases l‚ÇÅ with (_ | ‚ü®y, _ | ‚ü®z, l‚ÇÅ‚ü©‚ü©) <;> rcases l‚ÇÇ with (_ | ‚ü®u, _ | ‚ü®v, l‚ÇÇ‚ü©‚ü©) <;>
          dsimp at e‚ÇÅ e‚ÇÇ <;> injections <;> substs x y
          -- ‚ä¢ [] ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
          -- ‚ä¢ [] ++ r‚ÇÅ ~ [u] ++ r‚ÇÇ
          -- ‚ä¢ [] ++ r‚ÇÅ ~ u :: v :: l‚ÇÇ ++ r‚ÇÇ
          -- ‚ä¢ [y] ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
          -- ‚ä¢ [y] ++ r‚ÇÅ ~ [u] ++ r‚ÇÇ
          -- ‚ä¢ [y] ++ r‚ÇÅ ~ u :: v :: l‚ÇÇ ++ r‚ÇÇ
          -- ‚ä¢ y :: z :: l‚ÇÅ ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
          -- ‚ä¢ y :: z :: l‚ÇÅ ++ r‚ÇÅ ~ [u] ++ r‚ÇÇ
          -- ‚ä¢ y :: z :: l‚ÇÅ ++ r‚ÇÅ ~ u :: v :: l‚ÇÇ ++ r‚ÇÇ
                             -- ‚ä¢ [] ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
                             -- ‚ä¢ [] ++ r‚ÇÅ ~ [u] ++ r‚ÇÇ
                             -- ‚ä¢ [] ++ r‚ÇÅ ~ u :: v :: l‚ÇÇ ++ r‚ÇÇ
                             -- ‚ä¢ [y] ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
                             -- ‚ä¢ [y] ++ r‚ÇÅ ~ [u] ++ r‚ÇÇ
                             -- ‚ä¢ [y] ++ r‚ÇÅ ~ u :: v :: l‚ÇÇ ++ r‚ÇÇ
                             -- ‚ä¢ y :: z :: l‚ÇÅ ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
                             -- ‚ä¢ y :: z :: l‚ÇÅ ++ r‚ÇÅ ~ [u] ++ r‚ÇÇ
                             -- ‚ä¢ y :: z :: l‚ÇÅ ++ r‚ÇÅ ~ u :: v :: l‚ÇÇ ++ r‚ÇÇ
                                            -- ‚ä¢ [] ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
                                            -- ‚ä¢ [] ++ r‚ÇÅ ~ [u] ++ r‚ÇÇ
                                            -- ‚ä¢ [] ++ r‚ÇÅ ~ u :: v :: l‚ÇÇ ++ r‚ÇÇ
                                            -- ‚ä¢ [y] ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
                                            -- ‚ä¢ [y] ++ r‚ÇÅ ~ [u] ++ r‚ÇÇ
                                            -- ‚ä¢ [y] ++ r‚ÇÅ ~ u :: v :: l‚ÇÇ ++ r‚ÇÇ
                                            -- ‚ä¢ y :: z :: l‚ÇÅ ++ r‚ÇÅ ~ [] ++ r‚ÇÇ
                                            -- ‚ä¢ y :: z :: l‚ÇÅ ++ r‚ÇÅ ~ [u] ++ r‚ÇÇ
                                            -- ‚ä¢ y :: z :: l‚ÇÅ ++ r‚ÇÅ ~ u :: v :: l‚ÇÇ ++ r‚ÇÇ
    ¬∑ substs r‚ÇÅ r‚ÇÇ
      -- ‚ä¢ [] ++ a :: t‚ÇÅ ~ [] ++ a :: t‚ÇÇ
      exact p.cons a
      -- üéâ no goals
    ¬∑ substs r‚ÇÅ r‚ÇÇ
      -- ‚ä¢ [] ++ u :: t‚ÇÅ ~ [u] ++ t‚ÇÇ
      exact p.cons u
      -- üéâ no goals
    ¬∑ substs r‚ÇÅ v t‚ÇÇ
      -- ‚ä¢ [] ++ u :: t‚ÇÅ ~ u :: a :: l‚ÇÇ ++ r‚ÇÇ
      exact (p.trans perm_middle).cons u
      -- üéâ no goals
    ¬∑ substs r‚ÇÅ r‚ÇÇ
      -- ‚ä¢ [y] ++ t‚ÇÅ ~ [] ++ y :: t‚ÇÇ
      exact p.cons y
      -- üéâ no goals
    ¬∑ substs r‚ÇÅ r‚ÇÇ y u
      -- ‚ä¢ [a] ++ t‚ÇÅ ~ [a] ++ t‚ÇÇ
      exact p.cons a
      -- üéâ no goals
    ¬∑ substs r‚ÇÅ u v t‚ÇÇ
      -- ‚ä¢ [y] ++ t‚ÇÅ ~ a :: y :: l‚ÇÇ ++ r‚ÇÇ
      exact ((p.trans perm_middle).cons y).trans (swap _ _ _)
      -- üéâ no goals
    ¬∑ substs r‚ÇÇ z t‚ÇÅ
      -- ‚ä¢ y :: a :: l‚ÇÅ ++ r‚ÇÅ ~ [] ++ y :: t‚ÇÇ
      exact (perm_middle.symm.trans p).cons y
      -- üéâ no goals
    ¬∑ substs r‚ÇÇ y z t‚ÇÅ
      -- ‚ä¢ a :: u :: l‚ÇÅ ++ r‚ÇÅ ~ [u] ++ t‚ÇÇ
      exact (swap _ _ _).trans ((perm_middle.symm.trans p).cons u)
      -- üéâ no goals
    ¬∑ substs u v t‚ÇÅ t‚ÇÇ
      -- ‚ä¢ y :: z :: l‚ÇÅ ++ r‚ÇÅ ~ z :: y :: l‚ÇÇ ++ r‚ÇÇ
      exact (IH _ _ _ _ rfl rfl).swap' _ _
      -- üéâ no goals
  ¬∑ substs t‚ÇÅ t‚ÇÉ
    -- ‚ä¢ l‚ÇÅ ++ r‚ÇÅ ~ l‚ÇÇ ++ r‚ÇÇ
    have : a ‚àà t‚ÇÇ := p‚ÇÅ.subset (by simp)
    -- ‚ä¢ l‚ÇÅ ++ r‚ÇÅ ~ l‚ÇÇ ++ r‚ÇÇ
    rcases mem_split this with ‚ü®l‚ÇÇ, r‚ÇÇ, e‚ÇÇ‚ü©
    -- ‚ä¢ l‚ÇÅ ++ r‚ÇÅ ~ l‚ÇÇ‚úù ++ r‚ÇÇ‚úù
    subst t‚ÇÇ
    -- ‚ä¢ l‚ÇÅ ++ r‚ÇÅ ~ l‚ÇÇ‚úù ++ r‚ÇÇ‚úù
    exact (IH‚ÇÅ _ _ _ _ rfl rfl).trans (IH‚ÇÇ _ _ _ _ rfl rfl)
    -- üéâ no goals
#align list.perm_inv_core List.perm_inv_core

theorem Perm.cons_inv {a : Œ±} {l‚ÇÅ l‚ÇÇ : List Œ±} : a :: l‚ÇÅ ~ a :: l‚ÇÇ ‚Üí l‚ÇÅ ~ l‚ÇÇ :=
  @perm_inv_core _ _ [] [] _ _
#align list.perm.cons_inv List.Perm.cons_inv

@[simp]
theorem perm_cons (a : Œ±) {l‚ÇÅ l‚ÇÇ : List Œ±} : a :: l‚ÇÅ ~ a :: l‚ÇÇ ‚Üî l‚ÇÅ ~ l‚ÇÇ :=
  ‚ü®Perm.cons_inv, Perm.cons a‚ü©
#align list.perm_cons List.perm_cons

theorem perm_append_left_iff {l‚ÇÅ l‚ÇÇ : List Œ±} : ‚àÄ l, l ++ l‚ÇÅ ~ l ++ l‚ÇÇ ‚Üî l‚ÇÅ ~ l‚ÇÇ
  | [] => Iff.rfl
  | a :: l => (perm_cons a).trans (perm_append_left_iff l)
#align list.perm_append_left_iff List.perm_append_left_iff

theorem perm_append_right_iff {l‚ÇÅ l‚ÇÇ : List Œ±} (l) : l‚ÇÅ ++ l ~ l‚ÇÇ ++ l ‚Üî l‚ÇÅ ~ l‚ÇÇ :=
  ‚ü®fun p => (perm_append_left_iff _).1 <| perm_append_comm.trans <| p.trans perm_append_comm,
    Perm.append_right _‚ü©
#align list.perm_append_right_iff List.perm_append_right_iff

theorem perm_option_to_list {o‚ÇÅ o‚ÇÇ : Option Œ±} : o‚ÇÅ.toList ~ o‚ÇÇ.toList ‚Üî o‚ÇÅ = o‚ÇÇ := by
  refine' ‚ü®fun p => _, fun e => e ‚ñ∏ Perm.refl _‚ü©
  -- ‚ä¢ o‚ÇÅ = o‚ÇÇ
  cases' o‚ÇÅ with a <;> cases' o‚ÇÇ with b; ¬∑ rfl
  -- ‚ä¢ none = o‚ÇÇ
                       -- ‚ä¢ none = none
                       -- ‚ä¢ some a = none
                                           -- üéâ no goals
  ¬∑ cases p.length_eq
    -- üéâ no goals
  ¬∑ cases p.length_eq
    -- üéâ no goals
  ¬∑ exact Option.mem_toList.1 (p.symm.subset <| by simp)
    -- üéâ no goals
#align list.perm_option_to_list List.perm_option_to_list

theorem subperm_cons (a : Œ±) {l‚ÇÅ l‚ÇÇ : List Œ±} : a :: l‚ÇÅ <+~ a :: l‚ÇÇ ‚Üî l‚ÇÅ <+~ l‚ÇÇ :=
  ‚ü®fun ‚ü®l, p, s‚ü© => by
    cases' s with _ _ _ s' u _ _ s'
    -- ‚ä¢ l‚ÇÅ <+~ l‚ÇÇ
    ¬∑ exact (p.subperm_left.2 <| (sublist_cons _ _).subperm).trans s'.subperm
      -- üéâ no goals
    ¬∑ exact ‚ü®u, p.cons_inv, s'‚ü©, fun ‚ü®l, p, s‚ü© => ‚ü®a :: l, p.cons a, s.cons‚ÇÇ _‚ü©‚ü©
      -- üéâ no goals
#align list.subperm_cons List.subperm_cons

alias ‚ü®subperm.of_cons, subperm.cons‚ü© := subperm_cons
#align list.subperm.of_cons List.subperm.of_cons
#align list.subperm.cons List.subperm.cons

--Porting note: commented out
--attribute [protected] subperm.cons

theorem cons_subperm_of_mem {a : Œ±} {l‚ÇÅ l‚ÇÇ : List Œ±} (d‚ÇÅ : Nodup l‚ÇÅ) (h‚ÇÅ : a ‚àâ l‚ÇÅ) (h‚ÇÇ : a ‚àà l‚ÇÇ)
    (s : l‚ÇÅ <+~ l‚ÇÇ) : a :: l‚ÇÅ <+~ l‚ÇÇ := by
  rcases s with ‚ü®l, p, s‚ü©
  -- ‚ä¢ a :: l‚ÇÅ <+~ l‚ÇÇ
  induction s generalizing l‚ÇÅ
  case slnil => cases h‚ÇÇ
  -- ‚ä¢ a :: l‚ÇÅ <+~ a‚úù¬π :: l‚ÇÇ‚úù
  -- üéâ no goals
  case cons r‚ÇÅ r‚ÇÇ b s' ih =>
    simp at h‚ÇÇ
    cases' h‚ÇÇ with e m
    ¬∑ subst b
      exact ‚ü®a :: r‚ÇÅ, p.cons a, s'.cons‚ÇÇ _‚ü©
    ¬∑ rcases ih d‚ÇÅ h‚ÇÅ m p with ‚ü®t, p', s'‚ü©
      exact ‚ü®t, p', s'.cons _‚ü©
  case cons‚ÇÇ r‚ÇÅ r‚ÇÇ b _ ih =>
    have bm : b ‚àà l‚ÇÅ := p.subset <| mem_cons_self _ _
    have am : a ‚àà r‚ÇÇ := by
      simp only [find?, mem_cons] at h‚ÇÇ
      exact h‚ÇÇ.resolve_left fun e => h‚ÇÅ <| e.symm ‚ñ∏ bm
    rcases mem_split bm with ‚ü®t‚ÇÅ, t‚ÇÇ, rfl‚ü©
    have st : t‚ÇÅ ++ t‚ÇÇ <+ t‚ÇÅ ++ b :: t‚ÇÇ := by simp
    rcases ih (d‚ÇÅ.sublist st) (mt (fun x => st.subset x) h‚ÇÅ) am
        (Perm.cons_inv <| p.trans perm_middle) with
      ‚ü®t, p', s'‚ü©
    exact
      ‚ü®b :: t, (p'.cons b).trans <| (swap _ _ _).trans (perm_middle.symm.cons a), s'.cons‚ÇÇ _‚ü©
#align list.cons_subperm_of_mem List.cons_subperm_of_mem

theorem subperm_append_left {l‚ÇÅ l‚ÇÇ : List Œ±} : ‚àÄ l, l ++ l‚ÇÅ <+~ l ++ l‚ÇÇ ‚Üî l‚ÇÅ <+~ l‚ÇÇ
  | [] => Iff.rfl
  | a :: l => (subperm_cons a).trans (subperm_append_left l)
#align list.subperm_append_left List.subperm_append_left

theorem subperm_append_right {l‚ÇÅ l‚ÇÇ : List Œ±} (l) : l‚ÇÅ ++ l <+~ l‚ÇÇ ++ l ‚Üî l‚ÇÅ <+~ l‚ÇÇ :=
  (perm_append_comm.subperm_left.trans perm_append_comm.subperm_right).trans (subperm_append_left l)
#align list.subperm_append_right List.subperm_append_right

theorem Subperm.exists_of_length_lt {l‚ÇÅ l‚ÇÇ : List Œ±} :
    l‚ÇÅ <+~ l‚ÇÇ ‚Üí length l‚ÇÅ < length l‚ÇÇ ‚Üí ‚àÉ a, a :: l‚ÇÅ <+~ l‚ÇÇ
  | ‚ü®l, p, s‚ü©, h => by
    suffices length l < length l‚ÇÇ ‚Üí ‚àÉ a : Œ±, a :: l <+~ l‚ÇÇ from
      (this <| p.symm.length_eq ‚ñ∏ h).imp fun a => (p.cons a).subperm_right.1
    clear h p l‚ÇÅ
    -- ‚ä¢ length l < length l‚ÇÇ ‚Üí ‚àÉ a, a :: l <+~ l‚ÇÇ
    induction' s with l‚ÇÅ l‚ÇÇ a s IH _ _ b _ IH <;> intro h
                                                  -- ‚ä¢ ‚àÉ a, [a] <+~ []
                                                  -- ‚ä¢ ‚àÉ a_1, a_1 :: l‚ÇÅ <+~ a :: l‚ÇÇ
                                                  -- ‚ä¢ ‚àÉ a, a :: b :: l‚ÇÅ‚úù <+~ b :: l‚ÇÇ‚úù
    ¬∑ cases h
      -- üéâ no goals
    ¬∑ cases' lt_or_eq_of_le (Nat.le_of_lt_succ h : length l‚ÇÅ ‚â§ length l‚ÇÇ) with h h
      -- ‚ä¢ ‚àÉ a_1, a_1 :: l‚ÇÅ <+~ a :: l‚ÇÇ
      ¬∑ exact (IH h).imp fun a s => s.trans (sublist_cons _ _).subperm
        -- üéâ no goals
      ¬∑ exact ‚ü®a, s.eq_of_length h ‚ñ∏ Subperm.refl _‚ü©
        -- üéâ no goals
    ¬∑ exact (IH <| Nat.lt_of_succ_lt_succ h).imp fun a s =>
          (swap _ _ _).subperm_right.1 <| (subperm_cons _).2 s
#align list.subperm.exists_of_length_lt List.Subperm.exists_of_length_lt

protected theorem Nodup.subperm (d : Nodup l‚ÇÅ) (H : l‚ÇÅ ‚äÜ l‚ÇÇ) : l‚ÇÅ <+~ l‚ÇÇ := by
  induction' d with a l‚ÇÅ' h d IH
  -- ‚ä¢ [] <+~ l‚ÇÇ
  ¬∑ exact ‚ü®nil, Perm.nil, nil_sublist _‚ü©
    -- üéâ no goals
  ¬∑ cases' forall_mem_cons.1 H with H‚ÇÅ H‚ÇÇ
    -- ‚ä¢ a :: l‚ÇÅ' <+~ l‚ÇÇ
    simp at h
    -- ‚ä¢ a :: l‚ÇÅ' <+~ l‚ÇÇ
    exact cons_subperm_of_mem d h H‚ÇÅ (IH H‚ÇÇ)
    -- üéâ no goals
#align list.nodup.subperm List.Nodup.subperm

theorem perm_ext {l‚ÇÅ l‚ÇÇ : List Œ±} (d‚ÇÅ : Nodup l‚ÇÅ) (d‚ÇÇ : Nodup l‚ÇÇ) :
    l‚ÇÅ ~ l‚ÇÇ ‚Üî ‚àÄ a, a ‚àà l‚ÇÅ ‚Üî a ‚àà l‚ÇÇ :=
  ‚ü®fun p _ => p.mem_iff, fun H =>
    (d‚ÇÅ.subperm fun a => (H a).1).antisymm <| d‚ÇÇ.subperm fun a => (H a).2‚ü©
#align list.perm_ext List.perm_ext

theorem Nodup.sublist_ext {l‚ÇÅ l‚ÇÇ l : List Œ±} (d : Nodup l) (s‚ÇÅ : l‚ÇÅ <+ l) (s‚ÇÇ : l‚ÇÇ <+ l) :
    l‚ÇÅ ~ l‚ÇÇ ‚Üî l‚ÇÅ = l‚ÇÇ :=
  ‚ü®fun h => by
    induction' s‚ÇÇ with l‚ÇÇ l a s‚ÇÇ IH l‚ÇÇ l a _ IH generalizing l‚ÇÅ
    ¬∑ exact h.eq_nil
      -- üéâ no goals
    ¬∑ simp at d
      -- ‚ä¢ l‚ÇÅ = l‚ÇÇ
      cases' s‚ÇÅ with _ _ _ s‚ÇÅ l‚ÇÅ _ _ s‚ÇÅ
      -- ‚ä¢ l‚ÇÅ = l‚ÇÇ
      ¬∑ exact IH d.2 s‚ÇÅ h
        -- üéâ no goals
      ¬∑ apply d.1.elim
        -- ‚ä¢ a ‚àà l
        exact Subperm.subset ‚ü®_, h.symm, s‚ÇÇ‚ü© (mem_cons_self _ _)
        -- üéâ no goals
    ¬∑ simp at d
      -- ‚ä¢ l‚ÇÅ = a :: l‚ÇÇ
      cases' s‚ÇÅ with _ _ _ s‚ÇÅ l‚ÇÅ _ _ s‚ÇÅ
      -- ‚ä¢ l‚ÇÅ = a :: l‚ÇÇ
      ¬∑ apply d.1.elim
        -- ‚ä¢ a ‚àà l
        exact Subperm.subset ‚ü®_, h, s‚ÇÅ‚ü© (mem_cons_self _ _)
        -- üéâ no goals
      ¬∑ rw [IH d.2 s‚ÇÅ h.cons_inv], fun h => by rw [h]‚ü©
        -- üéâ no goals
                                               -- üéâ no goals
#align list.nodup.sublist_ext List.Nodup.sublist_ext

section

variable [DecidableEq Œ±]

-- attribute [congr]
theorem Perm.erase (a : Œ±) {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : l‚ÇÅ.erase a ~ l‚ÇÇ.erase a :=
  if h‚ÇÅ : a ‚àà l‚ÇÅ then
    have h‚ÇÇ : a ‚àà l‚ÇÇ := p.subset h‚ÇÅ
    Perm.cons_inv <| (perm_cons_erase h‚ÇÅ).symm.trans <| p.trans (perm_cons_erase h‚ÇÇ)
  else by
    have h‚ÇÇ : a ‚àâ l‚ÇÇ := mt p.mem_iff.2 h‚ÇÅ
    -- ‚ä¢ List.erase l‚ÇÅ a ~ List.erase l‚ÇÇ a
    rw [erase_of_not_mem h‚ÇÅ, erase_of_not_mem h‚ÇÇ]; exact p
    -- ‚ä¢ l‚ÇÅ ~ l‚ÇÇ
                                                   -- üéâ no goals
#align list.perm.erase List.Perm.erase

theorem subperm_cons_erase (a : Œ±) (l : List Œ±) : l <+~ a :: l.erase a := by
  by_cases h : a ‚àà l
  -- ‚ä¢ l <+~ a :: List.erase l a
  ¬∑ exact (perm_cons_erase h).subperm
    -- üéâ no goals
  ¬∑ rw [erase_of_not_mem h]
    -- ‚ä¢ l <+~ a :: l
    exact (sublist_cons _ _).subperm
    -- üéâ no goals
#align list.subperm_cons_erase List.subperm_cons_erase

theorem erase_subperm (a : Œ±) (l : List Œ±) : l.erase a <+~ l :=
  (erase_sublist _ _).subperm
#align list.erase_subperm List.erase_subperm

theorem Subperm.erase {l‚ÇÅ l‚ÇÇ : List Œ±} (a : Œ±) (h : l‚ÇÅ <+~ l‚ÇÇ) : l‚ÇÅ.erase a <+~ l‚ÇÇ.erase a :=
  let ‚ü®l, hp, hs‚ü© := h
  ‚ü®l.erase a, hp.erase _, hs.erase _‚ü©
#align list.subperm.erase List.Subperm.erase

theorem Perm.diff_right {l‚ÇÅ l‚ÇÇ : List Œ±} (t : List Œ±) (h : l‚ÇÅ ~ l‚ÇÇ) : l‚ÇÅ.diff t ~ l‚ÇÇ.diff t := by
  induction t generalizing l‚ÇÅ l‚ÇÇ h <;> simp [*, Perm.erase]
  -- ‚ä¢ List.diff l‚ÇÅ [] ~ List.diff l‚ÇÇ []
                                       -- üéâ no goals
                                       -- üéâ no goals
#align list.perm.diff_right List.Perm.diff_right

theorem Perm.diff_left (l : List Œ±) {t‚ÇÅ t‚ÇÇ : List Œ±} (h : t‚ÇÅ ~ t‚ÇÇ) : l.diff t‚ÇÅ = l.diff t‚ÇÇ := by
  induction h generalizing l <;>
    first |simp [*, Perm.erase, erase_comm]
    -- üéâ no goals
    -- üéâ no goals
    -- üéâ no goals
    -- üéâ no goals
#align list.perm.diff_left List.Perm.diff_left

theorem Perm.diff {l‚ÇÅ l‚ÇÇ t‚ÇÅ t‚ÇÇ : List Œ±} (hl : l‚ÇÅ ~ l‚ÇÇ) (ht : t‚ÇÅ ~ t‚ÇÇ) : l‚ÇÅ.diff t‚ÇÅ ~ l‚ÇÇ.diff t‚ÇÇ :=
  ht.diff_left l‚ÇÇ ‚ñ∏ hl.diff_right _
#align list.perm.diff List.Perm.diff

theorem Subperm.diff_right {l‚ÇÅ l‚ÇÇ : List Œ±} (h : l‚ÇÅ <+~ l‚ÇÇ) (t : List Œ±) :
    l‚ÇÅ.diff t <+~ l‚ÇÇ.diff t := by induction t generalizing l‚ÇÅ l‚ÇÇ h <;> simp [*, Subperm.erase]
                                  -- ‚ä¢ List.diff l‚ÇÅ [] <+~ List.diff l‚ÇÇ []
                                                                       -- üéâ no goals
                                                                       -- üéâ no goals
#align list.subperm.diff_right List.Subperm.diff_right

theorem erase_cons_subperm_cons_erase (a b : Œ±) (l : List Œ±) :
    (a :: l).erase b <+~ a :: l.erase b := by
  by_cases h : a = b
  -- ‚ä¢ List.erase (a :: l) b <+~ a :: List.erase l b
  ¬∑ subst b
    -- ‚ä¢ List.erase (a :: l) a <+~ a :: List.erase l a
    rw [erase_cons_head]
    -- ‚ä¢ l <+~ a :: List.erase l a
    apply subperm_cons_erase
    -- üéâ no goals
  ¬∑ rw [erase_cons_tail _ h]
    -- üéâ no goals
#align list.erase_cons_subperm_cons_erase List.erase_cons_subperm_cons_erase

theorem subperm_cons_diff {a : Œ±} : ‚àÄ {l‚ÇÅ l‚ÇÇ : List Œ±}, (a :: l‚ÇÅ).diff l‚ÇÇ <+~ a :: l‚ÇÅ.diff l‚ÇÇ
  | l‚ÇÅ, [] => ‚ü®a :: l‚ÇÅ, by simp‚ü©
                           -- üéâ no goals
  | l‚ÇÅ, b :: l‚ÇÇ => by
    simp only [diff_cons]
    -- ‚ä¢ List.diff (List.erase (a :: l‚ÇÅ) b) l‚ÇÇ <+~ a :: List.diff (List.erase l‚ÇÅ b) l‚ÇÇ
    refine' ((erase_cons_subperm_cons_erase a b l‚ÇÅ).diff_right l‚ÇÇ).trans _
    -- ‚ä¢ List.diff (a :: List.erase l‚ÇÅ b) l‚ÇÇ <+~ a :: List.diff (List.erase l‚ÇÅ b) l‚ÇÇ
    apply subperm_cons_diff
    -- üéâ no goals
#align list.subperm_cons_diff List.subperm_cons_diff

theorem subset_cons_diff {a : Œ±} {l‚ÇÅ l‚ÇÇ : List Œ±} : (a :: l‚ÇÅ).diff l‚ÇÇ ‚äÜ a :: l‚ÇÅ.diff l‚ÇÇ :=
  subperm_cons_diff.subset
#align list.subset_cons_diff List.subset_cons_diff

theorem Perm.bagInter_right {l‚ÇÅ l‚ÇÇ : List Œ±} (t : List Œ±) (h : l‚ÇÅ ~ l‚ÇÇ) :
    l‚ÇÅ.bagInter t ~ l‚ÇÇ.bagInter t := by
  induction' h with x _ _ _ _ x y _ _ _ _ _ _ ih_1 ih_2 generalizing t; ¬∑ simp
                                                                          -- üéâ no goals
  ¬∑ by_cases x ‚àà t <;> simp [*, Perm.cons]
    -- ‚ä¢ List.bagInter (x :: l‚ÇÅ‚úù) t ~ List.bagInter (x :: l‚ÇÇ‚úù) t
    -- ‚ä¢ List.bagInter (x :: l‚ÇÅ‚úù) t ~ List.bagInter (x :: l‚ÇÇ‚úù) t
                       -- üéâ no goals
                       -- üéâ no goals
  ¬∑ by_cases h : x = y
    -- ‚ä¢ List.bagInter (y :: x :: l‚úù) t ~ List.bagInter (x :: y :: l‚úù) t
    ¬∑ simp [h]
      -- üéâ no goals
    by_cases xt : x ‚àà t <;> by_cases yt : y ‚àà t
    -- ‚ä¢ List.bagInter (y :: x :: l‚úù) t ~ List.bagInter (x :: y :: l‚úù) t
                            -- ‚ä¢ List.bagInter (y :: x :: l‚úù) t ~ List.bagInter (x :: y :: l‚úù) t
                            -- ‚ä¢ List.bagInter (y :: x :: l‚úù) t ~ List.bagInter (x :: y :: l‚úù) t
    ¬∑ simp [xt, yt, mem_erase_of_ne h, mem_erase_of_ne (Ne.symm h), erase_comm, swap]
      -- üéâ no goals
    ¬∑ simp [xt, yt, mt mem_of_mem_erase, Perm.cons]
      -- üéâ no goals
    ¬∑ simp [xt, yt, mt mem_of_mem_erase, Perm.cons]
      -- üéâ no goals
    ¬∑ simp [xt, yt]
      -- üéâ no goals
  ¬∑ exact (ih_1 _).trans (ih_2 _)
    -- üéâ no goals
#align list.perm.bag_inter_right List.Perm.bagInter_right

theorem Perm.bagInter_left (l : List Œ±) {t‚ÇÅ t‚ÇÇ : List Œ±} (p : t‚ÇÅ ~ t‚ÇÇ) :
    l.bagInter t‚ÇÅ = l.bagInter t‚ÇÇ := by
  induction' l with a l IH generalizing t‚ÇÅ t‚ÇÇ p; ¬∑ simp
  -- ‚ä¢ List.bagInter [] t‚ÇÅ = List.bagInter [] t‚ÇÇ
                                                   -- üéâ no goals
  by_cases h : a ‚àà t‚ÇÅ
  -- ‚ä¢ List.bagInter (a :: l) t‚ÇÅ = List.bagInter (a :: l) t‚ÇÇ
  ¬∑ simp [h, p.subset h, IH (p.erase _)]
    -- üéâ no goals
  ¬∑ simp [h, mt p.mem_iff.2 h, IH p]
    -- üéâ no goals
#align list.perm.bag_inter_left List.Perm.bagInter_left

theorem Perm.bagInter {l‚ÇÅ l‚ÇÇ t‚ÇÅ t‚ÇÇ : List Œ±} (hl : l‚ÇÅ ~ l‚ÇÇ) (ht : t‚ÇÅ ~ t‚ÇÇ) :
    l‚ÇÅ.bagInter t‚ÇÅ ~ l‚ÇÇ.bagInter t‚ÇÇ :=
  ht.bagInter_left l‚ÇÇ ‚ñ∏ hl.bagInter_right _
#align list.perm.bag_inter List.Perm.bagInter

theorem cons_perm_iff_perm_erase {a : Œ±} {l‚ÇÅ l‚ÇÇ : List Œ±} :
    a :: l‚ÇÅ ~ l‚ÇÇ ‚Üî a ‚àà l‚ÇÇ ‚àß l‚ÇÅ ~ l‚ÇÇ.erase a :=
  ‚ü®fun h =>
    have : a ‚àà l‚ÇÇ := h.subset (mem_cons_self a l‚ÇÅ)
    ‚ü®this, (h.trans <| perm_cons_erase this).cons_inv‚ü©,
    fun ‚ü®m, h‚ü© => (h.cons a).trans (perm_cons_erase m).symm‚ü©
#align list.cons_perm_iff_perm_erase List.cons_perm_iff_perm_erase

theorem perm_iff_count {l‚ÇÅ l‚ÇÇ : List Œ±} : l‚ÇÅ ~ l‚ÇÇ ‚Üî ‚àÄ a, count a l‚ÇÅ = count a l‚ÇÇ :=
  ‚ü®Perm.count_eq, fun H => by
    induction' l‚ÇÅ with a l‚ÇÅ IH generalizing l‚ÇÇ
    -- ‚ä¢ [] ~ l‚ÇÇ
    ¬∑ cases' l‚ÇÇ with b l‚ÇÇ
      -- ‚ä¢ [] ~ []
      ¬∑ rfl
        -- üéâ no goals
      specialize H b
      -- ‚ä¢ [] ~ b :: l‚ÇÇ
      simp at H
      -- ‚ä¢ [] ~ b :: l‚ÇÇ
      contradiction
      -- üéâ no goals
    ¬∑ have : a ‚àà l‚ÇÇ := count_pos_iff_mem.1 (by rw [‚Üê H, count_pos_iff_mem]; simp)
      -- ‚ä¢ a :: l‚ÇÅ ~ l‚ÇÇ
      refine' ((IH fun b => _).cons a).trans (perm_cons_erase this).symm
      -- ‚ä¢ count b l‚ÇÅ = count b (List.erase l‚ÇÇ a)
      specialize H b
      -- ‚ä¢ count b l‚ÇÅ = count b (List.erase l‚ÇÇ a)
      rw [(perm_cons_erase this).count_eq] at H
      -- ‚ä¢ count b l‚ÇÅ = count b (List.erase l‚ÇÇ a)
      by_cases h : b = a <;> simpa [h] using H‚ü©
      -- ‚ä¢ count b l‚ÇÅ = count b (List.erase l‚ÇÇ a)
                             -- üéâ no goals
                             -- üéâ no goals
#align list.perm_iff_count List.perm_iff_count

theorem perm_replicate_append_replicate {l : List Œ±} {a b : Œ±} {m n : ‚Ñï} (h : a ‚â† b) :
    l ~ replicate m a ++ replicate n b ‚Üî count a l = m ‚àß count b l = n ‚àß l ‚äÜ [a, b] := by
  rw [perm_iff_count, ‚Üê Decidable.and_forall_ne a, ‚Üê Decidable.and_forall_ne b]
  -- ‚ä¢ (count a l = count a (replicate m a ++ replicate n b) ‚àß (b ‚â† a ‚Üí count b l = ‚Ä¶
  suffices : l ‚äÜ [a, b] ‚Üî ‚àÄ c, c ‚â† b ‚Üí c ‚â† a ‚Üí c ‚àâ l
  -- ‚ä¢ (count a l = count a (replicate m a ++ replicate n b) ‚àß (b ‚â† a ‚Üí count b l = ‚Ä¶
  { simp (config := { contextual := true }) [count_replicate, h, h.symm, this, count_eq_zero] }
  -- ‚ä¢ l ‚äÜ [a, b] ‚Üî ‚àÄ (c : Œ±), c ‚â† b ‚Üí c ‚â† a ‚Üí ¬¨c ‚àà l
  simp_rw [Ne.def, ‚Üê and_imp, ‚Üê not_or, Decidable.not_imp_not, subset_def, mem_cons,
    not_mem_nil, or_false, or_comm]
#align list.perm_replicate_append_replicate List.perm_replicate_append_replicate

theorem Subperm.cons_right {Œ± : Type*} {l l' : List Œ±} (x : Œ±) (h : l <+~ l') : l <+~ x :: l' :=
  h.trans (sublist_cons x l').subperm
#align list.subperm.cons_right List.Subperm.cons_right

/-- The list version of `add_tsub_cancel_of_le` for multisets. -/
theorem subperm_append_diff_self_of_count_le {l‚ÇÅ l‚ÇÇ : List Œ±}
    (h : ‚àÄ x ‚àà l‚ÇÅ, count x l‚ÇÅ ‚â§ count x l‚ÇÇ) : l‚ÇÅ ++ l‚ÇÇ.diff l‚ÇÅ ~ l‚ÇÇ := by
  induction' l‚ÇÅ with hd tl IH generalizing l‚ÇÇ
  -- ‚ä¢ [] ++ List.diff l‚ÇÇ [] ~ l‚ÇÇ
  ¬∑ simp
    -- üéâ no goals
  ¬∑ have : hd ‚àà l‚ÇÇ := by
      rw [‚Üê count_pos_iff_mem]
      exact lt_of_lt_of_le (count_pos_iff_mem.mpr (mem_cons_self _ _)) (h hd (mem_cons_self _ _))
    replace := perm_cons_erase this
    -- ‚ä¢ hd :: tl ++ List.diff l‚ÇÇ (hd :: tl) ~ l‚ÇÇ
    refine' Perm.trans _ this.symm
    -- ‚ä¢ hd :: tl ++ List.diff l‚ÇÇ (hd :: tl) ~ hd :: List.erase l‚ÇÇ hd
    rw [cons_append, diff_cons, perm_cons]
    -- ‚ä¢ tl ++ List.diff (List.erase l‚ÇÇ hd) tl ~ List.erase l‚ÇÇ hd
    refine' IH fun x hx => _
    -- ‚ä¢ count x tl ‚â§ count x (List.erase l‚ÇÇ hd)
    specialize h x (mem_cons_of_mem _ hx)
    -- ‚ä¢ count x tl ‚â§ count x (List.erase l‚ÇÇ hd)
    rw [perm_iff_count.mp this] at h
    -- ‚ä¢ count x tl ‚â§ count x (List.erase l‚ÇÇ hd)
    by_cases hx : x = hd
    -- ‚ä¢ count x tl ‚â§ count x (List.erase l‚ÇÇ hd)
    ¬∑ subst hd
      -- ‚ä¢ count x tl ‚â§ count x (List.erase l‚ÇÇ x)
      simpa [Nat.succ_le_succ_iff] using h
      -- üéâ no goals
    ¬∑ simpa [hx] using h
      -- üéâ no goals
#align list.subperm_append_diff_self_of_count_le List.subperm_append_diff_self_of_count_le

/-- The list version of `Multiset.le_iff_count`. -/
theorem subperm_ext_iff {l‚ÇÅ l‚ÇÇ : List Œ±} : l‚ÇÅ <+~ l‚ÇÇ ‚Üî ‚àÄ x ‚àà l‚ÇÅ, count x l‚ÇÅ ‚â§ count x l‚ÇÇ := by
  refine' ‚ü®fun h x _ => Subperm.count_le h x, fun h => _‚ü©
  -- ‚ä¢ l‚ÇÅ <+~ l‚ÇÇ
  suffices l‚ÇÅ <+~ l‚ÇÇ.diff l‚ÇÅ ++ l‚ÇÅ by
    refine' this.trans (Perm.subperm _)
    exact perm_append_comm.trans (subperm_append_diff_self_of_count_le h)
  exact (subperm_append_right l‚ÇÅ).mpr nil_subperm
  -- üéâ no goals
#align list.subperm_ext_iff List.subperm_ext_iff

instance decidableSubperm : DecidableRel ((¬∑ <+~ ¬∑) : List Œ± ‚Üí List Œ± ‚Üí Prop) := fun _ _ =>
  decidable_of_iff _ List.subperm_ext_iff.symm
#align list.decidable_subperm List.decidableSubperm

@[simp]
theorem subperm_singleton_iff {Œ±} {l : List Œ±} {a : Œ±} : [a] <+~ l ‚Üî a ‚àà l :=
  ‚ü®fun ‚ü®s, hla, h‚ü© => by rwa [perm_singleton.mp hla, singleton_sublist] at h, fun h =>
                         -- üéâ no goals
    ‚ü®[a], Perm.refl _, singleton_sublist.mpr h‚ü©‚ü©
#align list.subperm_singleton_iff List.subperm_singleton_iff

theorem Subperm.cons_left {l‚ÇÅ l‚ÇÇ : List Œ±} (h : l‚ÇÅ <+~ l‚ÇÇ) (x : Œ±) (hx : count x l‚ÇÅ < count x l‚ÇÇ) :
    x :: l‚ÇÅ <+~ l‚ÇÇ := by
  rw [subperm_ext_iff] at h ‚ä¢
  -- ‚ä¢ ‚àÄ (x_1 : Œ±), x_1 ‚àà x :: l‚ÇÅ ‚Üí count x_1 (x :: l‚ÇÅ) ‚â§ count x_1 l‚ÇÇ
  intro y hy
  -- ‚ä¢ count y (x :: l‚ÇÅ) ‚â§ count y l‚ÇÇ
  by_cases hy' : y = x
  -- ‚ä¢ count y (x :: l‚ÇÅ) ‚â§ count y l‚ÇÇ
  ¬∑ subst x
    -- ‚ä¢ count y (y :: l‚ÇÅ) ‚â§ count y l‚ÇÇ
    simpa using Nat.succ_le_of_lt hx
    -- üéâ no goals
  ¬∑ rw [count_cons_of_ne hy']
    -- ‚ä¢ count y l‚ÇÅ ‚â§ count y l‚ÇÇ
    refine' h y _
    -- ‚ä¢ y ‚àà l‚ÇÅ
    simpa [hy'] using hy
    -- üéâ no goals
#align list.subperm.cons_left List.Subperm.cons_left

instance decidablePerm : ‚àÄ l‚ÇÅ l‚ÇÇ : List Œ±, Decidable (l‚ÇÅ ~ l‚ÇÇ)
  | [], [] => isTrue <| Perm.refl _
  | [], b :: l‚ÇÇ => isFalse fun h => by have := h.nil_eq; contradiction
                                       -- ‚ä¢ False
                                                         -- üéâ no goals
  | a :: l‚ÇÅ, l‚ÇÇ =>
    haveI := decidablePerm l‚ÇÅ (l‚ÇÇ.erase a)
    decidable_of_iff' _ cons_perm_iff_perm_erase
#align list.decidable_perm List.decidablePerm

-- @[congr]
theorem Perm.dedup {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : dedup l‚ÇÅ ~ dedup l‚ÇÇ :=
  perm_iff_count.2 fun a =>
    if h : a ‚àà l‚ÇÅ then by simp [nodup_dedup, h, p.subset h] else by simp [h, mt p.mem_iff.2 h]
                          -- üéâ no goals
                                                                    -- üéâ no goals
#align list.perm.dedup List.Perm.dedup

-- attribute [congr]
protected theorem Perm.insert (a : Œ±) {l‚ÇÅ l‚ÇÇ : List Œ±} (p : l‚ÇÅ ~ l‚ÇÇ) : l‚ÇÅ.insert a ~ l‚ÇÇ.insert a :=
  if h : a ‚àà l‚ÇÅ then by simpa [h, p.subset h] using p
                        -- üéâ no goals
  else by simpa [h, mt p.mem_iff.2 h] using p.cons a
          -- üéâ no goals
#align list.perm.insert List.Perm.insert

theorem perm_insert_swap (x y : Œ±) (l : List Œ±) :
    List.insert x (List.insert y l) ~ List.insert y (List.insert x l) := by
  by_cases xl : x ‚àà l <;> by_cases yl : y ‚àà l <;> simp [xl, yl]
  -- ‚ä¢ List.insert x (List.insert y l) ~ List.insert y (List.insert x l)
                          -- ‚ä¢ List.insert x (List.insert y l) ~ List.insert y (List.insert x l)
                          -- ‚ä¢ List.insert x (List.insert y l) ~ List.insert y (List.insert x l)
                                                  -- üéâ no goals
                                                  -- üéâ no goals
                                                  -- üéâ no goals
                                                  -- ‚ä¢ List.insert x (y :: l) ~ List.insert y (x :: l)
  by_cases xy : x = y; ¬∑ simp [xy]
  -- ‚ä¢ List.insert x (y :: l) ~ List.insert y (x :: l)
                         -- üéâ no goals
  simp [List.insert, xl, yl, xy, Ne.symm xy]
  -- ‚ä¢ x :: y :: l ~ y :: x :: l
  constructor
  -- üéâ no goals
#align list.perm_insert_swap List.perm_insert_swap

theorem perm_insertNth {Œ±} (x : Œ±) (l : List Œ±) {n} (h : n ‚â§ l.length) :
    insertNth n x l ~ x :: l := by
  induction' l with _ _ l_ih generalizing n
  -- ‚ä¢ insertNth n x [] ~ [x]
  ¬∑ cases n
    -- ‚ä¢ insertNth zero x [] ~ [x]
    rfl
    -- ‚ä¢ insertNth (succ n‚úù) x [] ~ [x]
    cases h
    -- üéâ no goals
  cases n
  -- ‚ä¢ insertNth zero x (head‚úù :: tail‚úù) ~ x :: head‚úù :: tail‚úù
  ¬∑ simp [insertNth]
    -- üéâ no goals
  ¬∑ simp only [insertNth, modifyNthTail]
    -- ‚ä¢ head‚úù :: modifyNthTail (cons x) n‚úù tail‚úù ~ x :: head‚úù :: tail‚úù
    refine' Perm.trans (Perm.cons _ (l_ih _)) _
    -- ‚ä¢ n‚úù ‚â§ length tail‚úù
    ¬∑ apply Nat.le_of_succ_le_succ h
      -- üéâ no goals
    ¬∑ apply Perm.swap
      -- üéâ no goals
#align list.perm_insert_nth List.perm_insertNth

theorem Perm.union_right {l‚ÇÅ l‚ÇÇ : List Œ±} (t‚ÇÅ : List Œ±) (h : l‚ÇÅ ~ l‚ÇÇ) :
    l‚ÇÅ ‚à™ t‚ÇÅ ~ l‚ÇÇ ‚à™ t‚ÇÅ := by
  induction' h with a _ _ _ ih _ _ _ _ _ _ _ _ ih_1 ih_2 <;> try simp
                                                             -- üéâ no goals
                                                             -- ‚ä¢ List.insert a (l‚ÇÅ‚úù ‚à™ t‚ÇÅ) ~ List.insert a (l‚ÇÇ‚úù ‚à™ t‚ÇÅ)
                                                             -- ‚ä¢ List.insert y‚úù (List.insert x‚úù (l‚úù ‚à™ t‚ÇÅ)) ~ List.insert x‚úù (List.insert y‚úù ( ‚Ä¶
                                                             -- ‚ä¢ l‚ÇÅ‚úù ‚à™ t‚ÇÅ ~ l‚ÇÉ‚úù ‚à™ t‚ÇÅ
  ¬∑ exact ih.insert a
    -- üéâ no goals
  ¬∑ apply perm_insert_swap
    -- üéâ no goals
  ¬∑ exact ih_1.trans ih_2
    -- üéâ no goals
#align list.perm.union_right List.Perm.union_right

theorem Perm.union_left (l : List Œ±) {t‚ÇÅ t‚ÇÇ : List Œ±} (h : t‚ÇÅ ~ t‚ÇÇ) : l ‚à™ t‚ÇÅ ~ l ‚à™ t‚ÇÇ := by
  induction l <;> simp [*, Perm.insert]
  -- ‚ä¢ [] ‚à™ t‚ÇÅ ~ [] ‚à™ t‚ÇÇ
                  -- üéâ no goals
                  -- üéâ no goals
#align list.perm.union_left List.Perm.union_left

-- @[congr]
theorem Perm.union {l‚ÇÅ l‚ÇÇ t‚ÇÅ t‚ÇÇ : List Œ±} (p‚ÇÅ : l‚ÇÅ ~ l‚ÇÇ) (p‚ÇÇ : t‚ÇÅ ~ t‚ÇÇ) :
    l‚ÇÅ ‚à™ t‚ÇÅ ~ l‚ÇÇ ‚à™ t‚ÇÇ :=
  (p‚ÇÅ.union_right t‚ÇÅ).trans (p‚ÇÇ.union_left l‚ÇÇ)
#align list.perm.union List.Perm.union

theorem Perm.inter_right {l‚ÇÅ l‚ÇÇ : List Œ±} (t‚ÇÅ : List Œ±) : l‚ÇÅ ~ l‚ÇÇ ‚Üí l‚ÇÅ ‚à© t‚ÇÅ ~ l‚ÇÇ ‚à© t‚ÇÅ :=
  Perm.filter _
#align list.perm.inter_right List.Perm.inter_right

theorem Perm.inter_left (l : List Œ±) {t‚ÇÅ t‚ÇÇ : List Œ±} (p : t‚ÇÅ ~ t‚ÇÇ) : l ‚à© t‚ÇÅ = l ‚à© t‚ÇÇ :=
  filter_congr' fun a _ => by simpa using p.mem_iff
                              -- üéâ no goals
#align list.perm.inter_left List.Perm.inter_left

-- @[congr]
theorem Perm.inter {l‚ÇÅ l‚ÇÇ t‚ÇÅ t‚ÇÇ : List Œ±} (p‚ÇÅ : l‚ÇÅ ~ l‚ÇÇ) (p‚ÇÇ : t‚ÇÅ ~ t‚ÇÇ) : l‚ÇÅ ‚à© t‚ÇÅ ~ l‚ÇÇ ‚à© t‚ÇÇ :=
  p‚ÇÇ.inter_left l‚ÇÇ ‚ñ∏ p‚ÇÅ.inter_right t‚ÇÅ
#align list.perm.inter List.Perm.inter

theorem Perm.inter_append {l t‚ÇÅ t‚ÇÇ : List Œ±} (h : Disjoint t‚ÇÅ t‚ÇÇ) :
    l ‚à© (t‚ÇÅ ++ t‚ÇÇ) ~ l ‚à© t‚ÇÅ ++ l ‚à© t‚ÇÇ := by
  induction l
  -- ‚ä¢ [] ‚à© (t‚ÇÅ ++ t‚ÇÇ) ~ [] ‚à© t‚ÇÅ ++ [] ‚à© t‚ÇÇ
  case nil => simp
  -- ‚ä¢ (head‚úù :: tail‚úù) ‚à© (t‚ÇÅ ++ t‚ÇÇ) ~ (head‚úù :: tail‚úù) ‚à© t‚ÇÅ ++ (head‚úù :: tail‚úù) ‚à© t‚ÇÇ
  -- üéâ no goals
  case cons x xs l_ih =>
    by_cases h‚ÇÅ : x ‚àà t‚ÇÅ
    ¬∑ have h‚ÇÇ : x ‚àâ t‚ÇÇ := h h‚ÇÅ
      simp [*]
    by_cases h‚ÇÇ : x ‚àà t‚ÇÇ
    ¬∑ simp only [*, inter_cons_of_not_mem, false_or_iff, mem_append, inter_cons_of_mem,
        not_false_iff]
      refine' Perm.trans (Perm.cons _ l_ih) _
      change [x] ++ xs ‚à© t‚ÇÅ ++ xs ‚à© t‚ÇÇ ~ xs ‚à© t‚ÇÅ ++ ([x] ++ xs ‚à© t‚ÇÇ)
      rw [‚Üê List.append_assoc]
      solve_by_elim [Perm.append_right, perm_append_comm]
    ¬∑ simp [*]
#align list.perm.inter_append List.Perm.inter_append

end

theorem Perm.pairwise_iff {R : Œ± ‚Üí Œ± ‚Üí Prop} (S : Symmetric R) :
    ‚àÄ {l‚ÇÅ l‚ÇÇ : List Œ±} (_p : l‚ÇÅ ~ l‚ÇÇ), Pairwise R l‚ÇÅ ‚Üî Pairwise R l‚ÇÇ :=
  suffices ‚àÄ {l‚ÇÅ l‚ÇÇ}, l‚ÇÅ ~ l‚ÇÇ ‚Üí Pairwise R l‚ÇÅ ‚Üí Pairwise R l‚ÇÇ
    from fun p => ‚ü®this p, this p.symm‚ü©
  @fun l‚ÇÅ l‚ÇÇ p d => by
  induction' d with a l‚ÇÅ h _ IH generalizing l‚ÇÇ
  -- ‚ä¢ Pairwise R l‚ÇÇ
  ¬∑ rw [‚Üê p.nil_eq]
    -- ‚ä¢ Pairwise R []
    constructor
    -- üéâ no goals
  ¬∑ have : a ‚àà l‚ÇÇ := p.subset (mem_cons_self _ _)
    -- ‚ä¢ Pairwise R l‚ÇÇ
    rcases mem_split this with ‚ü®s‚ÇÇ, t‚ÇÇ, rfl‚ü©
    -- ‚ä¢ Pairwise R (s‚ÇÇ ++ a :: t‚ÇÇ)
    have p' := (p.trans perm_middle).cons_inv
    -- ‚ä¢ Pairwise R (s‚ÇÇ ++ a :: t‚ÇÇ)
    refine' (pairwise_middle S).2 (pairwise_cons.2 ‚ü®fun b m => _, IH _ p'‚ü©)
    -- ‚ä¢ R a b
    exact h _ (p'.symm.subset m)
    -- üéâ no goals
#align list.perm.pairwise_iff List.Perm.pairwise_iff


theorem Pairwise.perm {R : Œ± ‚Üí Œ± ‚Üí Prop} {l l' : List Œ±} (hR : l.Pairwise R) (hl : l ~ l')
    (hsymm : Symmetric R) : l'.Pairwise R :=
  (hl.pairwise_iff hsymm).mp hR
#align list.pairwise.perm List.Pairwise.perm

theorem Perm.pairwise {R : Œ± ‚Üí Œ± ‚Üí Prop} {l l' : List Œ±} (hl : l ~ l') (hR : l.Pairwise R)
    (hsymm : Symmetric R) : l'.Pairwise R :=
  hR.perm hl hsymm
#align list.perm.pairwise List.Perm.pairwise

theorem Perm.nodup_iff {l‚ÇÅ l‚ÇÇ : List Œ±} : l‚ÇÅ ~ l‚ÇÇ ‚Üí (Nodup l‚ÇÅ ‚Üî Nodup l‚ÇÇ) :=
  Perm.pairwise_iff <| @Ne.symm Œ±
#align list.perm.nodup_iff List.Perm.nodup_iff

theorem Perm.join {l‚ÇÅ l‚ÇÇ : List (List Œ±)} (h : l‚ÇÅ ~ l‚ÇÇ) : l‚ÇÅ.join ~ l‚ÇÇ.join :=
  Perm.recOn h (Perm.refl _) (fun x xs‚ÇÅ xs‚ÇÇ _ ih => ih.append_left x)
    (fun x‚ÇÅ x‚ÇÇ xs => by simpa only [join, append_assoc] using perm_append_comm.append_right _)
                        -- üéâ no goals
    @fun xs‚ÇÅ xs‚ÇÇ xs‚ÇÉ _ _ => Perm.trans
#align list.perm.join List.Perm.join

theorem Perm.bind_right {l‚ÇÅ l‚ÇÇ : List Œ±} (f : Œ± ‚Üí List Œ≤) (p : l‚ÇÅ ~ l‚ÇÇ) : l‚ÇÅ.bind f ~ l‚ÇÇ.bind f :=
  (p.map _).join
#align list.perm.bind_right List.Perm.bind_right

theorem Perm.join_congr :
    ‚àÄ {l‚ÇÅ l‚ÇÇ : List (List Œ±)} (_ : List.Forall‚ÇÇ (¬∑ ~ ¬∑) l‚ÇÅ l‚ÇÇ), l‚ÇÅ.join ~ l‚ÇÇ.join
  | _, _, Forall‚ÇÇ.nil => Perm.refl _
  | _ :: _, _ :: _, Forall‚ÇÇ.cons h‚ÇÅ h‚ÇÇ => h‚ÇÅ.append (Perm.join_congr h‚ÇÇ)
#align list.perm.join_congr List.Perm.join_congr

theorem Perm.bind_left (l : List Œ±) {f g : Œ± ‚Üí List Œ≤} (h : ‚àÄ a ‚àà l, f a ~ g a) :
    l.bind f ~ l.bind g :=
  Perm.join_congr <| by
    rwa [List.forall‚ÇÇ_map_right_iff, List.forall‚ÇÇ_map_left_iff, List.forall‚ÇÇ_same]
    -- üéâ no goals
#align list.perm.bind_left List.Perm.bind_left

theorem bind_append_perm (l : List Œ±) (f g : Œ± ‚Üí List Œ≤) :
    l.bind f ++ l.bind g ~ l.bind fun x => f x ++ g x := by
  induction' l with a l IH <;> simp
  -- ‚ä¢ List.bind [] f ++ List.bind [] g ~ List.bind [] fun x => f x ++ g x
                               -- üéâ no goals
                               -- ‚ä¢ f a ++ (List.bind l f ++ (g a ++ List.bind l g)) ~ f a ++ (g a ++ List.bind  ‚Ä¶
  refine' (Perm.trans _ (IH.append_left _)).append_left _
  -- ‚ä¢ List.bind l f ++ (g a ++ List.bind l g) ~ g a ++ (List.bind l f ++ List.bind ‚Ä¶
  rw [‚Üê append_assoc, ‚Üê append_assoc]
  -- ‚ä¢ List.bind l f ++ g a ++ List.bind l g ~ g a ++ List.bind l f ++ List.bind l g
  exact perm_append_comm.append_right _
  -- üéâ no goals
#align list.bind_append_perm List.bind_append_perm

theorem map_append_bind_perm (l : List Œ±) (f : Œ± ‚Üí Œ≤) (g : Œ± ‚Üí List Œ≤) :
    l.map f ++ l.bind g ~ l.bind fun x => f x :: g x := by
  simpa [‚Üê map_eq_bind] using bind_append_perm l (fun x => [f x]) g
  -- üéâ no goals
#align list.map_append_bind_perm List.map_append_bind_perm

theorem Perm.product_right {l‚ÇÅ l‚ÇÇ : List Œ±} (t‚ÇÅ : List Œ≤) (p : l‚ÇÅ ~ l‚ÇÇ) :
    product l‚ÇÅ t‚ÇÅ ~ product l‚ÇÇ t‚ÇÅ :=
  p.bind_right _
#align list.perm.product_right List.Perm.product_right

theorem Perm.product_left (l : List Œ±) {t‚ÇÅ t‚ÇÇ : List Œ≤} (p : t‚ÇÅ ~ t‚ÇÇ) :
    product l t‚ÇÅ ~ product l t‚ÇÇ :=
  (Perm.bind_left _) fun _ _ => p.map _
#align list.perm.product_left List.Perm.product_left

-- @[congr]
theorem Perm.product {l‚ÇÅ l‚ÇÇ : List Œ±} {t‚ÇÅ t‚ÇÇ : List Œ≤} (p‚ÇÅ : l‚ÇÅ ~ l‚ÇÇ) (p‚ÇÇ : t‚ÇÅ ~ t‚ÇÇ) :
    product l‚ÇÅ t‚ÇÅ ~ product l‚ÇÇ t‚ÇÇ :=
  (p‚ÇÅ.product_right t‚ÇÅ).trans (p‚ÇÇ.product_left l‚ÇÇ)
#align list.perm.product List.Perm.product

theorem perm_lookmap (f : Œ± ‚Üí Option Œ±) {l‚ÇÅ l‚ÇÇ : List Œ±}
    (H : Pairwise (fun a b => ‚àÄ c ‚àà f a, ‚àÄ d ‚àà f b, a = b ‚àß c = d) l‚ÇÅ) (p : l‚ÇÅ ~ l‚ÇÇ) :
    lookmap f l‚ÇÅ ~ lookmap f l‚ÇÇ := by
  induction' p with a l‚ÇÅ l‚ÇÇ p IH a b l l‚ÇÅ l‚ÇÇ l‚ÇÉ p‚ÇÅ _ IH‚ÇÅ IH‚ÇÇ; ¬∑ simp
                                                                -- üéâ no goals
  ¬∑ cases h : f a
    -- ‚ä¢ lookmap f (a :: l‚ÇÅ) ~ lookmap f (a :: l‚ÇÇ)
    ¬∑ simp [h]
      -- ‚ä¢ lookmap f l‚ÇÅ ~ lookmap f l‚ÇÇ
      exact IH (pairwise_cons.1 H).2
      -- üéâ no goals
    ¬∑ simp [lookmap_cons_some _ _ h, p]
      -- üéâ no goals
  ¬∑ cases' h‚ÇÅ : f a with c <;> cases' h‚ÇÇ : f b with d
    -- ‚ä¢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)
                               -- ‚ä¢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)
                               -- ‚ä¢ lookmap f (b :: a :: l) ~ lookmap f (a :: b :: l)
    ¬∑ simp [h‚ÇÅ, h‚ÇÇ]
      -- ‚ä¢ b :: a :: lookmap f l ~ a :: b :: lookmap f l
      apply swap
      -- üéâ no goals
    ¬∑ simp [h‚ÇÅ, lookmap_cons_some _ _ h‚ÇÇ]
      -- ‚ä¢ d :: a :: l ~ a :: d :: l
      apply swap
      -- üéâ no goals
    ¬∑ simp [lookmap_cons_some _ _ h‚ÇÅ, h‚ÇÇ]
      -- ‚ä¢ b :: c :: l ~ c :: b :: l
      apply swap
      -- üéâ no goals
    ¬∑ simp [lookmap_cons_some _ _ h‚ÇÅ, lookmap_cons_some _ _ h‚ÇÇ]
      -- ‚ä¢ d :: a :: l ~ c :: b :: l
      rcases(pairwise_cons.1 H).1 _ (mem_cons.2 (Or.inl rfl)) _ h‚ÇÇ _ h‚ÇÅ with ‚ü®rfl, rfl‚ü©
      -- ‚ä¢ d :: b :: l ~ d :: b :: l
      exact Perm.refl _
      -- üéâ no goals
  ¬∑ refine' (IH‚ÇÅ H).trans (IH‚ÇÇ ((p‚ÇÅ.pairwise_iff _).1 H))
    -- ‚ä¢ Symmetric fun a b => ‚àÄ (c : Œ±), c ‚àà f a ‚Üí ‚àÄ (d : Œ±), d ‚àà f b ‚Üí a = b ‚àß c = d
    exact fun a b h c h‚ÇÅ d h‚ÇÇ => (h d h‚ÇÇ c h‚ÇÅ).imp Eq.symm Eq.symm
    -- üéâ no goals
#align list.perm_lookmap List.perm_lookmap

theorem Perm.erasep (f : Œ± ‚Üí Prop) [DecidablePred f] {l‚ÇÅ l‚ÇÇ : List Œ±}
    (H : Pairwise (fun a b => f a ‚Üí f b ‚Üí False) l‚ÇÅ) (p : l‚ÇÅ ~ l‚ÇÇ) : eraseP f l‚ÇÅ ~ eraseP f l‚ÇÇ := by
  induction' p with a l‚ÇÅ l‚ÇÇ p IH a b l l‚ÇÅ l‚ÇÇ l‚ÇÉ p‚ÇÅ _ IH‚ÇÅ IH‚ÇÇ; ¬∑ simp
                                                                -- üéâ no goals
  ¬∑ by_cases h : f a
    -- ‚ä¢ eraseP (fun b => decide (f b)) (a :: l‚ÇÅ) ~ eraseP (fun b => decide (f b)) (a ‚Ä¶
    ¬∑ simp [h, p]
      -- üéâ no goals
    ¬∑ simp [h]
      -- ‚ä¢ eraseP (fun b => decide (f b)) l‚ÇÅ ~ eraseP (fun b => decide (f b)) l‚ÇÇ
      exact IH (pairwise_cons.1 H).2
      -- üéâ no goals
  ¬∑ by_cases h‚ÇÅ : f a <;> by_cases h‚ÇÇ : f b <;> simp [h‚ÇÅ, h‚ÇÇ]
    -- ‚ä¢ eraseP (fun b => decide (f b)) (b :: a :: l) ~ eraseP (fun b => decide (f b) ‚Ä¶
                          -- ‚ä¢ eraseP (fun b => decide (f b)) (b :: a :: l) ~ eraseP (fun b => decide (f b) ‚Ä¶
                          -- ‚ä¢ eraseP (fun b => decide (f b)) (b :: a :: l) ~ eraseP (fun b => decide (f b) ‚Ä¶
                                                -- ‚ä¢ a :: l ~ b :: l
                                                -- üéâ no goals
                                                -- üéâ no goals
                                                -- ‚ä¢ b :: a :: eraseP (fun b => decide (f b)) l ~ a :: b :: eraseP (fun b => deci ‚Ä¶
    ¬∑ cases (pairwise_cons.1 H).1 _ (mem_cons.2 (Or.inl rfl)) h‚ÇÇ h‚ÇÅ
      -- üéâ no goals
    ¬∑ apply swap
      -- üéâ no goals
  ¬∑ refine' (IH‚ÇÅ H).trans (IH‚ÇÇ ((p‚ÇÅ.pairwise_iff _).1 H))
    -- ‚ä¢ Symmetric fun a b => f a ‚Üí f b ‚Üí False
    exact fun a b h h‚ÇÅ h‚ÇÇ => h h‚ÇÇ h‚ÇÅ
    -- üéâ no goals
#align list.perm.erasep List.Perm.erasep

theorem Perm.take_inter {Œ± : Type*} [DecidableEq Œ±] {xs ys : List Œ±} (n : ‚Ñï) (h : xs ~ ys)
    (h' : ys.Nodup) : xs.take n ~ ys.inter (xs.take n) := by
  simp only [List.inter]
  -- ‚ä¢ take n xs ~ List.filter (fun x => decide (x ‚àà take n xs)) ys
  exact Perm.trans (show xs.take n ~ xs.filter (¬∑ ‚àà xs.take n) by
      conv_lhs => rw [Nodup.take_eq_filter_mem ((Perm.nodup_iff h).2 h')])
    (Perm.filter _ h)
#align list.perm.take_inter List.Perm.take_inter

theorem Perm.drop_inter {Œ±} [DecidableEq Œ±] {xs ys : List Œ±} (n : ‚Ñï) (h : xs ~ ys) (h' : ys.Nodup) :
    xs.drop n ~ ys.inter (xs.drop n) := by
  by_cases h'' : n ‚â§ xs.length
  -- ‚ä¢ drop n xs ~ List.inter ys (drop n xs)
  ¬∑ let n' := xs.length - n
    -- ‚ä¢ drop n xs ~ List.inter ys (drop n xs)
    have h‚ÇÄ : n = xs.length - n' := by
      rwa [tsub_tsub_cancel_of_le]
    have h‚ÇÅ : n' ‚â§ xs.length := by apply tsub_le_self
    -- ‚ä¢ drop n xs ~ List.inter ys (drop n xs)
    have h‚ÇÇ : xs.drop n = (xs.reverse.take n').reverse := by
      rw [reverse_take _ h‚ÇÅ, h‚ÇÄ, reverse_reverse]
    rw [h‚ÇÇ]
    -- ‚ä¢ reverse (take n' (reverse xs)) ~ List.inter ys (reverse (take n' (reverse xs ‚Ä¶
    apply (reverse_perm _).trans
    -- ‚ä¢ take n' (reverse xs) ~ List.inter ys (reverse (take n' (reverse xs)))
    rw [inter_reverse]
    -- ‚ä¢ take n' (reverse xs) ~ List.inter ys (take n' (reverse xs))
    apply Perm.take_inter _ _ h'
    -- ‚ä¢ reverse xs ~ ys
    apply (reverse_perm _).trans; assumption
    -- ‚ä¢ xs ~ ys
                                  -- üéâ no goals
  ¬∑ have : drop n xs = [] := by
      apply eq_nil_of_length_eq_zero
      rw [length_drop, tsub_eq_zero_iff_le]
      apply le_of_not_ge h''
    simp [this, List.inter]
    -- üéâ no goals
#align list.perm.drop_inter List.Perm.drop_inter

theorem Perm.dropSlice_inter {Œ±} [DecidableEq Œ±] {xs ys : List Œ±} (n m : ‚Ñï) (h : xs ~ ys)
    (h' : ys.Nodup) : List.dropSlice n m xs ~ ys ‚à© List.dropSlice n m xs := by
  simp only [dropSlice_eq]
  -- ‚ä¢ take n xs ++ drop (n + m) xs ~ ys ‚à© (take n xs ++ drop (n + m) xs)
  have : n ‚â§ n + m := Nat.le_add_right _ _
  -- ‚ä¢ take n xs ++ drop (n + m) xs ~ ys ‚à© (take n xs ++ drop (n + m) xs)
  have h‚ÇÇ := h.nodup_iff.2 h'
  -- ‚ä¢ take n xs ++ drop (n + m) xs ~ ys ‚à© (take n xs ++ drop (n + m) xs)
  apply Perm.trans _ (Perm.inter_append _).symm
  -- ‚ä¢ take n xs ++ drop (n + m) xs ~ ys ‚à© take n xs ++ ys ‚à© drop (n + m) xs
  ¬∑ exact Perm.append (Perm.take_inter _ h h') (Perm.drop_inter _ h h')
    -- üéâ no goals
  ¬∑ exact disjoint_take_drop h‚ÇÇ this
    -- üéâ no goals
#align list.perm.slice_inter List.Perm.dropSlice_inter

-- enumerating permutations
section Permutations

theorem perm_of_mem_permutationsAux :
    ‚àÄ {ts is l : List Œ±}, l ‚àà permutationsAux ts is ‚Üí l ~ ts ++ is := by
  show ‚àÄ (ts is l : List Œ±), l ‚àà permutationsAux ts is ‚Üí l ~ ts ++ is
  -- ‚ä¢ ‚àÄ (ts is l : List Œ±), l ‚àà permutationsAux ts is ‚Üí l ~ ts ++ is
  refine' permutationsAux.rec (by simp) _
  -- ‚ä¢ ‚àÄ (t : Œ±) (ts is : List Œ±), (‚àÄ (l : List Œ±), l ‚àà permutationsAux ts (t :: is ‚Ä¶
  introv IH1 IH2 m
  -- ‚ä¢ l ~ t :: ts ++ is
  rw [permutationsAux_cons, permutations, mem_foldr_permutationsAux2] at m
  -- ‚ä¢ l ~ t :: ts ++ is
  rcases m with (m | ‚ü®l‚ÇÅ, l‚ÇÇ, m, _, e‚ü©)
  -- ‚ä¢ l ~ t :: ts ++ is
  ¬∑ exact (IH1 _ m).trans perm_middle
    -- üéâ no goals
  ¬∑ subst e
    -- ‚ä¢ l‚ÇÅ ++ t :: l‚ÇÇ ++ ts ~ t :: ts ++ is
    have p : l‚ÇÅ ++ l‚ÇÇ ~ is := by
      simp [permutations] at m
      cases' m with e m
      ¬∑ simp [e]
      exact is.append_nil ‚ñ∏ IH2 _ m
    exact ((perm_middle.trans (p.cons _)).append_right _).trans (perm_append_comm.cons _)
    -- üéâ no goals
#align list.perm_of_mem_permutations_aux List.perm_of_mem_permutationsAux

theorem perm_of_mem_permutations {l‚ÇÅ l‚ÇÇ : List Œ±} (h : l‚ÇÅ ‚àà permutations l‚ÇÇ) : l‚ÇÅ ~ l‚ÇÇ :=
  (eq_or_mem_of_mem_cons h).elim (fun e => e ‚ñ∏ Perm.refl _) fun m =>
    append_nil l‚ÇÇ ‚ñ∏ perm_of_mem_permutationsAux m
#align list.perm_of_mem_permutations List.perm_of_mem_permutations

theorem length_permutationsAux :
    ‚àÄ ts is : List Œ±, length (permutationsAux ts is) + is.length ! = (length ts + length is)! := by
  refine' permutationsAux.rec (by simp) _
  -- ‚ä¢ ‚àÄ (t : Œ±) (ts is : List Œ±), length (permutationsAux ts (t :: is)) + (length  ‚Ä¶
  intro t ts is IH1 IH2
  -- ‚ä¢ length (permutationsAux (t :: ts) is) + (length is)! = (length (t :: ts) + l ‚Ä¶
  have IH2 : length (permutationsAux is nil) + 1 = is.length ! := by simpa using IH2
  -- ‚ä¢ length (permutationsAux (t :: ts) is) + (length is)! = (length (t :: ts) + l ‚Ä¶
  simp [Nat.factorial, Nat.add_succ, mul_comm] at IH1
  -- ‚ä¢ length (permutationsAux (t :: ts) is) + (length is)! = (length (t :: ts) + l ‚Ä¶
  rw [permutationsAux_cons,
    length_foldr_permutationsAux2' _ _ _ _ _ fun l m => (perm_of_mem_permutations m).length_eq,
    permutations, length, length, IH2, Nat.succ_add, Nat.factorial_succ, mul_comm (_ + 1),
    ‚Üê Nat.succ_eq_add_one, ‚Üê IH1, add_comm (_ * _), add_assoc, Nat.mul_succ, mul_comm]
#align list.length_permutations_aux List.length_permutationsAux

theorem length_permutations (l : List Œ±) : length (permutations l) = (length l)! :=
  length_permutationsAux l []
#align list.length_permutations List.length_permutations

theorem mem_permutations_of_perm_lemma {is l : List Œ±}
    (H : l ~ [] ++ is ‚Üí (‚àÉ (ts' : _) (_ : ts' ~ []), l = ts' ++ is) ‚à® l ‚àà permutationsAux is []) :
    l ~ is ‚Üí l ‚àà permutations is := by simpa [permutations, perm_nil] using H
                                       -- üéâ no goals
#align list.mem_permutations_of_perm_lemma List.mem_permutations_of_perm_lemma

theorem mem_permutationsAux_of_perm :
    ‚àÄ {ts is l : List Œ±},
      l ~ is ++ ts ‚Üí (‚àÉ (is' : _) (_ : is' ~ is), l = is' ++ ts) ‚à® l ‚àà permutationsAux ts is := by
  show ‚àÄ (ts is l : List Œ±),
      l ~ is ++ ts ‚Üí (‚àÉ (is' : _) (_ : is' ~ is), l = is' ++ ts) ‚à® l ‚àà permutationsAux ts is
  refine' permutationsAux.rec (by simp) _
  -- ‚ä¢ ‚àÄ (t : Œ±) (ts is : List Œ±), (‚àÄ (l : List Œ±), l ~ t :: is ++ ts ‚Üí (‚àÉ is' x, l ‚Ä¶
  intro t ts is IH1 IH2 l p
  -- ‚ä¢ (‚àÉ is' x, l = is' ++ t :: ts) ‚à® l ‚àà permutationsAux (t :: ts) is
  rw [permutationsAux_cons, mem_foldr_permutationsAux2]
  -- ‚ä¢ (‚àÉ is' x, l = is' ++ t :: ts) ‚à® l ‚àà permutationsAux ts (t :: is) ‚à® ‚àÉ l‚ÇÅ l‚ÇÇ,  ‚Ä¶
  rcases IH1 _ (p.trans perm_middle) with (‚ü®is', p', e‚ü© | m)
  -- ‚ä¢ (‚àÉ is' x, l = is' ++ t :: ts) ‚à® l ‚àà permutationsAux ts (t :: is) ‚à® ‚àÉ l‚ÇÅ l‚ÇÇ,  ‚Ä¶
  ¬∑ clear p
    -- ‚ä¢ (‚àÉ is' x, l = is' ++ t :: ts) ‚à® l ‚àà permutationsAux ts (t :: is) ‚à® ‚àÉ l‚ÇÅ l‚ÇÇ,  ‚Ä¶
    subst e
    -- ‚ä¢ (‚àÉ is'_1 x, is' ++ ts = is'_1 ++ t :: ts) ‚à® is' ++ ts ‚àà permutationsAux ts ( ‚Ä¶
    rcases mem_split (p'.symm.subset (mem_cons_self _ _)) with ‚ü®l‚ÇÅ, l‚ÇÇ, e‚ü©
    -- ‚ä¢ (‚àÉ is'_1 x, is' ++ ts = is'_1 ++ t :: ts) ‚à® is' ++ ts ‚àà permutationsAux ts ( ‚Ä¶
    subst is'
    -- ‚ä¢ (‚àÉ is' x, l‚ÇÅ ++ t :: l‚ÇÇ ++ ts = is' ++ t :: ts) ‚à® l‚ÇÅ ++ t :: l‚ÇÇ ++ ts ‚àà perm ‚Ä¶
    have p := (perm_middle.symm.trans p').cons_inv
    -- ‚ä¢ (‚àÉ is' x, l‚ÇÅ ++ t :: l‚ÇÇ ++ ts = is' ++ t :: ts) ‚à® l‚ÇÅ ++ t :: l‚ÇÇ ++ ts ‚àà perm ‚Ä¶
    cases' l‚ÇÇ with a l‚ÇÇ'
    -- ‚ä¢ (‚àÉ is' x, l‚ÇÅ ++ [t] ++ ts = is' ++ t :: ts) ‚à® l‚ÇÅ ++ [t] ++ ts ‚àà permutations ‚Ä¶
    ¬∑ exact Or.inl ‚ü®l‚ÇÅ, by simpa using p‚ü©
      -- üéâ no goals
    ¬∑ exact Or.inr (Or.inr ‚ü®l‚ÇÅ, a :: l‚ÇÇ', mem_permutations_of_perm_lemma (IH2 _) p, by simp‚ü©)
      -- üéâ no goals
  ¬∑ exact Or.inr (Or.inl m)
    -- üéâ no goals
#align list.mem_permutations_aux_of_perm List.mem_permutationsAux_of_perm

@[simp]
theorem mem_permutations {s t : List Œ±} : s ‚àà permutations t ‚Üî s ~ t :=
  ‚ü®perm_of_mem_permutations, mem_permutations_of_perm_lemma mem_permutationsAux_of_perm‚ü©
#align list.mem_permutations List.mem_permutations

--Porting note: temporary theorem to solve diamond issue
private theorem DecEq_eq {Œ± : Type*} [DecidableEq Œ±] :
     instBEqList = @instBEq (List Œ±) instDecidableEqList :=
  congr_arg BEq.mk <| by
    funext l‚ÇÅ l‚ÇÇ
    -- ‚ä¢ List.beq l‚ÇÅ l‚ÇÇ = decide (l‚ÇÅ = l‚ÇÇ)
    show (l‚ÇÅ == l‚ÇÇ) = _
    -- ‚ä¢ (l‚ÇÅ == l‚ÇÇ) = decide (l‚ÇÅ = l‚ÇÇ)
    rw [Bool.eq_iff_eq_true_iff, @beq_iff_eq _ (_), decide_eq_true_iff]
    -- üéâ no goals

theorem perm_permutations'Aux_comm (a b : Œ±) (l : List Œ±) :
    (permutations'Aux a l).bind (permutations'Aux b) ~
      (permutations'Aux b l).bind (permutations'Aux a) := by
  induction' l with c l ih
  -- ‚ä¢ List.bind (permutations'Aux a []) (permutations'Aux b) ~ List.bind (permutat ‚Ä¶
  ¬∑ simp [swap]
    -- üéâ no goals
  simp [permutations'Aux]
  -- ‚ä¢ (b :: a :: c :: l) :: (a :: b :: c :: l) :: (map (cons a ‚àò cons c) (permutat ‚Ä¶
  apply Perm.swap'
  -- ‚ä¢ map (cons a ‚àò cons c) (permutations'Aux b l) ++ List.bind (map (cons c) (per ‚Ä¶
  have :
    ‚àÄ a b,
      (map (cons c) (permutations'Aux a l)).bind (permutations'Aux b) ~
        map (cons b ‚àò cons c) (permutations'Aux a l) ++
          map (cons c) ((permutations'Aux a l).bind (permutations'Aux b)) := by
    intros a' b'
    simp only [map_bind, permutations'Aux]
    show List.bind (permutations'Aux _ l) (fun a => ([b' :: c :: a] ++
      map (cons c) (permutations'Aux _ a))) ~ _
    refine' (bind_append_perm _ (fun x => [b' :: c :: x]) _).symm.trans _
    rw [‚Üê map_eq_bind, ‚Üê bind_map]
    exact Perm.refl _
  refine' (((this _ _).append_left _).trans _).trans ((this _ _).append_left _).symm
  -- ‚ä¢ map (cons a ‚àò cons c) (permutations'Aux b l) ++ (map (cons b ‚àò cons c) (perm ‚Ä¶
  rw [‚Üê append_assoc, ‚Üê append_assoc]
  -- ‚ä¢ map (cons a ‚àò cons c) (permutations'Aux b l) ++ map (cons b ‚àò cons c) (permu ‚Ä¶
  exact perm_append_comm.append (ih.map _)
  -- üéâ no goals
#align list.perm_permutations'_aux_comm List.perm_permutations'Aux_comm

theorem Perm.permutations' {s t : List Œ±} (p : s ~ t) : permutations' s ~ permutations' t := by
  induction' p with a s t _ IH a b l s t u _ _ IH‚ÇÅ IH‚ÇÇ; ¬∑ simp
                                                          -- üéâ no goals
  ¬∑ exact IH.bind_right _
    -- üéâ no goals
  ¬∑ dsimp [permutations']
    -- ‚ä¢ List.bind (List.bind (List.permutations' l) (permutations'Aux a)) (permutati ‚Ä¶
    rw [bind_assoc, bind_assoc]
    -- ‚ä¢ (List.bind (List.permutations' l) fun x => List.bind (permutations'Aux a x)  ‚Ä¶
    apply Perm.bind_left
    -- ‚ä¢ ‚àÄ (a_1 : List Œ±), a_1 ‚àà List.permutations' l ‚Üí List.bind (permutations'Aux a ‚Ä¶
    intro l' _
    -- ‚ä¢ List.bind (permutations'Aux a l') (permutations'Aux b) ~ List.bind (permutat ‚Ä¶
    apply perm_permutations'Aux_comm
    -- üéâ no goals
  ¬∑ exact IH‚ÇÅ.trans IH‚ÇÇ
    -- üéâ no goals
#align list.perm.permutations' List.Perm.permutations'

theorem permutations_perm_permutations' (ts : List Œ±) : ts.permutations ~ ts.permutations' := by
  obtain ‚ü®n, h‚ü© : ‚àÉ n, length ts < n := ‚ü®_, Nat.lt_succ_self _‚ü©
  -- ‚ä¢ permutations ts ~ permutations' ts
  induction' n with n IH generalizing ts; ¬∑ cases h
  -- ‚ä¢ permutations ts ~ permutations' ts
                                            -- üéâ no goals
  refine' List.reverseRecOn ts (fun _ => _) (fun ts t _ h => _) h; ¬∑ simp [permutations]
  -- ‚ä¢ permutations [] ~ permutations' []
                                                                     -- üéâ no goals
  rw [‚Üê concat_eq_append, length_concat, Nat.succ_lt_succ_iff] at h
  -- ‚ä¢ permutations (ts ++ [t]) ~ permutations' (ts ++ [t])
  have IH‚ÇÇ := (IH ts.reverse (by rwa [length_reverse])).trans (reverse_perm _).permutations'
  -- ‚ä¢ permutations (ts ++ [t]) ~ permutations' (ts ++ [t])
  simp only [permutations_append, foldr_permutationsAux2, permutationsAux_nil,
    permutationsAux_cons, append_nil]
  refine'
    (perm_append_comm.trans ((IH‚ÇÇ.bind_right _).append ((IH _ h).map _))).trans
      (Perm.trans _ perm_append_comm.permutations')
  rw [map_eq_bind, singleton_append, permutations']
  -- ‚ä¢ ((List.bind (permutations' ts) fun y => (permutationsAux2 t [] [] y id).snd) ‚Ä¶
  refine' (bind_append_perm _ _ _).trans _
  -- ‚ä¢ (List.bind (permutations' ts) fun x => (permutationsAux2 t [] [] x id).snd + ‚Ä¶
  refine' Perm.of_eq _
  -- ‚ä¢ (List.bind (permutations' ts) fun x => (permutationsAux2 t [] [] x id).snd + ‚Ä¶
  congr
  -- ‚ä¢ (fun x => (permutationsAux2 t [] [] x id).snd ++ [x ++ [t]]) = permutations' ‚Ä¶
  funext _
  -- ‚ä¢ (permutationsAux2 t [] [] x‚úù id).snd ++ [x‚úù ++ [t]] = permutations'Aux t x‚úù
  rw [permutations'Aux_eq_permutationsAux2, permutationsAux2_append]
  -- üéâ no goals
#align list.permutations_perm_permutations' List.permutations_perm_permutations'

@[simp]
theorem mem_permutations' {s t : List Œ±} : s ‚àà permutations' t ‚Üî s ~ t :=
  (permutations_perm_permutations' _).symm.mem_iff.trans mem_permutations
#align list.mem_permutations' List.mem_permutations'

theorem Perm.permutations {s t : List Œ±} (h : s ~ t) : permutations s ~ permutations t :=
  (permutations_perm_permutations' _).trans <|
    h.permutations'.trans (permutations_perm_permutations' _).symm
#align list.perm.permutations List.Perm.permutations

@[simp]
theorem perm_permutations_iff {s t : List Œ±} : permutations s ~ permutations t ‚Üî s ~ t :=
  ‚ü®fun h => mem_permutations.1 <| h.mem_iff.1 <| mem_permutations.2 (Perm.refl _),
    Perm.permutations‚ü©
#align list.perm_permutations_iff List.perm_permutations_iff

@[simp]
theorem perm_permutations'_iff {s t : List Œ±} : permutations' s ~ permutations' t ‚Üî s ~ t :=
  ‚ü®fun h => mem_permutations'.1 <| h.mem_iff.1 <| mem_permutations'.2 (Perm.refl _),
    Perm.permutations'‚ü©
#align list.perm_permutations'_iff List.perm_permutations'_iff

set_option linter.deprecated false in
theorem nthLe_permutations'Aux (s : List Œ±) (x : Œ±) (n : ‚Ñï)
    (hn : n < length (permutations'Aux x s)) :
    (permutations'Aux x s).nthLe n hn = s.insertNth n x := by
  induction' s with y s IH generalizing n
  -- ‚ä¢ nthLe (permutations'Aux x []) n hn = insertNth n x []
  ¬∑ simp only [length, zero_add, lt_one_iff] at hn
    -- ‚ä¢ nthLe (permutations'Aux x []) n hn‚úù = insertNth n x []
    simp [hn]
    -- üéâ no goals
  ¬∑ cases n
    -- ‚ä¢ nthLe (permutations'Aux x (y :: s)) zero hn = insertNth zero x (y :: s)
    ¬∑ simp [nthLe]
      -- üéâ no goals
    ¬∑ simpa [nthLe] using IH _ _
      -- üéâ no goals
#align list.nth_le_permutations'_aux List.nthLe_permutations'Aux

theorem count_permutations'Aux_self [DecidableEq Œ±] (l : List Œ±) (x : Œ±) :
    count (x :: l) (permutations'Aux x l) = length (takeWhile ((¬∑ = ¬∑) x) l) + 1 := by
  induction' l with y l IH generalizing x
  -- ‚ä¢ count [x] (permutations'Aux x []) = length (takeWhile (fun b => decide ((fun ‚Ä¶
  ¬∑ simp [takeWhile, count]
    -- üéâ no goals
  ¬∑ rw [permutations'Aux, DecEq_eq, count_cons_self]
    -- ‚ä¢ count (x :: y :: l) (map (cons y) (permutations'Aux x l)) + 1 = length (take ‚Ä¶
    by_cases hx : x = y
    -- ‚ä¢ count (x :: y :: l) (map (cons y) (permutations'Aux x l)) + 1 = length (take ‚Ä¶
    ¬∑ subst hx
      -- ‚ä¢ count (x :: x :: l) (map (cons x) (permutations'Aux x l)) + 1 = length (take ‚Ä¶
      simpa [takeWhile, Nat.succ_inj', DecEq_eq] using IH _
      -- üéâ no goals
    ¬∑ rw [takeWhile]
      -- ‚ä¢ count (x :: y :: l) (map (cons y) (permutations'Aux x l)) + 1 =
      simp only [mem_map, cons.injEq, Ne.symm hx, false_and, and_false, exists_false,
        not_false_iff, count_eq_zero_of_not_mem, zero_add, hx, decide_False, length_nil]
#align list.count_permutations'_aux_self List.count_permutations'Aux_self

@[simp]
theorem length_permutations'Aux (s : List Œ±) (x : Œ±) :
    length (permutations'Aux x s) = length s + 1 := by
  induction' s with y s IH
  -- ‚ä¢ length (permutations'Aux x []) = length [] + 1
  ¬∑ simp
    -- üéâ no goals
  ¬∑ simpa using IH
    -- üéâ no goals
#align list.length_permutations'_aux List.length_permutations'Aux

@[simp]
theorem permutations'Aux_nthLe_zero (s : List Œ±) (x : Œ±)
    (hn : 0 < length (permutations'Aux x s) := (by simp)) :
                                                   -- üéâ no goals
    (permutations'Aux x s).nthLe 0 hn = x :: s :=
  nthLe_permutations'Aux _ _ _ _
#align list.permutations'_aux_nth_le_zero List.permutations'Aux_nthLe_zero

theorem injective_permutations'Aux (x : Œ±) : Function.Injective (permutations'Aux x) := by
  intro s t h
  -- ‚ä¢ s = t
  apply insertNth_injective s.length x
  -- ‚ä¢ insertNth (length s) x s = insertNth (length s) x t
  have hl : s.length = t.length := by simpa using congr_arg length h
  -- ‚ä¢ insertNth (length s) x s = insertNth (length s) x t
  rw [‚Üê nthLe_permutations'Aux s x s.length (by simp), ‚Üê
    nthLe_permutations'Aux t x s.length (by simp [hl])]
  simp [h, hl]
  -- üéâ no goals
#align list.injective_permutations'_aux List.injective_permutations'Aux

theorem nodup_permutations'Aux_of_not_mem (s : List Œ±) (x : Œ±) (hx : x ‚àâ s) :
    Nodup (permutations'Aux x s) := by
  induction' s with y s IH
  -- ‚ä¢ Nodup (permutations'Aux x [])
  ¬∑ simp
    -- üéâ no goals
  ¬∑ simp only [not_or, mem_cons] at hx
    -- ‚ä¢ Nodup (permutations'Aux x (y :: s))
    simp only [permutations'Aux, nodup_cons, mem_map, cons.injEq, exists_eq_right_right, not_and]
    -- ‚ä¢ (y :: s ‚àà permutations'Aux x s ‚Üí ¬¨y = x) ‚àß Nodup (map (cons y) (permutations ‚Ä¶
    refine' ‚ü®fun _ => Ne.symm hx.left, _‚ü©
    -- ‚ä¢ Nodup (map (cons y) (permutations'Aux x s))
    rw [nodup_map_iff]
    -- ‚ä¢ Nodup (permutations'Aux x s)
    ¬∑ exact IH hx.right
      -- üéâ no goals
    ¬∑ simp
      -- üéâ no goals
#align list.nodup_permutations'_aux_of_not_mem List.nodup_permutations'Aux_of_not_mem

set_option linter.deprecated false in
theorem nodup_permutations'Aux_iff {s : List Œ±} {x : Œ±} : Nodup (permutations'Aux x s) ‚Üî x ‚àâ s := by
  refine' ‚ü®fun h => _, nodup_permutations'Aux_of_not_mem _ _‚ü©
  -- ‚ä¢ ¬¨x ‚àà s
  intro H
  -- ‚ä¢ False
  obtain ‚ü®k, hk, hk'‚ü© := nthLe_of_mem H
  -- ‚ä¢ False
  rw [nodup_iff_nthLe_inj] at h
  -- ‚ä¢ False
  suffices k = k + 1 by simp at this
  -- ‚ä¢ k = k + 1
  refine' h k (k + 1) _ _ _
  ¬∑ simpa [Nat.lt_succ_iff] using hk.le
    -- üéâ no goals
  ¬∑ simpa using hk
    -- üéâ no goals
  rw [nthLe_permutations'Aux, nthLe_permutations'Aux]
  -- ‚ä¢ insertNth k x s = insertNth (k + 1) x s
  have hl : length (insertNth k x s) = length (insertNth (k + 1) x s) := by
    rw [length_insertNth _ _ hk.le, length_insertNth _ _ (Nat.succ_le_of_lt hk)]
  refine' ext_nthLe hl fun n hn hn' => _
  -- ‚ä¢ nthLe (insertNth k x s) n hn = nthLe (insertNth (k + 1) x s) n hn'
  rcases lt_trichotomy n k with (H | rfl | H)
  ¬∑ rw [nthLe_insertNth_of_lt _ _ _ _ H (H.trans hk),
      nthLe_insertNth_of_lt _ _ _ _ (H.trans (Nat.lt_succ_self _))]
  ¬∑ rw [nthLe_insertNth_self _ _ _ hk.le, nthLe_insertNth_of_lt _ _ _ _ (Nat.lt_succ_self _) hk,
      hk']
  ¬∑ rcases(Nat.succ_le_of_lt H).eq_or_lt with (rfl | H')
    -- ‚ä¢ nthLe (insertNth k x s) (succ k) hn = nthLe (insertNth (k + 1) x s) (succ k) ‚Ä¶
    ¬∑ rw [nthLe_insertNth_self _ _ _ (Nat.succ_le_of_lt hk)]
      -- ‚ä¢ nthLe (insertNth k x s) (succ k) hn = x
      convert hk' using 1
      -- ‚ä¢ nthLe (insertNth k x s) (succ k) hn = nthLe s k hk
      exact nthLe_insertNth_add_succ _ _ _ 0 _
      -- üéâ no goals
    ¬∑ obtain ‚ü®m, rfl‚ü© := Nat.exists_eq_add_of_lt H'
      -- ‚ä¢ nthLe (insertNth k x s) (succ k + m + 1) hn = nthLe (insertNth (k + 1) x s)  ‚Ä¶
      erw [length_insertNth _ _ hk.le, Nat.succ_lt_succ_iff, Nat.succ_add] at hn
      -- ‚ä¢ nthLe (insertNth k x s) (succ k + m + 1) hn‚úù = nthLe (insertNth (k + 1) x s) ‚Ä¶
      rw [nthLe_insertNth_add_succ]
      -- ‚ä¢ nthLe (insertNth k x s) (succ k + m + 1) hn‚úù = nthLe s (k + 1 + m) ?intro.in ‚Ä¶
      convert nthLe_insertNth_add_succ s x k m.succ (by simpa using hn) using 2
      ¬∑ simp [Nat.add_succ, Nat.succ_add]
        -- üéâ no goals
      ¬∑ simp [add_left_comm, add_comm]
        -- üéâ no goals
      ¬∑ simpa [Nat.succ_add] using hn
        -- üéâ no goals
#align list.nodup_permutations'_aux_iff List.nodup_permutations'Aux_iff

set_option linter.deprecated false in
theorem nodup_permutations (s : List Œ±) (hs : Nodup s) : Nodup s.permutations := by
  rw [(permutations_perm_permutations' s).nodup_iff]
  -- ‚ä¢ Nodup (permutations' s)
  induction' hs with x l h h' IH
  -- ‚ä¢ Nodup (permutations' [])
  ¬∑ simp
    -- üéâ no goals
  ¬∑ rw [permutations']
    -- ‚ä¢ Nodup (List.bind (permutations' l) (permutations'Aux x))
    rw [nodup_bind]
    -- ‚ä¢ (‚àÄ (x_1 : List Œ±), x_1 ‚àà permutations' l ‚Üí Nodup (permutations'Aux x x_1)) ‚àß ‚Ä¶
    constructor
    -- ‚ä¢ ‚àÄ (x_1 : List Œ±), x_1 ‚àà permutations' l ‚Üí Nodup (permutations'Aux x x_1)
    ¬∑ intro ys hy
      -- ‚ä¢ Nodup (permutations'Aux x ys)
      rw [mem_permutations'] at hy
      -- ‚ä¢ Nodup (permutations'Aux x ys)
      rw [nodup_permutations'Aux_iff, hy.mem_iff]
      -- ‚ä¢ ¬¨x ‚àà l
      exact fun H => h x H rfl
      -- üéâ no goals
    ¬∑ refine' IH.pairwise_of_forall_ne fun as ha bs hb H => _
      -- ‚ä¢ Disjoint (permutations'Aux x as) (permutations'Aux x bs)
      rw [disjoint_iff_ne]
      -- ‚ä¢ ‚àÄ (a : List Œ±), a ‚àà permutations'Aux x as ‚Üí ‚àÄ (b : List Œ±), b ‚àà permutations ‚Ä¶
      rintro a ha' b hb' rfl
      -- ‚ä¢ False
      obtain ‚ü®‚ü®n, hn‚ü©, hn'‚ü© := get_of_mem ha'
      -- ‚ä¢ False
      obtain ‚ü®‚ü®m, hm‚ü©, hm'‚ü© := get_of_mem hb'
      -- ‚ä¢ False
      rw [mem_permutations'] at ha hb
      -- ‚ä¢ False
      have hl : as.length = bs.length := (ha.trans hb.symm).length_eq
      -- ‚ä¢ False
      simp only [Nat.lt_succ_iff, length_permutations'Aux] at hn hm
      -- ‚ä¢ False
      rw [‚Üê nthLe, nthLe_permutations'Aux] at hn' hm'
      -- ‚ä¢ False
      have hx :
        nthLe (insertNth n x as) m (by rwa [length_insertNth _ _ hn, Nat.lt_succ_iff, hl]) = x :=
        by simp [hn', ‚Üê hm', hm]
      have hx' :
        nthLe (insertNth m x bs) n (by rwa [length_insertNth _ _ hm, Nat.lt_succ_iff, ‚Üê hl]) =
          x :=
        by simp [hm', ‚Üê hn', hn]
      rcases lt_trichotomy n m with (ht | ht | ht)
      ¬∑ suffices x ‚àà bs by exact h x (hb.subset this) rfl
        -- ‚ä¢ x ‚àà bs
        rw [‚Üê hx', nthLe_insertNth_of_lt _ _ _ _ ht (ht.trans_le hm)]
        -- ‚ä¢ nthLe bs n (_ : n < length bs) ‚àà bs
        exact nthLe_mem _ _ _
        -- üéâ no goals
      ¬∑ simp only [ht] at hm' hn'
        -- ‚ä¢ False
        rw [‚Üê hm'] at hn'
        -- ‚ä¢ False
        exact H (insertNth_injective _ _ hn')
        -- üéâ no goals
      ¬∑ suffices x ‚àà as by exact h x (ha.subset this) rfl
        -- ‚ä¢ x ‚àà as
        rw [‚Üê hx, nthLe_insertNth_of_lt _ _ _ _ ht (ht.trans_le hn)]
        -- ‚ä¢ nthLe as m (_ : m < length as) ‚àà as
        exact nthLe_mem _ _ _
        -- üéâ no goals
#align list.nodup_permutations List.nodup_permutations

-- TODO: `nodup s.permutations ‚Üî nodup s`
-- TODO: `count s s.permutations = (zip_with count s s.tails).prod`
end Permutations

end List
