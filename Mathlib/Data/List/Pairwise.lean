/-
Copyright (c) 2018 Mario Carneiro. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro
-/
import Mathlib.Data.List.Count
import Mathlib.Data.List.Lex
import Mathlib.Logic.Pairwise
import Mathlib.Logic.Relation

#align_import data.list.pairwise from "leanprover-community/mathlib"@"f694c7dead66f5d4c80f446c796a5aad14707f0e"

/-!
# Pairwise relations on a list

This file provides basic results about `List.Pairwise` and `List.pwFilter` (definitions are in
`Data.List.Defs`).
`Pairwise r [a 0, ..., a (n - 1)]` means `‚àÄ i j, i < j ‚Üí r (a i) (a j)`. For example,
`Pairwise (‚â†) l` means that all elements of `l` are distinct, and `Pairwise (<) l` means that `l`
is strictly increasing.
`pwFilter r l` is the list obtained by iteratively adding each element of `l` that doesn't break
the pairwiseness of the list we have so far. It thus yields `l'` a maximal sublist of `l` such that
`Pairwise r l'`.

## Tags

sorted, nodup
-/


open Nat Function

namespace List

variable {Œ± Œ≤ : Type*} {R S T : Œ± ‚Üí Œ± ‚Üí Prop} {a : Œ±} {l : List Œ±}

mk_iff_of_inductive_prop List.Pairwise List.pairwise_iff
#align list.pairwise_iff List.pairwise_iff

/-! ### Pairwise -/

#align list.pairwise.nil List.Pairwise.nil
#align list.pairwise.cons List.Pairwise.cons

theorem rel_of_pairwise_cons (p : (a :: l).Pairwise R) : ‚àÄ {a'}, a' ‚àà l ‚Üí R a a' :=
  (pairwise_cons.1 p).1 _
#align list.rel_of_pairwise_cons List.rel_of_pairwise_cons

theorem Pairwise.of_cons (p : (a :: l).Pairwise R) : Pairwise R l :=
  (pairwise_cons.1 p).2
#align list.pairwise.of_cons List.Pairwise.of_cons

theorem Pairwise.tail : ‚àÄ {l : List Œ±} (_p : Pairwise R l), Pairwise R l.tail
  | [], h => h
  | _ :: _, h => h.of_cons
#align list.pairwise.tail List.Pairwise.tail

theorem Pairwise.drop : ‚àÄ {l : List Œ±} {n : ‚Ñï}, List.Pairwise R l ‚Üí List.Pairwise R (l.drop n)
  | _, 0, h => h
  | [], _ + 1, _ => List.Pairwise.nil
  | a :: l, n + 1, h => by rw [List.drop]; exact Pairwise.drop (pairwise_cons.mp h).right
                           -- ‚ä¢ Pairwise R (List.drop n l)
                                           -- üéâ no goals
#align list.pairwise.drop List.Pairwise.drop

theorem Pairwise.imp_of_mem {S : Œ± ‚Üí Œ± ‚Üí Prop} {l : List Œ±}
    (H : ‚àÄ {a b}, a ‚àà l ‚Üí b ‚àà l ‚Üí R a b ‚Üí S a b) (p : Pairwise R l) : Pairwise S l := by
  induction p with
  | nil => constructor
  | @cons a l r _ ih =>
    constructor
    ¬∑ exact BAll.imp_right (fun x h ‚Ü¶ H (mem_cons_self _ _) (mem_cons_of_mem _ h)) r
    ¬∑ exact ih fun {a b} m m' ‚Ü¶ H (mem_cons_of_mem _ m) (mem_cons_of_mem _ m')
#align list.pairwise.imp_of_mem List.Pairwise.imp_of_mem

#align list.pairwise.imp List.Pairwise.imp‚Çì -- Implicits Order

theorem pairwise_and_iff : (l.Pairwise fun a b => R a b ‚àß S a b) ‚Üî l.Pairwise R ‚àß l.Pairwise S :=
  ‚ü®fun h => ‚ü®h.imp @fun a b h => h.1, h.imp @fun a b h => h.2‚ü©, fun ‚ü®hR, hS‚ü© =>
    by induction' hR with a l R1 R2 IH <;> simp only [Pairwise.nil, pairwise_cons] at *
       -- ‚ä¢ Pairwise (fun a b => R a b ‚àß S a b) []
                                           -- üéâ no goals
                                           -- ‚ä¢ (‚àÄ (a' : Œ±), a' ‚àà l ‚Üí R a a' ‚àß S a a') ‚àß Pairwise (fun a b => R a b ‚àß S a b) l
       exact ‚ü®fun b bl => ‚ü®R1 b bl, hS.1 b bl‚ü©, IH ‚ü®R2, hS.2‚ü© hS.2‚ü©‚ü©
       -- üéâ no goals
#align list.pairwise_and_iff List.pairwise_and_iff

theorem Pairwise.and (hR : l.Pairwise R) (hS : l.Pairwise S) :
    l.Pairwise fun a b => R a b ‚àß S a b :=
  pairwise_and_iff.2 ‚ü®hR, hS‚ü©
#align list.pairwise.and List.Pairwise.and

theorem Pairwise.imp‚ÇÇ (H : ‚àÄ a b, R a b ‚Üí S a b ‚Üí T a b) (hR : l.Pairwise R) (hS : l.Pairwise S) :
    l.Pairwise T :=
  (hR.and hS).imp fun h => (H _ _ h.1 h.2)
#align list.pairwise.imp‚ÇÇ List.Pairwise.imp‚ÇÇ

theorem Pairwise.iff_of_mem {S : Œ± ‚Üí Œ± ‚Üí Prop} {l : List Œ±}
    (H : ‚àÄ {a b}, a ‚àà l ‚Üí b ‚àà l ‚Üí (R a b ‚Üî S a b)) : Pairwise R l ‚Üî Pairwise S l :=
  ‚ü®Pairwise.imp_of_mem fun {_ _} m m' ‚Ü¶ (H m m').1,
   Pairwise.imp_of_mem fun {_ _} m m' ‚Ü¶ (H m m').2‚ü©
#align list.pairwise.iff_of_mem List.Pairwise.iff_of_mem

theorem Pairwise.iff {S : Œ± ‚Üí Œ± ‚Üí Prop} (H : ‚àÄ a b, R a b ‚Üî S a b) {l : List Œ±} :
    Pairwise R l ‚Üî Pairwise S l :=
  Pairwise.iff_of_mem fun _ _ => H _ _
#align list.pairwise.iff List.Pairwise.iff

theorem pairwise_of_forall {l : List Œ±} (H : ‚àÄ x y, R x y) : Pairwise R l := by
  induction l <;> [exact Pairwise.nil; simp only [*, pairwise_cons, forall‚ÇÇ_true_iff, and_true_iff]]
  -- üéâ no goals
#align list.pairwise_of_forall List.pairwise_of_forall

theorem Pairwise.and_mem {l : List Œ±} :
    Pairwise R l ‚Üî Pairwise (fun x y => x ‚àà l ‚àß y ‚àà l ‚àß R x y) l :=
  Pairwise.iff_of_mem
    (by simp (config := { contextual := true }) only [true_and_iff, iff_self_iff, forall‚ÇÇ_true_iff])
        -- üéâ no goals
#align list.pairwise.and_mem List.Pairwise.and_mem

theorem Pairwise.imp_mem {l : List Œ±} :
    Pairwise R l ‚Üî Pairwise (fun x y => x ‚àà l ‚Üí y ‚àà l ‚Üí R x y) l :=
  Pairwise.iff_of_mem
    (by simp (config := { contextual := true }) only [forall_prop_of_true, iff_self_iff,
        forall‚ÇÇ_true_iff])
#align list.pairwise.imp_mem List.Pairwise.imp_mem

#align list.pairwise.sublist List.Pairwise.sublist‚Çì -- Implicits order

theorem Pairwise.forall_of_forall_of_flip (h‚ÇÅ : ‚àÄ x ‚àà l, R x x) (h‚ÇÇ : l.Pairwise R)
    (h‚ÇÉ : l.Pairwise (flip R)) : ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà l ‚Üí ‚àÄ ‚¶Éy‚¶Ñ, y ‚àà l ‚Üí R x y := by
  induction' l with a l ih
  -- ‚ä¢ ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà [] ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà [] ‚Üí R x y
  ¬∑ exact forall_mem_nil _
    -- üéâ no goals
  rw [pairwise_cons] at h‚ÇÇ h‚ÇÉ
  -- ‚ä¢ ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x ‚àà a :: l ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y ‚àà a :: l ‚Üí R x y
  simp only [mem_cons]
  -- ‚ä¢ ‚àÄ ‚¶Éx : Œ±‚¶Ñ, x = a ‚à® x ‚àà l ‚Üí ‚àÄ ‚¶Éy : Œ±‚¶Ñ, y = a ‚à® y ‚àà l ‚Üí R x y
  rintro x (rfl | hx) y (rfl | hy)
  ¬∑ exact h‚ÇÅ _ (l.mem_cons_self _)
    -- üéâ no goals
  ¬∑ exact h‚ÇÇ.1 _ hy
    -- üéâ no goals
  ¬∑ exact h‚ÇÉ.1 _ hx
    -- üéâ no goals
  ¬∑ exact ih (fun x hx => h‚ÇÅ _ <| mem_cons_of_mem _ hx) h‚ÇÇ.2 h‚ÇÉ.2 hx hy
    -- üéâ no goals
#align list.pairwise.forall_of_forall_of_flip List.Pairwise.forall_of_forall_of_flip

theorem Pairwise.forall_of_forall (H : Symmetric R) (H‚ÇÅ : ‚àÄ x ‚àà l, R x x) (H‚ÇÇ : l.Pairwise R) :
    ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà l ‚Üí ‚àÄ ‚¶Éy‚¶Ñ, y ‚àà l ‚Üí R x y :=
  H‚ÇÇ.forall_of_forall_of_flip H‚ÇÅ <| by rwa [H.flip_eq]
                                       -- üéâ no goals
#align list.pairwise.forall_of_forall List.Pairwise.forall_of_forall

theorem Pairwise.forall (hR : Symmetric R) (hl : l.Pairwise R) :
    ‚àÄ ‚¶Éa‚¶Ñ, a ‚àà l ‚Üí ‚àÄ ‚¶Éb‚¶Ñ, b ‚àà l ‚Üí a ‚â† b ‚Üí R a b := by
  apply Pairwise.forall_of_forall
  ¬∑ exact fun a b h hne => hR (h hne.symm)
    -- üéâ no goals
  ¬∑ exact fun _ _ hx => (hx rfl).elim
    -- üéâ no goals
  ¬∑ exact hl.imp (@fun a b h _ => by exact h)
    -- üéâ no goals
#align list.pairwise.forall List.Pairwise.forall

theorem Pairwise.set_pairwise (hl : Pairwise R l) (hr : Symmetric R) : { x | x ‚àà l }.Pairwise R :=
  hl.forall hr
#align list.pairwise.set_pairwise List.Pairwise.set_pairwise

theorem pairwise_singleton (R) (a : Œ±) : Pairwise R [a] := by
  simp [Pairwise.nil]
  -- üéâ no goals
#align list.pairwise_singleton List.pairwise_singleton

theorem pairwise_pair {a b : Œ±} : Pairwise R [a, b] ‚Üî R a b := by
  simp only [pairwise_cons, mem_singleton, forall_eq, forall_prop_of_false (not_mem_nil _),
    forall_true_iff, Pairwise.nil, and_true_iff]
#align list.pairwise_pair List.pairwise_pair

#align list.pairwise_append List.pairwise_append

theorem pairwise_append_comm (s : Symmetric R) {l‚ÇÅ l‚ÇÇ : List Œ±} :
    Pairwise R (l‚ÇÅ ++ l‚ÇÇ) ‚Üî Pairwise R (l‚ÇÇ ++ l‚ÇÅ) := by
  have : ‚àÄ l‚ÇÅ l‚ÇÇ : List Œ±, (‚àÄ x : Œ±, x ‚àà l‚ÇÅ ‚Üí ‚àÄ y : Œ±, y ‚àà l‚ÇÇ ‚Üí R x y) ‚Üí
    ‚àÄ x : Œ±, x ‚àà l‚ÇÇ ‚Üí ‚àÄ y : Œ±, y ‚àà l‚ÇÅ ‚Üí R x y := fun l‚ÇÅ l‚ÇÇ a x xm y ym ‚Ü¶ s (a y ym x xm)
  simp only [pairwise_append, and_left_comm]; rw [Iff.intro (this l‚ÇÅ l‚ÇÇ) (this l‚ÇÇ l‚ÇÅ)]
  -- ‚ä¢ (Pairwise R l‚ÇÅ ‚àß Pairwise R l‚ÇÇ ‚àß ‚àÄ (a : Œ±), a ‚àà l‚ÇÅ ‚Üí ‚àÄ (b : Œ±), b ‚àà l‚ÇÇ ‚Üí R a ‚Ä¶
                                              -- üéâ no goals
#align list.pairwise_append_comm List.pairwise_append_comm

theorem pairwise_middle (s : Symmetric R) {a : Œ±} {l‚ÇÅ l‚ÇÇ : List Œ±} :
    Pairwise R (l‚ÇÅ ++ a :: l‚ÇÇ) ‚Üî Pairwise R (a :: (l‚ÇÅ ++ l‚ÇÇ)) :=
  show Pairwise R (l‚ÇÅ ++ ([a] ++ l‚ÇÇ)) ‚Üî Pairwise R ([a] ++ l‚ÇÅ ++ l‚ÇÇ) by
    rw [‚Üê append_assoc, pairwise_append, @pairwise_append _ _ ([a] ++ l‚ÇÅ), pairwise_append_comm s]
    -- ‚ä¢ (Pairwise R ([a] ++ l‚ÇÅ) ‚àß Pairwise R l‚ÇÇ ‚àß ‚àÄ (a_1 : Œ±), a_1 ‚àà l‚ÇÅ ++ [a] ‚Üí ‚àÄ ( ‚Ä¶
    simp only [mem_append, or_comm]
    -- üéâ no goals
#align list.pairwise_middle List.pairwise_middle

-- Porting note: Duplicate of `pairwise_map` but with `f` explicit.
@[deprecated] theorem pairwise_map' (f : Œ≤ ‚Üí Œ±) :
    ‚àÄ {l : List Œ≤}, Pairwise R (map f l) ‚Üî Pairwise (fun a b : Œ≤ => R (f a) (f b)) l
  | [] => by simp only [map, Pairwise.nil]
             -- üéâ no goals
  | b :: l => by
    simp only [map, pairwise_cons, mem_map, forall_exists_index, and_imp,
      forall_apply_eq_imp_iff‚ÇÇ, pairwise_map]
#align list.pairwise_map List.pairwise_map'

theorem Pairwise.of_map {S : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : Œ± ‚Üí Œ≤) (H : ‚àÄ a b : Œ±, S (f a) (f b) ‚Üí R a b)
    (p : Pairwise S (map f l)) : Pairwise R l :=
  (pairwise_map.1 p).imp (H _ _)
#align list.pairwise.of_map List.Pairwise.of_map

theorem Pairwise.map {S : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : Œ± ‚Üí Œ≤) (H : ‚àÄ a b : Œ±, R a b ‚Üí S (f a) (f b))
    (p : Pairwise R l) : Pairwise S (map f l) :=
  pairwise_map.2 <| p.imp (H _ _)
#align list.pairwise.map List.Pairwise.map

theorem pairwise_filterMap (f : Œ≤ ‚Üí Option Œ±) {l : List Œ≤} :
    Pairwise R (filterMap f l) ‚Üî Pairwise (fun a a' : Œ≤ => ‚àÄ b ‚àà f a, ‚àÄ b' ‚àà f a', R b b') l := by
  let _S (a a' : Œ≤) := ‚àÄ b ‚àà f a, ‚àÄ b' ‚àà f a', R b b'
  -- ‚ä¢ Pairwise R (filterMap f l) ‚Üî Pairwise (fun a a' => ‚àÄ (b : Œ±), b ‚àà f a ‚Üí ‚àÄ (b ‚Ä¶
  simp only [Option.mem_def]; induction' l with a l IH
  -- ‚ä¢ Pairwise R (filterMap f l) ‚Üî Pairwise (fun a a' => ‚àÄ (b : Œ±), f a = some b ‚Üí ‚Ä¶
                              -- ‚ä¢ Pairwise R (filterMap f []) ‚Üî Pairwise (fun a a' => ‚àÄ (b : Œ±), f a = some b  ‚Ä¶
  ¬∑ simp only [filterMap, Pairwise.nil]
    -- üéâ no goals
  cases' e : f a with b
  -- ‚ä¢ Pairwise R (filterMap f (a :: l)) ‚Üî Pairwise (fun a a' => ‚àÄ (b : Œ±), f a = s ‚Ä¶
  ¬∑ --Porting note: Why do I need `propext IH` here?
    rw [filterMap_cons_none _ _ e, propext IH, pairwise_cons]
    -- ‚ä¢ Pairwise (fun a a' => ‚àÄ (b : Œ±), f a = some b ‚Üí ‚àÄ (b' : Œ±), f a' = some b' ‚Üí ‚Ä¶
    simp only [e, forall_prop_of_false not_false, forall‚ÇÉ_true_iff, true_and_iff]
    -- üéâ no goals
  rw [filterMap_cons_some _ _ _ e]
  -- ‚ä¢ Pairwise R (b :: filterMap f l) ‚Üî Pairwise (fun a a' => ‚àÄ (b : Œ±), f a = som ‚Ä¶
  simp only [pairwise_cons, mem_filterMap, forall_exists_index, and_imp, IH, e, Option.some.injEq,
    forall_eq', and_congr_left_iff]
  intro _
  -- ‚ä¢ (‚àÄ (a' : Œ±) (x : Œ≤), x ‚àà l ‚Üí f x = some a' ‚Üí R b a') ‚Üî ‚àÄ (a' : Œ≤), a' ‚àà l ‚Üí  ‚Ä¶
  exact ‚ü®fun h a ha b hab => h _ _ ha hab, fun h a b ha hab => h _ ha _ hab‚ü©
  -- üéâ no goals
#align list.pairwise_filter_map List.pairwise_filterMap

theorem Pairwise.filter_map {S : Œ≤ ‚Üí Œ≤ ‚Üí Prop} (f : Œ± ‚Üí Option Œ≤)
    (H : ‚àÄ a a' : Œ±, R a a' ‚Üí ‚àÄ b ‚àà f a, ‚àÄ b' ‚àà f a', S b b') {l : List Œ±} (p : Pairwise R l) :
    Pairwise S (filterMap f l) :=
  (pairwise_filterMap _).2 <| p.imp (H _ _)
#align list.pairwise.filter_map List.Pairwise.filter_map

theorem pairwise_filter (p : Œ± ‚Üí Prop) [DecidablePred p] {l : List Œ±} :
    Pairwise R (filter p l) ‚Üî Pairwise (fun x y => p x ‚Üí p y ‚Üí R x y) l := by
  rw [‚Üê filterMap_eq_filter, pairwise_filterMap]
  -- ‚ä¢ Pairwise (fun a a' => ‚àÄ (b : Œ±), b ‚àà Option.guard (fun x => decide (p x) = t ‚Ä¶
  apply Pairwise.iff; intros
  -- ‚ä¢ ‚àÄ (a b : Œ±), (‚àÄ (b_1 : Œ±), b_1 ‚àà Option.guard (fun x => decide (p x) = true) ‚Ä¶
                      -- ‚ä¢ (‚àÄ (b : Œ±), b ‚àà Option.guard (fun x => decide (p x) = true) a‚úù ‚Üí ‚àÄ (b' : Œ±), ‚Ä¶
  simp only [decide_eq_true_eq, Option.mem_def, Option.guard_eq_some, and_imp, forall_eq']
  -- üéâ no goals
#align list.pairwise_filter List.pairwise_filter

--Porting note: changed Prop to Bool
theorem Pairwise.filter (p : Œ± ‚Üí Bool) : Pairwise R l ‚Üí Pairwise R (filter p l) :=
  Pairwise.sublist (filter_sublist _)
#align list.pairwise.filter List.Pairwise.filter‚Çì

theorem pairwise_pmap {p : Œ≤ ‚Üí Prop} {f : ‚àÄ b, p b ‚Üí Œ±} {l : List Œ≤} (h : ‚àÄ x ‚àà l, p x) :
    Pairwise R (l.pmap f h) ‚Üî
      Pairwise (fun b‚ÇÅ b‚ÇÇ => ‚àÄ (h‚ÇÅ : p b‚ÇÅ) (h‚ÇÇ : p b‚ÇÇ), R (f b‚ÇÅ h‚ÇÅ) (f b‚ÇÇ h‚ÇÇ)) l := by
  induction' l with a l ihl
  -- ‚ä¢ Pairwise R (pmap f [] h) ‚Üî Pairwise (fun b‚ÇÅ b‚ÇÇ => ‚àÄ (h‚ÇÅ : p b‚ÇÅ) (h‚ÇÇ : p b‚ÇÇ), ‚Ä¶
  ¬∑ simp
    -- üéâ no goals
  obtain ‚ü®_, hl‚ü© : p a ‚àß ‚àÄ b, b ‚àà l ‚Üí p b := by simpa using h
  -- ‚ä¢ Pairwise R (pmap f (a :: l) h) ‚Üî Pairwise (fun b‚ÇÅ b‚ÇÇ => ‚àÄ (h‚ÇÅ : p b‚ÇÅ) (h‚ÇÇ :  ‚Ä¶
  simp only [ihl hl, pairwise_cons, bex_imp, pmap, and_congr_left_iff, mem_pmap]
  -- ‚ä¢ Pairwise (fun b‚ÇÅ b‚ÇÇ => ‚àÄ (h‚ÇÅ : p b‚ÇÅ) (h‚ÇÇ : p b‚ÇÇ), R (f b‚ÇÅ h‚ÇÅ) (f b‚ÇÇ h‚ÇÇ)) l ‚Üí ‚Ä¶
  refine' fun _ => ‚ü®fun H b hb _ hpb => H _ _ hb rfl, _‚ü©
  -- ‚ä¢ (‚àÄ (a' : Œ≤), a' ‚àà l ‚Üí ‚àÄ (h‚ÇÅ : p a) (h‚ÇÇ : p a'), R (f a h‚ÇÅ) (f a' h‚ÇÇ)) ‚Üí ‚àÄ (a ‚Ä¶
  rintro H _ b hb rfl
  -- ‚ä¢ R (f a (_ : p a)) (f b (_ : p b))
  exact H b hb _ _
  -- üéâ no goals
#align list.pairwise_pmap List.pairwise_pmap

theorem Pairwise.pmap {l : List Œ±} (hl : Pairwise R l) {p : Œ± ‚Üí Prop} {f : ‚àÄ a, p a ‚Üí Œ≤}
    (h : ‚àÄ x ‚àà l, p x) {S : Œ≤ ‚Üí Œ≤ ‚Üí Prop}
    (hS : ‚àÄ ‚¶Éx‚¶Ñ (hx : p x) ‚¶Éy‚¶Ñ (hy : p y), R x y ‚Üí S (f x hx) (f y hy)) :
    Pairwise S (l.pmap f h) := by
  refine' (pairwise_pmap h).2 (Pairwise.imp_of_mem _ hl)
  -- ‚ä¢ ‚àÄ {a b : Œ±}, a ‚àà l ‚Üí b ‚àà l ‚Üí R a b ‚Üí ‚àÄ (h‚ÇÅ : p a) (h‚ÇÇ : p b), S (f a h‚ÇÅ) (f  ‚Ä¶
  intros; apply hS; assumption
  -- ‚ä¢ S (f a‚úù¬≥ h‚ÇÅ‚úù) (f b‚úù h‚ÇÇ‚úù)
          -- ‚ä¢ R a‚úù¬≥ b‚úù
                    -- üéâ no goals
#align list.pairwise.pmap List.Pairwise.pmap

theorem pairwise_join {L : List (List Œ±)} :
    Pairwise R (join L) ‚Üî
      (‚àÄ l ‚àà L, Pairwise R l) ‚àß Pairwise (fun l‚ÇÅ l‚ÇÇ => ‚àÄ x ‚àà l‚ÇÅ, ‚àÄ y ‚àà l‚ÇÇ, R x y) L := by
  induction' L with l L IH
  -- ‚ä¢ Pairwise R (join []) ‚Üî (‚àÄ (l : List Œ±), l ‚àà [] ‚Üí Pairwise R l) ‚àß Pairwise (f ‚Ä¶
  ¬∑ simp only [join, Pairwise.nil, forall_prop_of_false (not_mem_nil _), forall_const, and_self_iff]
    -- üéâ no goals
  have :
    (‚àÄ x : Œ±, x ‚àà l ‚Üí ‚àÄ (y : Œ±) (x_1 : List Œ±), x_1 ‚àà L ‚Üí y ‚àà x_1 ‚Üí R x y) ‚Üî
      ‚àÄ a' : List Œ±, a' ‚àà L ‚Üí ‚àÄ x : Œ±, x ‚àà l ‚Üí ‚àÄ y : Œ±, y ‚àà a' ‚Üí R x y :=
    ‚ü®fun h a b c d e => h c d e a b, fun h c d e a b => h a b c d e‚ü©
  simp only [join, pairwise_append, IH, mem_join, exists_imp, and_imp, this, forall_mem_cons,
    pairwise_cons]
  simp only [and_assoc, and_comm, and_left_comm]
  -- üéâ no goals
#align list.pairwise_join List.pairwise_join

theorem pairwise_bind {R : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {l : List Œ±} {f : Œ± ‚Üí List Œ≤} :
    List.Pairwise R (l.bind f) ‚Üî
      (‚àÄ a ‚àà l, Pairwise R (f a)) ‚àß Pairwise (fun a‚ÇÅ a‚ÇÇ => ‚àÄ x ‚àà f a‚ÇÅ, ‚àÄ y ‚àà f a‚ÇÇ, R x y) l :=
  by simp [List.bind, List.pairwise_join, List.mem_map, List.pairwise_map]
     -- üéâ no goals
#align list.pairwise_bind List.pairwise_bind

#align list.pairwise_reverse List.pairwise_reverse

theorem pairwise_of_reflexive_on_dupl_of_forall_ne [DecidableEq Œ±] {l : List Œ±} {r : Œ± ‚Üí Œ± ‚Üí Prop}
    (hr : ‚àÄ a, 1 < count a l ‚Üí r a a) (h : ‚àÄ a ‚àà l, ‚àÄ b ‚àà l, a ‚â† b ‚Üí r a b) : l.Pairwise r := by
  induction' l with hd tl IH
  -- ‚ä¢ Pairwise r []
  ¬∑ simp
    -- üéâ no goals
  ¬∑ rw [List.pairwise_cons]
    -- ‚ä¢ (‚àÄ (a' : Œ±), a' ‚àà tl ‚Üí r hd a') ‚àß Pairwise r tl
    constructor
    -- ‚ä¢ ‚àÄ (a' : Œ±), a' ‚àà tl ‚Üí r hd a'
    ¬∑ intro x hx
      -- ‚ä¢ r hd x
      by_cases H : hd = x
      -- ‚ä¢ r hd x
      ¬∑ rw [H]
        -- ‚ä¢ r x x
        refine' hr _ _
        -- ‚ä¢ 1 < count x (hd :: tl)
        simpa [count_cons, H, Nat.succ_lt_succ_iff, count_pos_iff_mem] using hx
        -- üéâ no goals
      ¬∑ exact h hd (mem_cons_self _ _) x (mem_cons_of_mem _ hx) H
        -- üéâ no goals
    ¬∑ refine' IH _ _
      -- ‚ä¢ ‚àÄ (a : Œ±), 1 < count a tl ‚Üí r a a
      ¬∑ intro x hx
        -- ‚ä¢ r x x
        refine' hr _ _
        -- ‚ä¢ 1 < count x (hd :: tl)
        rw [count_cons]
        -- ‚ä¢ 1 < count x tl + if x = hd then 1 else 0
        split_ifs
        -- ‚ä¢ 1 < count x tl + 1
        ¬∑ exact hx.trans (Nat.lt_succ_self _)
          -- üéâ no goals
        ¬∑ exact hx
          -- üéâ no goals
      ¬∑ intro x hx y hy
        -- ‚ä¢ x ‚â† y ‚Üí r x y
        exact h x (mem_cons_of_mem _ hx) y (mem_cons_of_mem _ hy)
        -- üéâ no goals
#align list.pairwise_of_reflexive_on_dupl_of_forall_ne List.pairwise_of_reflexive_on_dupl_of_forall_ne

theorem pairwise_of_forall_mem_list {l : List Œ±} {r : Œ± ‚Üí Œ± ‚Üí Prop} (h : ‚àÄ a ‚àà l, ‚àÄ b ‚àà l, r a b) :
    l.Pairwise r := by
  classical
    refine'
      pairwise_of_reflexive_on_dupl_of_forall_ne (fun a ha' => _) fun a ha b hb _ => h a ha b hb
    have ha := List.count_pos_iff_mem.1 ha'.le
    exact h a ha a ha
#align list.pairwise_of_forall_mem_list List.pairwise_of_forall_mem_list

theorem pairwise_of_reflexive_of_forall_ne {l : List Œ±} {r : Œ± ‚Üí Œ± ‚Üí Prop} (hr : Reflexive r)
    (h : ‚àÄ a ‚àà l, ‚àÄ b ‚àà l, a ‚â† b ‚Üí r a b) : l.Pairwise r := by
  classical exact pairwise_of_reflexive_on_dupl_of_forall_ne (fun _ _ => hr _) h
  -- üéâ no goals
#align list.pairwise_of_reflexive_of_forall_ne List.pairwise_of_reflexive_of_forall_ne

theorem pairwise_iff_get : ‚àÄ {l : List Œ±}, Pairwise R l ‚Üî
    ‚àÄ (i j) (_hij : i < j), R (get l i) (get l j)
  | [] => by
    simp only [Pairwise.nil, true_iff_iff]; exact fun i j _h => (Nat.not_lt_zero j).elim j.2
    -- ‚ä¢ ‚àÄ (i j : Fin (length [])), i < j ‚Üí R (get [] i) (get [] j)
                                            -- üéâ no goals
  | a :: l => by
    rw [pairwise_cons, pairwise_iff_get]
    -- ‚ä¢ ((‚àÄ (a' : Œ±), a' ‚àà l ‚Üí R a a') ‚àß ‚àÄ (i j : Fin (length l)), i < j ‚Üí R (get l  ‚Ä¶
    refine'
      ‚ü®fun H i j hij => _, fun H =>
        ‚ü®fun a' m => _, fun i j hij => _‚ü©‚ü©
    ¬∑ cases' j with j hj
      -- ‚ä¢ R (get (a :: l) i) (get (a :: l) { val := j, isLt := hj })
      cases' j with j
      -- ‚ä¢ R (get (a :: l) i) (get (a :: l) { val := zero, isLt := hj })
      ¬∑ exact (Nat.not_lt_zero _).elim hij
        -- üéâ no goals
      cases' i with i hi
      -- ‚ä¢ R (get (a :: l) { val := i, isLt := hi }) (get (a :: l) { val := succ j, isL ‚Ä¶
      cases' i with i
      -- ‚ä¢ R (get (a :: l) { val := zero, isLt := hi }) (get (a :: l) { val := succ j,  ‚Ä¶
      ¬∑ exact H.1 _ (get_mem l _ _)
        -- üéâ no goals
      ¬∑ exact H.2 _ _ (Nat.lt_of_succ_lt_succ hij)
        -- üéâ no goals
    ¬∑ rcases get_of_mem m with ‚ü®n, h, rfl‚ü©
      -- ‚ä¢ R a (get l n)
      have := H ‚ü®0, show 0 < (a::l).length from Nat.succ_pos _‚ü© ‚ü®n.succ, Nat.succ_lt_succ n.2‚ü©
        (Nat.succ_pos n)
      simpa
      -- üéâ no goals
    ¬∑ simpa using H i.succ j.succ (show i.1.succ < j.1.succ from Nat.succ_lt_succ hij)
      -- üéâ no goals

set_option linter.deprecated false in
@[deprecated pairwise_iff_get]
theorem pairwise_iff_nthLe {R} {l : List Œ±} : Pairwise R l ‚Üî
    ‚àÄ (i j) (h‚ÇÅ : j < length l) (h‚ÇÇ : i < j), R (nthLe l i (lt_trans h‚ÇÇ h‚ÇÅ)) (nthLe l j h‚ÇÅ) :=
  pairwise_iff_get.trans
    ‚ü®fun h i j _ h‚ÇÇ => h ‚ü®i, _‚ü© ‚ü®j, _‚ü© h‚ÇÇ,
     fun h i j hij => h i j _ hij‚ü©
#align list.pairwise_iff_nth_le List.pairwise_iff_nthLe

theorem pairwise_replicate {Œ± : Type*} {r : Œ± ‚Üí Œ± ‚Üí Prop} {x : Œ±} (hx : r x x) :
    ‚àÄ n : ‚Ñï, Pairwise r (List.replicate n x)
  | 0 => by simp
            -- üéâ no goals
  | n + 1 => by simp only [replicate, add_eq, add_zero, pairwise_cons, mem_replicate, ne_eq,
    and_imp, forall_eq_apply_imp_iff', hx, implies_true, pairwise_replicate hx n, and_self]
#align list.pairwise_replicate List.pairwise_replicate

/-! ### Pairwise filtering -/


variable [DecidableRel R]

@[simp]
theorem pwFilter_nil : pwFilter R [] = [] :=
  rfl
#align list.pw_filter_nil List.pwFilter_nil

@[simp]
theorem pwFilter_cons_of_pos {a : Œ±} {l : List Œ±} (h : ‚àÄ b ‚àà pwFilter R l, R a b) :
    pwFilter R (a :: l) = a :: pwFilter R l :=
  if_pos h
#align list.pw_filter_cons_of_pos List.pwFilter_cons_of_pos

@[simp]
theorem pwFilter_cons_of_neg {a : Œ±} {l : List Œ±} (h : ¬¨‚àÄ b ‚àà pwFilter R l, R a b) :
    pwFilter R (a :: l) = pwFilter R l :=
  if_neg h
#align list.pw_filter_cons_of_neg List.pwFilter_cons_of_neg

theorem pwFilter_map (f : Œ≤ ‚Üí Œ±) :
    ‚àÄ l : List Œ≤, pwFilter R (map f l) = map f (pwFilter (fun x y => R (f x) (f y)) l)
  | [] => rfl
  | x :: xs =>
    if h : ‚àÄ b ‚àà pwFilter R (map f xs), R (f x) b then by
      have h' : ‚àÄ b : Œ≤, b ‚àà pwFilter (fun x y : Œ≤ => R (f x) (f y)) xs ‚Üí R (f x) (f b) :=
        fun b hb => h _ (by rw [pwFilter_map f xs]; apply mem_map_of_mem _ hb)
      rw [map, pwFilter_cons_of_pos h, pwFilter_cons_of_pos h', pwFilter_map f xs, map]
      -- üéâ no goals
    else by
      have h' : ¬¨‚àÄ b : Œ≤, b ‚àà pwFilter (fun x y : Œ≤ => R (f x) (f y)) xs ‚Üí R (f x) (f b) :=
        fun hh =>
        h fun a ha => by
          rw [pwFilter_map f xs, mem_map] at ha
          rcases ha with ‚ü®b, hb‚ÇÄ, hb‚ÇÅ‚ü©
          subst a
          exact hh _ hb‚ÇÄ
      rw [map, pwFilter_cons_of_neg h, pwFilter_cons_of_neg h', pwFilter_map f xs]
      -- üéâ no goals
#align list.pw_filter_map List.pwFilter_map

theorem pwFilter_sublist : ‚àÄ l : List Œ±, pwFilter R l <+ l
  | [] => nil_sublist _
  | x :: l => by
    by_cases h : ‚àÄ y ‚àà pwFilter R l, R x y
    -- ‚ä¢ pwFilter R (x :: l) <+ x :: l
    ¬∑ rw [pwFilter_cons_of_pos h]
      -- ‚ä¢ x :: pwFilter R l <+ x :: l
      exact (pwFilter_sublist l).cons_cons _
      -- üéâ no goals
    ¬∑ rw [pwFilter_cons_of_neg h]
      -- ‚ä¢ pwFilter R l <+ x :: l
      exact sublist_cons_of_sublist _ (pwFilter_sublist l)
      -- üéâ no goals
#align list.pw_filter_sublist List.pwFilter_sublist

theorem pwFilter_subset (l : List Œ±) : pwFilter R l ‚äÜ l :=
  (pwFilter_sublist _).subset
#align list.pw_filter_subset List.pwFilter_subset

theorem pairwise_pwFilter : ‚àÄ l : List Œ±, Pairwise R (pwFilter R l)
  | [] => Pairwise.nil
  | x :: l => by
    by_cases h : ‚àÄ y ‚àà pwFilter R l, R x y
    -- ‚ä¢ Pairwise R (pwFilter R (x :: l))
    ¬∑ rw [pwFilter_cons_of_pos h]
      -- ‚ä¢ Pairwise R (x :: pwFilter R l)
      exact pairwise_cons.2 ‚ü®h, pairwise_pwFilter l‚ü©
      -- üéâ no goals
    ¬∑ rw [pwFilter_cons_of_neg h]
      -- ‚ä¢ Pairwise R (pwFilter R l)
      exact pairwise_pwFilter l
      -- üéâ no goals
#align list.pairwise_pw_filter List.pairwise_pwFilter

theorem pwFilter_eq_self {l : List Œ±} : pwFilter R l = l ‚Üî Pairwise R l :=
  ‚ü®fun e => e ‚ñ∏ pairwise_pwFilter l, fun p => by
    induction' l with x l IH; ¬∑ rfl
    -- ‚ä¢ pwFilter R [] = []
                                -- üéâ no goals
    cases' pairwise_cons.1 p with al p
    -- ‚ä¢ pwFilter R (x :: l) = x :: l
    rw [pwFilter_cons_of_pos (BAll.imp_left (pwFilter_subset l) al), IH p]‚ü©
    -- üéâ no goals
#align list.pw_filter_eq_self List.pwFilter_eq_self

alias ‚ü®_, Pairwise.pwFilter‚ü© := pwFilter_eq_self
#align list.pairwise.pw_filter List.Pairwise.pwFilter

-- Porting note: commented out
-- attribute [protected] List.Pairwise.pwFilter

@[simp]
theorem pwFilter_idempotent : pwFilter R (pwFilter R l) = pwFilter R l :=
  (pairwise_pwFilter l).pwFilter
#align list.pw_filter_idempotent List.pwFilter_idempotent

theorem forall_mem_pwFilter (neg_trans : ‚àÄ {x y z}, R x z ‚Üí R x y ‚à® R y z) (a : Œ±) (l : List Œ±) :
    (‚àÄ b ‚àà pwFilter R l, R a b) ‚Üî ‚àÄ b ‚àà l, R a b :=
  ‚ü®by
    induction' l with x l IH; ¬∑ exact fun _ _ h => (not_mem_nil _ h).elim
    -- ‚ä¢ (‚àÄ (b : Œ±), b ‚àà pwFilter R [] ‚Üí R a b) ‚Üí ‚àÄ (b : Œ±), b ‚àà [] ‚Üí R a b
                                -- üéâ no goals
    simp only [forall_mem_cons]
    -- ‚ä¢ (‚àÄ (b : Œ±), b ‚àà pwFilter R (x :: l) ‚Üí R a b) ‚Üí R a x ‚àß ‚àÄ (x : Œ±), x ‚àà l ‚Üí R  ‚Ä¶
    by_cases h : ‚àÄ y ‚àà pwFilter R l, R x y
    -- ‚ä¢ (‚àÄ (b : Œ±), b ‚àà pwFilter R (x :: l) ‚Üí R a b) ‚Üí R a x ‚àß ‚àÄ (x : Œ±), x ‚àà l ‚Üí R  ‚Ä¶
    ¬∑ simp only [pwFilter_cons_of_pos h, forall_mem_cons, and_imp]
      -- ‚ä¢ R a x ‚Üí (‚àÄ (x : Œ±), x ‚àà pwFilter R l ‚Üí R a x) ‚Üí R a x ‚àß ‚àÄ (x : Œ±), x ‚àà l ‚Üí R ‚Ä¶
      exact fun r H => ‚ü®r, IH H‚ü©
      -- üéâ no goals
    ¬∑ rw [pwFilter_cons_of_neg h]
      -- ‚ä¢ (‚àÄ (b : Œ±), b ‚àà pwFilter R l ‚Üí R a b) ‚Üí R a x ‚àß ‚àÄ (x : Œ±), x ‚àà l ‚Üí R a x
      refine' fun H => ‚ü®_, IH H‚ü©
      -- ‚ä¢ R a x
      cases' e : find? (fun y => ¬¨R x y) (pwFilter R l) with k
      -- ‚ä¢ R a x
      ¬∑ refine' h.elim (BAll.imp_right _ (find?_eq_none.1 e))
        -- ‚ä¢ ‚àÄ (x_1 : Œ±), x_1 ‚àà pwFilter R l ‚Üí ¬¨(decide ¬¨R x x_1) = true ‚Üí R x x_1
        exact fun y _ => by simp
        -- üéâ no goals
      ¬∑ have := find?_some e
        -- ‚ä¢ R a x
        exact (neg_trans (H k (find?_mem e))).resolve_right (by simpa),
        -- üéâ no goals
          BAll.imp_left (pwFilter_subset l)‚ü©
#align list.forall_mem_pw_filter List.forall_mem_pwFilter

end List
