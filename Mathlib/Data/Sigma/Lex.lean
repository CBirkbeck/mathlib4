/-
Copyright (c) 2021 Ya√´l Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Ya√´l Dillies
-/
import Mathlib.Data.Sigma.Basic
import Mathlib.Order.RelClasses

#align_import data.sigma.lex from "leanprover-community/mathlib"@"41cf0cc2f528dd40a8f2db167ea4fb37b8fde7f3"

/-!
# Lexicographic order on a sigma type

This defines the lexicographical order of two arbitrary relations on a sigma type and proves some
lemmas about `PSigma.Lex`, which is defined in core Lean.

Given a relation in the index type and a relation on each summand, the lexicographical order on the
sigma type relates `a` and `b` if their summands are related or they are in the same summand and
related by the summand's relation.

## See also

Related files are:
* `Combinatorics.CoLex`: Colexicographic order on finite sets.
* `Data.List.Lex`: Lexicographic order on lists.
* `Data.Sigma.Order`: Lexicographic order on `Œ£ i, Œ± i` per say.
* `Data.PSigma.Order`: Lexicographic order on `Œ£' i, Œ± i`.
* `Data.Prod.Lex`: Lexicographic order on `Œ± √ó Œ≤`. Can be thought of as the special case of
  `Sigma.Lex` where all summands are the same
-/


namespace Sigma

variable {Œπ : Type*} {Œ± : Œπ ‚Üí Type*} {r r‚ÇÅ r‚ÇÇ : Œπ ‚Üí Œπ ‚Üí Prop} {s s‚ÇÅ s‚ÇÇ : ‚àÄ i, Œ± i ‚Üí Œ± i ‚Üí Prop}
  {a b : Œ£ i, Œ± i}

/-- The lexicographical order on a sigma type. It takes in a relation on the index type and a
relation for each summand. `a` is related to `b` iff their summands are related or they are in the
same summand and are related through the summand's relation. -/
inductive Lex (r : Œπ ‚Üí Œπ ‚Üí Prop) (s : ‚àÄ i, Œ± i ‚Üí Œ± i ‚Üí Prop) : ‚àÄ _ _ : Œ£ i, Œ± i, Prop
  | left {i j : Œπ} (a : Œ± i) (b : Œ± j) : r i j ‚Üí Lex r s ‚ü®i, a‚ü© ‚ü®j, b‚ü©
  | right {i : Œπ} (a b : Œ± i) : s i a b ‚Üí Lex r s ‚ü®i, a‚ü© ‚ü®i, b‚ü©
#align sigma.lex Sigma.Lex

theorem lex_iff : Lex r s a b ‚Üî r a.1 b.1 ‚à® ‚àÉ h : a.1 = b.1, s b.1 (h.rec a.2) b.2 := by
  constructor
  -- ‚ä¢ Lex r s a b ‚Üí r a.fst b.fst ‚à® ‚àÉ h, s b.fst (h ‚ñ∏ a.snd) b.snd
  ¬∑ rintro (‚ü®a, b, hij‚ü© | ‚ü®a, b, hab‚ü©)
    -- ‚ä¢ r { fst := i‚úù, snd := a }.fst { fst := j‚úù, snd := b }.fst ‚à® ‚àÉ h, s { fst :=  ‚Ä¶
    ¬∑ exact Or.inl hij
      -- üéâ no goals
    ¬∑ exact Or.inr ‚ü®rfl, hab‚ü©
      -- üéâ no goals
  ¬∑ obtain ‚ü®i, a‚ü© := a
    -- ‚ä¢ (r { fst := i, snd := a }.fst b.fst ‚à® ‚àÉ h, s b.fst (h ‚ñ∏ { fst := i, snd := a ‚Ä¶
    obtain ‚ü®j, b‚ü© := b
    -- ‚ä¢ (r { fst := i, snd := a }.fst { fst := j, snd := b }.fst ‚à® ‚àÉ h, s { fst := j ‚Ä¶
    dsimp only
    -- ‚ä¢ (r i j ‚à® ‚àÉ h, s j (h ‚ñ∏ a) b) ‚Üí Lex r s { fst := i, snd := a } { fst := j, sn ‚Ä¶
    rintro (h | ‚ü®rfl, h‚ü©)
    -- ‚ä¢ Lex r s { fst := i, snd := a } { fst := j, snd := b }
    ¬∑ exact Lex.left _ _ h
      -- üéâ no goals
    ¬∑ exact Lex.right _ _ h
      -- üéâ no goals
#align sigma.lex_iff Sigma.lex_iff

instance Lex.decidable (r : Œπ ‚Üí Œπ ‚Üí Prop) (s : ‚àÄ i, Œ± i ‚Üí Œ± i ‚Üí Prop) [DecidableEq Œπ]
    [DecidableRel r] [‚àÄ i, DecidableRel (s i)] : DecidableRel (Lex r s) := fun _ _ =>
  decidable_of_decidable_of_iff lex_iff.symm
#align sigma.lex.decidable Sigma.Lex.decidable

theorem Lex.mono (hr : ‚àÄ a b, r‚ÇÅ a b ‚Üí r‚ÇÇ a b) (hs : ‚àÄ i a b, s‚ÇÅ i a b ‚Üí s‚ÇÇ i a b) {a b : Œ£ i, Œ± i}
    (h : Lex r‚ÇÅ s‚ÇÅ a b) : Lex r‚ÇÇ s‚ÇÇ a b := by
  obtain ‚ü®a, b, hij‚ü© | ‚ü®a, b, hab‚ü© := h
  -- ‚ä¢ Lex r‚ÇÇ s‚ÇÇ { fst := i‚úù, snd := a } { fst := j‚úù, snd := b }
  ¬∑ exact Lex.left _ _ (hr _ _ hij)
    -- üéâ no goals
  ¬∑ exact Lex.right _ _ (hs _ _ _ hab)
    -- üéâ no goals
#align sigma.lex.mono Sigma.Lex.mono

theorem Lex.mono_left (hr : ‚àÄ a b, r‚ÇÅ a b ‚Üí r‚ÇÇ a b) {a b : Œ£ i, Œ± i} (h : Lex r‚ÇÅ s a b) :
    Lex r‚ÇÇ s a b :=
  h.mono hr $ fun _ _ _ => id
#align sigma.lex.mono_left Sigma.Lex.mono_left

theorem Lex.mono_right (hs : ‚àÄ i a b, s‚ÇÅ i a b ‚Üí s‚ÇÇ i a b) {a b : Œ£ i, Œ± i} (h : Lex r s‚ÇÅ a b) :
    Lex r s‚ÇÇ a b :=
  h.mono (fun _ _ => id) hs
#align sigma.lex.mono_right Sigma.Lex.mono_right

theorem lex_swap : Lex (Function.swap r) s a b ‚Üî Lex r (fun i => Function.swap (s i)) b a := by
  constructor <;>
  -- ‚ä¢ Lex (Function.swap r) s a b ‚Üí Lex r (fun i => Function.swap (s i)) b a
    ¬∑ rintro (‚ü®a, b, h‚ü© | ‚ü®a, b, h‚ü©)
      -- ‚ä¢ Lex r (fun i => Function.swap (s i)) { fst := j‚úù, snd := b } { fst := i‚úù, sn ‚Ä¶
      -- ‚ä¢ Lex (Function.swap r) s { fst := j‚úù, snd := b } { fst := i‚úù, snd := a }
      -- üéâ no goals
      exacts [Lex.left _ _ h, Lex.right _ _ h]
      -- üéâ no goals
#align sigma.lex_swap Sigma.lex_swap

instance [‚àÄ i, IsRefl (Œ± i) (s i)] : IsRefl _ (Lex r s) :=
  ‚ü®fun ‚ü®_, _‚ü© => Lex.right _ _ $ refl _‚ü©

instance [IsIrrefl Œπ r] [‚àÄ i, IsIrrefl (Œ± i) (s i)] : IsIrrefl _ (Lex r s) :=
  ‚ü®by
    rintro _ (‚ü®a, b, hi‚ü© | ‚ü®a, b, ha‚ü©)
    -- ‚ä¢ False
    ¬∑ exact irrefl _ hi
      -- üéâ no goals
    ¬∑ exact irrefl _ ha
      -- üéâ no goals
      ‚ü©

instance [IsTrans Œπ r] [‚àÄ i, IsTrans (Œ± i) (s i)] : IsTrans _ (Lex r s) :=
  ‚ü®by
    rintro _ _ _ (‚ü®a, b, hij‚ü© | ‚ü®a, b, hab‚ü©) (‚ü®_, c, hk‚ü© | ‚ü®_, c, hc‚ü©)
    ¬∑ exact Lex.left _ _ (_root_.trans hij hk)
      -- üéâ no goals
    ¬∑ exact Lex.left _ _ hij
      -- üéâ no goals
    ¬∑ exact Lex.left _ _ hk
      -- üéâ no goals
    ¬∑ exact Lex.right _ _ (_root_.trans hab hc)‚ü©
      -- üéâ no goals

instance [IsSymm Œπ r] [‚àÄ i, IsSymm (Œ± i) (s i)] : IsSymm _ (Lex r s) :=
  ‚ü®by
    rintro _ _ (‚ü®a, b, hij‚ü© | ‚ü®a, b, hab‚ü©)
    -- ‚ä¢ Lex r s { fst := j‚úù, snd := b } { fst := i‚úù, snd := a }
    ¬∑ exact Lex.left _ _ (symm hij)
      -- üéâ no goals
    ¬∑ exact Lex.right _ _ (symm hab)
      -- üéâ no goals
      ‚ü©

attribute [local instance] IsAsymm.isIrrefl

instance [IsAsymm Œπ r] [‚àÄ i, IsAntisymm (Œ± i) (s i)] : IsAntisymm _ (Lex r s) :=
  ‚ü®by
    rintro _ _ (‚ü®a, b, hij‚ü© | ‚ü®a, b, hab‚ü©) (‚ü®_, _, hji‚ü© | ‚ü®_, _, hba‚ü©)
    ¬∑ exact (asymm hij hji).elim
      -- üéâ no goals
    ¬∑ exact (irrefl _ hij).elim
      -- üéâ no goals
    ¬∑ exact (irrefl _ hji).elim
      -- üéâ no goals
    ¬∑ exact ext rfl (heq_of_eq $ antisymm hab hba)‚ü©
      -- üéâ no goals

instance [IsTrichotomous Œπ r] [‚àÄ i, IsTotal (Œ± i) (s i)] : IsTotal _ (Lex r s) :=
  ‚ü®by
    rintro ‚ü®i, a‚ü© ‚ü®j, b‚ü©
    -- ‚ä¢ Lex r s { fst := i, snd := a } { fst := j, snd := b } ‚à® Lex r s { fst := j,  ‚Ä¶
    obtain hij | rfl | hji := trichotomous_of r i j
    ¬∑ exact Or.inl (Lex.left _ _ hij)
      -- üéâ no goals
    ¬∑ obtain hab | hba := total_of (s i) a b
      -- ‚ä¢ Lex r s { fst := i, snd := a } { fst := i, snd := b } ‚à® Lex r s { fst := i,  ‚Ä¶
      ¬∑ exact Or.inl (Lex.right _ _ hab)
        -- üéâ no goals
      ¬∑ exact Or.inr (Lex.right _ _ hba)
        -- üéâ no goals
    ¬∑ exact Or.inr (Lex.left _ _ hji)‚ü©
      -- üéâ no goals

instance [IsTrichotomous Œπ r] [‚àÄ i, IsTrichotomous (Œ± i) (s i)] : IsTrichotomous _ (Lex r s) :=
  ‚ü®by
    rintro ‚ü®i, a‚ü© ‚ü®j, b‚ü©
    -- ‚ä¢ Lex r s { fst := i, snd := a } { fst := j, snd := b } ‚à® { fst := i, snd := a ‚Ä¶
    obtain hij | rfl | hji := trichotomous_of r i j
    ¬∑ exact Or.inl (Lex.left _ _ hij)
      -- üéâ no goals
    ¬∑ obtain hab | rfl | hba := trichotomous_of (s i) a b
      ¬∑ exact Or.inl (Lex.right _ _ hab)
        -- üéâ no goals
      ¬∑ exact Or.inr (Or.inl rfl)
        -- üéâ no goals
      ¬∑ exact Or.inr (Or.inr $ Lex.right _ _ hba)
        -- üéâ no goals
    ¬∑ exact Or.inr (Or.inr $ Lex.left _ _ hji)‚ü©
      -- üéâ no goals

end Sigma

/-! ### `PSigma` -/


namespace PSigma

variable {Œπ : Sort*} {Œ± : Œπ ‚Üí Sort*} {r r‚ÇÅ r‚ÇÇ : Œπ ‚Üí Œπ ‚Üí Prop} {s s‚ÇÅ s‚ÇÇ : ‚àÄ i, Œ± i ‚Üí Œ± i ‚Üí Prop}

theorem lex_iff {a b : Œ£' i, Œ± i} :
    Lex r s a b ‚Üî r a.1 b.1 ‚à® ‚àÉ h : a.1 = b.1, s b.1 (h.rec a.2) b.2 := by
  constructor
  -- ‚ä¢ Lex r s a b ‚Üí r a.fst b.fst ‚à® ‚àÉ h, s b.fst (h ‚ñ∏ a.snd) b.snd
  ¬∑ rintro (‚ü®a, b, hij‚ü© | ‚ü®i, hab‚ü©)
    -- ‚ä¢ r { fst := a‚ÇÅ‚úù, snd := a }.fst { fst := a‚ÇÇ‚úù, snd := b }.fst ‚à® ‚àÉ h, s { fst : ‚Ä¶
    ¬∑ exact Or.inl hij
      -- üéâ no goals
    ¬∑ exact Or.inr ‚ü®rfl, hab‚ü©
      -- üéâ no goals
  ¬∑ obtain ‚ü®i, a‚ü© := a
    -- ‚ä¢ (r { fst := i, snd := a }.fst b.fst ‚à® ‚àÉ h, s b.fst (h ‚ñ∏ { fst := i, snd := a ‚Ä¶
    obtain ‚ü®j, b‚ü© := b
    -- ‚ä¢ (r { fst := i, snd := a }.fst { fst := j, snd := b }.fst ‚à® ‚àÉ h, s { fst := j ‚Ä¶
    dsimp only
    -- ‚ä¢ (r i j ‚à® ‚àÉ h, s j (h ‚ñ∏ a) b) ‚Üí Lex r s { fst := i, snd := a } { fst := j, sn ‚Ä¶
    rintro (h | ‚ü®rfl, h‚ü©)
    -- ‚ä¢ Lex r s { fst := i, snd := a } { fst := j, snd := b }
    ¬∑ exact Lex.left _ _ h
      -- üéâ no goals
    ¬∑ exact Lex.right _ h
      -- üéâ no goals
#align psigma.lex_iff PSigma.lex_iff

instance Lex.decidable (r : Œπ ‚Üí Œπ ‚Üí Prop) (s : ‚àÄ i, Œ± i ‚Üí Œ± i ‚Üí Prop) [DecidableEq Œπ]
    [DecidableRel r] [‚àÄ i, DecidableRel (s i)] : DecidableRel (Lex r s) := fun _ _ =>
  decidable_of_decidable_of_iff lex_iff.symm
#align psigma.lex.decidable PSigma.Lex.decidable

theorem Lex.mono {r‚ÇÅ r‚ÇÇ : Œπ ‚Üí Œπ ‚Üí Prop} {s‚ÇÅ s‚ÇÇ : ‚àÄ i, Œ± i ‚Üí Œ± i ‚Üí Prop}
  (hr : ‚àÄ a b, r‚ÇÅ a b ‚Üí r‚ÇÇ a b) (hs : ‚àÄ i a b, s‚ÇÅ i a b ‚Üí s‚ÇÇ i a b) {a b : Œ£' i, Œ± i}
    (h : Lex r‚ÇÅ s‚ÇÅ a b) : Lex r‚ÇÇ s‚ÇÇ a b := by
  obtain ‚ü®a, b, hij‚ü© | ‚ü®i, hab‚ü© := h
  -- ‚ä¢ Lex r‚ÇÇ s‚ÇÇ { fst := a‚ÇÅ‚úù, snd := a } { fst := a‚ÇÇ‚úù, snd := b }
  ¬∑ exact Lex.left _ _ (hr _ _ hij)
    -- üéâ no goals
  ¬∑ exact Lex.right _ (hs _ _ _ hab)
    -- üéâ no goals
#align psigma.lex.mono PSigma.Lex.mono

theorem Lex.mono_left {r‚ÇÅ r‚ÇÇ : Œπ ‚Üí Œπ ‚Üí Prop} {s : ‚àÄ i, Œ± i ‚Üí Œ± i ‚Üí Prop}
    (hr : ‚àÄ a b, r‚ÇÅ a b ‚Üí r‚ÇÇ a b) {a b : Œ£' i, Œ± i} (h : Lex r‚ÇÅ s a b) : Lex r‚ÇÇ s a b :=
  h.mono hr $ fun _ _ _ => id
#align psigma.lex.mono_left PSigma.Lex.mono_left

theorem Lex.mono_right {r : Œπ ‚Üí Œπ ‚Üí Prop} {s‚ÇÅ s‚ÇÇ : ‚àÄ i, Œ± i ‚Üí Œ± i ‚Üí Prop}
    (hs : ‚àÄ i a b, s‚ÇÅ i a b ‚Üí s‚ÇÇ i a b) {a b : Œ£' i, Œ± i} (h : Lex r s‚ÇÅ a b) : Lex r s‚ÇÇ a b :=
  h.mono (fun _ _ => id) hs
#align psigma.lex.mono_right PSigma.Lex.mono_right

end PSigma
