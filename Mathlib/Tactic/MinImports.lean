/-
Copyright (c) 2024 Damiano Testa. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Damiano Testa
-/
import ImportGraph.Imports
import Batteries.Data.Array.Basic

/-! # `#min_imports in` a command to find minimal imports

`#min_imports in stx` scans the syntax `stx` to find a collection of minimal imports that should be
sufficient for `stx` to make sense.
If `stx` is a command, then it also elaborates `stx` and, in case it is a declaration, then
it also finds the imports implied by the declaration.

Unlike the related `#find_home`, this command takes into account notation and tactic information.
-/

open Lean Elab Command

namespace Mathlib.Command.MinImports

/-- `getSyntaxNodeKinds stx` takes a `Syntax` input `stx` and returns the `NameSet` of all the
`SyntaxNodeKinds` and all the identifiers contained in `stx`. -/
partial
def getSyntaxNodeKinds : Syntax → NameSet
  | .node _ kind args =>
    ((args.map getSyntaxNodeKinds).foldl (NameSet.append · ·) {}).insert kind
  | .ident _ _ nm _ => NameSet.empty.insert nm
  | _ => {}

/-- extracts the names of the declarations in `env` on which `decl` depends. -/
-- source:
-- https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/Counting.20prerequisites.20of.20a.20theorem/near/425370265
def getVisited (env : Environment) (decl : Name) : NameSet :=
  let (_, { visited, .. }) := CollectAxioms.collect decl |>.run env |>.run {}
  visited

/-- `getId stx` takes as input a `Syntax` `stx`.
If `stx` contains a `declId`, then it returns the `ident`-syntax for the `declId`.
If `stx` is a nameless instance, then it also tries to fetch the `ident` for the instance.
Otherwise it returns `.missing`. -/
def getId (stx : Syntax) : CommandElabM Syntax := do
  -- If the command contains a `declId`, we use the implied `ident`.
  match stx.find? (·.isOfKind ``Lean.Parser.Command.declId) with
    | some declId => return declId[0]
    | none =>
      -- Otherwise, the command could be a nameless `instance`.
      match stx.find? (·.isOfKind ``Lean.Parser.Command.instance) with
        | none => return .missing
        | some stx => do
          -- if it is a nameless `instance`, we retrieve the autogenerated name
          let dv ← mkDefViewOfInstance {} stx
          return dv.declId[0]

/-- `getIds stx` extracts all identifiers, collecting them in a `NameSet`. -/
partial
def getIds : Syntax → NameSet
  | .node _ _ args => (args.map getIds).foldl (·.append ·) {}
  | .ident _ _ nm _ => NameSet.empty.insert nm
  | _ => {}

/-- `getAttrNames stx` extracts `attribute`s from `stx`.
It does not collect `simp`, `ext`, `to_additive`.
It should collect almost all other attributes, e.g., `fun_prop`. -/
def getAttrNames (stx : Syntax) : NameSet :=
  match stx.find? (·.isOfKind ``Lean.Parser.Term.attributes) with
    | none => {}
    | some stx => getIds stx

/-- `getAttrs env stx` returns all attribute declaration names contained in `stx` and registered
in the `Environment `env`. -/
def getAttrs (env : Environment) (stx : Syntax) : NameSet :=
  Id.run do
  let mut new : NameSet := {}
  for attr in (getAttrNames stx) do
    match getAttributeImpl env attr with
      | .ok attr => new := new.insert attr.ref
      | .error .. => pure ()
  return new

/-- `previousInstName nm` takes as input a name `nm`, assuming that it is the name of an
auto-generated "nameless" `instance`.
If `nm` ends in `..._n`, where `n` is a number, it returns the same name, but with `_n` replaced
by `_(n-1)`, unless `n ≤ 1`, in which case it simply removes the `_n` suffix.
-/
def previousInstName : Name → Name
  | nm@(.str init tail) =>
    let last := tail.takeRightWhile (· != '_')
    let newTail := match last.toNat? with
                    | some (n + 2) => s!"_{n + 1}"
                    | _ => ""
    let newTailPrefix := tail.dropRightWhile (· != '_')
    if newTailPrefix.isEmpty then nm else
    let newTail :=
      (if newTailPrefix.back == '_' then newTailPrefix.dropRight 1 else newTailPrefix) ++ newTail
    .str init newTail
  | nm => nm

/--`getAllImports cmd id` takes a `Syntax` input `cmd` and returns the `NameSet` of all the
module names that are implied by
* the `SyntaxNodeKinds`,
* the attributes of `cmd` (if there are any),
* the identifiers contained in `cmd`,
* if `cmd` adds a declaration `d` to the environment, then also all the module names implied by `d`.
The argument `id` is expected to be an identifier.
It is used either for the internally generated name of a "nameless" `instance` or when parsing
an identifier representing the name of a declaration.
-/
def getAllImports (cmd id : Syntax) (dbg? : Bool := false) :
    CommandElabM NameSet := do
  let env ← getEnv
  let id1 ← getId cmd
  let ns ← getCurrNamespace
  let id2 := mkIdentFrom id1 (previousInstName id1.getId)
  let nm ← liftCoreM do (
    -- try the visible name or the current "nameless" `instance` name
    realizeGlobalConstNoOverload id1 <|>
    -- otherwise, guess what the previous "nameless" `instance` name was
    realizeGlobalConstNoOverload id2 <|>
    -- failing everything, use the current namespace followed by the visible name
    return ns ++ id1.getId)
  -- We collect the implied declaration names, the `SyntaxNodeKinds` and the attributes.
  let ts := getVisited env nm
              |>.append (getVisited env id.getId)
              |>.append (getSyntaxNodeKinds cmd)
              |>.append (getAttrs env cmd)
  if dbg? then dbg_trace "{ts.toArray.qsort Name.lt}"
  let mut hm : HashMap Nat Name := {}
  for imp in env.header.moduleNames do
    hm := hm.insert ((env.getModuleIdx? imp).getD default) imp
  let mut fins : NameSet := {}
  for t1 in ts do
    let tns := t1::(← resolveGlobalName t1).map Prod.fst
    for t in tns do
      let new := match env.getModuleIdxFor? t with
        | some t => (hm.find? t).get!
        | none   => .anonymous -- instead of `getMainModule`, we omit the current module
      if !fins.contains new then fins := fins.insert new
  return fins.erase .anonymous

/-- `getIrredundantImports env importNames` takes an `Environment` and a `NameSet` as inputs.
Assuming that `importNames` are module names,
it returns the `NameSet` consisting of a minimal collection of module names whose transitive
closure is enough to parse (and elaborate) `cmd`. -/
def getIrredundantImports (env : Environment) (importNames : NameSet) : NameSet :=
  importNames.diff (env.findRedundantImports importNames.toArray)

/-- `minImpsCore stx id` is the internal function to elaborate the `#min_imports in` command.
It collects the irredundant imports to parse and elaborate `stx` and logs
```lean
import A
import B
...
import Z
```
The `id` input is expected to be the name of the declaration that is currently processed.
It is used to provide the internally generated name for "nameless" `instance`s.
-/
def minImpsCore (stx id : Syntax) : CommandElabM Unit := do
    let tot := getIrredundantImports (← getEnv) (← getAllImports stx id)
    let fileNames := tot.toArray.qsort Name.lt
    --let fileNames := if tk.isSome then (fileNames).filter (`Mathlib).isPrefixOf else fileNames
    logInfoAt (← getRef) m!"{"\n".intercalate (fileNames.map (s!"import {·}")).toList}"

/-- `#min_imports in cmd` scans the syntax `cmd` and the declaration obtained by elaborating `cmd`
to find a collection of minimal imports that should be sufficient for `cmd` to work. -/
syntax (name := minImpsStx) "#min_imports in" command : command

@[inherit_doc minImpsStx]
syntax "#min_imports in" term : command

elab_rules : command
  | `(#min_imports in $cmd:command) => do
    -- In case `cmd` is a "nameless" `instance`, we produce its name.
    -- It is important that this is collected *before* adding the declaration to the environment,
    -- since `getId` probes the name-generator using the current environment: if the declaration
    -- were already present, `getId` would return a new name that does not clash with it!
    let id ← getId cmd
    Elab.Command.elabCommand cmd <|> pure ()
    minImpsCore cmd id
  | `(#min_imports in $cmd:term) => minImpsCore cmd cmd

end Mathlib.Command.MinImports

namespace Mathlib.WithInfoTrees

/-- `Lean.Elab.Info.getNames i ref` takes as input an `Info` `i` and a `NameSet` `ref`.
It scans all the possibilities for `Info` except for `CompletionInfo`,
looking for `Name`s and adds them to `ref`.

When it is done, it returns the updated `ref`. -/
def _root_.Lean.Elab.Info.getNames (i : Info) (ref : NameSet) : NameSet :=
  match i with
    | .ofTacticInfo i         => ref.insert i.elaborator
    | .ofTermInfo i           => ref.insert i.elaborator
    | .ofCommandInfo i        => ref.insert i.elaborator
    | .ofMacroExpansionInfo i => ref.insert i.stx.getKind
    | .ofOptionInfo i         => (ref.insert i.declName).insert i.optionName
    | .ofFieldInfo i          => (ref.insert i.projName).insert i.fieldName
    | .ofUserWidgetInfo i     => ref.insert i.id
    | .ofCustomInfo i         => ref.insert i.value.typeName
    | .ofOmissionInfo i       => ref.insert i.elaborator
    | _ => ref

/-- `Array.insertIf l a` takes as input an array `l` of terms of type `α` and
a term `a` of type `α`.  If `a` is not already contained in `l`, then it adds it to `l`, otherwise
it does nothing. -/
def _root_.Array.insertIf {α} [BEq α] (l : Array α) (a : α) : Array α :=
  if !l.contains a then l.push a else l

/-- `Lean.Elab.Info.getSyntax i ref` takes as input an `Info` `i` and a `Array` of `Syntax` `ref`.
It scans all the possibilities for `Info` except for `CompletionInfo`,
looking for `Syntax`s and adds them to `ref`.

When it is done, it returns the updated `ref`. -/
def _root_.Lean.Elab.Info.getSyntax (i : Info) (ref : Array Syntax) : Array Syntax :=
  match i with
    | .ofTacticInfo i         => ref.insertIf i.stx
    | .ofTermInfo i           => ref.insertIf i.stx
    | .ofCommandInfo i        => ref.insertIf i.stx
    | .ofMacroExpansionInfo i => (ref.insertIf i.stx).insertIf i.output
    | .ofOptionInfo i         => ref.insertIf i.stx
    | .ofFieldInfo i          => ref.insertIf i.stx
    | .ofUserWidgetInfo i     => ref.insertIf i.stx
    | .ofCustomInfo i         => ref.insertIf i.stx
    | .ofFieldRedeclInfo i    => ref.insertIf i.stx
    | .ofOmissionInfo i       => ref.insertIf i.stx
    | _ => ref

/-- `mctxToExpr mc init` takes as input a `MetavarContext` `mc` and a `HashSet` of `Expr` `init`.
It scans all the `Expr`essions contained in the `eAssignment` for `mc` and adds them to `init`.
-/
-- check if there is more besides the `eAssignment`
def mctxToExpr (mc : MetavarContext) (init : HashSet Expr) : HashSet Expr :=
  mc.eAssignment.foldl (init := init) fun es _mv e => HashSet.insert es e

/-- `localDeclToExpr ld` takes as input a `LocalDecl` `ld`, extracts its `type` and, if it has
one, also its `value` and returns them as an array.
-/
def localDeclToExpr : LocalDecl → Array Expr
  | .cdecl _ _ _ type _ _ => #[type]
  | .ldecl _ _ _ type value _ _ => #[type, value]

/-- `Lean.HashSet.getLctxExpr lctx ref` takes as input a `LocalContext` `lctx` and a `HashSet` of
`Expr`s `ref`.
It scans all the `Expr`essions contained in the `LocalDecl`s contained in `lctx` and
adds them to `ref`. -/
def _root_.Lean.HashSet.getLctxExpr (lctx : LocalContext) (ref : HashSet Expr) : HashSet Expr :=
  ref.insertMany <| (lctx.decls.toArray.reduceOption.map localDeclToExpr).flatten

/-- `Lean.Elab.Info.getExpr i ref` takes as input an `Info` `i` and a `HashSet` of `Expr` `ref`.
It scans all the possibilities for `Info` except for `CompletionInfo`,
looking for `Expr`s and adds them to `ref`.

When it is done, it returns the updated `ref`. -/
def _root_.Lean.Elab.Info.getExpr (i : Info) (ref : HashSet Expr) : HashSet Expr :=
  match i with
    | .ofTacticInfo i         => mctxToExpr i.mctxBefore ref
    | .ofMacroExpansionInfo i => ref.getLctxExpr i.lctx
    | .ofFieldInfo i          => (ref.getLctxExpr i.lctx).insert i.val
    | .ofTermInfo i =>
      ((ref.getLctxExpr i.lctx).insert i.expr).insert (i.expectedType?.getD default)
    | .ofOmissionInfo i =>
      ((ref.getLctxExpr i.lctx).insert i.expr).insert (i.expectedType?.getD default)
    | _ => ref

/--  `Lean.Elab.InfoTree.getExpr i` takes as input an `Infotree` `i` and
collects all the `Expr`s that it contains, returning them as a `HashSet`. -/
partial
def _root_.Lean.Elab.InfoTree.getExpr : InfoTree → HashSet Expr
  | .context i t =>
    if let .commandCtx c := i then mctxToExpr c.mctx t.getExpr
    else t.getExpr
  | .node i children => (children.map getExpr).foldl .merge (i.getExpr {})
  | .hole _ => {}

/--  `Lean.Elab.InfoTree.getNames i` takes as input an `Infotree` `i` and
collects all the `Names`s that it contains, returning them as a `NameSet`. -/
partial
def _root_.Lean.Elab.InfoTree.getNames : InfoTree → NameSet
  | .context i t =>
    if let .parentDeclCtx n := i then t.getNames.insert n
    else t.getNames
  | .node i children => (children.map getNames).foldl .append (i.getNames {})
  | .hole _ => {}

/--  `Lean.Elab.InfoTree.getSyntax i` takes as input an `Infotree` `i` and
collects all the `Syntax`s that it contains, returning them as an `Array`. -/
partial
def _root_.Lean.Elab.InfoTree.getSyntax : InfoTree → Array Syntax
  | .context _ t     => t.getSyntax
  | .node i children => (children.map getSyntax).foldl (·.foldl .insertIf ·) (i.getSyntax #[])
  | .hole _          => {}

open Mathlib.Command.MinImports in
/-- `getAllImpliedConstants env i` takes as input an `Environment` `env` and an `InfoTree` `i`,
scans `i` for all `Name` and `SyntaxNodeKind` information, extracts all contants contained in
`Expr`s and returns all of them as a `NameSet`. -/
def getAllImpliedConstants (env : Environment) (i : InfoTree) : NameSet :=
  let exs := i.getExpr
  let nms := i.getNames
  let stxs := i.getSyntax
  let exnms := exs.fold (init := {}) fun a b => b.getUsedConstantsAsSet.append a
  let exnVis : NameSet := exnms.fold (init := {}) fun a b => (getVisited env b).append a
  let stxnms := stxs.foldl (init := {})
    fun a b => (getSyntaxNodeKinds b).append a
  let stxids := stxs.foldl (init := {})
    fun a b => (getIds b).append a
  ((exnVis.append nms).append stxnms).append stxids

end Mathlib.WithInfoTrees
