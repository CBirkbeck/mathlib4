/-
Copyright (c) 2024 Yuma Mizuno. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuma Mizuno
-/
import Mathlib.Tactic.CategoryTheory.BicategoricalComp

/-!
# Normalization of morphisms in monoidal categories
This file provides a tactic that normalizes morphisms in monoidal categories. This is used in the
string diagram widget given in `Mathlib.Tactic.StringDiagram`.
We say that the morphism `η` in a monoidal category is in normal form if
1. `η` is of the form `α₀ ≫ η₀ ≫ α₁ ≫ η₁ ≫ ... αₘ ≫ ηₘ ≫ αₘ₊₁` where each `αᵢ` is a
  structural 2-morphism (consisting of associators and unitors),
2. each `ηᵢ` is a non-structural 2-morphism of the form `f₁ ◁ ... ◁ fₘ ◁ θ`, and
3. `θ` is of the form `ι ▷ g₁ ▷ ... ▷ gₗ`

Note that the structural morphisms `αᵢ` are not necessarily normalized, as the main purpose
is to get a list of the non-structural morphisms out.

Currently, the primary application of the normalization tactic in mind is drawing string diagrams,
which are graphical representations of morphisms in monoidal categories, in the infoview. When
drawing string diagrams, we often ignore associators and unitors (i.e., drawing morphisms in
strict monoidal categories). On the other hand, in Lean, it is considered difficult to formalize
the concept of strict monoidal categories due to the feature of dependent type theory. The
normalization tactic can remove associators and unitors from the expression, extracting the
necessary data for drawing string diagrams.

The current plan on drawing string diagrams (#10581) is to use
Penrose (https://github.com/penrose) via ProofWidget. However, it should be noted that the
normalization procedure in this file does not rely on specific settings, allowing for broader
application.

Future plans include the following. At least I (Yuma) would like to work on these in the future,
but it might not be immediate. If anyone is interested, I would be happy to discuss.

- Currently (#10581), the string diagrams only do drawing. It would be better they also generate
  proofs. That is, by manipulating the string diagrams displayed in the infoview with a mouse to
  generate proofs. In #10581, the string diagram widget only uses the morphisms generated by the
  normalization tactic and does not use proof terms ensuring that the original morphism and the
  normalized morphism are equal. Proof terms will be necessary for proof generation.

- There is also the possibility of using homotopy.io (https://github.com/homotopy-io), a graphical
  proof assistant for category theory, from Lean. At this point, I have very few ideas regarding
  this approach.

- The normalization tactic allows for an alternative implementation of the coherent tactic.

## Main definitions
- `Tactic.Monoidal.eval`: Given a Lean expression `e` that represents a morphism in a monoidal
category, this function returns a pair of `⟨e', pf⟩` where `e'` is the normalized expression of `e`
and `pf` is a proof that `e = e'`.

-/

open Lean Meta Elab
open CategoryTheory

namespace Mathlib.Tactic.Bicategory

/-- The context for evaluating expressions. -/
structure Context where
  /-- The expression for the underlying category. -/
  B : Expr
  instBicategory : Expr
  level₀ : Level
  level₁ : Level
  level₂ : Level

/-- Populate a `context` object for evaluating `e`. -/
def mkContext (e : Expr) : MetaM Context := do
  match (← whnfR (← inferType e)).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, f, _]) =>
    match (← whnfR (← inferType f)).getAppFnArgs with
    | (``Quiver.Hom, #[_, _, a, _]) =>
      let B ← inferType a
      let .succ level₀ ← getLevel B |
        throwError m!"faled to get the universe level of {B}"
      let .succ level₁ ← getLevel (← inferType f) |
        throwError m!"faled to get the universe level of {← inferType f}"
      let .succ level₂ ← getLevel (← inferType e) |
        throwError m!"faled to get the universe level of {← inferType e}"
      let instBicategory ← synthInstance
        (mkAppN (.const ``Bicategory [level₂, level₁, level₀]) #[B])
      return ⟨B, instBicategory, level₀, level₁, level₂⟩
    | _ => throwError m!"{f} is not a morphism"
  | _ => throwError m!"{e} is not a morphism"

def mkContext? (e : Expr) : MetaM (Option Context) := do
  try
    return some (← mkContext e)
  catch _ =>
    return none

/-- The monad for the normalization of 2-morphisms. -/
abbrev BicategoryM := ReaderT Context MetaM

/-- Run a computation in the `M` monad. -/
abbrev BicategoryM.run {α : Type} (c : Context) (m : BicategoryM α) : MetaM α :=
  ReaderT.run m c

def getLevels : BicategoryM (List Level) := do
  let ctx ← read
  return [ctx.level₂, ctx.level₁, ctx.level₀]

/-- The domain of a morphism. -/
def srcExpr (η : Expr) : MetaM Expr := do
  match (← whnfR (← inferType η)).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, f, _]) => return f
  | _ => throwError m!"{η} is not a morphism"

/-- The codomain of a morphism. -/
def tgtExpr (η : Expr) : MetaM Expr := do
  match (← whnfR (← inferType η)).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, _, g]) => return g
  | _ => throwError m!"{η} is not a morphism"

/-- The domain of a morphism. -/
def srcExprOfIso (η : Expr) : MetaM Expr := do
  match (← whnfR (← inferType η)).getAppFnArgs with
  | (``Iso, #[_, _, f, _]) => return f
  | _ => throwError m!"{η} is not a morphism"

/-- The codomain of a morphism. -/
def tgtExprOfIso (η : Expr) : MetaM Expr := do
  match (← whnfR (← inferType η)).getAppFnArgs with
  | (``Iso, #[_, _, _, g]) => return g
  | _ => throwError m!"{η} is not a morphism"

def mkCategoryStructInst₁ : BicategoryM Expr := do
  let ctx ← read
  let B := ctx.B
  let instB := ctx.instBicategory
  return mkAppN (.const ``Bicategory.toCategoryStruct (← getLevels)) #[B, instB]

def mkQuiverInst₁ : BicategoryM Expr := do
  let ctx ← read
  return mkAppN (.const ``CategoryStruct.toQuiver [ctx.level₁, ctx.level₀])
    #[ctx.B, ← mkCategoryStructInst₁]

def mkHom₁ (a b : Expr) : BicategoryM Expr := do
  let ctx ← read
  return mkAppN (.const ``Quiver.Hom [ctx.level₁.succ, ctx.level₀])
    #[ctx.B, ← mkQuiverInst₁, a, b]

def mkComp₁ (f g : Expr) : BicategoryM Expr := do
  let ctx ← read
  return mkAppN (.const ``CategoryStruct.comp [ctx.level₁, ctx.level₀])
    #[ctx.B, ← mkCategoryStructInst₁, ← srcExpr f, ← tgtExpr f, ← tgtExpr g, f, g]

def mkId₁ (a : Expr) : BicategoryM Expr := do
  let ctx ← read
  return mkAppN (.const ``CategoryStruct.id [ctx.level₁, ctx.level₀])
    #[ctx.B, ← mkCategoryStructInst₁, a]

def mkHomCatInst (a b : Expr) : BicategoryM Expr := do
  let ctx ← read
  let B := ctx.B
  let instB := ctx.instBicategory
  return mkAppN (.const ``Bicategory.homCategory (← getLevels)) #[B, instB, a, b]

def mkCategoryStructInst₂ (f : Expr) : BicategoryM Expr := do
  let ctx ← read
  let instCat ← mkHomCatInst (← srcExpr f) (← tgtExpr f)
  return mkAppN (.const ``Category.toCategoryStruct [ctx.level₂, ctx.level₁])
    #[← inferType f, instCat]

def mkQuiverInst₂ (f : Expr) : BicategoryM Expr := do
  let ctx ← read
  return mkAppN (.const ``CategoryStruct.toQuiver [ctx.level₂, ctx.level₁])
    #[← inferType f, ← mkCategoryStructInst₂ f]

def mkHom₂ (f g : Expr) : BicategoryM Expr := do
  let ctx ← read
  return mkAppN (.const ``Quiver.Hom [ctx.level₂.succ, ctx.level₁])
    #[← inferType f, ← mkQuiverInst₂ f, f, g]

def mkComp₂ (η θ : Expr) : BicategoryM Expr := do
  let ctx ← read
  let f ← srcExpr η
  let g ← tgtExpr η
  let h ← tgtExpr θ
  return mkAppN (.const ``CategoryStruct.comp [ctx.level₂, ctx.level₁])
    #[← inferType f, ← mkCategoryStructInst₂ f, f, g, h, η, θ]

def mkId₂ (f : Expr) : BicategoryM Expr := do
  let ctx ← read
  return mkAppN (.const ``CategoryStruct.id [ctx.level₂, ctx.level₁])
    #[← inferType f, ← mkCategoryStructInst₂ f, f]

def mkIsoHom (η : Expr) : BicategoryM Expr := do
  let ctx ← read
  let f ← srcExprOfIso η
  let g ← tgtExprOfIso η
  let instCat ← mkHomCatInst (← srcExpr f) (← tgtExpr f)
  return mkAppN (.const ``Iso.hom [ctx.level₂, ctx.level₁])
    #[← inferType f, instCat, f, g, η]

def mkIsoInv (η : Expr) : BicategoryM Expr := do
  let ctx ← read
  let f ← srcExprOfIso η
  let g ← tgtExprOfIso η
  let instCat ← mkHomCatInst (← srcExpr f) (← tgtExpr f)
  return mkAppN (.const ``Iso.inv [ctx.level₂, ctx.level₁])
    #[← inferType f, instCat, f, g, η]

def mkWhiskerLeft (f η : Expr) : BicategoryM Expr := do
  let ctx ← read
  let a ← srcExpr f
  let b ← tgtExpr f
  let g ← srcExpr η
  let h ← tgtExpr η
  let c ← tgtExpr g
  return mkAppN (.const ``Bicategory.whiskerLeft (← getLevels))
    #[ctx.B, ctx.instBicategory, a, b, c, f, g, h, η]

def mkWhiskerRight (η h : Expr) : BicategoryM Expr := do
  let ctx ← read
  let f ← srcExpr η
  let g ← tgtExpr η
  let a ← srcExpr f
  let b ← tgtExpr f
  let c ← tgtExpr h
  return mkAppN (.const ``Bicategory.whiskerRight (← getLevels))
    #[ctx.B, ctx.instBicategory, a, b, c, f, g, η, h]

def mkAssociator (f g h : Expr) : BicategoryM Expr := do
  let ctx ← read
  let a ← srcExpr f
  let b ← tgtExpr f
  let c ← tgtExpr g
  let d ← tgtExpr h
  return mkAppN (.const ``Bicategory.associator (← getLevels))
    #[ctx.B, ctx.instBicategory, a, b, c, d, f, g, h]

def mkLeftUnitor (f : Expr) : BicategoryM Expr := do
  let ctx ← read
  let a ← srcExpr f
  let b ← tgtExpr f
  return mkAppN (.const ``Bicategory.leftUnitor (← getLevels))
    #[ctx.B, ctx.instBicategory, a, b, f]

def mkRightUnitor (f : Expr) : BicategoryM Expr := do
  let ctx ← read
  let a ← srcExpr f
  let b ← tgtExpr f
  return mkAppN (.const ``Bicategory.rightUnitor (← getLevels))
    #[ctx.B, ctx.instBicategory, a, b, f]

def mkBicategoricalCoherenceHom (f g inst : Expr) : BicategoryM Expr := do
  let ctx ← read
  let a ← srcExpr f
  let b ← tgtExpr f
  return mkAppN (.const ``BicategoricalCoherence.hom (← getLevels))
    #[ctx.B, ctx.instBicategory, a, b, f, g, inst]

/-- Expressions for atomic 1-morphisms. -/
structure Atom₁ : Type where
  /-- Extract a Lean expression from an `Atom₁` expression. -/
  e : Expr
  /-- The domain of the 1-morphism. -/
  src : Expr
  /-- The codomain of the 1-morphism. -/
  tgt : Expr

def Atom₁.mkM (e : Expr) : MetaM Atom₁ := do
  let src ← srcExpr e
  let tgt ← tgtExpr e
  return ⟨e, src, tgt⟩

/-- Expressions for 1-morphisms. -/
inductive Mor₁ : Type
  /-- `id a` is the expression for `𝟙 a`. -/
  | id (a : Expr) : Mor₁
  /-- `comp a b f g` is the expression for `f ≫ g` with `f g : a ⟶ b`. -/
  | comp : Mor₁ → Mor₁ → Mor₁
  /-- Construct the expression for an atomic 1-morphism. -/
  | of : Atom₁ → Mor₁
  deriving Inhabited

/-- Converts a 1-morphism into a list of its components. -/
def Mor₁.toList : Mor₁ → List Atom₁
  | .id _ => []
  | .comp f g => f.toList ++ g.toList
  | .of f => [f]

/-- Returns `a` if the expression `e` is of the form `𝟙 a`. -/
def isId? (e : Expr) : BicategoryM (Option (Expr)) := do
  let ctx ← read
  let a ← mkFreshExprMVar ctx.B
  let i ← mkId₁ a
  if ← withDefault <| isDefEq e i then
    return (← instantiateMVars a)
  else
    return none

/-- Returns `(f, g)` if the expression `e` is of the form `f ≫ g`. -/
def isComp? (e : Expr) : BicategoryM (Option (Expr × Expr)) := do
  let ctx ← read
  let a ← mkFreshExprMVar ctx.B
  let b ← mkFreshExprMVar ctx.B
  let c ← mkFreshExprMVar ctx.B
  let hom_ab ← mkHom₁ a b
  let hom_bc ← mkHom₁ b c
  let f ← mkFreshExprMVar hom_ab
  let g ← mkFreshExprMVar hom_bc
  let fg ← mkComp₁ f g
  if ← withDefault <| isDefEq e fg then
    return (← instantiateMVars f, ← instantiateMVars g)
  else
    return none

/-- Construct a `Mor₁` expression from a Lean expression. -/
partial def toMor₁ (e : Expr) : BicategoryM Mor₁ := do
  if let some a ← isId? e then
    return Mor₁.id a
  else if let some (f, g) ← isComp? e then
    return (← toMor₁ f).comp (← toMor₁ g)
  else
    return Mor₁.of (← Atom₁.mkM e)

/-- Expressions for atomic structural 2-morphisms. -/
inductive StructuralAtom : Type
  /-- The expression for the associator `(α_ f g h).hom`. -/
  | associator (f g h : Mor₁) : StructuralAtom
  /-- The expression for the inverse of the associator `(α_ f g h).inv`. -/
  | associatorInv (f g h : Mor₁) : StructuralAtom
  /-- The expression for the left unitor `(λ_ f).hom`. -/
  | leftUnitor (f : Mor₁) : StructuralAtom
  /-- The expression for the inverse of the left unitor `(λ_ f).inv`. -/
  | leftUnitorInv (f : Mor₁) : StructuralAtom
  /-- The expression for the right unitor `(ρ_ f).hom`. -/
  | rightUnitor (f : Mor₁) : StructuralAtom
  /-- The expression for the inverse of the right unitor `(ρ_ f).inv`. -/
  | rightUnitorInv (f : Mor₁) : StructuralAtom
  /-- Expressions for `α` in the monoidal composition `η ⊗≫ θ := η ≫ α ≫ θ`. -/
  | bicategoricalCoherence (f g : Mor₁) (e : Expr) : StructuralAtom
  deriving Inhabited

/-- Construct a `StructuralAtom` expression from a Lean expression. -/
def structuralAtom? (e : Expr) : BicategoryM (Option StructuralAtom) := do
  match ← whnfR e with
  -- whnfR version of `| (``Iso.hom, #[_, _, _, _, η]) =>`
  | .proj ``Iso 0 η =>
    match (← whnfR η).getAppFnArgs with
    | (``Bicategory.associator, #[_, _, _, _, _, _, f, g, h]) =>
      return some <| .associator (← toMor₁ f) (← toMor₁ g) (← toMor₁ h)
    | (``Bicategory.leftUnitor, #[_, _, _, _, f]) =>
      return some <| .leftUnitor (← toMor₁ f)
    | (``Bicategory.rightUnitor, #[_, _, _, _, f]) =>
      return some <| .rightUnitor (← toMor₁ f)
    | _ => return none
  -- whnfR version of `| (``Iso.inv, #[_, _, _, _, η]) =>`
  | .proj ``Iso 1 η =>
    match (← whnfR η).getAppFnArgs with
    | (``Bicategory.associator, #[_, _, _, _, _, _, f, g, h]) =>
      return some <| .associatorInv (← toMor₁ f) (← toMor₁ g) (← toMor₁ h)
    | (``Bicategory.leftUnitor, #[_, _, _, _, f]) =>
      return some <| .leftUnitorInv (← toMor₁ f)
    | (``Bicategory.rightUnitor, #[_, _, _, _, f]) =>
      return some <| .rightUnitorInv (← toMor₁ f)
    | _ => return none
  | _ =>
    match (← whnfR e).getAppFnArgs with
    | (``BicategoricalCoherence.hom, #[_, _, _, _, f, g, inst]) =>
      return some <| .bicategoricalCoherence (← toMor₁ f) (← toMor₁ g) inst
    | _ => return none

/-- Expressions for atomic non-structural 2-morphisms. -/
structure Atom where
  /-- Extract a Lean expression from an `Atom` expression. -/
  e : Expr
  /-- The domain of a 2-morphism. -/
  src : Mor₁
  /-- The codomain of a 2-morphism. -/
  tgt : Mor₁
  deriving Inhabited

def Atom.mkM (e : Expr) : BicategoryM Atom := do
  let src ← toMor₁ (← srcExpr e)
  let tgt ← toMor₁ (← tgtExpr e)
  return ⟨e, src, tgt⟩

/-- Expressions of the form `η ▷ f₁ ▷ ... ▷ fₙ`. -/
inductive WhiskerRightExpr : Type
  /-- Construct the expression for an atomic 2-morphism. -/
  | of (η : Atom) : WhiskerRightExpr
  /-- Construct the expression for `η ▷ f`. -/
  | whisker (η : WhiskerRightExpr) (f : Atom₁) : WhiskerRightExpr
  deriving Inhabited

/-- Expressions of the form `f₁ ◁ ... ◁ fₙ ◁ η`. -/
inductive WhiskerLeftExpr : Type
  /-- Construct the expression for a right-whiskered 2-morphism. -/
  | of (η : WhiskerRightExpr) : WhiskerLeftExpr
  /-- Construct the expression for `f ◁ η`. -/
  | whisker (f : Atom₁) (η : WhiskerLeftExpr) : WhiskerLeftExpr
  deriving Inhabited

/-- Expressions for structural 2-morphisms. -/
inductive Structural : Type
  /-- Expressions for atomic structural 2-morphisms. -/
  | atom (η : StructuralAtom) : Structural
  /-- Expressions for the identity `𝟙 f`. -/
  | id (f : Mor₁) : Structural
  /-- Expressions for the composition `η ≫ θ`. -/
  | comp (α β : Structural) : Structural
  /-- Expressions for the left whiskering `f ◁ η`. -/
  | whiskerLeft (f : Mor₁) (η : Structural) : Structural
  /-- Expressions for the right whiskering `η ▷ f`. -/
  | whiskerRight (η : Structural) (f : Mor₁) : Structural
  deriving Inhabited

/-- Normalized expressions for 2-morphisms. -/
inductive NormalExpr : Type
  /-- Construct the expression for a structural 2-morphism. -/
  | nil (α : Structural) : NormalExpr
  /-- Construct the normalized expression of 2-morphisms recursively. -/
  | cons (head_structural : Structural) (head : WhiskerLeftExpr) (tail : NormalExpr) : NormalExpr
  deriving Inhabited

/-- The domain of a 1-morphism. -/
def Mor₁.src : Mor₁ → Expr
  | .id a => a
  | .comp f _ => f.src
  | .of f => f.src

/-- The codomain of a 1-morphism. -/
def Mor₁.tgt : Mor₁ → Expr
  | .id a => a
  | .comp _ g => g.tgt
  | .of f => f.tgt

/-- The domain of a 2-morphism. -/
def WhiskerRightExpr.src : WhiskerRightExpr → Mor₁
  | WhiskerRightExpr.of η => η.src
  | WhiskerRightExpr.whisker η f => η.src.comp (Mor₁.of f)

/-- The codomain of a 2-morphism. -/
def WhiskerRightExpr.tgt : WhiskerRightExpr → Mor₁
  | WhiskerRightExpr.of η => η.tgt
  | WhiskerRightExpr.whisker η f => η.tgt.comp (Mor₁.of f)

/-- The domain of a 2-morphism. -/
def WhiskerLeftExpr.src : WhiskerLeftExpr → Mor₁
  | WhiskerLeftExpr.of η => η.src
  | WhiskerLeftExpr.whisker f η => (Mor₁.of f).comp η.src

/-- The codomain of a 2-morphism. -/
def WhiskerLeftExpr.tgt : WhiskerLeftExpr → Mor₁
  | WhiskerLeftExpr.of η => η.tgt
  | WhiskerLeftExpr.whisker f η => (Mor₁.of f).comp η.tgt

/-- The domain of a 2-morphism. -/
def StructuralAtom.src : StructuralAtom → Mor₁
  | .associator f g h => (f.comp g).comp h
  | .associatorInv f g h => f.comp (g.comp h)
  | .leftUnitor f => (Mor₁.id f.src).comp f
  | .leftUnitorInv f => f
  | .rightUnitor f => f.comp (Mor₁.id f.tgt)
  | .rightUnitorInv f => f
  | .bicategoricalCoherence f _ _ => f

/-- The codomain of a 2-morphism. -/
def StructuralAtom.tgt : StructuralAtom → Mor₁
  | .associator f g h => f.comp (g.comp h)
  | .associatorInv f g h => (f.comp g).comp h
  | .leftUnitor f => f
  | .leftUnitorInv f => (Mor₁.id f.src).comp f
  | .rightUnitor f => f
  | .rightUnitorInv f => f.comp (Mor₁.id f.tgt)
  | .bicategoricalCoherence _ g _ => g

/-- The domain of a 2-morphism. -/
def Structural.src : Structural → Mor₁
  | .atom η => η.src
  | .id f => f
  | .comp α _ => α.src
  | .whiskerLeft f η => f.comp η.src
  | .whiskerRight η f => η.src.comp f

/-- The codomain of a 2-morphism. -/
def Structural.tgt : Structural → Mor₁
  | .atom η => η.tgt
  | .id f => f
  | .comp _ β => β.tgt
  | .whiskerLeft f η => f.comp η.tgt
  | .whiskerRight η f => η.tgt.comp f

/-- The domain of a 2-morphism. -/
def NormalExpr.src : NormalExpr → Mor₁
  | NormalExpr.nil η => η.src
  | NormalExpr.cons α _ _ => α.src

/-- The codomain of a 2-morphism. -/
def NormalExpr.tgt : NormalExpr → Mor₁
  | NormalExpr.nil η => η.tgt
  | NormalExpr.cons _ _ ηs => ηs.tgt

/-- The associator as a term of `normalExpr`. -/
def NormalExpr.associator (f g h : Mor₁) : NormalExpr :=
  .nil <| .atom <| .associator f g h

/-- The inverse of the associator as a term of `normalExpr`. -/
def NormalExpr.associatorInv (f g h : Mor₁) : NormalExpr :=
  .nil <| .atom <| .associatorInv f g h

/-- The left unitor as a term of `normalExpr`. -/
def NormalExpr.leftUnitor (f : Mor₁) : NormalExpr :=
  .nil <| .atom <| .leftUnitor f

/-- The inverse of the left unitor as a term of `normalExpr`. -/
def NormalExpr.leftUnitorInv (f : Mor₁) : NormalExpr :=
  .nil <| .atom <| .leftUnitorInv f

/-- The right unitor as a term of `normalExpr`. -/
def NormalExpr.rightUnitor (f : Mor₁) : NormalExpr :=
  .nil <| .atom <| .rightUnitor f

/-- The inverse of the right unitor as a term of `normalExpr`. -/
def NormalExpr.rightUnitorInv (f : Mor₁) : NormalExpr :=
  .nil <| .atom <| .rightUnitorInv f

/-- Construct a `NormalExpr` expression from a `WhiskerLeftExpr` expression. -/
def NormalExpr.of (η : WhiskerLeftExpr) : NormalExpr :=
  .cons (.id η.src) η (.nil (.id η.tgt))

/-- Construct a `NormalExpr` expression from a Lean expression for an atomic 2-morphism. -/
def NormalExpr.ofExpr (η : Expr) : BicategoryM NormalExpr := do
  return NormalExpr.of <| .of <| .of <| ← Atom.mkM η

/-- If `e` is an expression of the form `η ⊗≫ θ := η ≫ α ≫ θ` in the monoidal category `C`,
return the expression for `α` .-/
def structuralOfBicategoricalComp (e : Expr) : BicategoryM Structural := do
  let ctx ← read
  let a ← mkFreshExprMVar ctx.B
  let b ← mkFreshExprMVar ctx.B
  let hom_ab ← mkHom₁ a b
  let f ← mkFreshExprMVar hom_ab
  let g ← mkFreshExprMVar hom_ab
  let h ← mkFreshExprMVar hom_ab
  let i ← mkFreshExprMVar hom_ab
  let η ← mkFreshExprMVar (← mkHom₂ f g)
  let α₀ ← mkFreshExprMVar (← mkHom₂ g h)
  let θ ← mkFreshExprMVar (← mkHom₂ h i)
  let αθ ← mkComp₂ α₀ θ
  let ηαθ ← mkComp₂ η αθ
  _ ← isDefEq e ηαθ
  match ← structuralAtom? α₀ with
  | some η => return .atom η
  | none => throwError "not a structural 2-morphism"

section

open scoped Bicategory

universe w v u

variable {B : Type u} [Bicategory.{w, v} B]

variable {a₀ a₁ a b c d : B}
variable {f f' g g' h i j : a ⟶ b}

theorem evalComp_nil_cons (α : f ⟶ g) (β : g ⟶ h) (η : h ⟶ i) (ηs : i ⟶ j) :
    α ≫ (β ≫ η ≫ ηs) = (α ≫ β) ≫ η ≫ ηs := by
  simp

def mkEvalComp_nil_cons (α β η ηs : Expr) : BicategoryM Expr := do
    let ctx ← read
    let f ← srcExpr α
    let g ← tgtExpr α
    let h ← tgtExpr β
    let i ← tgtExpr η
    let j ← tgtExpr ηs
    let a ← srcExpr f
    let b ← tgtExpr f
    return mkAppN (.const ``evalComp_nil_cons (← getLevels))
      #[ctx.B, ctx.instBicategory, a, b, f, g, h, i, j, α, β, η, ηs]

@[nolint synTaut]
theorem evalComp_nil_nil (α : f ⟶ g) (β : g ⟶ h) :
    α ≫ β = α ≫ β := by
  simp

def mkEvalComp_nil_nil (α β : Expr) : BicategoryM Expr := do
    let ctx ← read
    let f ← srcExpr α
    let g ← tgtExpr α
    let h ← tgtExpr β
    let a ← srcExpr f
    let b ← tgtExpr f
    return mkAppN (.const ``evalComp_nil_nil (← getLevels))
      #[ctx.B, ctx.instBicategory, a, b, f, g, h, α, β]

theorem evalComp_cons (α : f ⟶ g) (η : g ⟶ h) {ηs : h ⟶ i} {θ : i ⟶ j} {ι : h ⟶ j}
    (pf_ι : ηs ≫ θ = ι)  :
    (α ≫ η ≫ ηs) ≫ θ = α ≫ η ≫ ι := by
  simp [pf_ι]

def mkEvalComp_cons (α η ηs θ ι pf_ι : Expr) : BicategoryM Expr := do
    let ctx ← read
    let f ← srcExpr α
    let g ← tgtExpr α
    let h ← tgtExpr η
    let i ← tgtExpr ηs
    let j ← tgtExpr θ
    let a ← srcExpr f
    let b ← tgtExpr f
    return mkAppN (.const ``evalComp_cons (← getLevels))
      #[ctx.B, ctx.instBicategory, a, b, f, g, h, i, j, α, η, ηs, θ, ι, pf_ι]

@[nolint synTaut]
theorem evalWhiskerLeft_nil (f : a ⟶ b) {g h : b ⟶ c} (α : g ⟶ h) :
    f ◁ α = f ◁ α := by
  simp

def mkEvalWhiskerLeft_nil (f α : Expr) : BicategoryM Expr := do
    let ctx ← read
    let a ← srcExpr f
    let b ← tgtExpr f
    let g ← srcExpr α
    let h ← tgtExpr α
    let c ← tgtExpr g
    return mkAppN (.const ``evalWhiskerLeft_nil (← getLevels))
      #[ctx.B, ctx.instBicategory, a, b, c, f, g, h, α]

theorem evalWhiskerLeft_of_cons
    {f : a ⟶ b} {g h i j : b ⟶ c}
    (α : g ⟶ h) (η : h ⟶ i) {ηs : i ⟶ j} {θ : f ≫ i ⟶ f ≫ j} (pf_θ : f ◁ ηs = θ) :
    f ◁ (α ≫ η ≫ ηs) = f ◁ α ≫ f ◁ η ≫ θ := by
  simp [pf_θ]

def mkEvalWhiskerLeft_of_cons (f α η ηs θ pf_θ : Expr) : BicategoryM Expr := do
    let ctx ← read
    let a ← srcExpr f
    let b ← tgtExpr f
    let g ← srcExpr α
    let h ← tgtExpr α
    let i ← tgtExpr η
    let j ← tgtExpr ηs
    let c ← tgtExpr g
    return mkAppN (.const ``evalWhiskerLeft_of_cons (← getLevels))
      #[ctx.B, ctx.instBicategory, a, b, c, f, g, h, i, j, α, η, ηs, θ, pf_θ]

theorem evalWhiskerLeft_comp
    {f : a ⟶ b} {g : b ⟶ c} {h i : c ⟶ d}
    {η : h ⟶ i} {θ : g ≫ h ⟶ g ≫ i} {ι : f ≫ g ≫ h ⟶ f ≫ g ≫ i}
    {ι' : f ≫ g ≫ h ⟶ (f ≫ g) ≫ i} {ι'' : (f ≫ g) ≫ h ⟶ (f ≫ g) ≫ i}
    (pf_θ : g ◁ η = θ) (pf_ι : f ◁ θ = ι)
    (pf_ι' : ι ≫ (α_ _ _ _).inv = ι') (pf_ι'' : (α_ _ _ _).hom ≫ ι' = ι'') :
    (f ≫ g) ◁ η = ι'' := by
  simp [pf_θ, pf_ι, pf_ι', pf_ι'']

def mkEvalWhiskerLeft_comp (f g η θ ι ι' ι'' pf_θ pf_ι pf_ι' pf_ι'' : Expr) : BicategoryM Expr := do
    let ctx ← read
    let a ← srcExpr f
    let b ← tgtExpr f
    let c ← tgtExpr g
    let h ← srcExpr η
    let i ← tgtExpr η
    let d ← tgtExpr h
    return mkAppN (.const ``evalWhiskerLeft_comp (← getLevels))
      #[ctx.B, ctx.instBicategory, a, b, c, d, f, g, h, i, η, θ, ι, ι', ι'',
        pf_θ, pf_ι, pf_ι', pf_ι'']

theorem evalWhiskerLeft_id {η : f ⟶ g}
    {η' : f ⟶ 𝟙 a ≫ g} {η'' : 𝟙 a ≫ f ⟶ 𝟙 a ≫ g}
    (pf_η' : η ≫ (λ_ _).inv = η') (pf_η'' : (λ_ _).hom ≫ η' = η'') :
    𝟙 a ◁ η = η'' := by
  simp [pf_η', pf_η'']

def mkEvalWhiskerLeft_id (η η' η'' pf_η' pf_η'' : Expr) : BicategoryM Expr := do
    let ctx ← read
    let f ← srcExpr η
    let g ← tgtExpr η
    let a ← srcExpr f
    let b ← tgtExpr f
    return mkAppN (.const ``evalWhiskerLeft_id (← getLevels))
      #[ctx.B, ctx.instBicategory, a, b, f, g, η, η', η'', pf_η', pf_η'']

theorem eval_comp
    {η η' : f ⟶ g} {θ θ' : g ⟶ h} {ι : f ⟶ h}
    (pf_η : η = η') (pf_θ : θ = θ') (pf_ηθ : η' ≫ θ' = ι) :
    η ≫ θ = ι := by
  simp [pf_η, pf_θ, pf_ηθ]

theorem eval_whiskerLeft
    {f : a ⟶ b} {g h : b ⟶ c}
    {η η' : g ⟶ h} {θ : f ≫ g ⟶ f ≫ h}
    (pf_η : η = η') (pf_θ : f ◁ η' = θ) :
    f ◁ η = θ := by
  simp [pf_η, pf_θ]

theorem eval_whiskerRight
    {f g : a ⟶ b} {h : b ⟶ c}
    {η η' : f ⟶ g} {θ : f ≫ h ⟶ g ≫ h}
    (pf_η : η = η') (pf_θ : η' ▷ h = θ) :
    η ▷ h = θ := by
  simp [pf_η, pf_θ]

theorem eval_of (η : f ⟶ g) :
    η = 𝟙 _ ≫ η ≫ 𝟙 _ := by
  simp

@[nolint synTaut]
theorem evalWhiskerRight_nil (α : f ⟶ g) (h : b ⟶ c) :
    α ▷ h = α ▷ h := by
  simp

theorem evalWhiskerRight_cons_of_of
    {f g h i : a ⟶ b} {j : b ⟶ c}
    (α : f ⟶ g) (η : g ⟶ h) {ηs : h ⟶ i} {θ : h ≫ j ⟶ i ≫ j}
    (pf_θ : ηs ▷ j = θ) :
    (α ≫ η ≫ ηs) ▷ j = α ▷ j ≫ η ▷ j ≫ θ := by
  simp [pf_θ]

theorem evalWhiskerRight_cons_whisker
    {g j : a ⟶ c} {f : a ⟶ b} {h i : b ⟶ c} {k : c ⟶ d}
    {α : g ⟶ f ≫ h} {η : h ⟶ i} {ηs : f ≫ i ⟶ j}
    {η₁ : h ≫ k ⟶ i ≫ k} {η₂ : f ≫ (h ≫ k) ⟶ f ≫ (i ≫ k)} {ηs₁ : (f ≫ i) ≫ k ⟶ j ≫ k}
    {ηs₂ : f ≫ (i ≫ k) ⟶ j ≫ k} {η₃ : f ≫ (h ≫ k) ⟶ j ≫ k} {η₄ : (f ≫ h) ≫ k ⟶ j ≫ k}
    {η₅ : g ≫ k ⟶ j ≫ k}
    (pf_η₁ : (𝟙 _ ≫ η ≫ 𝟙 _ ) ▷ k = η₁) (pf_η₂ : f ◁ η₁ = η₂)
    (pf_ηs₁ : ηs ▷ k = ηs₁) (pf_ηs₂ : (α_ _ _ _).inv ≫ ηs₁ = ηs₂)
    (pf_η₃ : η₂ ≫ ηs₂ = η₃) (pf_η₄ : (α_ _ _ _).hom ≫ η₃ = η₄) (pf_η₅ : α ▷ k ≫ η₄ = η₅) :
    (α ≫ (f ◁ η) ≫ ηs) ▷ k = η₅ := by
  simp at pf_η₁
  simp [pf_η₁, pf_η₂, pf_ηs₁, pf_ηs₂, pf_η₃, pf_η₄, pf_η₅]

theorem evalWhiskerRight_comp
    {f f' : a ⟶ b} {g : b ⟶ c} {h : c ⟶ d}
    {η : f ⟶ f'} {η₁ : f ≫ g ⟶ f' ≫ g} {η₂ : (f ≫ g) ≫ h ⟶ (f' ≫ g) ≫ h}
    {η₃ : (f ≫ g) ≫ h ⟶ f' ≫ (g ≫ h)} {η₄ : f ≫ (g ≫ h) ⟶ f' ≫ (g ≫ h)}
    (pf_η₁ : η ▷ g = η₁) (pf_η₂ : η₁ ▷ h = η₂)
    (pf_η₃ : η₂ ≫ (α_ _ _ _).hom = η₃) (pf_η₄ : (α_ _ _ _).inv ≫ η₃ = η₄) :
    η ▷ (g ≫ h) = η₄ := by
  simp [pf_η₁, pf_η₂, pf_η₃, pf_η₄]

theorem evalWhiskerRight_id
    {η : f ⟶ g} {η₁ : f ⟶ g ≫ 𝟙 b} {η₂ : f ≫ 𝟙 b ⟶ g ≫ 𝟙 b}
    (pf_η₁ : η ≫ (ρ_ _).inv = η₁) (pf_η₂ : (ρ_ _).hom ≫ η₁ = η₂) :
    η ▷ 𝟙 b = η₂ := by
  simp [pf_η₁, pf_η₂]

theorem eval_bicategoricalComp
    {η η' : f ⟶ g} {α : g ⟶ h} {θ θ' : h ⟶ i} {αθ : g ⟶ i} {ηαθ : f ⟶ i}
    (pf_η : η = η') (pf_θ : θ = θ') (pf_αθ : α ≫ θ' = αθ) (pf_ηαθ : η' ≫ αθ = ηαθ) :
    η ≫ α ≫ θ = ηαθ := by
  simp [pf_η, pf_θ, pf_αθ, pf_ηαθ]

end

/-- Extract a Lean expression from a `Mor₁` expression. -/
def Mor₁.e : Mor₁ → BicategoryM Expr
  | .id  a => do mkId₁ a
  | .comp f g => do mkComp₁ (← f.e) (← g.e)
  | .of f => return f.e

/-- Extract a Lean expression from a `StructuralAtom` expression. -/
def StructuralAtom.e : StructuralAtom → BicategoryM Expr
  | .associator f g h => do mkIsoHom (← mkAssociator (← f.e) (← g.e) (← h.e))
  | .associatorInv f g h => do mkIsoInv (← mkAssociator (← f.e) (← g.e) (← h.e))
  | .leftUnitor f => do mkIsoHom (← mkLeftUnitor (← f.e))
  | .leftUnitorInv f => do mkIsoInv (← mkLeftUnitor (← f.e))
  | .rightUnitor f => do mkIsoHom (← mkRightUnitor (← f.e))
  | .rightUnitorInv f => do mkIsoInv (← mkRightUnitor (← f.e))
  | .bicategoricalCoherence f g e => do mkBicategoricalCoherenceHom (← f.e) (← g.e) e

/-- Extract a Lean expression from a `Structural` expression. -/
partial def Structural.e : Structural → BicategoryM Expr
  | .atom η => η.e
  | .id f => do mkId₂ (← f.e)
  | .comp α β => do mkComp₂ (← α.e) (← β.e)
  | .whiskerLeft f η => do mkWhiskerLeft (← f.e) (← η.e)
  | .whiskerRight η f => do mkWhiskerRight (← η.e) (← f.e)

/-- Extract a Lean expression from a `WhiskerRightExpr` expression. -/
def WhiskerRightExpr.e : WhiskerRightExpr → BicategoryM Expr
  | WhiskerRightExpr.of η => return η.e
  | WhiskerRightExpr.whisker η f => do mkWhiskerRight (← η.e) f.e

/-- Extract a Lean expression from a `WhiskerLeftExpr` expression. -/
def WhiskerLeftExpr.e : WhiskerLeftExpr → BicategoryM Expr
  | WhiskerLeftExpr.of η => η.e
  | WhiskerLeftExpr.whisker f η => do mkWhiskerLeft f.e (← η.e)

/-- Extract a Lean expression from a `NormalExpr` expression. -/
def NormalExpr.e : NormalExpr → BicategoryM Expr
  | NormalExpr.nil α => α.e
  | NormalExpr.cons α η θ => do mkComp₂ (← α.e) (← mkComp₂ (← η.e) (← θ.e))

/-- The result of evaluating an expression into normal form. -/
structure Result where
  /-- The normalized expression of the 2-morphism. -/
  expr : NormalExpr
  /-- The proof that the normalized expression is equal to the original expression. -/
  proof : Expr

/-- Evaluate the expression `η ≫ θ` into a normalized form. -/
partial def evalComp : NormalExpr → NormalExpr → BicategoryM Result
  | .nil α, .cons β η ηs => do
    let η' := .cons (α.comp β) η ηs
    return ⟨η', ← mkEvalComp_nil_cons (← α.e) (← β.e) (← η.e) (← ηs.e)⟩
  | .nil α, .nil α' => do
    return ⟨.nil (α.comp α'), ← mkEvalComp_nil_nil (← α.e) (← α'.e)⟩
  | .cons α η ηs, θ => do
    let ⟨ι, pf_ι⟩ ← evalComp ηs θ
    let ι' := .cons α η ι
    return ⟨ι', ← mkEvalComp_cons (← α.e) (← η.e) (← ηs.e) (← θ.e) (← ι.e) pf_ι⟩

/-- Evaluate the expression `f ◁ η` into a normalized form. -/
partial def evalWhiskerLeftExpr : Mor₁ → NormalExpr → BicategoryM Result
  | f, .nil α => do
    return ⟨.nil (.whiskerLeft f α), ← mkEvalWhiskerLeft_nil (← f.e) (← α.e)⟩
  | .of f, .cons α η ηs => do
    let η' := WhiskerLeftExpr.whisker f η
    let ⟨θ, pf_θ⟩ ← evalWhiskerLeftExpr (.of f) ηs
    let η'' := .cons (.whiskerLeft (.of f) α) η' θ
    return ⟨η'', ← mkEvalWhiskerLeft_of_cons (f.e) (← α.e) (← η.e) (← ηs.e) (← θ.e) pf_θ⟩
  | .comp f g, η => do
    let ⟨θ, pf_θ⟩ ← evalWhiskerLeftExpr g η
    let ⟨ι, pf_ι⟩ ← evalWhiskerLeftExpr f θ
    let h := η.src
    let h' := η.tgt
    let ⟨ι', pf_ι'⟩ ← evalComp ι (NormalExpr.associatorInv f g h')
    let ⟨ι'', pf_ι''⟩ ← evalComp (NormalExpr.associator f g h) ι'
    return ⟨ι'', ← mkEvalWhiskerLeft_comp (← f.e) (← g.e) (← η.e) (← θ.e)
      (← ι.e) (← ι'.e) (← ι''.e) pf_θ pf_ι pf_ι' pf_ι''⟩
  | .id _, η => do
    let f := η.src
    let g := η.tgt
    let ⟨η', pf_η'⟩ ← evalComp η (NormalExpr.leftUnitorInv g)
    let ⟨η'', pf_η''⟩ ← evalComp (NormalExpr.leftUnitor f) η'
    return ⟨η'', ← mkEvalWhiskerLeft_id (← η.e) (← η'.e) (← η''.e) pf_η' pf_η''⟩

/-- Evaluate the expression `η ▷ f` into a normalized form. -/
partial def evalWhiskerRightExpr : NormalExpr → Mor₁ → BicategoryM Result
  | .nil α, h => do
    return ⟨.nil (.whiskerRight α h), ← mkAppM ``evalWhiskerRight_nil #[← α.e, ← h.e]⟩
  | .cons α (.of η) ηs, .of f => do
    let ⟨θ, pf_θ⟩ ← evalWhiskerRightExpr ηs (.of f)
    let η' := .cons (.whiskerRight α (.of f)) (.of (.whisker η f)) θ
    let pf ← mkAppM ``evalWhiskerRight_cons_of_of #[← α.e, ← η.e, pf_θ]
    return ⟨η', pf⟩
  | .cons α (.whisker f η) ηs, h => do
    let g := η.src
    let g' := η.tgt
    let ⟨η₁, pf_η₁⟩ ← evalWhiskerRightExpr (.cons (.id g) η (.nil (.id g'))) h
    let ⟨η₂, pf_η₂⟩ ← evalWhiskerLeftExpr (.of f) η₁
    let ⟨ηs₁, pf_ηs₁⟩ ← evalWhiskerRightExpr ηs h
    let α' := .whiskerRight α h
    let ⟨ηs₂, pf_ηs₂⟩ ← evalComp (.associatorInv (.of f) g' h) ηs₁
    let ⟨η₃, pf_η₃⟩ ← evalComp η₂ ηs₂
    let ⟨η₄, pf_η₄⟩ ← evalComp (.associator (.of f) g h) η₃
    let ⟨η₅, pf_η₅⟩ ← evalComp (.nil α') η₄
    return ⟨η₅, ← mkAppM ``evalWhiskerRight_cons_whisker
      #[pf_η₁, pf_η₂, pf_ηs₁, pf_ηs₂, pf_η₃, pf_η₄, pf_η₅]⟩
  | η, .comp g h => do
    let ⟨η₁, pf_η₁⟩ ← evalWhiskerRightExpr η g
    let ⟨η₂, pf_η₂⟩ ← evalWhiskerRightExpr η₁ h
    let f := η.src
    let f' := η.tgt
    let ⟨η₃, pf_η₃⟩ ← evalComp η₂ (.associator f' g h)
    let ⟨η₄, pf_η₄⟩ ← evalComp (.associatorInv f g h) η₃
    return ⟨η₄, ← mkAppM ``evalWhiskerRight_comp #[pf_η₁, pf_η₂, pf_η₃, pf_η₄]⟩
  | η, .id _ => do
    let f := η.src
    let g := η.tgt
    let ⟨η₁, pf_η₁⟩ ← evalComp η (.rightUnitorInv g)
    let ⟨η₂, pf_η₂⟩ ← evalComp (.rightUnitor f) η₁
    return ⟨η₂, ← mkAppM ``evalWhiskerRight_id #[pf_η₁, pf_η₂]⟩

/-- Evaluate the expression of a 2-morphism into a normalized form. -/
partial def eval (e : Expr) : BicategoryM Result := do
  if let .some α ← structuralAtom? e then
    return ⟨.nil <| .atom α, ← mkEqRefl (← α.e)⟩
  else
    match (← whnfR e).getAppFnArgs with
    | (``CategoryStruct.id, #[_, _, f]) =>
      return ⟨.nil (.id (← toMor₁ f)), ← mkEqRefl (← mkId₂ f)⟩
    | (``CategoryStruct.comp, #[_, _, _, _, _, η, θ]) =>
      withTraceNode `bicategory (fun _ => return m!"comp") do
        let ⟨η', pf_η⟩ ← eval η
        let ⟨θ', pf_θ⟩ ← eval θ
        let ⟨ηθ, pf⟩ ← evalComp η' θ'
        let result ← mkAppM ``eval_comp #[pf_η, pf_θ, pf]
        trace[bicategory] m!"{checkEmoji} {← inferType result}"
        return ⟨ηθ, result⟩
    | (``Bicategory.whiskerLeft, #[_, _, _, _, _, f, _, _, η]) =>
      withTraceNode `bicategory (fun _ => return m!"whiskerLeft") do
        let ⟨η', pf_η⟩ ← eval η
        let ⟨θ, pf_θ⟩ ← evalWhiskerLeftExpr (← toMor₁ f) η'
        let result ← mkAppM ``eval_whiskerLeft #[pf_η, pf_θ]
        trace[bicategory] m!"{checkEmoji} {← inferType result}"
        return ⟨θ, result⟩
    | (``Bicategory.whiskerRight, #[_, _, _, _, _, _, _, η, h]) =>
      withTraceNode `bicategory (fun _ => return m!"whiskerRight") do
        let ⟨η', pf_η⟩ ← eval η
        let ⟨θ, pf_θ⟩ ← evalWhiskerRightExpr η' (← toMor₁ h)
        let result ← mkAppM ``eval_whiskerRight #[pf_η, pf_θ]
        trace[bicategory] m!"{checkEmoji} {← inferType result}"
        return ⟨θ, result⟩
    | (``bicategoricalComp, #[_, _, _, _, _, _, _, _, _, η, θ]) =>
      withTraceNode `bicategory (fun _ => return m!"bicategoricalComp") do
        let ⟨η', pf_η⟩ ← eval η
        let α₀ ← structuralOfBicategoricalComp e
        let α := NormalExpr.nil α₀
        let ⟨θ', pf_θ⟩ ← eval θ
        let ⟨αθ, pf_θα⟩ ← evalComp α θ'
        let ⟨ηαθ, pf_ηαθ⟩ ← evalComp η' αθ
        let result ← mkAppM ``eval_bicategoricalComp #[pf_η, pf_θ, pf_θα, pf_ηαθ]
        trace[bicategory] m!"{checkEmoji} {← inferType result}"
        return ⟨ηαθ, result⟩
    | _ =>
      let result ← mkAppM ``eval_of #[e]
      trace[bicategory] m!"{checkEmoji} {← inferType result}"
      return ⟨← NormalExpr.ofExpr e, result⟩

/-- Convert a `NormalExpr` expression into a list of `WhiskerLeftExpr` expressions. -/
def NormalExpr.toList : NormalExpr → List WhiskerLeftExpr
  | NormalExpr.nil _ => []
  | NormalExpr.cons _ η ηs => η :: NormalExpr.toList ηs

/-- `normalize% η` is the normalization of the 2-morphism `η`.
1. The normalized 2-morphism is of the form `α₀ ≫ η₀ ≫ α₁ ≫ η₁ ≫ ... αₘ ≫ ηₘ ≫ αₘ₊₁` where
  each `αᵢ` is a structural 2-morphism (consisting of associators and unitors),
2. each `ηᵢ` is a non-structural 2-morphism of the form `f₁ ◁ ... ◁ fₘ ◁ θ`, and
3. `θ` is of the form `ι ▷ g₁ ▷ ... ▷ gₗ`
-/
elab "normalize% " t:term:51 : term => do
  let e ← Lean.Elab.Term.elabTerm t none
  let ctx ← mkContext e
  BicategoryM.run ctx do (← eval e).expr.e

theorem mk_eq {α : Type _} (a b a' b' : α) (ha : a = a') (hb : b = b') (h : a' = b') : a = b := by
  simp [h, ha, hb]

open Lean Elab Meta Tactic in
/-- Transform an equality between 2-morphisms into the equality between their normalizations. -/
def mkEqOfNormalizedEq (e : Expr) : MetaM Expr := do
  withTraceNode `bicategory (fun _ => return m!"normalizing {e}") do
    let some (_, e₁, e₂) := (← whnfR <| ← instantiateMVars <| e).eq?
      | throwError "bicategory_nf requires an equality goal"
    let ctx ← mkContext e₁
    BicategoryM.run ctx do
      let ⟨e₁', p₁⟩ ← eval e₁
      let ⟨e₂', p₂⟩ ← eval e₂
      mkAppM ``mk_eq #[e₁, e₂, ← e₁'.e, ← e₂'.e, p₁, p₂]

open Lean Elab Tactic in
/-- Normalize the both sides of an equality. -/
elab "bicategory_nf" : tactic => withMainContext do
  let t ← getMainTarget
  let mvarIds ← (← getMainGoal).apply (← mkEqOfNormalizedEq t)
  replaceMainGoal mvarIds

end Mathlib.Tactic.Bicategory
