/-
Copyright (c) 2024 Yuma Mizuno. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuma Mizuno
-/
-- import Mathlib.CategoryTheory.Monoidal.Category
import Mathlib.Tactic.CategoryTheory.Coherence.PureCoherence


import Mathlib.Tactic.CategoryTheory.BicategoricalComp
-- import Mathlib.Tactic.CategoryTheory.BicategoryLike

/-!
# Normalization of morphisms in monoidal categories
This file provides a tactic that normalizes morphisms in monoidal categories. This is used in the
string diagram widget given in `Mathlib.Tactic.StringDiagram`.
We say that the morphism `η` in a monoidal category is in normal form if
1. `η` is of the form `α₀ ≫ η₀ ≫ α₁ ≫ η₁ ≫ ... αₘ ≫ ηₘ ≫ αₘ₊₁` where each `αᵢ` is a
  structural 2-morphism (consisting of associators and unitors),
2. each `ηᵢ` is a non-structural 2-morphism of the form `f₁ ◁ ... ◁ fₘ ◁ θ`, and
3. `θ` is of the form `ι ▷ g₁ ▷ ... ▷ gₗ`

Note that the structural morphisms `αᵢ` are not necessarily normalized, as the main purpose
is to get a list of the non-structural morphisms out.

Currently, the primary application of the normalization tactic in mind is drawing string diagrams,
which are graphical representations of morphisms in monoidal categories, in the infoview. When
drawing string diagrams, we often ignore associators and unitors (i.e., drawing morphisms in
strict monoidal categories). On the other hand, in Lean, it is considered difficult to formalize
the concept of strict monoidal categories due to the feature of dependent type theory. The
normalization tactic can remove associators and unitors from the expression, extracting the
necessary data for drawing string diagrams.

The current plan on drawing string diagrams (#10581) is to use
Penrose (https://github.com/penrose) via ProofWidget. However, it should be noted that the
normalization procedure in this file does not rely on specific settings, allowing for broader
application.

Future plans include the following. At least I (Yuma) would like to work on these in the future,
but it might not be immediate. If anyone is interested, I would be happy to discuss.

- Currently (#10581), the string diagrams only do drawing. It would be better they also generate
  proofs. That is, by manipulating the string diagrams displayed in the infoview with a mouse to
  generate proofs. In #10581, the string diagram widget only uses the morphisms generated by the
  normalization tactic and does not use proof terms ensuring that the original morphism and the
  normalized morphism are equal. Proof terms will be necessary for proof generation.

- There is also the possibility of using homotopy.io (https://github.com/homotopy-io), a graphical
  proof assistant for category theory, from Lean. At this point, I have very few ideas regarding
  this approach.

- The normalization tactic allows for an alternative implementation of the coherent tactic.

## Main definitions
- `Tactic.Monoidal.eval`: Given a Lean expression `e` that represents a morphism in a monoidal
category, this function returns a pair of `⟨e', pf⟩` where `e'` is the normalized expression of `e`
and `pf` is a proof that `e = e'`.

-/

open Lean Meta Elab
open CategoryTheory Mathlib.Tactic.BicategoryLike
-- MkClass

namespace Mathlib.Tactic

namespace Bicategory

/-- The domain of a morphism. -/
def srcExpr (η : Expr) : MetaM Expr := do
  match (← whnfR (← inferType η)).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, f, _]) => return f
  | _ => throwError m!"{η} is not a morphism"

def srcExpr? (η : Expr) : MetaM (Option Expr) := do
  try return some (← srcExpr η)
  catch _ => return none

/-- The codomain of a morphism. -/
def tgtExpr (η : Expr) : MetaM Expr := do
  match (← whnfR (← inferType η)).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, _, g]) => return g
  | _ => throwError m!"{η} is not a morphism"

def tgtExpr? (η : Expr) : MetaM (Option Expr) := do
  try return some (← tgtExpr η)
  catch _ => return none

/-- The domain of an isomorphism. -/
def srcExprOfIso (η : Expr) : MetaM Expr := do
  match (← whnfR (← inferType η)).getAppFnArgs with
  | (``Iso, #[_, _, f, _]) => return f
  | _ => throwError m!"{η} is not a morphism"

/-- The codomain of an isomorphism. -/
def tgtExprOfIso (η : Expr) : MetaM Expr := do
  match (← whnfR (← inferType η)).getAppFnArgs with
  | (``Iso, #[_, _, _, g]) => return g
  | _ => throwError m!"{η} is not a morphism"

initialize registerTraceClass `bicategory

/-- The context for evaluating expressions. -/
structure Context where
  /-- The expression for the underlying category. -/
  B : Expr
  instBicategory : Expr
  level₀ : Level
  level₁ : Level
  level₂ : Level

-- /-- Populate a `context` object for evaluating `e`. -/
-- def mkContext (e : Expr) : MetaM Context := do
--   let e ← instantiateMVars e
--   let type ← instantiateMVars <| ← inferType e
--   match (← whnfR type).getAppFnArgs with
--   | (``Quiver.Hom, #[_, _, f, _]) =>
--     let C ← instantiateMVars <| ← inferType f
--     let .succ level₁ ← getLevel C |
--       throwError m!"faled to get the universe level of {C}"
--     let .succ level₂ ← getLevel type |
--       throwError m!"failed to get the universe level of {type}"
--     let instCat ← synthInstance (mkAppN (.const ``Category [level₂, level₁]) #[C])
--     let instMonoidal ← synthInstance?
--       (mkAppN (.const ``MonoidalCategory [level₂, level₁]) #[C, instCat])
--     return ⟨C, instCat, instMonoidal, level₁, level₂⟩
--   | _ => throwError m!"{e} is not a morphism"

/-- Populate a `context` object for evaluating `e`. -/
def mkContext (e : Expr) : MetaM Context := do
  let e ← instantiateMVars e
  let e ← (match (← whnfR e).eq? with
    | some (_, lhs, _) => return lhs
    | none => return e)
  let type ← instantiateMVars <| ← inferType e
  match (← whnfR (← inferType e)).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, f, _]) =>
    let fType ← instantiateMVars <| ← inferType f
    match (← whnfR fType).getAppFnArgs with
    | (``Quiver.Hom, #[_, _, a, _]) =>
      let B ← inferType a
      let .succ level₀ ← getLevel B |
        throwError m!"faled to get the universe level of {B}"
      let .succ level₁ ← getLevel fType |
        throwError m!"faled to get the universe level of {fType}"
      let .succ level₂ ← getLevel type |
        throwError m!"faled to get the universe level of {type}"
      let instBicategory ← synthInstance
        (mkAppN (.const ``Bicategory [level₂, level₁, level₀]) #[B])
      return ⟨B, instBicategory, level₀, level₁, level₂⟩
    | _ => throwError m!"{f} is not a morphism"
  | _ => throwError m!"{e} is not a morphism"

instance : BicategoryLike.Context Bicategory.Context where
  mkContext := Bicategory.mkContext

/-- The monad for the normalization of 2-morphisms. -/
abbrev BicategoryM := CoherenceM Context

-- /-- Run a computation in the `BicategoryM` monad. -/
-- abbrev BicategoryM.run {α : Type} (c : Context) (m : BicategoryM α) : MetaM α :=
--   ReaderT.run m c

def getLevels : BicategoryM (List Level) := do
  let ctx ← read
  return [ctx.level₂, ctx.level₁, ctx.level₀]

def mkCategoryStructInst₁ : BicategoryM Expr := do
  let ctx ← read
  let B := ctx.B
  let instB := ctx.instBicategory
  return mkAppN (.const ``Bicategory.toCategoryStruct (← getLevels)) #[B, instB]

def mkQuiverInst₁ : BicategoryM Expr := do
  let ctx ← read
  return mkAppN (.const ``CategoryStruct.toQuiver [ctx.level₁, ctx.level₀])
    #[ctx.B, ← mkCategoryStructInst₁]

def mkHom₁ (a b : Expr) : BicategoryM Expr := do
  let ctx ← read
  return mkAppN (.const ``Quiver.Hom [ctx.level₁.succ, ctx.level₀])
    #[ctx.B, ← mkQuiverInst₁, a, b]

def mkHomCatInst (a b : Expr) : BicategoryM Expr := do
  let ctx ← read
  return mkAppN (.const ``Bicategory.homCategory (← getLevels))
    #[ctx.B, ctx.instBicategory, a, b]

def mkHomCatStructInst (a b : Expr) : BicategoryM Expr := do
  let ctx ← read
  return mkAppN (.const ``Category.toCategoryStruct [ctx.level₂, ctx.level₁])
    #[← mkHom₁ a b, ← mkHomCatInst a b]

def mkCategoryStructInst₂ (f : Expr) : BicategoryM Expr := do
  let ctx ← read
  let instCat ← mkHomCatInst (← srcExpr f) (← tgtExpr f)
  return mkAppN (.const ``Category.toCategoryStruct [ctx.level₂, ctx.level₁])
    #[← inferType f, instCat]

def mkQuiverInst₂ (f : Expr) : BicategoryM Expr := do
  let ctx ← read
  return mkAppN (.const ``CategoryStruct.toQuiver [ctx.level₂, ctx.level₁])
    #[← inferType f, ← mkCategoryStructInst₂ f]

def mkHom₂ (f g : Expr) : BicategoryM Expr := do
  let ctx ← read
  return mkAppN (.const ``Quiver.Hom [ctx.level₂.succ, ctx.level₁])
    #[← inferType f, ← mkQuiverInst₂ f, f, g]

def mkBicategoricalCoherenceHom (f g inst : Expr) : BicategoryM Expr := do
  let ctx ← read
  let a ← srcExpr f
  let b ← tgtExpr f
  return mkAppN (.const ``BicategoricalCoherence.hom (← getLevels))
    #[ctx.B, ctx.instBicategory, a, b, f, g, inst]

-- def mkMonoidalCoherenceHom' (α : Expr) : BicategoryM Expr := do
--   let ctx ← read
--   match (← whnfR α).getAppFnArgs with
--   | (``MonoidalCoherence.hom, #[_, _, f, g, inst]) =>
--     return mkAppN (.const ``MonoidalCoherence.hom (← getLevels))
--       #[ctx.B, ctx.instCat, f, g, inst]
  -- return mkAppN (.const ``MonoidalCoherence.hom (← getLevels))
  --   #[ctx.B, ctx.instCat, f, g, inst]

def mkMonoidalCoherenceIso (a b f g inst : Expr) : BicategoryM Expr := do
  let ctx ← read
  return mkAppN (.const ``BicategoricalCoherence.iso (← getLevels))
    #[ctx.B, ctx.instBicategory, a, b, f, g, inst]

def mkIsoHom (η : Expr) : BicategoryM Expr := do
    let ctx ← read
    let f ← srcExprOfIso η
    let g ← tgtExprOfIso η
    let a ← srcExpr f
    let b ← tgtExpr f
    return mkAppN (.const ``Iso.hom [ctx.level₂, ctx.level₁])
      #[← mkHom₁ a b, ← mkHomCatInst a b, f, g, η]

def mkId₁ (a : Option Expr) : BicategoryM Expr := do
  let ctx ← read
  let .some a := a | throwError "failed to find the domain of the identity morphism"
  return mkAppN (.const ``CategoryStruct.id [ctx.level₁, ctx.level₀])
    #[ctx.B, ← mkCategoryStructInst₁, a]

def mkComp₁ (f g : Expr) : BicategoryM Expr := do
  let ctx ← read
  return mkAppN (.const ``CategoryStruct.comp [ctx.level₁, ctx.level₀])
    #[ctx.B, ← mkCategoryStructInst₁, ← srcExpr f, ← tgtExpr f, ← tgtExpr g, f, g]

instance : MonadMor₁ BicategoryM where
  id₁M a := return .id (← mkId₁ a.e) a
  comp₁M f g := return .comp (← mkComp₁ f.e g.e) f g

section

open Bicategory

universe w v u
variable {B : Type u} [Bicategory.{w, v} B] {a b c d e : B}

theorem structuralIso_inv {f g : a ⟶ b} (η : f ≅ g) :
    η.symm.hom = η.inv := by
  simp only [Iso.symm_hom]

theorem structuralIsoOfExpr_comp {f g h : a ⟶ b}
    (η : f ⟶ g) (η' : f ≅ g) (ih_η : η'.hom = η)
    (θ : g ⟶ h) (θ' : g ≅ h) (ih_θ : θ'.hom = θ) :
    (η' ≪≫ θ').hom  = η ≫ θ := by
  simp [ih_η, ih_θ]

theorem structuralIsoOfExpr_whiskerLeft {f : a ⟶ b} {g h : b ⟶ c}
    (η : g ⟶ h) (η' : g ≅ h) (ih_η : η'.hom = η)  :
    (whiskerLeftIso f η').hom = f ◁ η := by
  simp [ih_η]

theorem structuralIsoOfExpr_whiskerRight {f g : a ⟶ b} {h : b ⟶ c}
    (η : f ⟶ g) (η' : f ≅ g) (ih_η : η'.hom = η)  :
    (whiskerRightIso η' h).hom = η ▷ h := by
  simp [ih_η]

theorem StructuralIsoOfExpr_bicategoricalComp {f g h i : a ⟶ b} [BicategoricalCoherence g h]
    (η : f ⟶ g) (η' : f ≅ g) (ih_η : η'.hom = η) (θ : h ⟶ i) (θ' : h ≅ i) (ih_θ : θ'.hom = θ) :
    -- (α : g ≅ h) (ih_α : α.hom = (≫𝟙 : g ⟶ h)) :
    (bicategoricalIsoComp η' θ').hom = η ⊗≫ θ := by
  simp [ih_η, ih_θ, bicategoricalIsoComp, bicategoricalComp]

end

open MonadMor₁

-- instance : MkCoherenceHom BicategoryM  where
--   ofExpr inst := do
--     let ctx ← read
--     match (← whnfI inst).getAppFnArgs with
--     | (``MonoidalCoherence.mk, #[_, _, f, g, α, isIso]) =>
--       let e := mkAppN (.const ``monoidalIso (← getLevels))
--         #[ctx.B, ctx.instCat, f, g, inst]
--       ⟨⟩
--     | _ => throwError m!"failed to unfold {inst}"

instance : MonadStructuralIsoAtom BicategoryM where
  associatorM f g h := do
    let ctx ← read
    let a := f.src
    let b := f.tgt
    let c := g.tgt
    let d := h.tgt
    let e := mkAppN (.const ``Bicategory.associator (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, c.e, d.e, f.e, g.e, h.e]
    return .associator e f g h
  leftUnitorM f := do
    let ctx ← read
    let a := f.src
    let b := f.tgt
    let e := mkAppN (.const ``Bicategory.leftUnitor (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, f.e]
    return .leftUnitor e f
  rightUnitorM f := do
    let ctx ← read
    let a := f.src
    let b := f.tgt
    let e := mkAppN (.const ``Bicategory.rightUnitor (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, f.e]
    return .rightUnitor e f
  id₂M f := do
    let ctx ← read
    let a := f.src
    let b := f.tgt
    let e := mkAppN (.const ``Iso.refl [ctx.level₂, ctx.level₁])
      #[← mkHom₁ a.e b.e, ← mkHomCatInst a.e b.e, f.e]
    return .id e f
  coherenceHomM f g inst := do
    let ctx ← read
    let a := f.src
    let b := f.tgt
    match (← whnfI inst).getAppFnArgs with
    | (``BicategoricalCoherence.mk, #[_, _, _, _, _, _, α]) =>
      let e := mkAppN (.const ``BicategoricalCoherence.iso (← getLevels))
        #[ctx.B, ctx.instBicategory, a.e, b.e, f.e, g.e, inst]
      return ⟨e, f, g, inst, α⟩
    | _ => throwError m!"failed to unfold {inst}"


instance : MonadMor₂Iso BicategoryM where
  comp₂M η θ := do
    let ctx ← read
    let f ← η.srcM
    let g ← η.tgtM
    let h ← θ.tgtM
    let a := f.src
    let b := f.tgt
    let e := mkAppN (.const ``Iso.trans [ctx.level₂, ctx.level₁])
      #[← mkHom₁ a.e b.e, ← mkHomCatInst a.e b.e, f.e, g.e, h.e, η.e, θ.e]
    return .comp e f g h η θ
  whiskerLeftM f η := do
    let ctx ← read
    let g ← η.srcM
    let h ← η.tgtM
    let a := f.src
    let b := f.tgt
    let c := g.tgt
    let e := mkAppN (.const ``Bicategory.whiskerLeftIso (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, c.e, f.e, g.e, h.e, η.e]
    return .whiskerLeft e f g h η
  whiskerRightM η h := do
    let ctx ← read
    let f ← η.srcM
    let g ← η.tgtM
    let a := f.src
    let b := f.tgt
    let c := h.tgt
    let e := mkAppN (.const ``Bicategory.whiskerRightIso (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, c.e, f.e, g.e, η.e, h.e]
    return .whiskerRight e f g η h
  horizontalCompM η θ := throwError "horizontal composition is not implemented"
  symmM η := do
    let ctx ← read
    let f ← η.srcM
    let g ← η.tgtM
    let a := f.src
    let b := f.tgt
    let e := mkAppN (.const ``Iso.symm [ctx.level₂, ctx.level₁])
      #[← mkHom₁ a.e b.e, ← mkHomCatInst a.e b.e, f.e, g.e, η.e]
    return .inv e f g η
  coherenceCompM α η θ := do
    let ctx ← read
    let f ← η.srcM
    let g ← η.tgtM
    let h ← θ.srcM
    let i ← θ.tgtM
    let a := f.src
    let b := f.tgt
    let e := mkAppN (.const ``bicategoricalIsoComp (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, f.e, g.e, h.e, i.e, α.inst, η.e, θ.e]
    return .coherenceComp e f g h i α η θ

instance : MonadMor₂ BicategoryM where
  homM η := do
    let ctx ← read
    let f ← η.srcM
    let g ← η.tgtM
    let a := f.src
    let b := f.tgt
    let e := mkAppN (.const ``Iso.hom [ctx.level₂, ctx.level₁])
      #[← mkHom₁ a.e b.e, ← mkHomCatInst a.e b.e, f.e, g.e, η.e]
    return .isoHom e ⟨η, ← mkEqRefl e⟩ η
  homAtomM η := do
    let ctx ← read
    let f := η.src
    let g := η.tgt
    let a := f.src
    let b := f.tgt
    let e := mkAppN (.const ``Iso.hom [ctx.level₂, ctx.level₁])
      #[← mkHom₁ a.e b.e, ← mkHomCatInst a.e b.e, f.e, g.e, η.e]
    return .mk e f g
  invM η := do
    let ctx ← read
    let f ← η.srcM
    let g ← η.tgtM
    let a := f.src
    let b := f.tgt
    let e := mkAppN (.const ``Iso.inv [ctx.level₂, ctx.level₁])
      #[← mkHom₁ a.e b.e, ← mkHomCatInst a.e b.e, f.e, g.e, η.e]
    let ηInv ← Mor₂Iso.symmM η
    let eq := mkAppN (.const ``Iso.symm_hom [ctx.level₂, ctx.level₁])
      #[← mkHom₁ a.e b.e, ← mkHomCatInst a.e b.e, f.e, g.e, η.e]
    return .isoInv e ⟨ηInv, eq⟩ η
  invAtomM η := do
    let ctx ← read
    let f := η.src
    let g := η.tgt
    let a := f.src
    let b := f.tgt
    let e := mkAppN (.const ``Iso.inv [ctx.level₂, ctx.level₁])
      #[← mkHom₁ a.e b.e, ← mkHomCatInst a.e b.e, f.e, g.e, η.e]
    return .mk e g f
  id₂M f := do
    let ctx ← read
    let a := f.src
    let b := f.tgt
    let e := mkAppN (.const ``CategoryStruct.id [ctx.level₂, ctx.level₁])
      #[← mkHom₁ a.e b.e, ← mkHomCatStructInst a.e b.e, f.e]
    let eq := mkAppN (.const ``Iso.refl_hom [ctx.level₂, ctx.level₁])
      #[← mkHom₁ a.e b.e, ← mkHomCatInst a.e b.e, f.e]
    return .id e ⟨(.structuralAtom <| ← StructuralIsoAtom.id₂M f), eq⟩ f
  comp₂M η θ := do
    let ctx ← read
    let f ← η.srcM
    let g ← η.tgtM
    let h ← θ.tgtM
    let a := f.src
    let b := f.tgt
    let isoLift? ← (match (η.isoLift?, θ.isoLift?) with
      | (some ηIso, some θIso) => do
        let eq := mkAppN (.const ``structuralIsoOfExpr_comp (← getLevels))
          #[ctx.B, ctx.instBicategory, a.e, b.e, f.e, g.e, h.e,
            η.e, ηIso.iso.e, ηIso.eq, θ.e, θIso.iso.e, θIso.eq]
        return .some ⟨← MonadMor₂Iso.comp₂M ηIso.iso θIso.iso, eq⟩
      | _ => return none)
    let e := mkAppN (.const ``CategoryStruct.comp [ctx.level₂, ctx.level₁])
      #[← mkHom₁ a.e b.e, ← mkHomCatStructInst a.e b.e, f.e, g.e, h.e, η.e, θ.e]
    return .comp e isoLift? f g h η θ
  whiskerLeftM f η := do
    let ctx ← read
    let g ← η.srcM
    let h ← η.tgtM
    let a := f.src
    let b := f.tgt
    let c := g.tgt
    let isoLift? ← (match η.isoLift? with
      | some ηIso => do
        let eq := mkAppN (.const ``structuralIsoOfExpr_whiskerLeft (← getLevels))
          #[ctx.B, ctx.instBicategory, a.e, b.e, c.e, f.e, g.e, h.e, η.e, ηIso.iso.e, ηIso.eq]
        return .some ⟨← MonadMor₂Iso.whiskerLeftM f ηIso.iso, eq⟩
      | _ => return none)
    let e := mkAppN (.const ``Bicategory.whiskerLeft (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, c.e, f.e, g.e, h.e, η.e]
    return .whiskerLeft e isoLift? f g h η
  whiskerRightM η h := do
    let ctx ← read
    let f ← η.srcM
    let g ← η.tgtM
    let a := f.src
    let b := h.src
    let c := h.tgt
    let isoLift? ← (match η.isoLift? with
      | some ηIso => do
        let eq := mkAppN (.const ``structuralIsoOfExpr_whiskerRight (← getLevels))
          #[ctx.B, ctx.instBicategory, a.e, b.e, c.e, f.e, g.e, h.e, η.e, ηIso.iso.e, ηIso.eq]
        return .some ⟨← MonadMor₂Iso.whiskerRightM ηIso.iso h, eq⟩
      | _ => return none)
    let e := mkAppN (.const ``Bicategory.whiskerRight (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, c.e, f.e, g.e, η.e, h.e]
    return .whiskerRight e isoLift? f g η h
  horizontalCompM η θ := throwError "horizontal composition is not implemented"
  coherenceCompM α η θ := do
    let ctx ← read
    let f ← η.srcM
    let g ← η.tgtM
    let h ← θ.srcM
    let i ← θ.tgtM
    let a := f.src
    let b := f.tgt
    let isoLift? ← (match (η.isoLift?, θ.isoLift?) with
      | (some ηIso, some θIso) => do
        let eq := mkAppN (.const ``StructuralIsoOfExpr_bicategoricalComp (← getLevels))
          #[ctx.B, ctx.instBicategory, a.e, b.e, f.e, g.e, h.e, i.e, α.inst,
            η.e, ηIso.iso.e, ηIso.eq, θ.e, θIso.iso.e, θIso.eq]
        return .some ⟨← MonadMor₂Iso.coherenceCompM α ηIso.iso θIso.iso, eq⟩
      | _ => return none)
    let e := mkAppN (.const ``bicategoricalComp (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, f.e, g.e, h.e, i.e, α.inst, η.e, θ.e]
    return .coherenceComp e isoLift? f g h i α η θ

section

open Bicategory

universe w v u

variable {B : Type u} [Bicategory.{w, v} B] {a b c d e : B}

local infixr:81 " ◁ " => Bicategory.whiskerLeftIso
local infixl:81 " ▷ " => Bicategory.whiskerRightIso

abbrev normalizeIsoComp {p : a ⟶ b} {f : b ⟶ c} {g : c ⟶ d} {pf : a ⟶ c} {pfg : a ⟶ d}
    (η_f : p ≫ f ≅ pf) (η_g : pf ≫ g ≅ pfg) :=
  (α_ _ _ _).symm ≪≫ whiskerRightIso η_f g ≪≫ η_g

theorem naturality_associator
    {p : a ⟶ b} {f : b ⟶ c} {g : c ⟶ d} {h : d ⟶ e} {pf : a ⟶ c} {pfg : a ⟶ d} {pfgh : a ⟶ e}
    (η_f : (p ≫ f) ≅ pf) (η_g : (pf ≫ g) ≅ pfg) (η_h : pfg ≫ h ≅ pfgh) :
    p ◁ (α_ f g h) ≪≫ (normalizeIsoComp η_f (normalizeIsoComp η_g η_h)) =
    (normalizeIsoComp (normalizeIsoComp η_f η_g) η_h) :=
  Iso.ext (by simp)

theorem naturality_leftUnitor {p : a ⟶ b} {f : b ⟶ c} {pf : a ⟶ c} (η_f : p ≫ f ≅ pf) :
    p ◁ (λ_ f) ≪≫ η_f = normalizeIsoComp (ρ_ p) η_f :=
  Iso.ext (by simp)

theorem naturality_rightUnitor {p : a ⟶ b} {f : b ⟶ c} {pf : a ⟶ c} (η_f : p ≫ f ≅ pf) :
    p ◁ (ρ_ f) ≪≫ η_f = normalizeIsoComp η_f (ρ_ pf) :=
  Iso.ext (by simp)

theorem naturality_id {p : a ⟶ b} {f : b ⟶ c} {pf : a ⟶ c} (η_f : p ≫ f ≅ pf) :
    p ◁ Iso.refl f ≪≫ η_f = η_f :=
  Iso.ext (by simp)

theorem naturality_comp {p : a ⟶ b} {f g h : b ⟶ c} {pf : a ⟶ c} {η : f ≅ g} {θ : g ≅ h}
    (η_f : (p ≫ f) ≅ pf) (η_g : (p ≫ g) ≅ pf) (η_h : p ≫ h ≅ pf)
    (ih_η : p ◁ η ≪≫ η_g = η_f) (ih_θ : p ◁ θ ≪≫ η_h = η_g) :
    p ◁ (η ≪≫ θ) ≪≫ η_h = η_f := by
  rw [← ih_η, ← ih_θ]
  apply Iso.ext (by simp)

theorem naturality_whiskerLeft {p : a ⟶ b} {f : b ⟶ c} {g h : c ⟶ d} {pf : a ⟶ c} {pfg : a ⟶ d}
    {η : g ≅ h} (η_f : (p ≫ f) ≅ pf) (η_fg : (pf ≫ g) ≅ pfg) (η_fh : (pf ≫ h) ≅ pfg)
    (ih_η : pf ◁ η ≪≫ η_fh = η_fg) :
    p ◁ (f ◁ η) ≪≫ normalizeIsoComp η_f η_fh = normalizeIsoComp η_f η_fg := by
  rw [← ih_η]
  apply Iso.ext (by simp [← whisker_exchange_assoc])

theorem naturality_whiskerRight {p : a ⟶ b} {f g : b ⟶ c} {h : c ⟶ d} {pf : a ⟶ c} {pfh : a ⟶ d}
    {η : f ≅ g} (η_f : (p ≫ f) ≅ pf) (η_g : (p ≫ g) ≅ pf) (η_fh : (pf ≫ h) ≅ pfh)
    (ih_η : p ◁ η ≪≫ η_g = η_f) :
    p ◁ (η ▷ h) ≪≫ normalizeIsoComp η_g η_fh = normalizeIsoComp η_f η_fh := by
  rw [← ih_η]
  apply Iso.ext (by simp)

theorem naturality_inv {p : a ⟶ b} {f g : b ⟶ c} {pf : a ⟶ c}
    {η : f ≅ g} (η_f : p ≫ f ≅ pf) (η_g : p ≫ g ≅ pf) (ih : p ◁ η ≪≫ η_g = η_f) :
    p ◁ η.symm ≪≫ η_f = η_g := by
  rw [← ih]
  apply Iso.ext (by simp)

instance : MonadNormalizeNaturality BicategoryM where
  mkNaturalityAssociator p pf pfg pfgh f g h η_f η_g η_h := do
    let ctx ← read
    let a := p.src
    let b := p.tgt
    let c := f.tgt
    let d := g.tgt
    let e := h.tgt
    return mkAppN (.const ``naturality_associator (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, c.e, d.e, e.e, p.e.e, f.e, g.e, h.e,
        pf.e.e, pfg.e.e, pfgh.e.e, η_f.e, η_g.e, η_h.e]
  mkNaturalityLeftUnitor p pf f η_f := do
    let ctx ← read
    let a := p.src
    let b := p.tgt
    let c := f.tgt
    return mkAppN (.const ``naturality_leftUnitor (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, c.e, p.e.e, f.e, pf.e.e, η_f.e]
  mkNaturalityRightUnitor p pf f η_f := do
    let ctx ← read
    let a := p.src
    let b := p.tgt
    let c := f.tgt
    return mkAppN (.const ``naturality_rightUnitor (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, c.e, p.e.e, f.e, pf.e.e, η_f.e]
  mkNaturalityId p pf f η_f := do
    let ctx ← read
    let a := p.src
    let b := p.tgt
    let c := f.tgt
    return mkAppN (.const ``naturality_id (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, c.e, p.e.e, f.e, pf.e.e, η_f.e]
  mkNaturalityComp p pf f g h η θ η_f η_g η_h ih_η ih_θ := do
    let ctx ← read
    let a := p.src
    let b := p.tgt
    let c := f.tgt
    return mkAppN (.const ``naturality_comp (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, c.e, p.e.e, f.e, g.e, h.e, pf.e.e, η.e, θ.e,
        η_f.e, η_g.e, η_h.e, ih_η, ih_θ]
  mkNaturalityWhiskerLeft p pf pfg f g h η η_f η_fg η_fh ih_η := do
    let ctx ← read
    let a := p.src
    let b := p.tgt
    let c := f.tgt
    let d := g.tgt
    return mkAppN (.const ``naturality_whiskerLeft (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, c.e, d.e, p.e.e, f.e, g.e, h.e,
        pf.e.e, pfg.e.e, η.e, η_f.e, η_fg.e, η_fh.e, ih_η]
  mkNaturalityWhiskerRight p pf pfh f g h η η_f η_g η_fh ih_η := do
    let ctx ← read
    let a := p.src
    let b := p.tgt
    let c := f.tgt
    let d := h.tgt
    return mkAppN (.const ``naturality_whiskerRight (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, c.e, d.e, p.e.e, f.e, g.e, h.e,
        pf.e.e, pfh.e.e, η.e, η_f.e, η_g.e, η_fh.e, ih_η]
  mkNaturalityHorizontalComp _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ := do
    throwError "horizontal composition is not implemented"
  mkNaturalityInv p pf f g η η_f η_g ih := do
    let ctx ← read
    let a := p.src
    let b := p.tgt
    let c := f.tgt
    return mkAppN (.const ``naturality_inv (← getLevels))
      #[ctx.B, ctx.instBicategory, a.e, b.e, c.e, p.e.e, f.e, g.e, pf.e.e, η.e, η_f.e, η_g.e, ih]

theorem of_normalize_eq {f g f' : a ⟶ b} {η θ : f ≅ g} (η_f : 𝟙 a ≫ f ≅ f') (η_g : 𝟙 a ≫ g ≅ f')
    (h_η : 𝟙 a ◁ η ≪≫ η_g = η_f)
    (h_θ : 𝟙 a ◁ θ ≪≫ η_g = η_f) : η = θ := by
  apply Iso.ext
  calc
    η.hom = (λ_ f).inv ≫ η_f.hom ≫ η_g.inv ≫ (λ_ g).hom := by
      simp [← reassoc_of% (congrArg Iso.hom h_η)]
    _ = θ.hom := by
      simp [← reassoc_of% (congrArg Iso.hom h_θ)]

end

-- def eval₁ (e : Expr) : BicategoryM Mor₁ := sorry

def Atom₁.mkM (e : Expr) : MetaM Atom₁ := do
  let src ← srcExpr? e
  let tgt ← tgtExpr? e
  return ⟨e, ⟨src⟩, ⟨tgt⟩⟩

-- def isId₁? (e : Expr) : BicategoryM (Option Obj) := do
--   let ctx ← read
--   let f ← mkFreshExprMVar ctx.B
--   let unit ← withReader _ (id₁M ⟨none⟩)
--   if ← withDefault <| isDefEq e unit.e then
--     return .some ⟨none⟩
--   else
--     return none


def isId₁? (e : Expr) : BicategoryM (Option Obj) := do
  let ctx ← read
  let a ← mkFreshExprMVar ctx.B
  let i ← mkId₁ a
  if ← withDefault <| isDefEq e i then
    return .some ⟨← instantiateMVars a⟩
  else
    return none

def isComp₁? (e : Expr) : BicategoryM (Option (Mor₁ × Mor₁)) := do
  let ctx ← read
  let a ← mkFreshExprMVar ctx.B
  let b ← mkFreshExprMVar ctx.B
  let c ← mkFreshExprMVar ctx.B
  let hom_ab ← mkHom₁ a b
  let hom_bc ← mkHom₁ b c
  let f ← mkFreshExprMVar hom_ab
  let g ← mkFreshExprMVar hom_bc
  let fg ← mkComp₁ f g
  if ← withDefault <| isDefEq e fg then
    let a ← instantiateMVars a
    let b ← instantiateMVars b
    let c ← instantiateMVars c
    let f ← instantiateMVars f
    let g ← instantiateMVars g
    return .some ((.of ⟨f, ⟨.some a⟩, ⟨.some b⟩⟩), .of ⟨g, ⟨.some b⟩, ⟨.some c⟩⟩)
  else
    return none

/-- Construct a `Mor₁` expression from a Lean expression. -/
partial def mor₁OfExpr (e : Expr) : BicategoryM Mor₁ := do
  if let some a ← isId₁? e then
    MonadMor₁.id₁M a
  else if let some (f, g) ← isComp₁? e then
    MonadMor₁.comp₁M (← mor₁OfExpr f.e) (← mor₁OfExpr g.e)
  else
    return Mor₁.of (← Atom₁.mkM e)

instance : MkMor₁ BicategoryM where
  ofExpr := mor₁OfExpr

-- open MonadStructuralIso
open MonadMor₂Iso in

partial def Mor₂IsoOfExpr (e : Expr) : BicategoryM Mor₂Iso := do
  match (← whnfR e).getAppFnArgs with
  | (``Bicategory.associator, #[_, _, _, _, _, _, f, g, h]) =>
    Mor₂Iso.associatorM' (← MkMor₁.ofExpr f) (← MkMor₁.ofExpr g) (← MkMor₁.ofExpr h)
  | (``Bicategory.leftUnitor, #[_, _, _, _, f]) =>
    Mor₂Iso.leftUnitorM' (← MkMor₁.ofExpr f)
  | (``Bicategory.rightUnitor, #[_, _, _, _, f]) =>
    Mor₂Iso.rightUnitorM' (← MkMor₁.ofExpr f)
  | (``Iso.refl, #[_, _, f]) =>
    Mor₂Iso.id₂M' (← MkMor₁.ofExpr f)
  | (``Iso.symm, #[_, _, _, _, η]) =>
    Mor₂Iso.symmM (← Mor₂IsoOfExpr η)
  | (``Iso.trans, #[_, _, _, _, _, η, θ]) =>
    Mor₂Iso.comp₂M (← Mor₂IsoOfExpr η) (← Mor₂IsoOfExpr θ)
  | (``Bicategory.whiskerLeftIso, #[_, _, _, _, _, f, g, h, η]) =>
    Mor₂Iso.whiskerLeftM (← MkMor₁.ofExpr f) (← Mor₂IsoOfExpr η)
  | (``Bicategory.whiskerRightIso, #[_, _, _, _, _, f, g, η, h]) =>
    Mor₂Iso.whiskerRightM (← Mor₂IsoOfExpr η) (← MkMor₁.ofExpr h)
  | (``bicategoricalIsoComp, #[_, _, _, _, _, g, h, _, inst, η, θ]) =>
    -- let α ← Mor₂Iso.coherenceHomM' (← MkMor₁.ofExpr g) (← MkMor₁.ofExpr h) inst
    let α ← Mor₂IsoOfExpr <| ← mkBicategoricalCoherenceHom g h inst
    match α with
    | .structuralAtom (.coherenceHom α) =>
      Mor₂Iso.coherenceCompM α (← Mor₂IsoOfExpr η) (← Mor₂IsoOfExpr θ)
    | _ => unreachable!
  | (``BicategoricalCoherence.iso, #[_, _, _, _, f, g, inst]) =>
    Mor₂Iso.coherenceHomM' (← MkMor₁.ofExpr f) (← MkMor₁.ofExpr g) inst
  | _ =>
    return .of ⟨e, ← MkMor₁.ofExpr (← srcExprOfIso e), ← MkMor₁.ofExpr (← tgtExprOfIso e)⟩
    -- let result ← mkEvalOf e
    -- trace[monoidal] m!"{checkEmoji} {← inferType result}"
    -- return ⟨← NormalExpr.ofExpr e, result⟩
  -- throwError m!"could not identify a structural 2-morphism {e}"

-- set_option trace.profiler true in
open MonadMor₂ in
partial def Mor₂OfExpr (e : Expr) : BicategoryM Mor₂ := do
  match ← whnfR e with
  -- whnfR version of `Iso.hom η`
  | .proj ``Iso 0 η => homM (← Mor₂IsoOfExpr η)
  -- whnfR version of `Iso.inv η`
  | .proj ``Iso 1 η => invM (← Mor₂IsoOfExpr η)
  | .app .. => match (← whnfR e).getAppFnArgs with
    -- | (``MonoidalCoherence.hom, #[_, _, f, g, inst]) =>
    --   Mor₂OfExpr (← mkMonoidalCoherenceHom f g inst)
    | (``CategoryStruct.id, #[_, _, f]) => id₂M (← MkMor₁.ofExpr f)
    | (``CategoryStruct.comp, #[_, _, _, _, _, η, θ]) =>
      comp₂M (← Mor₂OfExpr η) (← Mor₂OfExpr θ)
    | (``Bicategory.whiskerLeft, #[_, _, _, _, _, f, g, h, η]) =>
      whiskerLeftM (← MkMor₁.ofExpr f) (← Mor₂OfExpr η)
    | (``Bicategory.whiskerRight, #[_, _, _, _, _, f, g, η, h]) =>
      whiskerRightM (← Mor₂OfExpr η) (← MkMor₁.ofExpr h)
    | (``bicategoricalComp, #[_, _, _, _, _, g, h, _, inst, η, θ]) =>
      coherenceCompM (← MonadStructuralIsoAtom.coherenceHomM (← MkMor₁.ofExpr g) (← MkMor₁.ofExpr h) inst) (← Mor₂OfExpr η) (← Mor₂OfExpr θ)
      -- let α ← Mor₂IsoOfExpr <| ← mkMonoidalCoherenceIso g h inst
      -- logInfo m!"α: {α.e}"
      -- match α with
      -- | .structuralAtom (.coherenceHom α) =>
      --   coherenceCompM α (← Mor₂OfExpr η) (← Mor₂OfExpr θ)
      -- | _ => throwError m!"{α.e}"

      -- throwError m!"could not identify a structural 2-morphism {e}"
    | _ => return .of ⟨e, ← MkMor₁.ofExpr (← srcExpr e), ← MkMor₁.ofExpr (← tgtExpr e)⟩
    -- throwError m!"could not identify a structural 2-morphism {e}"
      -- let α ← mkMonoidalCoherenceHom g h inst
      -- comp₂M (← Mor₂OfExpr η)
        -- (← comp₂M (← Mor₂OfExpr α) (← Mor₂OfExpr θ))
    -- | (Name.anonymous, _) => match ← whnfR e with
    --   -- whnfR version of `Iso.hom η`
    --   | .proj ``Iso 0 η => homM (← Mor₂IsoOfExpr η)
    --   -- whnfR version of `Iso.inv η`
    --   | .proj ``Iso 1 η => invM (← Mor₂IsoOfExpr η)
    --   | _ => throwError "could't find a structural 2-morphism"
  | _ =>
    return .of ⟨e, ← MkMor₁.ofExpr (← srcExpr e), ← MkMor₁.ofExpr (← tgtExpr e)⟩

instance : BicategoryLike.MkMor₂ BicategoryM where
  ofExpr := Mor₂OfExpr

instance : MonadCoherehnceHom BicategoryM where
  unfoldM α := Mor₂IsoOfExpr α.unfold

universe w v u
variable {B : Type u} [Bicategory.{w, v} B] {a b : B}

open Bicategory

theorem mk_eq_of_normalized_eq {f g f' : a ⟶ b} (η θ : f ⟶ g) (η' θ' : f ≅ g)
    (η_f : 𝟙 a ≫ f ≅ f') (η_g : 𝟙 a ≫ g ≅ f')
    (Hη : η'.hom = η) (Hθ : θ'.hom = θ)
    (Hη' : whiskerLeftIso (𝟙 a) η' ≪≫ η_g = η_f)
    (Hθ' : whiskerLeftIso (𝟙 a) θ' ≪≫ η_g = η_f) : η = θ :=
  calc
    η = η'.hom := Hη.symm
    _ = (λ_ f).inv ≫ η_f.hom ≫ η_g.inv ≫ (λ_ g).hom := by
      simp [← reassoc_of% (congrArg Iso.hom Hη')]
    _ = θ'.hom := by
      simp [← reassoc_of% (congrArg Iso.hom Hθ')]
    _ = θ := Hθ

open Elab.Tactic

def pureCoherence (mvarId : MVarId) : MetaM (List MVarId) :=
  BicategoryLike.pureCoherence `bicategory
    Bicategory.Context (mkAppM ``mk_eq_of_normalized_eq) mvarId

elab "bicategory_coherence" : tactic => withMainContext do
  replaceMainGoal <| ← Bicategory.pureCoherence <| ← getMainGoal

end Mathlib.Tactic.Bicategory
