/-
Copyright (c) 2024 Yuma Mizuno. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuma Mizuno
-/
import Mathlib.Tactic.CategoryTheory.Coherence

/-!
# Normalization of morphisms in monoidal categories

This file provides a tactic that normalizes morphisms in monoidal categories. This is used in the
string diagram widget given in `Mathlib.Tactic.StringDiagram`.

We say that the morphism `Œ∑` in a monoidal category is in normal form if
1. `Œ∑` is of the form `Œ±‚ÇÄ ‚â´ Œ∑‚ÇÄ ‚â´ Œ±‚ÇÅ ‚â´ Œ∑‚ÇÅ ‚â´ ... Œ±‚Çò ‚â´ Œ∑‚Çò ‚â´ Œ±‚Çò‚Çä‚ÇÅ` where each `Œ±·µ¢` is a
  structural 2-morphism (consisting of associators and unitors),
2. each `Œ∑·µ¢` is a non-structural 2-morphism of the form `f‚ÇÅ ‚óÅ ... ‚óÅ f‚Çò ‚óÅ Œ∏`, and
3. `Œ∏` is of the form `Œπ ‚ñ∑ g‚ÇÅ ‚ñ∑ ... ‚ñ∑ g‚Çó`

-/


open Lean Meta Elab
open CategoryTheory
open Mathlib.Tactic.Coherence

namespace Mathlib.Tactic.Monoidal

/-- Expressions for atomic 1-morphisms. -/
structure Atom‚ÇÅ : Type where
  /-- Extract a Lean expression from an `Atom‚ÇÅ` expression. -/
  e : Expr

/-- Expressions for 1-morphisms. -/
inductive Mor‚ÇÅ : Type
  /-- `id` is the expression for `ùüô_ C`. -/
  | id : Mor‚ÇÅ
  /-- `comp X Y` is the expression for `X ‚äó Y` -/
  | comp : Mor‚ÇÅ ‚Üí Mor‚ÇÅ ‚Üí Mor‚ÇÅ
  /-- Construct the expression for an atomic 1-morphism. -/
  | of : Atom‚ÇÅ ‚Üí Mor‚ÇÅ
  deriving Inhabited

/-- Converts a 1-morphism into a list of its components. -/
def Mor‚ÇÅ.toList : Mor‚ÇÅ ‚Üí List Atom‚ÇÅ
  | .id => []
  | .comp f g => f.toList ++ g.toList
  | .of f => [f]

/-- Returns `ùüô_ C` if the expression `e` is of the form `ùüô_ C`. -/
def isTensorUnit? (e : Expr) : MetaM (Option Expr) := do
  let C ‚Üê mkFreshExprMVar none
  let instC ‚Üê mkFreshExprMVar none
  let instMC ‚Üê mkFreshExprMVar none
  let unit := mkAppN (‚Üê mkConstWithFreshMVarLevels
    ``MonoidalCategoryStruct.tensorUnit) #[C, instC, instMC]
  if ‚Üê withDefault <| isDefEq e unit then
    return ‚Üê instantiateMVars unit
  else
    return none

/-- Returns `(f, g)` if the expression `e` is of the form `f ‚äó g`. -/
def isTensorObj? (e : Expr) : MetaM (Option (Expr √ó Expr)) := do
  let C ‚Üê mkFreshExprMVar none
  let f ‚Üê mkFreshExprMVar C
  let g ‚Üê mkFreshExprMVar C
  let instC ‚Üê mkFreshExprMVar none
  let instMC ‚Üê mkFreshExprMVar none
  let fg := mkAppN (‚Üê mkConstWithFreshMVarLevels
    ``MonoidalCategoryStruct.tensorObj) #[C, instC, instMC, f, g]
  if ‚Üê withDefault <| isDefEq e fg then
    return (‚Üê instantiateMVars f, ‚Üê instantiateMVars g)
  else
    return none

/-- Construct a `Mor‚ÇÅ` expression from a Lean expression. -/
partial def toMor‚ÇÅ (e : Expr) : MetaM Mor‚ÇÅ := do
  if let some _ ‚Üê isTensorUnit? e then
    return Mor‚ÇÅ.id
  else if let some (f, g) ‚Üê isTensorObj? e then
    return (‚Üê toMor‚ÇÅ f).comp (‚Üê toMor‚ÇÅ g)
  else
    return Mor‚ÇÅ.of ‚ü®e‚ü©

/-- Expressions for atomic structural 2-morphisms. -/
inductive StructuralAtom : Type
  /-- The expression for the associator `(Œ±_ f g h).hom`. -/
  | associator (f g h : Mor‚ÇÅ) : StructuralAtom
  /-- The expression for the inverse of the associator `(Œ±_ f g h).inv`. -/
  | associatorInv (f g h : Mor‚ÇÅ) : StructuralAtom
  /-- The expression for the left unitor `(Œª_ f).hom`. -/
  | leftUnitor (f : Mor‚ÇÅ) : StructuralAtom
  /-- The expression for the inverse of the left unitor `(Œª_ f).inv`. -/
  | leftUnitorInv (f : Mor‚ÇÅ) : StructuralAtom
  /-- The expression for the right unitor `(œÅ_ f).hom`. -/
  | rightUnitor (f : Mor‚ÇÅ) : StructuralAtom
  /-- The expression for the inverse of the right unitor `(œÅ_ f).inv`. -/
  | rightUnitorInv (f : Mor‚ÇÅ) : StructuralAtom
  deriving Inhabited

/-- Construct a `StructuralAtom` expression from a Lean expression. -/
def structuralAtom? (e : Expr) : MetaM (Option StructuralAtom) := do
  match e.getAppFnArgs with
  | (``Iso.hom, #[_, _, _, _, Œ∑]) =>
    match (‚Üê whnfR Œ∑).getAppFnArgs with
    | (``MonoidalCategoryStruct.associator, #[_, _, _, f, g, h]) =>
      return some <| .associator (‚Üê toMor‚ÇÅ f) (‚Üê toMor‚ÇÅ g) (‚Üê toMor‚ÇÅ h)
    | (``MonoidalCategoryStruct.leftUnitor, #[_, _, _, f]) =>
      return some <| .leftUnitor (‚Üê toMor‚ÇÅ f)
    | (``MonoidalCategoryStruct.rightUnitor, #[_, _, _, f]) =>
      return some <| .rightUnitor (‚Üê toMor‚ÇÅ f)
    | _ => return none
  | (``Iso.inv, #[_, _, _, _, Œ∑]) =>
    match (‚Üê whnfR Œ∑).getAppFnArgs with
    | (``MonoidalCategoryStruct.associator, #[_, _, _, f, g, h]) =>
      return some <| .associatorInv (‚Üê toMor‚ÇÅ f) (‚Üê toMor‚ÇÅ g) (‚Üê toMor‚ÇÅ h)
    | (``MonoidalCategoryStruct.leftUnitor, #[_, _, _, f]) =>
      return some <| .leftUnitorInv (‚Üê toMor‚ÇÅ f)
    | (``MonoidalCategoryStruct.rightUnitor, #[_, _, _, f]) =>
      return some <| .rightUnitorInv (‚Üê toMor‚ÇÅ f)
    | _ => return none
  | _ => return none

/-- Expressions for atomic non-structural 2-morphisms. -/
structure Atom where
  /-- Extract a Lean expression from an `Atom` expression. -/
  e : Expr
  deriving Inhabited

/-- Expressions of the form `Œ∑ ‚ñ∑ f‚ÇÅ ‚ñ∑ ... ‚ñ∑ f‚Çô`. -/
inductive WhiskerRightExpr : Type
  /-- Construct the expression for an atomic 2-morphism. -/
  | of (Œ∑ : Atom) : WhiskerRightExpr
  /-- Construct the expression for `Œ∑ ‚ñ∑ f`. -/
  | whisker (Œ∑ : WhiskerRightExpr) (f : Atom‚ÇÅ) : WhiskerRightExpr
  deriving Inhabited

/-- Expressions of the form `Œ∑‚ÇÅ ‚äó ... ‚äó Œ∑‚Çô`. -/
inductive TensorHomExpr : Type
  | of (Œ∑ : WhiskerRightExpr) : TensorHomExpr
  | cons (head : WhiskerRightExpr) (tail : TensorHomExpr) : TensorHomExpr
  deriving Inhabited

/-- Expressions of the form `f‚ÇÅ ‚óÅ ... ‚óÅ f‚Çô ‚óÅ Œ∑`. -/
inductive WhiskerLeftExpr : Type
  /-- Construct the expression for a right-whiskered 2-morphism. -/
  | of (Œ∑ : TensorHomExpr) : WhiskerLeftExpr
  /-- Construct the expression for `f ‚óÅ Œ∑`. -/
  | whisker (f : Atom‚ÇÅ) (Œ∑ : WhiskerLeftExpr) : WhiskerLeftExpr
  deriving Inhabited

/-- Expressions for structural 2-morphisms. -/
inductive Structural : Type
  /-- Expressions for atomic structural 2-morphisms. -/
  | atom (Œ∑ : StructuralAtom) : Structural
  /-- Expressions for the identity `ùüô f`. -/
  | id (f : Mor‚ÇÅ) : Structural
  /-- Expressions for the composition `Œ∑ ‚â´ Œ∏`. -/
  | comp (Œ± Œ≤ : Structural) : Structural
  /-- Expressions for the left whiskering `f ‚óÅ Œ∑`. -/
  | whiskerLeft (f : Mor‚ÇÅ) (Œ∑ : Structural) : Structural
  /-- Expressions for the right whiskering `Œ∑ ‚ñ∑ f`. -/
  | whiskerRight (Œ∑ : Structural) (f : Mor‚ÇÅ) : Structural
  /-- Expressions for the tensor `Œ± ‚äó Œ≤`. -/
  | tensorHom (Œ± Œ≤ : Structural) : Structural
  /-- Expressions for `Œ±` in the monoidal composition `Œ∑ ‚äó‚â´ Œ∏ := Œ∑ ‚â´ Œ± ‚â´ Œ∏`. -/
  | monoidalCoherence (f g : Mor‚ÇÅ) (e : Expr) : Structural
  deriving Inhabited

/-- Normalized expressions for 2-morphisms. -/
inductive NormalExpr : Type
  /-- Construct the expression for a structural 2-morphism. -/
  | nil (Œ± : Structural) : NormalExpr
  /-- Construct the normalized expression of 2-morphisms recursively. -/
  | cons (head_structural : Structural) (head : WhiskerLeftExpr) (tail : NormalExpr) : NormalExpr
  deriving Inhabited

/-- The domain of a morphism. -/
def src (Œ∑ : Expr) : MetaM Mor‚ÇÅ := do
  match (‚Üê whnfR <| ‚Üê inferType Œ∑).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, f, _]) => toMor‚ÇÅ f
  | _ => throwError "{Œ∑} is not a morphism"

/-- The codomain of a morphism. -/
def tar (Œ∑ : Expr) : MetaM Mor‚ÇÅ := do
  match (‚Üê whnfR <| ‚Üê inferType Œ∑).getAppFnArgs with
  | (``Quiver.Hom, #[_, _, _, g]) => toMor‚ÇÅ g
  | _ => throwError "{Œ∑} is not a morphism"

/-- The domain of a 2-morphism. -/
def Atom.src (Œ∑ : Atom) : MetaM Mor‚ÇÅ := do Monoidal.src Œ∑.e

/-- The codomain of a 2-morphism. -/
def Atom.tar (Œ∑ : Atom) : MetaM Mor‚ÇÅ := do Monoidal.tar Œ∑.e

/-- The domain of a 2-morphism. -/
def WhiskerRightExpr.src : WhiskerRightExpr ‚Üí MetaM Mor‚ÇÅ
  | WhiskerRightExpr.of Œ∑ => Œ∑.src
  | WhiskerRightExpr.whisker Œ∑ f => return (‚Üê WhiskerRightExpr.src Œ∑).comp (Mor‚ÇÅ.of f)

/-- The codomain of a 2-morphism. -/
def WhiskerRightExpr.tar : WhiskerRightExpr ‚Üí MetaM Mor‚ÇÅ
  | WhiskerRightExpr.of Œ∑ => Œ∑.tar
  | WhiskerRightExpr.whisker Œ∑ f => return (‚Üê WhiskerRightExpr.tar Œ∑).comp (Mor‚ÇÅ.of f)

/-- The domain of a 2-morphism. -/
def TensorHomExpr.src : TensorHomExpr ‚Üí MetaM Mor‚ÇÅ
  | TensorHomExpr.of Œ∑ => Œ∑.src
  | TensorHomExpr.cons Œ∑ Œ∑s => return (‚Üê Œ∑.src).comp (‚Üê Œ∑s.src)

/-- The codomain of a 2-morphism. -/
def TensorHomExpr.tar : TensorHomExpr ‚Üí MetaM Mor‚ÇÅ
  | TensorHomExpr.of Œ∑ => Œ∑.tar
  | TensorHomExpr.cons Œ∑ Œ∑s => return (‚Üê Œ∑.tar).comp (‚Üê Œ∑s.tar)

/-- The domain of a 2-morphism. -/
def WhiskerLeftExpr.src : WhiskerLeftExpr ‚Üí MetaM Mor‚ÇÅ
  | WhiskerLeftExpr.of Œ∑ => TensorHomExpr.src Œ∑
  | WhiskerLeftExpr.whisker f Œ∑ => return (Mor‚ÇÅ.of f).comp (‚Üê WhiskerLeftExpr.src Œ∑)

/-- The codomain of a 2-morphism. -/
def WhiskerLeftExpr.tar : WhiskerLeftExpr ‚Üí MetaM Mor‚ÇÅ
  | WhiskerLeftExpr.of Œ∑ => TensorHomExpr.tar Œ∑
  | WhiskerLeftExpr.whisker f Œ∑ => return (Mor‚ÇÅ.of f).comp (‚Üê WhiskerLeftExpr.tar Œ∑)

/-- The domain of a 2-morphism. -/
def StructuralAtom.src : StructuralAtom ‚Üí Mor‚ÇÅ
  | .associator f g h => (f.comp g).comp h
  | .associatorInv f g h => f.comp (g.comp h)
  | .leftUnitor f => Mor‚ÇÅ.id.comp f
  | .leftUnitorInv f => f
  | .rightUnitor f => f.comp Mor‚ÇÅ.id
  | .rightUnitorInv f => f

/-- The codomain of a 2-morphism. -/
def StructuralAtom.tar : StructuralAtom ‚Üí Mor‚ÇÅ
  | .associator f g h => f.comp (g.comp h)
  | .associatorInv f g h => (f.comp g).comp h
  | .leftUnitor f => f
  | .leftUnitorInv f => Mor‚ÇÅ.id.comp f
  | .rightUnitor f => f
  | .rightUnitorInv f => f.comp Mor‚ÇÅ.id

/-- The domain of a 2-morphism. -/
def Structural.src : Structural ‚Üí Mor‚ÇÅ
  | .atom Œ∑ => Œ∑.src
  | .id f => f
  | .comp Œ± _ => Œ±.src
  | .whiskerLeft f Œ∑ => f.comp Œ∑.src
  | .whiskerRight Œ∑ f => Œ∑.src.comp f
  | .tensorHom Œ± Œ≤ => Œ±.src.comp Œ≤.src
  | .monoidalCoherence f _ _ => f

/-- The codomain of a 2-morphism. -/
def Structural.tar : Structural ‚Üí Mor‚ÇÅ
  | .atom Œ∑ => Œ∑.tar
  | .id f => f
  | .comp _ Œ≤ => Œ≤.tar
  | .whiskerLeft f Œ∑ => f.comp Œ∑.tar
  | .whiskerRight Œ∑ f => Œ∑.tar.comp f
  | .tensorHom Œ± Œ≤ => Œ±.tar.comp Œ≤.tar
  | .monoidalCoherence _ g _ => g

/-- The domain of a 2-morphism. -/
def NormalExpr.src : NormalExpr ‚Üí Mor‚ÇÅ
  | NormalExpr.nil Œ∑ => Œ∑.src
  | NormalExpr.cons Œ± _ _ => Œ±.src

/-- The codomain of a 2-morphism. -/
def NormalExpr.tar : NormalExpr ‚Üí Mor‚ÇÅ
  | NormalExpr.nil Œ∑ => Œ∑.tar
  | NormalExpr.cons _ _ Œ∑s => Œ∑s.tar

/-- The associator as a term of `normalExpr`. -/
def NormalExpr.associator (f g h : Mor‚ÇÅ) : NormalExpr :=
  .nil <| .atom <| .associator f g h

/-- The inverse of the associator as a term of `normalExpr`. -/
def NormalExpr.associatorInv (f g h : Mor‚ÇÅ) : NormalExpr :=
  .nil <| .atom <| .associatorInv f g h

/-- The left unitor as a term of `normalExpr`. -/
def NormalExpr.leftUnitor (f : Mor‚ÇÅ) : NormalExpr :=
  .nil <| .atom <| .leftUnitor f

/-- The inverse of the left unitor as a term of `normalExpr`. -/
def NormalExpr.leftUnitorInv (f : Mor‚ÇÅ) : NormalExpr :=
  .nil <| .atom <| .leftUnitorInv f

/-- The right unitor as a term of `normalExpr`. -/
def NormalExpr.rightUnitor (f : Mor‚ÇÅ) : NormalExpr :=
  .nil <| .atom <| .rightUnitor f

/-- The inverse of the right unitor as a term of `normalExpr`. -/
def NormalExpr.rightUnitorInv (f : Mor‚ÇÅ) : NormalExpr :=
  .nil <| .atom <| .rightUnitorInv f

-- /-- Return `Œ∑` for `Œ∑ ‚ñ∑ g‚ÇÅ ‚ñ∑ ... ‚ñ∑ g‚Çô`. -/
-- def WhiskerRightExpr.atom : WhiskerRightExpr ‚Üí Atom
--   | WhiskerRightExpr.of Œ∑ => Œ∑
--   | WhiskerRightExpr.whisker Œ∑ _ => Œ∑.atom

--   /-- Return `Œ∑` for `Œ∑ ‚ñ∑ g‚ÇÅ ‚ñ∑ ... ‚ñ∑ g‚Çô`. -/
-- def TensorHomExpr.atom : TensorHomExpr ‚Üí Atom
--   | TensorHomExpr.of Œ∑ => Œ∑
--   | TensorHomExpr.cons Œ∑ _ => Œ∑.atom

-- /-- Return `Œ∑` for `f‚ÇÅ ‚óÅ ... ‚óÅ f‚Çô ‚óÅ Œ∑ ‚ñ∑ g‚ÇÅ ‚ñ∑ ... ‚ñ∑ g‚Çô`. -/
-- def WhiskerLeftExpr.atom : WhiskerLeftExpr ‚Üí Atom
--   | WhiskerLeftExpr.of Œ∑ => Œ∑.atom
--   | WhiskerLeftExpr.whisker _ Œ∑ => Œ∑.atom

/-- Construct a `Structural` expression from a Lean expression for a structural 2-morphism. -/
partial def structural? (e : Expr) : MetaM Structural := do
  match (‚Üê whnfR e).getAppFnArgs with
  | (``CategoryStruct.comp, #[_, _, _, Œ±, Œ≤]) =>
    return .comp (‚Üê structural? Œ±) (‚Üê structural? Œ≤)
  | (``CategoryStruct.id, #[_, f]) => return .id (‚Üê toMor‚ÇÅ f)
  | (``MonoidalCategoryStruct.whiskerLeft, #[f, Œ∑]) =>
    return .whiskerLeft (‚Üê toMor‚ÇÅ f) (‚Üê structural? Œ∑)
  | (``MonoidalCategoryStruct.whiskerRight, #[Œ∑, f]) =>
    return .whiskerRight (‚Üê structural? Œ∑) (‚Üê toMor‚ÇÅ f)
  | (``MonoidalCoherence.hom, #[_, _, f, g, inst]) =>
    return .monoidalCoherence (‚Üê toMor‚ÇÅ f) (‚Üê toMor‚ÇÅ g) inst
  | _ => match ‚Üê structuralAtom? e with
    | some Œ∑ => return .atom Œ∑
    | none => throwError "not a structural 2-morphism"

/-- Construct a `NormalExpr` expression from a `WhiskerLeftExpr` expression. -/
def NormalExpr.of (Œ∑ : WhiskerLeftExpr) : MetaM NormalExpr := do
  return .cons (.id (‚Üê Œ∑.src)) Œ∑ (.nil (.id (‚Üê Œ∑.tar)))

/-- Construct a `NormalExpr` expression from a Lean expression for an atomic 2-morphism. -/
def NormalExpr.ofExpr (Œ∑ : Expr) : MetaM NormalExpr :=
  NormalExpr.of <| .of <| .of <| .of ‚ü®Œ∑‚ü©

/-- If `e` is an expression of the form `Œ∑ ‚äó‚â´ Œ∏ := Œ∑ ‚â´ Œ± ‚â´ Œ∏` in the monoidal category `C`,
return the expression for `Œ±` .-/
def structuralOfMonoidalComp (C e : Expr) : MetaM Structural := do
  let W ‚Üê mkFreshExprMVar none
  let X ‚Üê mkFreshExprMVar none
  let Y ‚Üê mkFreshExprMVar none
  let Z ‚Üê mkFreshExprMVar none
  let f ‚Üê mkFreshExprMVar none
  let g ‚Üê mkFreshExprMVar none
  let Œ±‚ÇÄ ‚Üê mkFreshExprMVar none
  let instC ‚Üê mkFreshExprMVar none
  let Œ±g := mkAppN (‚Üê mkConstWithFreshMVarLevels ``CategoryStruct.comp) #[C, instC, X, Y, Z, Œ±‚ÇÄ, g]
  let fŒ±g := mkAppN (‚Üê mkConstWithFreshMVarLevels
    ``CategoryStruct.comp) #[C, instC, W, X, Z, f, Œ±g]
  _ ‚Üê isDefEq e fŒ±g
  structural? Œ±‚ÇÄ

/-- Construct a `NormalExpr` expression from another `NormalExpr` expression by adding a structural
2-morphism at the head. -/
def NormalExpr.ofNormalExpr (Œ± : Structural) (e : NormalExpr) : MetaM NormalExpr :=
  match e with
  | .nil Œ≤ => return .nil (Œ±.comp Œ≤)
  | .cons Œ≤ Œ∑ Œ∑s => return .cons (Œ±.comp Œ≤) Œ∑ Œ∑s

mutual

/-- Evaluate the expression `Œ∑ ‚â´ Œ∏` into a normalized form. -/
partial def evalComp : NormalExpr ‚Üí NormalExpr ‚Üí MetaM NormalExpr
  | .nil Œ±, .cons Œ≤ Œ∑ Œ∑s => do
    return (.cons (Œ±.comp Œ≤) Œ∑ Œ∑s)
  | .nil Œ±, .nil Œ±' => do
    return .nil (Œ±.comp Œ±')
  | .cons Œ± Œ∑ Œ∑s, Œ∏ => do
    let Œπ ‚Üê evalComp Œ∑s Œ∏
    return .cons Œ± Œ∑ Œπ

/-- Evaluate the expression `f ‚óÅ Œ∑` into a normalized form. -/
partial def evalWhiskerLeftExpr : Mor‚ÇÅ ‚Üí NormalExpr ‚Üí MetaM NormalExpr
  | f, .nil Œ± => return .nil (.whiskerLeft f Œ±)
  | .of f, .cons Œ± Œ∑ Œ∑s => do
    let Œ∑' := WhiskerLeftExpr.whisker f Œ∑
    let Œ∏ ‚Üê evalWhiskerLeftExpr (.of f) Œ∑s
    return .cons (.whiskerLeft (.of f) Œ±) Œ∑' Œ∏
  | .comp f g, Œ∑ => do
    let Œ∏ ‚Üê evalWhiskerLeftExpr g Œ∑
    let Œπ ‚Üê evalWhiskerLeftExpr f Œ∏
    let h := Œ∑.src
    let h' := Œ∑.tar
    let Œπ' ‚Üê evalComp Œπ (NormalExpr.associatorInv f g h')
    let Œπ'' ‚Üê evalComp (NormalExpr.associator f g h) Œπ'
    return Œπ''
  | .id, Œ∑ => do
    let f := Œ∑.src
    let g := Œ∑.tar
    let Œ∑' ‚Üê evalComp Œ∑ (NormalExpr.leftUnitorInv g)
    let Œ∑'' ‚Üê evalComp (NormalExpr.leftUnitor f) Œ∑'
    return Œ∑''

/-- Evaluate the expression `Œ∑ ‚ñ∑ f` into a normalized form. -/
partial def evalWhiskerRightExprAux : TensorHomExpr ‚Üí Atom‚ÇÅ ‚Üí MetaM NormalExpr
  | .of Œ∑, f => NormalExpr.of <| .of <| .of <| .whisker Œ∑ f
  | .cons Œ∑ Œ∑s, f => do
    let Œ∑s' ‚Üê evalWhiskerRightExprAux Œ∑s f
    let Œ∑‚ÇÅ ‚Üê evalTensorHomExpr (‚Üê NormalExpr.of <| .of <| .of Œ∑) Œ∑s'
    let Œ∑‚ÇÇ ‚Üê evalComp Œ∑‚ÇÅ (.associatorInv (‚Üê Œ∑.tar) (‚Üê Œ∑s.tar) (.of f))
    let Œ∑‚ÇÉ ‚Üê evalComp (.associator (‚Üê Œ∑.src) (‚Üê Œ∑s.src) (.of f)) Œ∑‚ÇÇ
    return Œ∑‚ÇÉ

/-- Evaluate the expression `Œ∑ ‚ñ∑ f` into a normalized form. -/
partial def evalWhiskerRightExpr : NormalExpr ‚Üí Mor‚ÇÅ ‚Üí MetaM NormalExpr
  | .nil Œ±, h => return .nil (.whiskerRight Œ± h)
  | .cons Œ± (.of Œ∑) Œ∑s, .of f => do
    let Œ∑s‚ÇÅ ‚Üê evalWhiskerRightExpr Œ∑s (.of f)
    let Œ∑‚ÇÅ ‚Üê evalWhiskerRightExprAux Œ∑ f
    let Œ∑‚ÇÇ ‚Üê evalComp Œ∑‚ÇÅ Œ∑s‚ÇÅ
    let Œ∑‚ÇÉ ‚Üê NormalExpr.ofNormalExpr (.whiskerRight Œ± (.of f)) Œ∑‚ÇÇ
    return Œ∑‚ÇÉ
  | .cons Œ± (.whisker f Œ∑) Œ∑s, h => do
    let g ‚Üê Œ∑.src
    let g' ‚Üê Œ∑.tar
    let Œ∑‚ÇÅ ‚Üê evalWhiskerRightExpr (‚Üê NormalExpr.of Œ∑) h
    let Œ∑‚ÇÇ ‚Üê evalWhiskerLeftExpr (.of f) Œ∑‚ÇÅ
    let Œ∑s‚ÇÅ ‚Üê evalWhiskerRightExpr Œ∑s h
    let Œ∑s‚ÇÇ ‚Üê evalComp (.associatorInv (.of f) g' h) Œ∑s‚ÇÅ
    let Œ∑‚ÇÉ ‚Üê evalComp Œ∑‚ÇÇ Œ∑s‚ÇÇ
    let Œ∑‚ÇÑ ‚Üê evalComp (.associator (.of f) g h) Œ∑‚ÇÉ
    let Œ∑‚ÇÖ ‚Üê NormalExpr.ofNormalExpr (.whiskerRight Œ± h) Œ∑‚ÇÑ
    return Œ∑‚ÇÖ
  | Œ∑, .comp g h => do
    let Œ∑‚ÇÅ ‚Üê evalWhiskerRightExpr Œ∑ g
    let Œ∑‚ÇÇ ‚Üê evalWhiskerRightExpr Œ∑‚ÇÅ h
    let f := Œ∑.src
    let f' := Œ∑.tar
    let Œ∑‚ÇÉ ‚Üê evalComp Œ∑‚ÇÇ (.associator f' g h)
    let Œ∑‚ÇÑ ‚Üê evalComp (.associatorInv f g h) Œ∑‚ÇÉ
    return Œ∑‚ÇÑ
  | Œ∑, .id => do
    let f := Œ∑.src
    let g := Œ∑.tar
    let Œ∑‚ÇÅ ‚Üê evalComp Œ∑ (.rightUnitorInv g)
    let Œ∑‚ÇÇ ‚Üê evalComp (.rightUnitor f) Œ∑‚ÇÅ
    return Œ∑‚ÇÇ

/-- Evaluate the expression `Œ∑ ‚äó Œ∏` into a normalized form. -/
partial def evalTensorHomAux : TensorHomExpr ‚Üí TensorHomExpr ‚Üí MetaM NormalExpr
  | .of Œ∑, Œ∏ => NormalExpr.of <| .of <| .cons Œ∑ Œ∏
  | .cons Œ∑ Œ∑s, Œ∏ => do
    let Œ± := NormalExpr.associator (‚Üê Œ∑.src) (‚Üê Œ∑s.src) (‚Üê Œ∏.src)
    let Œ±' := NormalExpr.associatorInv (‚Üê Œ∑.tar) (‚Üê Œ∑s.tar) (‚Üê Œ∏.tar)
    let Œ∑Œ∏ ‚Üê evalTensorHomAux Œ∑s Œ∏
    let Œ∑‚ÇÅ ‚Üê evalTensorHomExpr (‚Üê NormalExpr.of <| .of <| .of Œ∑) Œ∑Œ∏
    let Œ∑Œ∏‚ÇÅ ‚Üê evalComp Œ∑‚ÇÅ Œ±'
    let Œ∑Œ∏‚ÇÇ ‚Üê evalComp Œ± Œ∑Œ∏‚ÇÅ
    return Œ∑Œ∏‚ÇÇ

/-- Evaluate the expression `Œ∑ ‚äó Œ∏` into a normalized form. -/
partial def evalTensorHomAux' : WhiskerLeftExpr ‚Üí WhiskerLeftExpr ‚Üí MetaM NormalExpr
  | .of Œ∑, .of Œ∏ => evalTensorHomAux Œ∑ Œ∏
  | .whisker f Œ∑, Œ∏ => do
    let Œ∑Œ∏ ‚Üê evalTensorHomAux' Œ∑ Œ∏
    let Œ∑Œ∏‚ÇÅ ‚Üê evalWhiskerLeftExpr (.of f) Œ∑Œ∏
    let Œ∑Œ∏‚ÇÇ ‚Üê evalComp Œ∑Œ∏‚ÇÅ (.associatorInv (.of f) (‚Üê Œ∑.tar) (‚Üê Œ∏.tar))
    let Œ∑Œ∏‚ÇÉ ‚Üê evalComp (.associator (.of f) (‚Üê Œ∑.src) (‚Üê Œ∏.src)) Œ∑Œ∏‚ÇÇ
    return Œ∑Œ∏‚ÇÉ
  | .of Œ∑, .whisker f Œ∏ => do
    let Œ∑‚ÇÅ ‚Üê evalWhiskerRightExprAux Œ∑ f
    let Œ∑Œ∏ ‚Üê evalTensorHomExpr Œ∑‚ÇÅ (‚Üê NormalExpr.of Œ∏)
    let Œ∑Œ∏‚ÇÅ ‚Üê evalComp Œ∑Œ∏ (.associator (‚Üê Œ∑.tar) (.of f) (‚Üê Œ∏.tar))
    let Œ∑Œ∏‚ÇÇ ‚Üê evalComp (.associatorInv (‚Üê Œ∑.src) (.of f) (‚Üê Œ∏.src)) Œ∑Œ∏‚ÇÅ
    return Œ∑Œ∏‚ÇÇ

/-- Evaluate the expression `Œ∑ ‚äó Œ∏` into a normalized form. -/
partial def evalTensorHomExpr : NormalExpr ‚Üí NormalExpr ‚Üí MetaM NormalExpr
  | .nil Œ±, .nil Œ≤ => do
    return .nil (Œ±.tensorHom Œ≤)
  | .nil Œ±, .cons Œ≤ Œ∑ Œ∑s => do
    let Œ∑‚ÇÅ ‚Üê evalWhiskerLeftExpr Œ±.tar (‚Üê NormalExpr.of Œ∑)
    let Œ∑s‚ÇÅ ‚Üê evalWhiskerLeftExpr Œ±.tar Œ∑s
    let Œ∑‚ÇÇ ‚Üê evalComp Œ∑‚ÇÅ Œ∑s‚ÇÅ
    let Œ∑‚ÇÉ ‚Üê NormalExpr.ofNormalExpr (Œ±.tensorHom Œ≤) Œ∑‚ÇÇ
    return Œ∑‚ÇÉ
  | .cons Œ± Œ∑ Œ∑s, .nil Œ≤ => do
    let Œ∑‚ÇÅ ‚Üê evalWhiskerRightExpr (‚Üê NormalExpr.of Œ∑) Œ≤.tar
    let Œ∑s‚ÇÅ ‚Üê evalWhiskerRightExpr Œ∑s Œ≤.tar
    let Œ∑‚ÇÇ ‚Üê evalComp Œ∑‚ÇÅ Œ∑s‚ÇÅ
    let Œ∑‚ÇÉ ‚Üê NormalExpr.ofNormalExpr (Œ±.tensorHom Œ≤) Œ∑‚ÇÇ
    return Œ∑‚ÇÉ
  | .cons Œ± Œ∑ Œ∑s, .cons Œ≤ Œ∏ Œ∏s => do
    let Œ∑Œ∏ ‚Üê evalTensorHomAux' Œ∑ Œ∏
    let Œ∑Œ∏s ‚Üê evalTensorHomExpr Œ∑s Œ∏s
    let Œ∑Œ∏‚ÇÅ ‚Üê evalComp Œ∑Œ∏ Œ∑Œ∏s
    let Œ∑Œ∏‚ÇÇ ‚Üê NormalExpr.ofNormalExpr (Œ±.tensorHom Œ≤) Œ∑Œ∏‚ÇÅ
    return Œ∑Œ∏‚ÇÇ

end

/-- Evaluate the expression of a 2-morphism into a normalized form. -/
partial def eval (e : Expr) : MetaM NormalExpr := do
  if let .some e' ‚Üê structuralAtom? e then return .nil <| .atom e' else
    match e.getAppFnArgs with
    | (``CategoryStruct.id, #[_, _, f]) =>
      return .nil (.id (‚Üê toMor‚ÇÅ f))
    | (``CategoryStruct.comp, #[_, _, _, _, _, Œ∑, Œ∏]) =>
      let Œ∑_e ‚Üê eval Œ∑
      let Œ∏_e ‚Üê eval Œ∏
      let Œ∑Œ∏ ‚Üê evalComp Œ∑_e Œ∏_e
      return Œ∑Œ∏
    | (``MonoidalCategoryStruct.whiskerLeft, #[_, _, _, f, _, _, Œ∑]) =>
      evalWhiskerLeftExpr (‚Üê toMor‚ÇÅ f) (‚Üê eval Œ∑)
    | (``MonoidalCategoryStruct.whiskerRight, #[_, _, _, _, _, Œ∑, h]) =>
      evalWhiskerRightExpr (‚Üê eval Œ∑) (‚Üê toMor‚ÇÅ h)
    | (``monoidalComp, #[C, _, _, _, _, _, _, Œ∑, Œ∏]) =>
      let Œ∑_e ‚Üê eval Œ∑
      let Œ±‚ÇÄ ‚Üê structuralOfMonoidalComp C e
      let Œ± := NormalExpr.nil Œ±‚ÇÄ
      let Œ∏_e ‚Üê eval Œ∏
      let Œ±Œ∏ ‚Üê evalComp Œ± Œ∏_e
      let Œ∑Œ±Œ∏ ‚Üê evalComp Œ∑_e Œ±Œ∏
      return Œ∑Œ±Œ∏
    | (``MonoidalCategoryStruct.tensorHom, #[_, _, _, _, _, _, _, Œ∑, Œ∏]) =>
      evalTensorHomExpr (‚Üê eval Œ∑) (‚Üê eval Œ∏)
    | _ => NormalExpr.ofExpr e

/-- Convert a `NormalExpr` expression into a list of `WhiskerLeftExpr` expressions. -/
def NormalExpr.toList : NormalExpr ‚Üí List WhiskerLeftExpr
  | NormalExpr.nil _ => []
  | NormalExpr.cons _ Œ∑ Œ∑s => Œ∑ :: NormalExpr.toList Œ∑s

/- ## Test for `eval`. -/

/-- The context for evaluating expressions. -/
structure Context where
  /-- The expression for the underlying category. -/
  C : Expr

/-- Populate a `context` object for evaluating `e`. -/
def mkContext (e : Expr) : MetaM (Context) := do
  match (‚Üê whnfR <| ‚Üê inferType e).getAppFnArgs with
  | (``Quiver.Hom, #[C, _, _, _]) =>
    return { C := C }
  | _ => throwError "not a morphism"

/-- The monad for the normalization of 2-morphisms. -/
abbrev MonoidalM := ReaderT Context MetaM

/-- Run a computation in the `M` monad. -/
abbrev MonoidalM.run {Œ± : Type} (c : Context) (m : MonoidalM Œ±) : MetaM Œ± :=
  ReaderT.run m c

/-- Extract a Lean expression from a `Mor‚ÇÅ` expression. -/
def Mor‚ÇÅ.e : Mor‚ÇÅ ‚Üí MonoidalM Expr
  | .id => do
    let ctx ‚Üê read
    mkAppOptM ``MonoidalCategoryStruct.tensorUnit #[ctx.C, none, none]
  | .comp f g => do
    mkAppM ``MonoidalCategoryStruct.tensorObj #[‚Üê Mor‚ÇÅ.e f, ‚Üê Mor‚ÇÅ.e g]
  | .of f => return f.e

/-- Extract a Lean expression from a `StructuralAtom` expression. -/
def StructuralAtom.e : StructuralAtom ‚Üí MonoidalM Expr
  | .associator f g h => do
    mkAppM ``Iso.hom #[‚Üê mkAppM ``MonoidalCategoryStruct.associator #[‚Üê f.e, ‚Üê g.e, ‚Üê h.e]]
  | .associatorInv f g h => do
    mkAppM ``Iso.inv #[‚Üê mkAppM ``MonoidalCategoryStruct.associator #[‚Üê f.e, ‚Üê g.e, ‚Üê h.e]]
  | .leftUnitor f => do
    mkAppM ``Iso.hom #[‚Üê mkAppM ``MonoidalCategoryStruct.leftUnitor #[‚Üê f.e]]
  | .leftUnitorInv f => do
    mkAppM ``Iso.inv #[‚Üê mkAppM ``MonoidalCategoryStruct.leftUnitor #[‚Üê f.e]]
  | .rightUnitor f => do
    mkAppM ``Iso.hom #[‚Üê mkAppM ``MonoidalCategoryStruct.rightUnitor #[‚Üê f.e]]
  | .rightUnitorInv f => do
    mkAppM ``Iso.inv #[‚Üê mkAppM ``MonoidalCategoryStruct.rightUnitor #[‚Üê f.e]]

/-- Extract a Lean expression from a `Structural` expression. -/
partial def Structural.e : Structural ‚Üí MonoidalM Expr
  | .atom Œ∑ => Œ∑.e
  | .id f => do mkAppM ``CategoryStruct.id #[‚Üê f.e]
  | .comp Œ± Œ≤ => do match Œ±, Œ≤ with
    | _, _ => mkAppM ``CategoryStruct.comp #[‚Üê Œ±.e, ‚Üê Œ≤.e]
  | .whiskerLeft f Œ∑ => do mkAppM ``MonoidalCategoryStruct.whiskerLeft #[‚Üê f.e, ‚Üê Œ∑.e]
  | .whiskerRight Œ∑ f => do mkAppM ``MonoidalCategoryStruct.whiskerRight #[‚Üê Œ∑.e, ‚Üê f.e]
  | .tensorHom Œ± Œ≤ => do mkAppM ``MonoidalCategoryStruct.tensorHom #[‚Üê Œ±.e, ‚Üê Œ≤.e]
  | .monoidalCoherence _ _ e => do
    mkAppOptM ``MonoidalCoherence.hom #[none, none, none, none, e]

/-- Extract a Lean expression from a `WhiskerRightExpr` expression. -/
def WhiskerRightExpr.e : WhiskerRightExpr ‚Üí MonoidalM Expr
  | WhiskerRightExpr.of Œ∑ => return Œ∑.e
  | WhiskerRightExpr.whisker Œ∑ f => do
    mkAppM ``MonoidalCategoryStruct.whiskerRight #[‚Üê Œ∑.e, f.e]

/-- Extract a Lean expression from a `TensorHomExpr` expression. -/
def TensorHomExpr.e : TensorHomExpr ‚Üí MonoidalM Expr
  | TensorHomExpr.of Œ∑ => Œ∑.e
  | TensorHomExpr.cons Œ∑ Œ∑s => do
    mkAppM ``MonoidalCategoryStruct.tensorHom #[‚Üê Œ∑.e, ‚Üê Œ∑s.e]

/-- Extract a Lean expression from a `WhiskerLeftExpr` expression. -/
def WhiskerLeftExpr.e : WhiskerLeftExpr ‚Üí MonoidalM Expr
  | WhiskerLeftExpr.of Œ∑ => Œ∑.e
  | WhiskerLeftExpr.whisker f Œ∑ => do
    mkAppM ``MonoidalCategoryStruct.whiskerLeft #[f.e, ‚Üê Œ∑.e]

/-- Extract a Lean expression from a `NormalExpr` expression. -/
def NormalExpr.e : NormalExpr ‚Üí MonoidalM Expr
  | NormalExpr.nil Œ± => Œ±.e
  | NormalExpr.cons Œ± Œ∑ Œ∏ => do
    mkAppM ``CategoryStruct.comp #[‚Üê Œ±.e, ‚Üê mkAppM ``CategoryStruct.comp #[‚Üê Œ∑.e, ‚Üê Œ∏.e]]

/-- `normalize% Œ∑` is the normalization of the 2-morphism `Œ∑`. It is of the form
`Œ±‚ÇÄ ‚â´ Œ∑‚ÇÄ ‚â´ Œ±‚ÇÅ ‚â´ Œ∑‚ÇÅ ‚â´ ... Œ±‚Çô ‚â´ Œ∑‚Çô ‚â´ Œ±‚Çô‚Çä‚ÇÅ`, where `Œ±·µ¢` are structural 2-morphisms
and `Œ∑·µ¢` are non-structural 2-morphisms. -/
elab "normalize% " t:term:51 : term => do
  let e ‚Üê Lean.Elab.Term.elabTerm t none
  MonoidalM.run (‚Üê mkContext e) do (‚Üê eval e).e

end Mathlib.Tactic.Monoidal
