/-
Copyright (c) 2024 Yuma Mizuno. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuma Mizuno
-/
import Mathlib.Tactic.CategoryTheory.Monoidal

/-!
# A `coherence` tactic for monoidal categories

-/

open Lean Elab Meta Tactic
open CategoryTheory

universe v u

namespace Mathlib.Tactic.Monoidal

variable {C : Type u} [Category.{v} C] [MonoidalCategory C]

open MonoidalCategory

/-- Make a `Iso.refl` expression. -/
def mkIsoRefl (f : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  return mkAppN (.const ``Iso.refl (‚Üê getLevels))
    #[ctx.C, ctx.instCat, f]

/-- Make a `whiskerRightIso` expression. -/
def mkWhiskerRightIso (Œ∑ : Expr) (h : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExprOfIso Œ∑
  let g ‚Üê tgtExprOfIso Œ∑
  return mkAppN (.const ``MonoidalCategory.whiskerRightIso (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, f, g, Œ∑, h]

/-- Make a `Iso.trans` expression. -/
def mkIsoTrans (Œ∑ Œ∏ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExprOfIso Œ∑
  let g ‚Üê tgtExprOfIso Œ∑
  let h ‚Üê tgtExprOfIso Œ∏
  return mkAppN (.const ``Iso.trans (‚Üê getLevels))
    #[ctx.C, ctx.instCat, f, g, h, Œ∑, Œ∏]

/-- Make a `Iso.symm` expression. -/
def mkIsoSymm (Œ∑ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let f ‚Üê srcExprOfIso Œ∑
  let g ‚Üê tgtExprOfIso Œ∑
  return mkAppN (.const ``Iso.symm (‚Üê getLevels))
    #[ctx.C, ctx.instCat, f, g, Œ∑]

inductive NormalizedHom (Œ± : Type u) : Type u
  | nil : NormalizedHom Œ±
  | cons : NormalizedHom Œ± ‚Üí Œ± ‚Üí NormalizedHom Œ±

structure Coherence.Result where
  /-- The normalized 1-morphism. -/
  normalizedHom : NormalizedHom Expr
  /-- The 2-morphism from the original 1-morphism to the normalized 1-morphism. -/
  toNormalize : Expr

abbrev normalizeIso {p f g pf pfg : C} (Œ∑_f : p ‚äó f ‚âÖ pf) (Œ∑_g : pf ‚äó g ‚âÖ pfg) :=
  (Œ±_ _ _ _).symm ‚â™‚â´ whiskerRightIso Œ∑_f g ‚â™‚â´ Œ∑_g

theorem naturality_associator {p f g h pf pfg pfgh : C}
    (Œ∑_f : (p ‚äó f) ‚âÖ pf) (Œ∑_g : (pf ‚äó g) ‚âÖ pfg) (Œ∑_h : pfg ‚äó h ‚âÖ pfgh) :
    p ‚óÅ (Œ±_ f g h).hom ‚â´ (normalizeIso Œ∑_f (normalizeIso Œ∑_g Œ∑_h)).hom =
    (normalizeIso (normalizeIso Œ∑_f Œ∑_g) Œ∑_h).hom := by
  simp only [Iso.trans_hom, Iso.symm_hom, whiskerRightIso_hom, whiskerRight_tensor, Category.assoc,
    Iso.hom_inv_id_assoc, pentagon_hom_inv_inv_inv_inv_assoc, whiskerRightIso_trans,
    Iso.trans_assoc, Iso.refl_hom, Category.comp_id]

def mkNaturalityAssociator (p f g h Œ∑_f Œ∑_g Œ∑_h : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let pf ‚Üê tgtExprOfIso Œ∑_f
  let pfg ‚Üê tgtExprOfIso Œ∑_g
  let pfgh ‚Üê tgtExprOfIso Œ∑_h
  return mkAppN (.const ``naturality_associator (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, p, f, g, h, pf, pfg, pfgh, Œ∑_f, Œ∑_g, Œ∑_h]

theorem naturality_associator_inv {p f g h pf pfg pfgh : C}
    (Œ∑_f : (p ‚äó f) ‚âÖ pf) (Œ∑_g : (pf ‚äó g) ‚âÖ pfg) (Œ∑_h : pfg ‚äó h ‚âÖ pfgh) :
    p ‚óÅ (Œ±_ f g h).inv ‚â´ (normalizeIso (normalizeIso Œ∑_f Œ∑_g) Œ∑_h).hom =
    (normalizeIso Œ∑_f (normalizeIso Œ∑_g Œ∑_h)).hom := by
  simp only [Iso.trans_hom, Iso.symm_hom, whiskerRightIso_trans, Iso.trans_assoc,
    whiskerRightIso_hom, pentagon_inv_assoc, whiskerRight_tensor, Category.assoc,
    Iso.hom_inv_id_assoc, Iso.refl_hom, Category.comp_id]

def mkNaturalityAssociatorInv (p f g h Œ∑_f Œ∑_g Œ∑_h : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let pf ‚Üê tgtExprOfIso Œ∑_f
  let pfg ‚Üê tgtExprOfIso Œ∑_g
  let pfgh ‚Üê tgtExprOfIso Œ∑_h
  return mkAppN (.const ``naturality_associator_inv (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, p, f, g, h, pf, pfg, pfgh, Œ∑_f, Œ∑_g, Œ∑_h]

theorem naturality_leftUnitor {p f pf : C} (Œ∑_f : p ‚äó f ‚âÖ pf) :
    p ‚óÅ (Œª_ f).hom ‚â´ Œ∑_f.hom = (normalizeIso (œÅ_ p) Œ∑_f).hom := by
  simp only [Iso.trans_hom, Iso.symm_hom, whiskerRightIso_hom, triangle_assoc_comp_right_assoc,
    Iso.refl_hom, Category.comp_id]

def mkNaturalityLeftUnitor (p f Œ∑_f : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let pf ‚Üê tgtExprOfIso Œ∑_f
  return mkAppN (.const ``naturality_leftUnitor (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, p, f, pf, Œ∑_f]

theorem naturality_leftUnitor_inv {p f pf : C} (Œ∑_f : p ‚äó f ‚âÖ pf) :
    p ‚óÅ (Œª_ f).inv ‚â´ (normalizeIso (œÅ_ p) Œ∑_f).hom = Œ∑_f.hom := by
  simp only [Iso.trans_hom, Iso.symm_hom, whiskerRightIso_hom, triangle_assoc_comp_right_assoc,
    whiskerLeft_inv_hom_assoc, Iso.refl_hom, Category.comp_id]

def mkNaturalityLeftUnitorInv (p f Œ∑_f : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let pf ‚Üê tgtExprOfIso Œ∑_f
  return mkAppN (.const ``naturality_leftUnitor_inv (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, p, f, pf, Œ∑_f]

theorem naturality_rightUnitor {p f pf : C} (Œ∑_f : p ‚äó f ‚âÖ pf) :
    p ‚óÅ (œÅ_ f).hom ‚â´ Œ∑_f.hom = (normalizeIso Œ∑_f (œÅ_ pf)).hom := by
  simp only [whiskerLeft_rightUnitor, Category.assoc, Iso.trans_hom, Iso.symm_hom,
    whiskerRightIso_hom, MonoidalCategory.whiskerRight_id, Iso.inv_hom_id, Category.comp_id,
    Iso.refl_hom]

def mkNaturalityRightUnitor (p f Œ∑_f : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let pf ‚Üê tgtExprOfIso Œ∑_f
  return mkAppN (.const ``naturality_rightUnitor (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, p, f, pf, Œ∑_f]

theorem naturality_rightUnitor_inv {p f pf : C} (Œ∑_f : p ‚äó f ‚âÖ pf) :
    p ‚óÅ (œÅ_ f).inv ‚â´ (normalizeIso Œ∑_f (œÅ_ pf)).hom = Œ∑_f.hom := by
  simp only [whiskerLeft_rightUnitor_inv, Iso.trans_hom, Iso.symm_hom, whiskerRightIso_hom,
    MonoidalCategory.whiskerRight_id, Category.assoc, Iso.inv_hom_id, Category.comp_id,
    Iso.hom_inv_id_assoc, Iso.inv_hom_id_assoc, Iso.refl_hom]

def mkNaturalityRightUnitorInv (p f Œ∑_f : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let pf ‚Üê tgtExprOfIso Œ∑_f
  return mkAppN (.const ``naturality_rightUnitor_inv (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, p, f, pf, Œ∑_f]

theorem naturality_id {p f pf : C} (Œ∑_f : p ‚äó f ‚âÖ pf) :
    p ‚óÅ (ùüô f) ‚â´ Œ∑_f.hom = Œ∑_f.hom := by
  simp only [MonoidalCategory.whiskerLeft_id, Category.id_comp]

def mkNaturalityId (p f Œ∑_f : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let pf ‚Üê tgtExprOfIso Œ∑_f
  return mkAppN (.const ``naturality_id (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, p, f, pf, Œ∑_f]

theorem naturality_comp {p f g h pf : C}
    (Œ∑ : f ‚ü∂ g) (Œ∏ : g ‚ü∂ h) (Œ∑_f : (p ‚äó f) ‚âÖ pf) (Œ∑_g : (p ‚äó g) ‚âÖ pf) (Œ∑_h : p ‚äó h ‚âÖ pf)
    (ih_Œ∑ : p ‚óÅ Œ∑ ‚â´ Œ∑_g.hom = Œ∑_f.hom) (ih_Œ∏ : p ‚óÅ Œ∏ ‚â´ Œ∑_h.hom = Œ∑_g.hom) :
    p ‚óÅ (Œ∑ ‚â´ Œ∏) ‚â´ Œ∑_h.hom = Œ∑_f.hom := by
  simp only [MonoidalCategory.whiskerLeft_comp, Category.assoc, ‚Üê ih_Œ∑, ‚Üê ih_Œ∏]

def mkNaturalityComp (p f g h Œ∑ Œ∏ Œ∑_f Œ∑_g Œ∑_h ih_Œ∑ ih_Œ∏ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let pf ‚Üê tgtExprOfIso Œ∑_f
  return mkAppN (.const ``naturality_comp (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, p, f, g, h, pf, Œ∑, Œ∏, Œ∑_f, Œ∑_g, Œ∑_h, ih_Œ∑, ih_Œ∏]

theorem naturality_whiskerLeft {p f g h pf pfg : C} (Œ∑ : g ‚ü∂ h) (Œ∑_f : (p ‚äó f) ‚âÖ pf)
    (Œ∑_fg : (pf ‚äó g) ‚âÖ pfg)
    (Œ∑_fh : (pf ‚äó h) ‚âÖ pfg)
    (ih_Œ∑ : pf ‚óÅ Œ∑ ‚â´ Œ∑_fh.hom = Œ∑_fg.hom) :
    p ‚óÅ (f ‚óÅ Œ∑) ‚â´ (normalizeIso Œ∑_f Œ∑_fh).hom =
    (normalizeIso Œ∑_f Œ∑_fg).hom := by
  simp only [Iso.trans_hom, Iso.symm_hom, whiskerRightIso_hom, ‚Üê ih_Œ∑, ‚Üê whisker_exchange_assoc,
    tensor_whiskerLeft, Category.assoc, Iso.inv_hom_id_assoc, Iso.refl_hom, Category.comp_id]

def mkNaturalityWhiskerLeft (p f g h Œ∑ Œ∑_f Œ∑_fg Œ∑_fh ih_Œ∑ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let pf ‚Üê tgtExprOfIso Œ∑_f
  let pfg ‚Üê tgtExprOfIso Œ∑_fg
  return mkAppN (.const ``naturality_whiskerLeft (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, p, f, g, h, pf, pfg, Œ∑, Œ∑_f, Œ∑_fg, Œ∑_fh, ih_Œ∑]

theorem naturality_whiskerRight {p f g h pf pfh : C} (Œ∑ : f ‚ü∂ g) (Œ∑_f : (p ‚äó f) ‚âÖ pf)
    (Œ∑_g : (p ‚äó g) ‚âÖ pf)
    (Œ∑_fh : (pf ‚äó h) ‚âÖ pfh)
    (ih_Œ∑ : p ‚óÅ Œ∑ ‚â´ Œ∑_g.hom = Œ∑_f.hom) :
    p ‚óÅ (Œ∑ ‚ñ∑ h) ‚â´ (normalizeIso Œ∑_g Œ∑_fh).hom =
    (normalizeIso Œ∑_f Œ∑_fh).hom := by
  simp only [Iso.trans_hom, Iso.symm_hom, whiskerRightIso_hom, ‚Üê ih_Œ∑, comp_whiskerRight,
    whisker_assoc, Category.assoc, Iso.inv_hom_id_assoc]

def mkNaturalityWhiskerRight (p f g h Œ∑ Œ∑_f Œ∑_g Œ∑_fh ih_Œ∑ : Expr) : MonoidalM Expr := do
  let ctx ‚Üê read
  let pf ‚Üê tgtExprOfIso Œ∑_f
  let pfh ‚Üê tgtExprOfIso Œ∑_fh
  return mkAppN (.const ``naturality_whiskerRight (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal, p, f, g, h, pf, pfh, Œ∑, Œ∑_f, Œ∑_g, Œ∑_fh, ih_Œ∑]

theorem naturality_tensorHom {p f‚ÇÅ g‚ÇÅ f‚ÇÇ g‚ÇÇ pf‚ÇÅ pf‚ÇÅf‚ÇÇ : C} (Œ∑ : f‚ÇÅ ‚ü∂ g‚ÇÅ) (Œ∏ : f‚ÇÇ ‚ü∂ g‚ÇÇ)
    (Œ∑_f‚ÇÅ : p ‚äó f‚ÇÅ ‚âÖ pf‚ÇÅ) (Œ∑_g‚ÇÅ : p ‚äó g‚ÇÅ ‚âÖ pf‚ÇÅ)
    (Œ∑_f‚ÇÇ : pf‚ÇÅ ‚äó f‚ÇÇ ‚âÖ pf‚ÇÅf‚ÇÇ) (Œ∑_g‚ÇÇ : pf‚ÇÅ ‚äó g‚ÇÇ ‚âÖ pf‚ÇÅf‚ÇÇ)
    (ih_Œ∑ : p ‚óÅ Œ∑ ‚â´ Œ∑_g‚ÇÅ.hom = Œ∑_f‚ÇÅ.hom)
    (ih_Œ∏ : pf‚ÇÅ ‚óÅ Œ∏ ‚â´ Œ∑_g‚ÇÇ.hom = Œ∑_f‚ÇÇ.hom) :
    p ‚óÅ (Œ∑ ‚äó Œ∏) ‚â´ (normalizeIso Œ∑_g‚ÇÅ Œ∑_g‚ÇÇ).hom = (normalizeIso Œ∑_f‚ÇÅ Œ∑_f‚ÇÇ).hom := by
  simp only [tensorHom_def, MonoidalCategory.whiskerLeft_comp, Iso.trans_hom, Iso.symm_hom,
    whiskerRightIso_hom, Category.assoc, ‚Üê ih_Œ∑, comp_whiskerRight, whisker_assoc, ‚Üê ih_Œ∏,
    Iso.inv_hom_id_assoc]
  simp only [‚Üê whisker_exchange_assoc, associator_inv_naturality_right_assoc]

def mkNaturalityTensorHom (p f‚ÇÅ g‚ÇÅ f‚ÇÇ g‚ÇÇ Œ∑ Œ∏ Œ∑_f‚ÇÅ Œ∑_g‚ÇÅ Œ∑_f‚ÇÇ Œ∑_g‚ÇÇ ih_Œ∑ ih_Œ∏ : Expr) :
    MonoidalM Expr := do
  let ctx ‚Üê read
  let pf‚ÇÅ ‚Üê tgtExprOfIso Œ∑_f‚ÇÅ
  let pf‚ÇÅf‚ÇÇ ‚Üê tgtExprOfIso Œ∑_f‚ÇÇ
  return mkAppN (.const ``naturality_tensorHom (‚Üê getLevels))
    #[ctx.C, ctx.instCat, ctx.instMonoidal,
      p, f‚ÇÅ, g‚ÇÅ, f‚ÇÇ, g‚ÇÇ, pf‚ÇÅ, pf‚ÇÅf‚ÇÇ, Œ∑, Œ∏, Œ∑_f‚ÇÅ, Œ∑_g‚ÇÅ, Œ∑_f‚ÇÇ, Œ∑_g‚ÇÇ, ih_Œ∑, ih_Œ∏]

def eval‚ÇÅ (p : NormalizedHom Expr) : MonoidalM Expr := do
  match p with
  | .nil => mkTensorUnit
  | .cons fs f => mkTensorObj (‚Üê eval‚ÇÅ fs) f

partial def normalize (p : NormalizedHom Expr) (f : Expr) : MonoidalM Coherence.Result := do
  if let some _ ‚Üê isTensorUnit? f then
    let Œ± ‚Üê mkRightUnitor (‚Üê eval‚ÇÅ p)
    return ‚ü®p, Œ±‚ü©
  else if let some (f, g) ‚Üê isTensorObj? f then
    let ‚ü®pf, Hf‚ü© ‚Üê normalize p f
    let Hf' ‚Üê mkWhiskerRightIso Hf g
    let ‚ü®pfg, Hg‚ü© ‚Üê normalize pf g
    let Œ∑ ‚Üê mkIsoTrans Hf' Hg
    let alpha ‚Üê mkIsoSymm (‚Üê mkAssociator (‚Üê eval‚ÇÅ p) f g)
    let Œ∑' ‚Üê mkIsoTrans alpha Œ∑
    return ‚ü®pfg, Œ∑'‚ü©
  else
    let Œ± ‚Üê mkIsoRefl (‚Üê eval‚ÇÅ (p.cons f))
    return ‚ü®p.cons f, Œ±‚ü©

theorem of_normalize_eq {f g f' : C} (Œ∑ Œ∏ : f ‚ü∂ g) (Œ∑_f : ùüô_ C ‚äó f ‚âÖ f') (Œ∑_g : ùüô_ C ‚äó g ‚âÖ f')
  (h_Œ∑ : ùüô_ C ‚óÅ Œ∑ ‚â´ Œ∑_g.hom = Œ∑_f.hom)
  (h_Œ∏ : ùüô_ C ‚óÅ Œ∏ ‚â´ Œ∑_g.hom = Œ∑_f.hom) : Œ∑ = Œ∏ := by
  simp only [id_whiskerLeft, Category.assoc] at h_Œ∑ h_Œ∏
  calc
    Œ∑ = (Œª_ f).inv ‚â´ Œ∑_f.hom ‚â´ Œ∑_g.inv ‚â´ (Œª_ g).hom := by
      simp [‚Üê reassoc_of% h_Œ∑]
    _ = Œ∏ := by
      simp [‚Üê reassoc_of% h_Œ∏]

partial def naturality (p : NormalizedHom Expr) (Œ∑ : Expr) : MonoidalM Expr := do
  match Œ∑.getAppFnArgs with
  | (``Iso.hom, #[_, _, _, _, Œ∑]) =>
    match (‚Üê whnfR Œ∑).getAppFnArgs with
    | (``MonoidalCategoryStruct.associator, #[_, _, _, f, g, h]) =>
      withTraceNode `monoidal (fun _ => return m!"associator") do
        let ‚ü®pf, Œ∑_f‚ü© ‚Üê normalize p f
        let ‚ü®pfg, Œ∑_g‚ü© ‚Üê normalize pf g
        let ‚ü®_, Œ∑_h‚ü© ‚Üê normalize pfg h
        let result ‚Üê mkNaturalityAssociator (‚Üê eval‚ÇÅ p) f g h Œ∑_f Œ∑_g Œ∑_h
        trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
        return result
    | (``MonoidalCategoryStruct.leftUnitor, #[_, _, _, f]) =>
      withTraceNode `monoidal (fun _ => return m!"leftUnitor") do
        let ‚ü®_, Œ∑_f‚ü© ‚Üê normalize p f
        let result ‚Üê mkNaturalityLeftUnitor (‚Üê eval‚ÇÅ p) f Œ∑_f
        trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
        return result
    | (``MonoidalCategoryStruct.rightUnitor, #[_, _, _, f]) =>
      withTraceNode `monoidal (fun _ => return m!"rightUnitor") do
        let ‚ü®_, Œ∑_f‚ü© ‚Üê normalize p f
        let result ‚Üê mkNaturalityRightUnitor (‚Üê eval‚ÇÅ p) f Œ∑_f
        trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
        return result
    | _ => throwError "failed to prove the naturality for {Œ∑}"
  | (``Iso.inv, #[_, _, _, _, Œ∑]) =>
    match (‚Üê whnfR Œ∑).getAppFnArgs with
    | (``MonoidalCategoryStruct.associator, #[_, _, _, f, g, h]) =>
      withTraceNode `monoidal (fun _ => return m!"associator_inv") do
        let ‚ü®pf, Œ∑_f‚ü© ‚Üê normalize p f
        let ‚ü®pfg, Œ∑_g‚ü© ‚Üê normalize pf g
        let ‚ü®_, Œ∑_h‚ü© ‚Üê normalize pfg h
        let result ‚Üê mkNaturalityAssociatorInv (‚Üê eval‚ÇÅ p) f g h Œ∑_f Œ∑_g Œ∑_h
        trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
        return result
    | (``MonoidalCategoryStruct.leftUnitor, #[_, _, _, f]) =>
      withTraceNode `monoidal (fun _ => return m!"leftUnitor_inv") do
        let ‚ü®_, Œ∑_f‚ü© ‚Üê normalize p f
        let result ‚Üê mkNaturalityLeftUnitorInv (‚Üê eval‚ÇÅ p) f Œ∑_f
        trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
        return result
    | (``MonoidalCategoryStruct.rightUnitor, #[_, _, _, f]) =>
      withTraceNode `monoidal (fun _ => return m!"rightUnitor_inv") do
        let ‚ü®_, Œ∑_f‚ü© ‚Üê normalize p f
        let result ‚Üê mkNaturalityRightUnitorInv (‚Üê eval‚ÇÅ p) f Œ∑_f
        trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
        return result
    | _ => throwError "failed to prove the naturality for {Œ∑}"
  | _ =>  match (‚Üê whnfR Œ∑).getAppFnArgs with
    | (``CategoryStruct.id, #[_, _, f]) =>
      withTraceNode `monoidal (fun _ => return m!"id") do
        let ‚ü®_, Œ∑_f‚ü© ‚Üê normalize p f
        let result ‚Üê mkNaturalityId (‚Üê eval‚ÇÅ p) f Œ∑_f
        trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
        return result
    | (``CategoryStruct.comp, #[_, _, f, g, h, Œ∑, Œ∏]) =>
      withTraceNode `monoidal (fun _ => return m!"comp") do
        let ‚ü®_, Œ∑_f‚ü© ‚Üê normalize p f
        let ‚ü®_, Œ∑_g‚ü© ‚Üê normalize p g
        let ‚ü®_, Œ∑_h‚ü© ‚Üê normalize p h
        let ih_Œ∑ ‚Üê naturality p Œ∑
        let ih_Œ∏ ‚Üê naturality p Œ∏
        let result ‚Üê mkNaturalityComp (‚Üê eval‚ÇÅ p) f g h Œ∑ Œ∏ Œ∑_f Œ∑_g Œ∑_h ih_Œ∑ ih_Œ∏
        trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
        return result
    | (``MonoidalCategoryStruct.whiskerLeft, #[_, _, _, f, g, h, Œ∑]) =>
      withTraceNode `monoidal (fun _ => return m!"whiskerLeft") do
        let ‚ü®pf, Œ∑_f‚ü© ‚Üê normalize p f
        let ‚ü®_, Œ∑_fg‚ü© ‚Üê normalize pf g
        let ‚ü®_, Œ∑_fh‚ü© ‚Üê normalize pf h
        let ih ‚Üê naturality pf Œ∑
        let result ‚Üê mkNaturalityWhiskerLeft (‚Üê eval‚ÇÅ p) f g h Œ∑ Œ∑_f Œ∑_fg Œ∑_fh ih
        trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
        return result
    | (``MonoidalCategoryStruct.whiskerRight, #[_, _, _, f, g, Œ∑, h]) =>
      withTraceNode `monoidal (fun _ => return m!"whiskerRight") do
        let ‚ü®pf, Œ∑_f‚ü© ‚Üê normalize p f
        let ‚ü®_, Œ∑_g‚ü© ‚Üê normalize p g
        let ‚ü®_, Œ∑_fh‚ü© ‚Üê normalize pf h
        let ih ‚Üê naturality p Œ∑
        let result ‚Üê mkNaturalityWhiskerRight (‚Üê eval‚ÇÅ p) f g h Œ∑ Œ∑_f Œ∑_g Œ∑_fh ih
        trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
        return result
    | (``monoidalComp, #[_, _, _, f, g, _, inst, Œ∑, Œ∏]) =>
      withTraceNode `monoidal (fun _ => return m!"monoidalComp") do
        let Œ± ‚Üê mkMonoidalCoherenceHom f g inst
        let Œ±Œ∏ ‚Üê mkComp Œ± Œ∏
        let Œ∑Œ±Œ∏ ‚Üê mkComp Œ∑ Œ±Œ∏
        naturality p Œ∑Œ±Œ∏
    | (``MonoidalCoherence.hom, #[_, _, _, _, _]) =>
      withTraceNode `monoidal (fun _ => return m!"MonoidalCoherence.hom") do
        let (Œ∑', _) ‚Üê dsimp Œ∑
          { simpTheorems := #[.addDeclToUnfoldCore {} ``MonoidalCoherence.hom] }
        naturality p Œ∑'
    | (``MonoidalCategoryStruct.tensorHom, #[_, _, _, f‚ÇÅ, g‚ÇÅ, f‚ÇÇ, g‚ÇÇ, Œ∑, Œ∏]) =>
      withTraceNode `monoidal (fun _ => return m!"tensorHom") do
        let ‚ü®pf‚ÇÅ, Œ∑_f‚ÇÅ‚ü© ‚Üê normalize p f‚ÇÅ
        let ‚ü®pg‚ÇÅ, Œ∑_g‚ÇÅ‚ü© ‚Üê normalize p g‚ÇÅ
        let ‚ü®_, Œ∑_f‚ÇÇ‚ü© ‚Üê normalize pf‚ÇÅ f‚ÇÇ
        let ‚ü®_, Œ∑_g‚ÇÇ‚ü© ‚Üê normalize pg‚ÇÅ g‚ÇÇ
        let ih_Œ∑ ‚Üê naturality p Œ∑
        let ih_Œ∏ ‚Üê naturality pf‚ÇÅ Œ∏
        let result ‚Üê mkNaturalityTensorHom (‚Üê eval‚ÇÅ p) f‚ÇÅ g‚ÇÅ f‚ÇÇ g‚ÇÇ Œ∑ Œ∏ Œ∑_f‚ÇÅ Œ∑_g‚ÇÅ Œ∑_f‚ÇÇ Œ∑_g‚ÇÇ ih_Œ∑ ih_Œ∏
        trace[monoidal] m!"{checkEmoji} {‚Üê inferType result}"
        return result
    | _ => throwError "failed to prove the naturality for {Œ∑}"

def pure_coherence (mvarId : MVarId) : MetaM (List MVarId) :=
  mvarId.withContext do
    withTraceNode `monoidal (fun ex => match ex with
      | .ok _ => return m!"{checkEmoji} coherence equality: {‚Üê mvarId.getType}"
      | .error err => return m!"{crossEmoji} {err.toMessageData}") do
      let e ‚Üê instantiateMVars <| ‚Üê mvarId.getType
      let some (_, Œ∑, Œ∏) := (‚Üê whnfR e).eq?
        | throwError "coherence requires an equality goal"
      let f ‚Üê srcExpr Œ∑
      let g ‚Üê tgtExpr Œ∑
      let some ctx ‚Üê mkContext? Œ∑ | throwError "the lhs and rhs must be 2-morphisms"
      MonoidalM.run ctx do
        trace[monoidal] m!"LHS"
        let ‚ü®_, Œ±f‚ü© ‚Üê normalize .nil f
        let HŒ∑ ‚Üê naturality .nil Œ∑
        trace[monoidal] m!"RHS"
        let ‚ü®_, Œ±g‚ü© ‚Üê normalize .nil g
        let HŒ∏ ‚Üê naturality .nil Œ∏
        let H ‚Üê mkAppM ``of_normalize_eq #[Œ∑, Œ∏, Œ±f, Œ±g, HŒ∑, HŒ∏]
        mvarId.apply H

elab "monoidal_coherence" : tactic => withMainContext do
  replaceMainGoal <| ‚Üê pure_coherence <| ‚Üê getMainGoal

theorem mk_eq_of_cons {C : Type u} [CategoryStruct.{v} C]
    {f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ : C}
    (Œ± Œ±' : f‚ÇÅ ‚ü∂ f‚ÇÇ) (Œ∑ Œ∑' : f‚ÇÇ ‚ü∂ f‚ÇÉ) (Œ∑s Œ∑s' : f‚ÇÉ ‚ü∂ f‚ÇÑ)
    (pf_Œ± : Œ± = Œ±') (pf_Œ∑ : Œ∑ = Œ∑') (pf_Œ∑s : Œ∑s = Œ∑s') :
    Œ± ‚â´ Œ∑ ‚â´ Œ∑s = Œ±' ‚â´ Œ∑' ‚â´ Œ∑s' := by
  simp [pf_Œ±, pf_Œ∑, pf_Œ∑s]

/-- Transform an equality between 2-morphisms into the equality between their normalizations. -/
def mkEqOfHom‚ÇÇ (mvarId : MVarId) : MetaM Expr := do
  let some (_, e‚ÇÅ, e‚ÇÇ) := (‚Üê whnfR <| ‚Üê instantiateMVars <| ‚Üê mvarId.getType).eq?
    | throwError "monoidal requires an equality goal"
  let some c ‚Üê mkContext? e‚ÇÅ | throwError "monoidal requires an equality goal"
  MonoidalM.run c do
    let ‚ü®e‚ÇÅ', p‚ÇÅ‚ü© ‚Üê eval e‚ÇÅ
    let ‚ü®e‚ÇÇ', p‚ÇÇ‚ü© ‚Üê eval e‚ÇÇ
    mkAppM ``mk_eq #[e‚ÇÅ, e‚ÇÇ, ‚Üê e‚ÇÅ'.e, ‚Üê e‚ÇÇ'.e, p‚ÇÅ, p‚ÇÇ]

def ofNormalizedEq (mvarId : MVarId) : MetaM (List MVarId) :=
  mvarId.withContext do
    let e ‚Üê instantiateMVars <| ‚Üê mvarId.getType
    let some (_, e‚ÇÅ, e‚ÇÇ) := (‚Üê whnfR e).eq? | throwError "monoidal requires an equality goal"
    match (‚Üê whnfR e‚ÇÅ).getAppFnArgs, (‚Üê whnfR e‚ÇÇ).getAppFnArgs with
    | (``CategoryStruct.comp, #[_, _, _, _, _, Œ±, Œ∑]) ,
      (``CategoryStruct.comp, #[_, _, _, _, _, Œ±', Œ∑']) =>
      match (‚Üê whnfR Œ∑).getAppFnArgs, (‚Üê whnfR Œ∑').getAppFnArgs with
      | (``CategoryStruct.comp, #[_, _, _, _, _, Œ∑, Œ∑s]),
        (``CategoryStruct.comp, #[_, _, _, _, _, Œ∑', Œ∑s']) =>
        let pf_Œ± ‚Üê mkFreshExprMVar (‚Üê mkEq Œ± Œ±')
        let pf_Œ∑  ‚Üê mkFreshExprMVar (‚Üê mkEq Œ∑ Œ∑')
        let pf_Œ∑s ‚Üê mkFreshExprMVar (‚Üê mkEq Œ∑s Œ∑s')
        let x ‚Üê mvarId.apply (‚Üê mkAppM ``mk_eq_of_cons #[Œ±, Œ±', Œ∑, Œ∑', Œ∑s, Œ∑s', pf_Œ±, pf_Œ∑, pf_Œ∑s])
        return x
      | _, _ => throwError "failed to make a normalized equality for {e}"
    | _, _ => throwError "failed to make a normalized equality for {e}"

def monoidal (mvarId : MVarId) : MetaM (List MVarId) :=
  mvarId.withContext do
    let mvarIds ‚Üê mvarId.apply (‚Üê mkEqOfHom‚ÇÇ mvarId)
    let mvarIds' ‚Üê repeat' (fun i ‚Ü¶ ofNormalizedEq i) mvarIds
    let mvarIds'' ‚Üê mvarIds'.mapM fun mvarId => do
      try
        mvarId.refl
        return [mvarId]
      catch _ =>
        try
          pure_coherence mvarId
        catch _ => return [mvarId]
    return mvarIds''.join

/-- Normalize the both sides of an equality. -/
elab "monoidal" : tactic => withMainContext do
  replaceMainGoal <| ‚Üê monoidal <| ‚Üê getMainGoal

end Monoidal

end Mathlib.Tactic
