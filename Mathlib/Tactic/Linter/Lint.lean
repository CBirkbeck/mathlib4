/-
Copyright (c) 2023 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn
-/
import Lean.Linter.Util
import Batteries.Data.Array.Basic
import Batteries.Tactic.Lint

/-!
# Linters for Mathlib

In this file we define additional linters for mathlib.

Perhaps these should be moved to Batteries in the future.
-/

namespace Std.Tactic.Lint
open Lean Meta

/--
Linter that checks whether a structure should be in Prop.
-/
@[env_linter] def structureInType : Linter where
  noErrorsFound := "no structures that should be in Prop found."
  errorsFound := "FOUND STRUCTURES THAT SHOULD BE IN PROP."
  test declName := do
    unless isStructure (← getEnv) declName do return none
    -- remark: using `Lean.Meta.isProp` doesn't suffice here, because it doesn't (always?)
    -- recognize predicates as propositional.
    let isProp ← forallTelescopeReducing (← inferType (← mkConstWithLevelParams declName))
      fun _ ty => return ty == .sort .zero
    if isProp then return none
    let projs := (getStructureInfo? (← getEnv) declName).get!.fieldNames
    if projs.isEmpty then return none -- don't flag empty structures
    let allProofs ← projs.allM (do isProof <| ← mkConstWithLevelParams <| declName ++ ·)
    unless allProofs do return none
    return m!"all fields are propositional but the structure isn't."

/-- Linter that check that all `deprecated` tags come with `since` dates. -/
@[env_linter] def deprecatedNoSince : Linter where
  noErrorsFound := "no `deprecated` tags without `since` dates."
  errorsFound := "FOUND `deprecated` tags without `since` dates."
  test declName := do
    let some info := Lean.Linter.deprecatedAttr.getParam? (← getEnv) declName | return none
    match info.since? with
    | some _ => return none -- TODO: enforce `YYYY-MM-DD` format
    | none => return m!"`deprecated` attribute without `since` date"

end Std.Tactic.Lint

namespace Mathlib.Linter

/-!
#  `dupNamespace` linter

The `dupNamespace` linter produces a warning when a declaration contains the same namespace
at least twice consecutively.

For instance, `Nat.Nat.foo` and `One.two.two` trigger a warning, while `Nat.One.Nat` does not.
-/

/--
The `dupNamespace` linter is set on by default.  Lean emits a warning on any declaration that
contains the same namespace at least twice consecutively.

For instance, `Nat.Nat.foo` and `One.two.two` trigger a warning, while `Nat.One.Nat` does not.

*Note.*
This linter will not detect duplication in namespaces of autogenerated declarations
(other than the one whose `declId` is present in the source declaration).
-/
register_option linter.dupNamespace : Bool := {
  defValue := true
  descr := "enable the duplicated namespace linter"
}

namespace DupNamespaceLinter

open Lean Parser Elab Command Meta

/-- Gets the value of the `linter.dupNamespace` option. -/
def getLinterDupNamespace (o : Options) : Bool := Linter.getLinterValue linter.dupNamespace o

/-- `getIds stx` extracts the `declId` nodes from the `Syntax` `stx`.
If `stx` is an `alias` or an `export`, then it extracts an `ident`, instead of a `declId`. -/
partial
def getIds : Syntax → Array Syntax
  | .node _ `Batteries.Tactic.Alias.alias args => args[2:3]
  | .node _ ``Lean.Parser.Command.export args => (args[3:4] : Array Syntax).map (·[0])
  | stx@(.node _ _ args) =>
    ((args.attach.map fun ⟨a, _⟩ => getIds a).foldl (· ++ ·) #[stx]).filter (·.getKind == ``declId)
  | _ => default

@[inherit_doc linter.dupNamespace]
def dupNamespace : Linter where run := withSetOptionIn fun stx => do
  if getLinterDupNamespace (← getOptions) then
    match getIds stx with
      | #[id] =>
        let ns := (← getScope).currNamespace
        let declName := ns ++ (if id.getKind == ``declId then id[0].getId else id.getId)
        let nm := declName.components
        let some (dup, _) := nm.zip (nm.tailD []) |>.find? fun (x, y) => x == y
          | return
        Linter.logLint linter.dupNamespace id
          m!"The namespace '{dup}' is duplicated in the declaration '{declName}'"
      | _ => return

initialize addLinter dupNamespace

end DupNamespaceLinter

/-!
# The "missing end" linter

The "missing end" linter emits a warning on non-closed `section`s and `namespace`s.
It allows the "outermost" `noncomputable section` to be left open (whether or not it is named).
-/

open Lean Elab Command

/-- The "missing end" linter emits a warning on non-closed `section`s and `namespace`s.
It allows the "outermost" `noncomputable section` to be left open (whether or not it is named).
-/
register_option linter.missingEnd : Bool := {
  defValue := true
  descr := "enable the missing end linter"
}

namespace MissingEnd

/-- Gets the value of the `linter.missingEnd` option. -/
def getLinterHash (o : Options) : Bool := Linter.getLinterValue linter.missingEnd o

@[inherit_doc Mathlib.Linter.linter.missingEnd]
def missingEndLinter : Linter where run := withSetOptionIn fun stx ↦ do
    -- Only run this linter at the end of a module.
    unless stx.isOfKind ``Lean.Parser.Command.eoi do return
    -- TODO: once mathlib's Lean version includes leanprover/lean4#4741, make this configurable
    unless #[`Mathlib, `test, `Archive, `Counterexamples].contains (← getMainModule).getRoot do
      return
    if getLinterHash (← getOptions) && !(← MonadState.get).messages.hasErrors then
      let sc ← getScopes
      -- The last scope is always the "base scope", corresponding to no active `section`s or
      -- `namespace`s. We are interested in any *other* unclosed scopes.
      if sc.length == 1 then return
      let ends := sc.dropLast.map fun s ↦ (s.header, s.isNoncomputable)
      -- If the outermost scope corresponds to a `noncomputable section`, we ignore it.
      let ends := if ends.getLast!.2 then ends.dropLast else ends
      -- If there are any further un-closed scopes, we emit a warning.
      if !ends.isEmpty then
        let ending := (ends.map Prod.fst).foldl (init := "") fun a b ↦
          a ++ s!"\n\nend{if b == "" then "" else " "}{b}"
        Linter.logLint linter.missingEnd stx
         m!"unclosed sections or namespaces; expected: '{ending}'"

initialize addLinter missingEndLinter

end MissingEnd

/-!
# The `cdot` linter

The `cdot` linter is a syntax-linter that flags uses of the "cdot" `·` that are achieved
by typing a character different from `·`.
For instance, a "plain" dot `.` is allowed syntax, but is flagged by the linter.
-/

/--
The `cdot` linter flags uses of the "cdot" `·` that are achieved by typing a character
different from `·`.
For instance, a "plain" dot `.` is allowed syntax, but is flagged by the linter. -/
register_option linter.cdot : Bool := {
  defValue := true
  descr := "enable the `cdot` linter"
}

/-- `isCDot? stx` checks whether `stx` is a `Syntax` node corresponding to a `cdot` typed with
the character `·`. -/
def isCDot? : Syntax → Bool
  | .node _ ``cdotTk #[.node _ `patternIgnore #[.node _ _ #[.atom _ v]]] => v == "·"
  | .node _ ``Lean.Parser.Term.cdot #[.atom _ v] => v == "·"
  | _ => false

/--
`findCDot stx` extracts from `stx` the syntax nodes of `kind` `Lean.Parser.Term.cdot` or `cdotTk`. -/
partial
def findCDot : Syntax → Array Syntax
  | stx@(.node _ kind args) =>
    let dargs := (args.map findCDot).flatten
    match kind with
      | ``Lean.Parser.Term.cdot | ``cdotTk=> dargs.push stx
      | _ =>  dargs
  |_ => #[]

/-- `unwanted_cdot stx` returns an array of syntax atoms within `stx`
corresponding to `cdot`s that are not written with the character `·`.
This is precisely what the `cdot` linter flags.
-/
def unwanted_cdot (stx : Syntax) : Array Syntax :=
  (findCDot stx).filter (!isCDot? ·)

namespace CDotLinter

/-- Gets the value of the `linter.generic` option. -/
def getLinterHash (o : Options) : Bool := Linter.getLinterValue linter.cdot o

@[inherit_doc linter.cdot]
def cdotLinter : Linter where run := withSetOptionIn fun stx => do
    unless getLinterHash (← getOptions) do
      return
    if (← MonadState.get).messages.hasErrors then
      return
    for s in unwanted_cdot stx do
      Linter.logLint linter.cdot s m!"Please, use '·' (typed as `\\·`) instead of '{s}' as 'cdot'."

initialize addLinter cdotLinter

end CDotLinter

/-!
#  The "badVariable" linter
The "badVariable" linter emits a warning when a variable command
changes how a variable is bound and declares new variables at the same time.

This is discouraged since it leads to surprising behaviour.
-/

open Lean Elab

/-- The "badVariable" linter emits a warning when a variable command
changes how a variable is bound and declares new variables at the same time.

This is discouraged since it leads to surprising behaviour.
-/
register_option linter.badVariable : Bool := {
  defValue := true
  descr := "enable the badVariable linter"
}

namespace BadVariable

/-- Gets the value of the `linter.badVariable` option. -/
def getLinterHash (o : Options) : Bool := Linter.getLinterValue linter.badVariable o

/-- `getBinders stx` returns the array of all the implicit or explicit binders contained in `stx`. -/
partial
def getBinders : Syntax → Array Syntax
  | stx@(.node _ kind args) =>
    let fargs := (args.map getBinders).flatten
    if #[``Lean.Parser.Term.implicitBinder, ``Lean.Parser.Term.explicitBinder].contains kind then
      fargs.push stx else fargs
  | _ => #[]

open Command in
@[inherit_doc Mathlib.Linter.linter.badVariable]
def badVariableLinter : Linter where
  run := withSetOptionIn fun stx => do
    unless getLinterHash (← getOptions) do
      return
    if (← MonadState.get).messages.hasErrors then
      return
    -- Currently, this assumes the file uses `autoImplicit false` and `relaxedAutoImplicit false`.
    -- This means there is no need to track previously declared variables.
    -- TODO: use the current `Scope` to make this more precise.

    if let Syntax.node _ ``Lean.Parser.Command.variable args := stx then
      Linter.logLint linter.badVariable stx m!"args are {args}"
      let first := args.get! 0
      Linter.logLint linter.badVariable first s!"first arg is {first}"
      let second := args.get! 1
      Linter.logLint linter.badVariable first s!"second arg is {second}, of kind {second.getKind}"
      if let .node _ k iargs := second then
        Linter.logLint linter.badVariable second s!"inner args are {iargs}"
      --let binders := getBinders stx
      --for b in binders do
        --Linter.logLint linter.badVariable b s!"interesting binder {b}"
        -- let _asdf := match b with
        -- |
        -- | `("{" `a [":" ("Type*")] "}") => some `a
        -- | _ => none
        -- if let some n := _asdf then
        --   Linter.logLint linter.badVariable b s!"name {n}"
      --Linter.logLint linter.badVariable stx s!"args are {args}"
      -- All implicit or explicit binders.
      let imex := args.filter fun arg ↦
        arg.isOfKind ``Lean.Parser.Term.implicitBinder || arg.isOfKind ``Lean.Parser.Term.explicitBinder
      for a in imex do
        Linter.logLint linter.badVariable a s!"interesting binder"
      --Linter.logLint linter.badVariable stx s!"args are {args}"
--      Linter.logLint linter.badVariable stx "test"
      -- TODO: put main logic here!
    -- TODO: extract the implicit and explicit binder names,
    -- together whether each of them has a type specified or not: (binder, withAType)
    let allBinders : Array (Name × Bool) := sorry
    -- We error if there is an implicit or explicit binder without a type,
    -- while there is a new binder declared with a type.
    let withTypes := allBinders.filter fun b ↦ b.2
    let withoutTypes := allBinders.filter fun b ↦ !b.2
    if withTypes.size > 0 && withoutTypes.size > 0 then
      Linter.logLint linter.badVariable stx -- TODO: underline the actual args!
        s!"bad variable declaration:
        the binder types of the variable(s) {withoutTypes.map fun b ↦ b.1} are changed,
        while the new variable(s) {withTypes.map fun b ↦ b.1} are declared\n\
        please split these into separate 'variable' commands"

initialize addLinter badVariableLinter

end BadVariable

end Mathlib.Linter
