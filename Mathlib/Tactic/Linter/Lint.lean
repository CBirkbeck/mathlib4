/-
Copyright (c) 2023 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn
-/
import Lean.Linter.Util
import Batteries.Data.Array.Basic
import Batteries.Data.String.Matcher
import Batteries.Tactic.Lint

/-!
# Linters for Mathlib

In this file we define additional linters for mathlib.

Perhaps these should be moved to Batteries in the future.
-/

namespace Std.Tactic.Lint
open Lean Meta

/--
Linter that checks whether a structure should be in Prop.
-/
@[env_linter] def structureInType : Linter where
  noErrorsFound := "no structures that should be in Prop found."
  errorsFound := "FOUND STRUCTURES THAT SHOULD BE IN PROP."
  test declName := do
    unless isStructure (← getEnv) declName do return none
    -- remark: using `Lean.Meta.isProp` doesn't suffice here, because it doesn't (always?)
    -- recognize predicates as propositional.
    let isProp ← forallTelescopeReducing (← inferType (← mkConstWithLevelParams declName))
      fun _ ty => return ty == .sort .zero
    if isProp then return none
    let projs := (getStructureInfo? (← getEnv) declName).get!.fieldNames
    if projs.isEmpty then return none -- don't flag empty structures
    let allProofs ← projs.allM (do isProof <| ← mkConstWithLevelParams <| declName ++ ·)
    unless allProofs do return none
    return m!"all fields are propositional but the structure isn't."

/-- Linter that check that all `deprecated` tags come with `since` dates. -/
@[env_linter] def deprecatedNoSince : Linter where
  noErrorsFound := "no `deprecated` tags without `since` dates."
  errorsFound := "FOUND `deprecated` tags without `since` dates."
  test declName := do
    let some info := Lean.Linter.deprecatedAttr.getParam? (← getEnv) declName | return none
    match info.since? with
    | some _ => return none -- TODO: enforce `YYYY-MM-DD` format
    | none => return m!"`deprecated` attribute without `since` date"

end Std.Tactic.Lint

namespace Mathlib.Linter

/-!
#  `dupNamespace` linter

The `dupNamespace` linter produces a warning when a declaration contains the same namespace
at least twice consecutively.

For instance, `Nat.Nat.foo` and `One.two.two` trigger a warning, while `Nat.One.Nat` does not.
-/

/--
The `dupNamespace` linter is set on by default.  Lean emits a warning on any declaration that
contains the same namespace at least twice consecutively.

For instance, `Nat.Nat.foo` and `One.two.two` trigger a warning, while `Nat.One.Nat` does not.

*Note.*
This linter will not detect duplication in namespaces of autogenerated declarations
(other than the one whose `declId` is present in the source declaration).
-/
register_option linter.dupNamespace : Bool := {
  defValue := true
  descr := "enable the duplicated namespace linter"
}

namespace DupNamespaceLinter

open Lean Parser Elab Command Meta

/-- Gets the value of the `linter.dupNamespace` option. -/
def getLinterDupNamespace (o : Options) : Bool := Linter.getLinterValue linter.dupNamespace o

/-- `getIds stx` extracts the `declId` nodes from the `Syntax` `stx`.
If `stx` is an `alias` or an `export`, then it extracts an `ident`, instead of a `declId`. -/
partial
def getIds : Syntax → Array Syntax
  | .node _ `Batteries.Tactic.Alias.alias args => args[2:3]
  | .node _ ``Lean.Parser.Command.export args => (args[3:4] : Array Syntax).map (·[0])
  | stx@(.node _ _ args) =>
    ((args.attach.map fun ⟨a, _⟩ => getIds a).foldl (· ++ ·) #[stx]).filter (·.getKind == ``declId)
  | _ => default

@[inherit_doc linter.dupNamespace]
def dupNamespace : Linter where run := withSetOptionIn fun stx => do
  if getLinterDupNamespace (← getOptions) then
    match getIds stx with
      | #[id] =>
        let ns := (← getScope).currNamespace
        let declName := ns ++ (if id.getKind == ``declId then id[0].getId else id.getId)
        let nm := declName.components
        let some (dup, _) := nm.zip (nm.tailD []) |>.find? fun (x, y) => x == y
          | return
        Linter.logLint linter.dupNamespace id
          m!"The namespace '{dup}' is duplicated in the declaration '{declName}'"
      | _ => return

initialize addLinter dupNamespace

end DupNamespaceLinter

/-!
#  The "noInitialWhitespace" linter

The "noInitialWhitespace" linter emits a warning somewhere.
-/

open Lean Elab

namespace Mathlib.Linter

/-- The "noInitialWhitespace" linter emits a warning when a command does not begin on the
first column. -/
register_option linter.noInitialWhitespace : Bool := {
  defValue := true
  descr := "enable the noInitialWhitespace linter"
}

/-- `getStartPos stx` assumes that `stx` is an im/ex-plicit binder and returns the positions of
* the first open bracket, `{` or `(`;
* the starting positions of each variable declared within the same binder;
* the position of the `:`;
* the starting position of the Type of the collection of variables;
* the position of the closing bracket , `}` or `)`.
-/
def getStartPos (stx : Syntax) : Array String.Pos :=
  if stx.isOfKind ``Lean.Parser.Term.implicitBinder ||
     stx.isOfKind ``Lean.Parser.Term.explicitBinder then
    match stx with
      | .node _ _ #[ -- `im`/`explicitBinder`
          .atom openBracket _, -- `{`
          .node _ _ vars,
          .node _ _ #[.atom siColon _, type],
          .atom closedBracket _
        ] =>
        let vars := vars.map fun v => v.getHeadInfo.getPos?
        (#[openBracket.getPos?] ++ vars ++
          #[siColon.getPos?, type.getHeadInfo.getPos?, closedBracket.getPos?]).reduceOption
      | _ => default
  else default

/-- `inappropriateSpacing file stx` takes as input the text `file` of a file and
the `stx` of a binder.
It returns the substring of `file` corresponding to `stx`, assuming that it is incorrectly
formatted.
The format is "incorrect" if
* either one of the two characters neighbouring the `:` is not a space ` `;
* either one of the two characters at distance 2 from the `:` is a space ` `;
* either one of the two characters two positions before each variable in the binder
  from the second onwards is a space;
* the character following the opening binder or the character preceding the closing binder
  is not a space.
-/
def inappropriateSpacing (file : String) (stx : Syntax) : Substring :=
  let startPos := getStartPos stx
  if startPos.isEmpty then default else
  let closedBracketPos := startPos.back
  let colonPos := startPos.pop.pop.back
  -- this should not be a space
  let charFollowingOpenBracket   := file.get ⟨startPos[0]!.byteIdx+1⟩
  -- this should not be a space
  let charPrecedingClosedBracket := file.get ⟨closedBracketPos.byteIdx-1⟩
  let varPos := (startPos.pop.pop.pop.eraseIdx 0).eraseIdx 0
  -- these should not be spaces
  let charsTwoBeforeAVar := varPos.map (file.get ⟨·.byteIdx-2⟩)
  let afterColon := file.get ⟨colonPos.byteIdx+1⟩
  -- these should be spaces -- we allow a line break after `:`
  let charAroundColon := #[file.get ⟨colonPos.byteIdx-1⟩].push <|
    if afterColon == '\n' then ' ' else afterColon
  -- these should not be spaces
  let charAroundColonPlusOne := #[file.get ⟨colonPos.byteIdx-2⟩].push <|
    if afterColon == '\n' then 'A' else file.get ⟨colonPos.byteIdx+2⟩
  let spaces := charAroundColon
  let nonspaces := ((charsTwoBeforeAVar ++ charAroundColonPlusOne).push
    charFollowingOpenBracket).push charPrecedingClosedBracket
  if !(spaces.filter (· != ' ') ++ nonspaces.filter (· == ' ')).isEmpty then
    { str := file, startPos := startPos[0]!, stopPos:= startPos.back + ⟨1⟩ }
  else default

/-- `getBinders stx` returns the array of all the im/ex-plicit binders contained in `stx`. -/
partial
def getBinders : Syntax → Array Syntax
  | stx@(.node _ kind args) =>
    let fargs := (args.map getBinders).flatten
    if kind == ``Lean.Parser.Term.implicitBinder || kind == ``Lean.Parser.Term.explicitBinder then
      fargs.push stx else fargs
  | _ => #[]

/-- `modNameToFilePath modName` takes as input the name of a file and it returns the corresponding
`System.FilePath`.  There is no guarantee that the file exists. -/
def modNameToFilePath (modName : Name) : System.FilePath :=
  let cmps := (modName.components.drop 1).foldl (init := modName.getRoot.toString) fun a b =>
    ((a.toString : System.FilePath) / b.toString)
  cmps.addExtension "lean"

namespace NoInitialWhitespace

/-- Gets the value of the `linter.noInitialWhitespace` option. -/
def getLinterHash (o : Options) : Bool := Linter.getLinterValue linter.noInitialWhitespace o

@[inherit_doc Mathlib.Linter.linter.noInitialWhitespace]
def noInitialWhitespaceLinter : Linter where
  run := withSetOptionIn fun stx => do
    unless getLinterHash (← getOptions) do
      return
    if (← MonadState.get).messages.hasErrors then
      return
    if let some rg := stx.getRange? then
      let pos := (← getFileMap).toPosition rg.start
      let relevantLine := (← IO.FS.lines (← getFileName))[pos.line - 1]!
      if pos.column != 0 && !"#guard_msgs".isPrefixOf relevantLine
      then
        Linter.logLint linter.noInitialWhitespace stx
          m!"'{stx}' starts on column {pos.column}.\n\
             Please, do not leave any whitespace before this command!"
      let fileName := modNameToFilePath (← getMainModule)
      let file := (← IO.FS.readFile fileName)
      let binders := getBinders stx
      for binder in binders do
        let shouldBeEmpty := inappropriateSpacing file binder
        if ! shouldBeEmpty.isEmpty then
          let var ← `(command| variable $(⟨binder⟩))
          Linter.logLint linter.noInitialWhitespace binder
            m!"'{shouldBeEmpty}' should be printed as '{var}'"

initialize addLinter noInitialWhitespaceLinter

end NoInitialWhitespace

/-!
#  `oneLineAlign` linter

The "missing end" linter emits a warning on non-closed `section`s and `namespace`s.
It allows the "outermost" `noncomputable section` to be left open (whether or not it is named).
-/

open Lean Elab Command

/-- The "missing end" linter emits a warning on non-closed `section`s and `namespace`s.
It allows the "outermost" `noncomputable section` to be left open (whether or not it is named).
-/
register_option linter.missingEnd : Bool := {
  defValue := true
  descr := "enable the missing end linter"
}

namespace MissingEnd

/-- Gets the value of the `linter.missingEnd` option. -/
def getLinterHash (o : Options) : Bool := Linter.getLinterValue linter.missingEnd o

@[inherit_doc Mathlib.Linter.linter.missingEnd]
def missingEndLinter : Linter where run := withSetOptionIn fun stx ↦ do
    -- Only run this linter at the end of a module.
    unless stx.isOfKind ``Lean.Parser.Command.eoi do return
    -- TODO: once mathlib's Lean version includes leanprover/lean4#4741, make this configurable
    unless #[`Mathlib, `test, `Archive, `Counterexamples].contains (← getMainModule).getRoot do
      return
    if getLinterHash (← getOptions) && !(← MonadState.get).messages.hasErrors then
      let sc ← getScopes
      -- The last scope is always the "base scope", corresponding to no active `section`s or
      -- `namespace`s. We are interested in any *other* unclosed scopes.
      if sc.length == 1 then return
      let ends := sc.dropLast.map fun s ↦ (s.header, s.isNoncomputable)
      -- If the outermost scope corresponds to a `noncomputable section`, we ignore it.
      let ends := if ends.getLast!.2 then ends.dropLast else ends
      -- If there are any further un-closed scopes, we emit a warning.
      if !ends.isEmpty then
        let ending := (ends.map Prod.fst).foldl (init := "") fun a b ↦
          a ++ s!"\n\nend{if b == "" then "" else " "}{b}"
        Linter.logLint linter.missingEnd stx
         m!"unclosed sections or namespaces; expected: '{ending}'"

initialize addLinter missingEndLinter

end MissingEnd

/-!
# The `cdot` linter

The `cdot` linter is a syntax-linter that flags uses of the "cdot" `·` that are achieved
by typing a character different from `·`.
For instance, a "plain" dot `.` is allowed syntax, but is flagged by the linter.
-/

/--
The `cdot` linter flags uses of the "cdot" `·` that are achieved by typing a character
different from `·`.
For instance, a "plain" dot `.` is allowed syntax, but is flagged by the linter. -/
register_option linter.cdot : Bool := {
  defValue := true
  descr := "enable the `cdot` linter"
}

/-- `isCDot? stx` checks whether `stx` is a `Syntax` node corresponding to a `cdot` typed with
the character `·`. -/
def isCDot? : Syntax → Bool
  | .node _ ``cdotTk #[.node _ `patternIgnore #[.node _ _ #[.atom _ v]]] => v == "·"
  | .node _ ``Lean.Parser.Term.cdot #[.atom _ v] => v == "·"
  | _ => false

/--
`findCDot stx` extracts from `stx` the syntax nodes of `kind` `Lean.Parser.Term.cdot` or `cdotTk`. -/
partial
def findCDot : Syntax → Array Syntax
  | stx@(.node _ kind args) =>
    let dargs := (args.map findCDot).flatten
    match kind with
      | ``Lean.Parser.Term.cdot | ``cdotTk=> dargs.push stx
      | _ =>  dargs
  |_ => #[]

/-- `unwanted_cdot stx` returns an array of syntax atoms within `stx`
corresponding to `cdot`s that are not written with the character `·`.
This is precisely what the `cdot` linter flags.
-/
def unwanted_cdot (stx : Syntax) : Array Syntax :=
  (findCDot stx).filter (!isCDot? ·)

namespace CDotLinter

/-- Gets the value of the `linter.generic` option. -/
def getLinterHash (o : Options) : Bool := Linter.getLinterValue linter.cdot o

@[inherit_doc linter.cdot]
def cdotLinter : Linter where run := withSetOptionIn fun stx => do
    unless getLinterHash (← getOptions) do
      return
    if (← MonadState.get).messages.hasErrors then
      return
    for s in unwanted_cdot stx do
      Linter.logLint linter.cdot s m!"Please, use '·' (typed as `\\·`) instead of '{s}' as 'cdot'."

initialize addLinter cdotLinter

end CDotLinter

/-- The "longLine" linter emits a warning on lines longer than 100 characters.
We allow lines containing URLs to be longer, though. -/
register_option linter.longLine : Bool := {
  defValue := true
  descr := "enable the longLine linter"
}

namespace LongLine

/-- Gets the value of the `linter.longLine` option. -/
def getLinterHash (o : Options) : Bool := Linter.getLinterValue linter.longLine o

@[inherit_doc Mathlib.Linter.linter.longLine]
def longLineLinter : Linter where run := withSetOptionIn fun stx ↦ do
    unless getLinterHash (← getOptions) do
      return
    if (← MonadState.get).messages.hasErrors then
      return
    -- TODO: once per-project settings are available,
    -- revert this hack to make it only apply on `Mathlib`
    unless #[`Mathlib, `test, `Archive, `Counterexamples].contains (← getMainModule).getRoot do
      return
    -- The linter ignores the `#guard_msgs` command, in particular its doc-string.
    -- The linter still lints the message guarded by `#guard_msgs`.
    if stx.isOfKind ``Lean.guardMsgsCmd then
      return
    -- if the linter reached the end of the file, then we scan the `import` syntax instead
    let stx := ← do
      if stx.isOfKind ``Lean.Parser.Command.eoi then
        let fname ← getFileName
        if !(← System.FilePath.pathExists fname) then return default
        let contents ← IO.FS.readFile fname
        -- `impMods` is the syntax for the modules imported in the current file
        let (impMods, _) ← Parser.parseHeader (Parser.mkInputContext contents fname)
        return impMods
      else return stx
    let sstr := stx.getSubstring?
    let fm ← getFileMap
    let longLines := ((sstr.getD default).splitOn "\n").filter fun line =>
      (100 < (fm.toPosition line.stopPos).column)
    for line in longLines do
      if !(line.containsSubstr "http") then
        Linter.logLint linter.longLine (.ofRange ⟨line.startPos, line.stopPos⟩)
          m!"This line exceeds the 100 character limit, please shorten it!"

initialize addLinter longLineLinter

end LongLine

/-!
#  The "pedanticWhitespace" linter

The "pedanticWhitespace" linter emits a warning when the syntax of a command differs substantially
from the pretty-printed version of itself.
-/

open Lean Elab

namespace Mathlib.Linter

/--
The "pedanticWhitespace" linter emits a warning when the syntax of a command differs substantially
from the pretty-printed version of itself.
-/
register_option linter.pedanticWhitespace : Bool := {
  defValue := true
  descr := "enable the pedanticWhitespace linter"
}

def dropTrailingComments (s : List String) : List String :=
  Id.run do
  let mut s := s
  let mut repl := true
  while repl do
    let last := s.getLast?.getD ""
    repl := "--".isPrefixOf last
    if repl then
      s := s.dropLast
  return s

def collapseWhitespace (s : String) : String :=
  let s := s.split (·.isWhitespace)
  (" ".intercalate (dropTrailingComments (s.filter (!·.isEmpty))))
    |>.replace "/-!" "/-! "
    |>.replace "`` " "``" -- weird pp ```#eval ``«Nat»``` pretty-prints as ```#eval `` «Nat»```
    |>.replace "notation3(" "notation3 ("
    --|>.replace "{" "{"   -- probably better?

def collapseLineBreaksPlusSpaces (st : String) : String :=
  let s := ((st.split (· == '\n')).map .trimLeft).filter (!· == "")
  let s := dropTrailingComments s
  " ".intercalate (s.filter (!·.isEmpty))

def zoomString (str : String) (centre offset : Nat) : Substring :=
  ({ str := str, startPos := ⟨centre - offset⟩, stopPos := ⟨centre + offset⟩ } : Substring)

namespace PedanticWhitespace

/-- Gets the value of the `linter.pedanticWhitespace` option. -/
def getLinterHash (o : Options) : Bool := Linter.getLinterValue linter.pedanticWhitespace o

@[inherit_doc Mathlib.Linter.linter.pedanticWhitespace]
def pedanticWhitespaceLinter : Linter where run := withSetOptionIn fun stx ↦ do
    unless getLinterHash (← getOptions) do
      return
    if (← MonadState.get).messages.hasErrors then
      return
    let fmt ← liftCoreM do PrettyPrinter.ppCategory `command stx
    let st := collapseWhitespace fmt.pretty
    let real := collapseLineBreaksPlusSpaces (stx.getSubstring?.getD default).toString
    if st != real then
      let diff := real.firstDiffPos st
      let srcCtxt := zoomString real diff.byteIdx 5 --({ str := real, startPos := diff - ⟨4⟩, stopPos := diff + ⟨5⟩ } : Substring)
      let ppCtxt  := ({ str := st,   startPos := diff - ⟨4⟩, stopPos := diff + ⟨5⟩ } : Substring)
      if srcCtxt.toString == ppCtxt.toString then logInfo m!"{diff}\n{real}\n{ppCtxt}"
      --dbg_trace "{real}\n{st}"
      Linter.logLint linter.pedanticWhitespace stx m!"---\n\
        '{srcCtxt}' -- src\n\
        '{ppCtxt}' -- pp\n---"
      --Linter.logLint linter.pedanticWhitespace stx m!"pretty:\n'{st}'\n'{real}'"


run_cmd
  let s1 := "· 2"
  let s2 := "·12"
  let diff : String.Pos := s1.firstDiffPos s2
  logInfo m!"Difference at: {diff}\n\
        s1: '{({ str := s1, startPos := diff - ⟨1⟩, stopPos := diff + ⟨1⟩ } : Substring)}'\n\
        s2: '{({ str := s2, startPos := diff - ⟨1⟩, stopPos := diff + ⟨1⟩ } : Substring)}'"


initialize addLinter pedanticWhitespaceLinter

end PedanticWhitespace

end Mathlib.Linter


end Mathlib.Linter
