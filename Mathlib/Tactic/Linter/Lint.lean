/-
Copyright (c) 2023 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn
-/
import Lean.Linter.Util
import Batteries.Data.Array.Basic
import Batteries.Tactic.Lint

/-!
# Linters for Mathlib

In this file we define additional linters for mathlib.

Perhaps these should be moved to Batteries in the future.
-/

namespace Std.Tactic.Lint
open Lean Meta

/--
Linter that checks whether a structure should be in Prop.
-/
@[env_linter] def structureInType : Linter where
  noErrorsFound := "no structures that should be in Prop found."
  errorsFound := "FOUND STRUCTURES THAT SHOULD BE IN PROP."
  test declName := do
    unless isStructure (← getEnv) declName do return none
    -- remark: using `Lean.Meta.isProp` doesn't suffice here, because it doesn't (always?)
    -- recognize predicates as propositional.
    let isProp ← forallTelescopeReducing (← inferType (← mkConstWithLevelParams declName))
      fun _ ty => return ty == .sort .zero
    if isProp then return none
    let projs := (getStructureInfo? (← getEnv) declName).get!.fieldNames
    if projs.isEmpty then return none -- don't flag empty structures
    let allProofs ← projs.allM (do isProof <| ← mkConstWithLevelParams <| declName ++ ·)
    unless allProofs do return none
    return m!"all fields are propositional but the structure isn't."

/-- Linter that check that all `deprecated` tags come with `since` dates. -/
@[env_linter] def deprecatedNoSince : Linter where
  noErrorsFound := "no `deprecated` tags without `since` dates."
  errorsFound := "FOUND `deprecated` tags without `since` dates."
  test declName := do
    let some info := Lean.Linter.deprecatedAttr.getParam? (← getEnv) declName | return none
    match info.since? with
    | some _ => return none -- TODO: enforce `YYYY-MM-DD` format
    | none => return m!"`deprecated` attribute without `since` date"

end Std.Tactic.Lint

/-!
#  `dupNamespace` linter

The `dupNamespace` linter produces a warning when a declaration contains the same namespace
at least twice consecutively.

For instance, `Nat.Nat.foo` and `One.two.two` trigger a warning, while `Nat.One.Nat` does not.
-/

namespace Mathlib.Linter

/--
The `dupNamespace` linter is set on by default.  Lean emits a warning on any declaration that
contains the same namespace at least twice consecutively.

For instance, `Nat.Nat.foo` and `One.two.two` trigger a warning, while `Nat.One.Nat` does not.

*Note.*
This linter will not detect duplication in namespaces of autogenerated declarations
(other than the one whose `declId` is present in the source declaration).
-/
register_option linter.dupNamespace : Bool := {
  defValue := true
  descr := "enable the duplicated namespace linter"
}

namespace DupNamespaceLinter

open Lean Parser Elab Command Meta

/-- Gets the value of the `linter.dupNamespace` option. -/
def getLinterDupNamespace (o : Options) : Bool := Linter.getLinterValue linter.dupNamespace o

/-- `getIds stx` extracts the `declId` nodes from the `Syntax` `stx`.
If `stx` is an `alias` or an `export`, then it extracts an `ident`, instead of a `declId`. -/
partial
def getIds : Syntax → Array Syntax
  | .node _ `Batteries.Tactic.Alias.alias args => args[2:3]
  | .node _ ``Lean.Parser.Command.export args => (args[3:4] : Array Syntax).map (·[0])
  | stx@(.node _ _ args) =>
    ((args.attach.map fun ⟨a, _⟩ => getIds a).foldl (· ++ ·) #[stx]).filter (·.getKind == ``declId)
  | _ => default

@[inherit_doc linter.dupNamespace]
def dupNamespace : Linter where run := withSetOptionIn fun stx => do
  if getLinterDupNamespace (← getOptions) then
    match getIds stx with
      | #[id] =>
        let ns := (← getScope).currNamespace
        let declName := ns ++ (if id.getKind == ``declId then id[0].getId else id.getId)
        let nm := declName.components
        let some (dup, _) := nm.zip (nm.tailD []) |>.find? fun (x, y) => x == y
          | return
        Linter.logLint linter.dupNamespace id
          m!"The namespace '{dup}' is duplicated in the declaration '{declName}'"
      | _ => return

initialize addLinter dupNamespace

end DupNamespaceLinter

/-!
#  The "noInitialWhitespace" linter

The "noInitialWhitespace" linter emits a warning somewhere.
-/

open Lean Elab

namespace Mathlib.Linter

/-- The "noInitialWhitespace" linter emits a warning when a command does not begin on the
first column. -/
register_option linter.noInitialWhitespace : Bool := {
  defValue := true
  descr := "enable the noInitialWhitespace linter"
}

/-- `getStartPos stx` assumes that `stx` is an im/ex-plicit binder and returns the positions of
* the first open bracket, `{` or `(`;
* the starting positions of each variable declared within the same binder;
* the position of the `:`;
* the starting position of the Type of the collection of variables;
* the position of the closing bracket , `}` or `)`.
-/
def getStartPos (stx : Syntax) : Array String.Pos :=
  if stx.isOfKind ``Lean.Parser.Term.implicitBinder ||
     stx.isOfKind ``Lean.Parser.Term.explicitBinder then
    match stx with
      | .node _ _ #[ -- `im`/`explicitBinder`
          .atom openBracket _, -- `{`
          .node _ _ vars,
          .node _ _ #[.atom siColon _, type],
          .atom closedBracket _
        ] =>
        let vars := vars.map fun v => v.getHeadInfo.getPos?
        (#[openBracket.getPos?] ++ vars ++
          #[siColon.getPos?, type.getHeadInfo.getPos?, closedBracket.getPos?]).reduceOption
      | _ => default
  else default

/-- `inappropriateSpacing file stx` takes as input the text `file` of a file and
the `stx` of a binder.
It returns an array of characters that should be empty if the binder has the correct spacing.
It returns:
* the two characters neighbouring the `:`, if they are not spaces ` `;
* the two characters at distance 2 from the `:`, if they are spaces ` `;
* the characters two positions before each variable in the binder from the second onwards,
  unless it is a space;
* the character following the opening binder and the character preceding the closing binder,
  if they are spaces.
-/
def inappropriateSpacing (file : String) (stx : Syntax) : Array Char :=
  let startPos := getStartPos stx
  if startPos.isEmpty then #[] else
  let closedBracketPos := startPos.back
  let colonPos := startPos.pop.pop.back
  -- this should not be a space
  let charFollowingOpenBracket   := file.get ⟨startPos[0]!.byteIdx+1⟩
  -- this should not be a space
  let charPrecedingClosedBracket := file.get ⟨closedBracketPos.byteIdx-1⟩
  let varPos := (startPos.pop.pop.pop.eraseIdx 0).eraseIdx 0
  -- these should not be spaces
  let charsTwoBeforeAVar := varPos.map (file.get ⟨·.byteIdx-2⟩)
  -- these should be spaces
  let charAroundColon := #[file.get ⟨colonPos.byteIdx-1⟩, file.get ⟨colonPos.byteIdx+1⟩]
  -- these should not be spaces
  let charAroundColonPlusOne := #[file.get ⟨colonPos.byteIdx-2⟩, file.get ⟨colonPos.byteIdx+2⟩]
  let spaces := charAroundColon
  let nonspaces := ((charsTwoBeforeAVar ++ charAroundColonPlusOne).push
    charFollowingOpenBracket).push charPrecedingClosedBracket
  spaces.filter (· != ' ') ++ nonspaces.filter (· == ' ')

/-- `getBinders stx` returns the array of all the im/ex-plicit binders contained in `stx`. -/
partial
def getBinders : Syntax → Array Syntax
  | stx@(.node _ kind args) =>
    let fargs := (args.map getBinders).flatten
    if kind == ``Lean.Parser.Term.implicitBinder || kind == ``Lean.Parser.Term.explicitBinder then
      fargs.push stx else fargs
  | _ => #[]

/-- `modNameToFilePath modName` takes as input the name of a file and it returns the corresponding
`System.FilePath`.  There is no guarantee that the file exists. -/
def modNameToFilePath (modName : Name) : System.FilePath :=
  let cmps := (modName.components.drop 1).foldl (init := modName.getRoot.toString) fun a b =>
    ((a.toString : System.FilePath) / b.toString)
  cmps.addExtension "lean"

namespace NoInitialWhitespace

/-- Gets the value of the `linter.noInitialWhitespace` option. -/
def getLinterHash (o : Options) : Bool := Linter.getLinterValue linter.noInitialWhitespace o

@[inherit_doc Mathlib.Linter.linter.noInitialWhitespace]
def noInitialWhitespaceLinter : Linter where
  run := withSetOptionIn fun stx => do
    unless getLinterHash (← getOptions) do
      return
    if (← MonadState.get).messages.hasErrors then
      return
    if let some rg := stx.getRange? then
      let pos := (← getFileMap).toPosition rg.start
      let relevantLine := (← IO.FS.lines (← getFileName))[pos.line - 1]!
      if pos.column != 0 && !"#guard_msgs".isPrefixOf relevantLine
      then
        Linter.logLint linter.noInitialWhitespace stx
          m!"'{stx}' starts on column {pos.column}.\n\
             Please, do not leave any whitespace before this command!"
      let fileName := modNameToFilePath (← getMainModule)
      let file := (← IO.FS.readFile fileName)
      let binders := getBinders stx
      for binder in binders do
        let shouldBeEmpty := inappropriateSpacing file binder
        if ! shouldBeEmpty.isEmpty then
          Linter.logLint linter.noInitialWhitespace binder m!"{shouldBeEmpty} spaces!"

initialize addLinter noInitialWhitespaceLinter

end NoInitialWhitespace

end Mathlib.Linter
