/-
Copyright (c) 2024 Damiano Testa. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Damiano Testa
-/

import Std.Data.Array.Init.Lemmas
import Mathlib.Lean.Expr.Basic
import Mathlib.Tactic.Lemma

/-!
#  `deprecate_to` -- a deprecation tool

Writing
```lean
deprecate_to id₁ id₂ ... idₙ 2024-02-23
theorem easy₁ : True := .intro
```
where `id₁ id₂ ... idₙ` is a sequence of identifiers adds to the environment the following aliases:
```lean
@[deprecated] alias easy₁ := id₁
@[deprecated] alias easy₂ := id₂
...
@[deprecated] alias easyₙ := idₙ
```
where `easy₁ easy₂ ... easyₙ` are the non-blacklisted declarations autogenerated by the initial
theorem.

See the doc-string for `deprecationCommands` for more information.

TODO:
* the "new" names come fully qualified with their namespace -- if the deprecation is happening
  inside a `namespace X`, it would be better to remove the `X` prefix from them;
* automatically insert today's date in the deprecations.
-/

namespace Mathlib.Tactic.DeprecateMe

open Lean Elab Parser Command

/-- Returns the array of names that are in `new` but not in `old`. -/
def newNames (old new : Environment) : Array Name := Id.run do
  let mut diffs := #[]
  for (c, _) in new.constants.map₂.toList do
    unless old.constants.map₂.contains c do
      diffs := diffs.push c
  pure <| diffs

/-- `isNumOfLength n num` checks that the numeric literal `num` represents a natural number
of size strictly smaller than `10 ^ n` and consisting of exactly `n` characters.
This means that `num` is "padded with `0`s" to achieve length `n`. -/
def isNumOfLength (n : Nat) (num : TSyntax `num) : Bool :=
  let rawNum := num.raw.reprint.getD ""
  let rawNum := if rawNum.back == '\n' then rawNum.dropRight 1 else rawNum
  num.getNat < 10 ^ n && rawNum.length == n

/-- `isDate? yy mm dd` checks whether the numeric literals `yy, mm, dd` "look like" a date in
the YYYY MM DD format.
`isDate?` *does not* check that the date is valid: for instance, the list of inputs
`(2024, 02, 30)` passes the test. -/
def isDate? {m : Type → Type} [Monad m] [MonadLog m] [AddMessageContext m] [MonadOptions m]
    (yy mm dd : TSyntax `num) : m Unit := do
  if ! (isNumOfLength 4 yy) then logErrorAt yy "Year format is YYYY"
  if ! (isNumOfLength 2 mm) then logErrorAt mm "Month format is MM"
  if ! (isNumOfLength 2 dd) then logErrorAt dd "Day format is DD, followed by a line break"
  if ! (2024 ≤ yy.getNat)   then logErrorAt yy "The year should be at least 2024!"
  if   (mm.getNat == 0)     then logErrorAt mm "The month is at least 01!"
  if ! (mm.getNat ≤ 12)     then logErrorAt mm "There are at most 12 months!"
  if   (dd.getNat == 0)     then logErrorAt dd "The day of the month is at least 01!"
  if ! (dd.getNat ≤ 31)     then logErrorAt dd "There are at most 31 days!"

/-- Produce the syntax for the command `@[deprecated] alias n := id`. -/
def mkDeprecationStx (id n : Name) : CommandElabM (TSyntax `command) := do
  `(command| @[deprecated] alias $(mkIdent n) := $(mkIdent id))

/-- `getIds stx` extracts the array of nodes of `stx` with `SyntaxNodeKind` equal to
`Lean.Parser.Command.declId`.
If the `stx` represents a `theorem`, then `getIds` extracts the name of the theorem,
together with a list of universe names, if they are present. -/
partial
def getIds : Syntax → Array Syntax
  | stx@(.node _ _ args) =>
    ((args.map getIds).foldl (· ++ ·) #[stx]).filter (·.getKind == ``declId)
  | _ => default

/--
Writing
```lean
deprecate_to id₁ id₂ ... idₙ 2024-02-23
theorem easy₁ : True := .intro
```
where `id₁ id₂ ... idₙ` is a sequence of identifiers adds to the environment the following aliases:
```lean
@[deprecated] alias easy₁ := id₁
@[deprecated] alias easy₂ := id₂
...
@[deprecated] alias easyₙ := idₙ
```
where `easy₁ easy₂ ... easyₙ` are the non-blacklisted declarations autogenerated by the initial
theorem.

The "date" input `2024-02-23` is mandatory and should be the first day of deprecation.

The version `deprecate_to!` shows what aliases the command adds, as well as the explicit pairings
`new_names ↔ old_names`.

*Note.*
The declarations `easy₁ easy₂ ... easyₙ` are not produced in any specific order.
`deprecate_to` makes an effort to match `easy₁` (the "visible" one) with
`id₁` (the first identifier provided by the user).
The ordering of the remaining assignment is unspecified.
However, in the case in which the initial declaration produces at most 2 non-blacklisted
declarations, then in effect there is no choice in the ordering.
-/
def deprecationCommands (bang : Bool) (tk : Syntax) (yy mm dd : TSyntax `num)
    (deprIds : TSyntaxArray `ident) (cmd : TSyntax `command) :
    CommandElabM Unit := do
  isDate? yy mm dd
  let oldEnv ← getEnv
  try
    elabCommand cmd
  finally
    let newEnv ← getEnv
    let allNew := newNames oldEnv newEnv
    let skip ← allNew.filterM (·.isBlackListed)
    let news := allNew.filter (! · ∈ skip)
    let newDecl := match getIds cmd with
      | #[d] => d[0]
      | _ => default
    if newDecl == default then throwError "Too many identifiers!"

    let mut news := news
    let mut warn := #[]
    if news.size < deprIds.size then
      for i in deprIds.toList.drop news.size do logErrorAt i "unused"
      warn := warn.push s!"Unused names: {deprIds.toList.drop news.size}"
    let fil := news.partition (·.toString.endsWith newDecl.getId.toString)
    if fil.1.size != 1 then
      logError m!"Expected to find one declaration called {newDecl}, found {fil.1.size}"
    let pairs := (fil.1 ++ fil.2).zip (deprIds.map (·.getId))
    if deprIds.size < news.size then
      warn := warn.push s!"Un-deprecated declarations: {(fil.1 ++ fil.2).toList.drop deprIds.size}"
    let stxs ← pairs.mapM fun (id, n) => mkDeprecationStx id n
    for cm in stxs do elabCommand cm
    let stxInfo :=
      stxs.foldl (m!"{·}" ++ "\n\n" ++ m!"{·}") "Generated deprecations:\n-------"
    let pairsInfo :=
      pairs.foldl (m!"{·}" ++ "\n" ++ m!"  {·}") "Pairings used (new, deprecated):" ++
      if skip.size != 0 then s!"\n-------\n* Ignoring: {skip}" else ""
    if bang then logInfo <| m!"{stxInfo}\n\n-------\n{pairsInfo}"
    if warn != #[] then
      logWarningAt tk m!"{warn.foldl (· ++ "\n" ++ ·) "Warnings:\n"}"

@[inherit_doc deprecationCommands]
elab tk:"deprecate_to "
    deprIds:ident* yy:num noWs &"-" noWs mm:num noWs &"-" noWs dd:num ws cmd:command :
    command => do
  deprecationCommands false tk yy mm dd deprIds cmd

@[inherit_doc deprecationCommands]
elab tk:"deprecate_to! "
    deprIds:ident* yy:num noWs &"-" noWs mm:num noWs &"-" noWs dd:num ws cmd:command :
    command => do
  deprecationCommands true tk yy mm dd deprIds cmd

end Mathlib.Tactic.DeprecateMe
