/-
Copyright (c) 2020 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, Scott Morrison, Ainsley Pahljina
-/
import Mathlib.Data.Nat.Parity
import Mathlib.Data.PNat.Interval
import Mathlib.Data.ZMod.Basic
import Mathlib.GroupTheory.OrderOfElement
import Mathlib.RingTheory.Fintype
import Mathlib.Tactic.IntervalCases

#align_import number_theory.lucas_lehmer from "leanprover-community/mathlib"@"10b4e499f43088dd3bb7b5796184ad5216648ab1"

/-!
# The Lucas-Lehmer test for Mersenne primes.

We define `lucasLehmerResidue : Œ† p : ‚Ñï, ZMod (2^p - 1)`, and
prove `lucasLehmerResidue p = 0 ‚Üí Prime (mersenne p)`.

We construct a `norm_num` extension to calculate this residue to certify primality of Mersenne
primes using `lucas_lehmer_sufficiency`.


## TODO

- Show reverse implication.
- Speed up the calculations using `n ‚â° (n % 2^p) + (n / 2^p) [MOD 2^p - 1]`.
- Find some bigger primes!

## History

This development began as a student project by Ainsley Pahljina,
and was then cleaned up for mathlib by Scott Morrison.
The tactic for certified computation of Lucas-Lehmer residues was provided by Mario Carneiro.
This tactic was ported by Thomas Murrills to Lean 4, and then it was converted to a `norm_num`
extension and made to use kernel reductions by Kyle Miller.
-/


/-- The Mersenne numbers, 2^p - 1. -/
def mersenne (p : ‚Ñï) : ‚Ñï :=
  2 ^ p - 1
#align mersenne mersenne

theorem mersenne_pos {p : ‚Ñï} (h : 0 < p) : 0 < mersenne p := by
  dsimp [mersenne]
  -- ‚ä¢ 0 < 2 ^ p - 1
  calc
    0 < 2 ^ 1 - 1 := by norm_num
    _ ‚â§ 2 ^ p - 1 := Nat.sub_le_sub_right (Nat.pow_le_pow_of_le_right (Nat.succ_pos 1) h) 1
#align mersenne_pos mersenne_pos

theorem one_lt_mersenne {p : ‚Ñï} (hp : 1 < p) : 1 < mersenne p :=
  lt_tsub_iff_right.2 <|
    calc 1 + 1 = 2 ^ 1 := by rw [one_add_one_eq_two, pow_one]
                             -- üéâ no goals
    _ < 2 ^ p := Nat.pow_lt_pow_of_lt_right one_lt_two hp

@[simp]
theorem succ_mersenne (k : ‚Ñï) : mersenne k + 1 = 2 ^ k := by
  rw [mersenne, tsub_add_cancel_of_le]
  -- ‚ä¢ 1 ‚â§ 2 ^ k
  exact one_le_pow_of_one_le (by norm_num) k
  -- üéâ no goals
#align succ_mersenne succ_mersenne

namespace LucasLehmer

open Nat

/-!
We now define three(!) different versions of the recurrence
`s (i+1) = (s i)^2 - 2`.

These versions take values either in `‚Ñ§`, in `ZMod (2^p - 1)`, or
in `‚Ñ§` but applying `% (2^p - 1)` at each step.

They are each useful at different points in the proof,
so we take a moment setting up the lemmas relating them.
-/

/-- The recurrence `s (i+1) = (s i)^2 - 2` in `‚Ñ§`. -/
def s : ‚Ñï ‚Üí ‚Ñ§
  | 0 => 4
  | i + 1 => s i ^ 2 - 2
#align lucas_lehmer.s LucasLehmer.s

/-- The recurrence `s (i+1) = (s i)^2 - 2` in `ZMod (2^p - 1)`. -/
def sZMod (p : ‚Ñï) : ‚Ñï ‚Üí ZMod (2 ^ p - 1)
  | 0 => 4
  | i + 1 => sZMod p i ^ 2 - 2
#align lucas_lehmer.s_zmod LucasLehmer.sZMod

/-- The recurrence `s (i+1) = ((s i)^2 - 2) % (2^p - 1)` in `‚Ñ§`. -/
def sMod (p : ‚Ñï) : ‚Ñï ‚Üí ‚Ñ§
  | 0 => 4 % (2 ^ p - 1)
  | i + 1 => (sMod p i ^ 2 - 2) % (2 ^ p - 1)
#align lucas_lehmer.s_mod LucasLehmer.sMod

theorem mersenne_int_pos {p : ‚Ñï} (hp : 0 < p) : (0 : ‚Ñ§) < 2 ^ p - 1 :=
  sub_pos.2 <| by exact_mod_cast Nat.one_lt_two_pow p hp
                  -- üéâ no goals

theorem mersenne_int_ne_zero (p : ‚Ñï) (w : 0 < p) : (2 ^ p - 1 : ‚Ñ§) ‚â† 0 :=
  (mersenne_int_pos w).ne'
#align lucas_lehmer.mersenne_int_ne_zero LucasLehmer.mersenne_int_ne_zero

theorem sMod_nonneg (p : ‚Ñï) (w : 0 < p) (i : ‚Ñï) : 0 ‚â§ sMod p i := by
  cases i <;> dsimp [sMod]
  -- ‚ä¢ 0 ‚â§ sMod p zero
              -- ‚ä¢ 0 ‚â§ 4 % (2 ^ p - 1)
              -- ‚ä¢ 0 ‚â§ (sMod p n‚úù ^ 2 - 2) % (2 ^ p - 1)
  ¬∑ exact sup_eq_right.mp rfl
    -- üéâ no goals
  ¬∑ apply Int.emod_nonneg
    -- ‚ä¢ 2 ^ p - 1 ‚â† 0
    exact mersenne_int_ne_zero p w
    -- üéâ no goals
#align lucas_lehmer.s_mod_nonneg LucasLehmer.sMod_nonneg

theorem sMod_mod (p i : ‚Ñï) : sMod p i % (2 ^ p - 1) = sMod p i := by cases i <;> simp [sMod]
                                                                     -- ‚ä¢ sMod p zero % (2 ^ p - 1) = sMod p zero
                                                                                 -- üéâ no goals
                                                                                 -- üéâ no goals
#align lucas_lehmer.s_mod_mod LucasLehmer.sMod_mod

theorem sMod_lt (p : ‚Ñï) (w : 0 < p) (i : ‚Ñï) : sMod p i < 2 ^ p - 1 := by
  rw [‚Üê sMod_mod]
  -- ‚ä¢ sMod p i % (2 ^ p - 1) < 2 ^ p - 1
  refine (Int.emod_lt _ (mersenne_int_ne_zero p w)).trans_eq ?_
  -- ‚ä¢ |2 ^ p - 1| = 2 ^ p - 1
  exact abs_of_nonneg (mersenne_int_pos w).le
  -- üéâ no goals
#align lucas_lehmer.s_mod_lt LucasLehmer.sMod_lt

theorem sZMod_eq_s (p' : ‚Ñï) (i : ‚Ñï) : sZMod (p' + 2) i = (s i : ZMod (2 ^ (p' + 2) - 1)) := by
  induction' i with i ih
  -- ‚ä¢ sZMod (p' + 2) zero = ‚Üë(s zero)
  ¬∑ dsimp [s, sZMod]
    -- ‚ä¢ 4 = ‚Üë4
    norm_num
    -- üéâ no goals
  ¬∑ push_cast [s, sZMod, ih]; rfl
    -- ‚ä¢ ‚Üë(s i) ^ 2 - 2 = ‚Üë(s i) ^ 2 - 2
                              -- üéâ no goals
#align lucas_lehmer.s_zmod_eq_s LucasLehmer.sZMod_eq_s

-- These next two don't make good `norm_cast` lemmas.
theorem Int.coe_nat_pow_pred (b p : ‚Ñï) (w : 0 < b) : ((b ^ p - 1 : ‚Ñï) : ‚Ñ§) = (b : ‚Ñ§) ^ p - 1 := by
  have : 1 ‚â§ b ^ p := Nat.one_le_pow p b w
  -- ‚ä¢ ‚Üë(b ^ p - 1) = ‚Üëb ^ p - 1
  norm_cast
  -- üéâ no goals
#align lucas_lehmer.int.coe_nat_pow_pred LucasLehmer.Int.coe_nat_pow_pred

theorem Int.coe_nat_two_pow_pred (p : ‚Ñï) : ((2 ^ p - 1 : ‚Ñï) : ‚Ñ§) = (2 ^ p - 1 : ‚Ñ§) :=
  Int.coe_nat_pow_pred 2 p (by decide)
                               -- üéâ no goals
#align lucas_lehmer.int.coe_nat_two_pow_pred LucasLehmer.Int.coe_nat_two_pow_pred

theorem sZMod_eq_sMod (p : ‚Ñï) (i : ‚Ñï) : sZMod p i = (sMod p i : ZMod (2 ^ p - 1)) := by
  induction i <;> push_cast [‚Üê Int.coe_nat_two_pow_pred p, sMod, sZMod, *] <;> rfl
  -- ‚ä¢ sZMod p zero = ‚Üë(sMod p zero)
                  -- ‚ä¢ 4 = 4
                  -- ‚ä¢ ‚Üë(sMod p n‚úù) ^ 2 - 2 = ‚Üë(sMod p n‚úù) ^ 2 - 2
                                                                               -- üéâ no goals
                                                                               -- üéâ no goals
#align lucas_lehmer.s_zmod_eq_s_mod LucasLehmer.sZMod_eq_sMod

/-- The Lucas-Lehmer residue is `s p (p-2)` in `ZMod (2^p - 1)`. -/
def lucasLehmerResidue (p : ‚Ñï) : ZMod (2 ^ p - 1) :=
  sZMod p (p - 2)
#align lucas_lehmer.lucas_lehmer_residue LucasLehmer.lucasLehmerResidue

theorem residue_eq_zero_iff_sMod_eq_zero (p : ‚Ñï) (w : 1 < p) :
    lucasLehmerResidue p = 0 ‚Üî sMod p (p - 2) = 0 := by
  dsimp [lucasLehmerResidue]
  -- ‚ä¢ sZMod p (p - 2) = 0 ‚Üî sMod p (p - 2) = 0
  rw [sZMod_eq_sMod p]
  -- ‚ä¢ ‚Üë(sMod p (p - 2)) = 0 ‚Üî sMod p (p - 2) = 0
  constructor
  -- ‚ä¢ ‚Üë(sMod p (p - 2)) = 0 ‚Üí sMod p (p - 2) = 0
  ¬∑ -- We want to use that fact that `0 ‚â§ s_mod p (p-2) < 2^p - 1`
    -- and `lucas_lehmer_residue p = 0 ‚Üí 2^p - 1 ‚à£ s_mod p (p-2)`.
    intro h
    -- ‚ä¢ sMod p (p - 2) = 0
    simp [ZMod.int_cast_zmod_eq_zero_iff_dvd] at h
    -- ‚ä¢ sMod p (p - 2) = 0
    apply Int.eq_zero_of_dvd_of_nonneg_of_lt _ _ h <;> clear h
    -- ‚ä¢ 0 ‚â§ sMod p (p - 2)
                                                       -- ‚ä¢ 0 ‚â§ sMod p (p - 2)
                                                       -- ‚ä¢ sMod p (p - 2) < 2 ^ p - 1
    ¬∑ apply sMod_nonneg _ (Nat.lt_of_succ_lt w)
      -- üéâ no goals
    ¬∑ exact sMod_lt _ (Nat.lt_of_succ_lt w) (p - 2)
      -- üéâ no goals
  ¬∑ intro h
    -- ‚ä¢ ‚Üë(sMod p (p - 2)) = 0
    rw [h]
    -- ‚ä¢ ‚Üë0 = 0
    simp
    -- üéâ no goals
#align lucas_lehmer.residue_eq_zero_iff_s_mod_eq_zero LucasLehmer.residue_eq_zero_iff_sMod_eq_zero

/-- A Mersenne number `2^p-1` is prime if and only if
the Lucas-Lehmer residue `s p (p-2) % (2^p - 1)` is zero.
-/
def LucasLehmerTest (p : ‚Ñï) : Prop :=
  lucasLehmerResidue p = 0
#align lucas_lehmer.lucas_lehmer_test LucasLehmer.LucasLehmerTest

-- Porting note: We have a fast `norm_num` extension, and we would rather use that than accidentally
-- have `simp` use `decide`!
/-
instance : DecidablePred LucasLehmerTest :=
  inferInstanceAs (DecidablePred (lucasLehmerResidue ¬∑ = 0))
-/

/-- `q` is defined as the minimum factor of `mersenne p`, bundled as an `‚Ñï+`. -/
def q (p : ‚Ñï) : ‚Ñï+ :=
  ‚ü®Nat.minFac (mersenne p), Nat.minFac_pos (mersenne p)‚ü©
#align lucas_lehmer.q LucasLehmer.q

-- It would be nice to define this as (‚Ñ§/q‚Ñ§)[x] / (x^2 - 3),
-- obtaining the ring structure for free,
-- but that seems to be more trouble than it's worth;
-- if it were easy to make the definition,
-- cardinality calculations would be somewhat more involved, too.
/-- We construct the ring `X q` as ‚Ñ§/q‚Ñ§ + ‚àö3 ‚Ñ§/q‚Ñ§. -/
def X (q : ‚Ñï+) : Type :=
  ZMod q √ó ZMod q
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X LucasLehmer.X

namespace X

variable {q : ‚Ñï+}

instance : Inhabited (X q) := inferInstanceAs (Inhabited (ZMod q √ó ZMod q))
instance : Fintype (X q) := inferInstanceAs (Fintype (ZMod q √ó ZMod q))
instance : DecidableEq (X q) := inferInstanceAs (DecidableEq (ZMod q √ó ZMod q))
instance : AddCommGroup (X q) := inferInstanceAs (AddCommGroup (ZMod q √ó ZMod q))

@[ext]
theorem ext {x y : X q} (h‚ÇÅ : x.1 = y.1) (h‚ÇÇ : x.2 = y.2) : x = y := by
  cases x; cases y; congr
  -- ‚ä¢ (fst‚úù, snd‚úù) = y
           -- ‚ä¢ (fst‚úù¬π, snd‚úù¬π) = (fst‚úù, snd‚úù)
                    -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.ext LucasLehmer.X.ext

@[simp] theorem zero_fst : (0 : X q).1 = 0 := rfl
@[simp] theorem zero_snd : (0 : X q).2 = 0 := rfl

@[simp]
theorem add_fst (x y : X q) : (x + y).1 = x.1 + y.1 :=
  rfl
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.add_fst LucasLehmer.X.add_fst

@[simp]
theorem add_snd (x y : X q) : (x + y).2 = x.2 + y.2 :=
  rfl
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.add_snd LucasLehmer.X.add_snd

@[simp]
theorem neg_fst (x : X q) : (-x).1 = -x.1 :=
  rfl
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.neg_fst LucasLehmer.X.neg_fst

@[simp]
theorem neg_snd (x : X q) : (-x).2 = -x.2 :=
  rfl
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.neg_snd LucasLehmer.X.neg_snd

instance : Mul (X q) where mul x y := (x.1 * y.1 + 3 * x.2 * y.2, x.1 * y.2 + x.2 * y.1)

@[simp]
theorem mul_fst (x y : X q) : (x * y).1 = x.1 * y.1 + 3 * x.2 * y.2 :=
  rfl
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.mul_fst LucasLehmer.X.mul_fst

@[simp]
theorem mul_snd (x y : X q) : (x * y).2 = x.1 * y.2 + x.2 * y.1 :=
  rfl
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.mul_snd LucasLehmer.X.mul_snd

instance : One (X q) where one := ‚ü®1, 0‚ü©

@[simp]
theorem one_fst : (1 : X q).1 = 1 :=
  rfl
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.one_fst LucasLehmer.X.one_fst

@[simp]
theorem one_snd : (1 : X q).2 = 0 :=
  rfl
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.one_snd LucasLehmer.X.one_snd

#noalign lucas_lehmer.X.bit0_fst
#noalign lucas_lehmer.X.bit0_snd
#noalign lucas_lehmer.X.bit1_fst
#noalign lucas_lehmer.X.bit1_snd

instance : Monoid (X q) :=
  { inferInstanceAs (Mul (X q)), inferInstanceAs (One (X q)) with
    mul_assoc := fun x y z => by ext <;> dsimp <;> ring
                                 -- ‚ä¢ (x * y * z).fst = (x * (y * z)).fst
                                         -- ‚ä¢ (x.fst * y.fst + 3 * x.snd * y.snd) * z.fst + 3 * (x.fst * y.snd + x.snd * y ‚Ä¶
                                         -- ‚ä¢ (x.fst * y.fst + 3 * x.snd * y.snd) * z.snd + (x.fst * y.snd + x.snd * y.fst ‚Ä¶
                                                   -- üéâ no goals
                                                   -- üéâ no goals
    one_mul := fun x => by ext <;> simp
                           -- ‚ä¢ (1 * x).fst = x.fst
                                   -- üéâ no goals
                                   -- üéâ no goals
    mul_one := fun x => by ext <;> simp }
                           -- ‚ä¢ (x * 1).fst = x.fst
                                   -- üéâ no goals
                                   -- üéâ no goals

instance : NatCast (X q) where
    natCast := fun n => ‚ü®n, 0‚ü©

@[simp] theorem nat_coe_fst (n : ‚Ñï) : (n : X q).fst = (n : ZMod q) := rfl
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.nat_coe_fst LucasLehmer.X.nat_coe_fst

@[simp] theorem nat_coe_snd (n : ‚Ñï) : (n : X q).snd = (0 : ZMod q) := rfl
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.nat_coe_snd LucasLehmer.X.nat_coe_snd

@[simp] theorem ofNat_fst (n : ‚Ñï) [n.AtLeastTwo] :
    (no_index (OfNat.ofNat n) : X q).fst = OfNat.ofNat n :=
  rfl

@[simp] theorem ofNat_snd (n : ‚Ñï) [n.AtLeastTwo] :
    (no_index (OfNat.ofNat n) : X q).snd = 0 :=
  rfl

instance : AddGroupWithOne (X q) :=
  { inferInstanceAs (Monoid (X q)), inferInstanceAs (AddCommGroup (X q)),
      inferInstanceAs (NatCast (X q)) with
    natCast_zero := by ext <;> simp
                       -- ‚ä¢ (NatCast.natCast 0).fst = 0.fst
                               -- üéâ no goals
                               -- üéâ no goals
    natCast_succ := fun _ ‚Ü¶ by ext <;> simp
                               -- ‚ä¢ (NatCast.natCast (x‚úù + 1)).fst = (NatCast.natCast x‚úù + 1).fst
                                       -- üéâ no goals
                                       -- üéâ no goals
    intCast := fun n => ‚ü®n, 0‚ü©
    intCast_ofNat := fun n => by ext <;> simp
                                 -- ‚ä¢ (IntCast.intCast ‚Üën).fst = (‚Üën).fst
                                         -- üéâ no goals
                                         -- üéâ no goals
    intCast_negSucc := fun n => by ext <;> simp }
                                   -- ‚ä¢ (IntCast.intCast (Int.negSucc n)).fst = (-‚Üë(n + 1)).fst
                                           -- üéâ no goals
                                           -- üéâ no goals

theorem left_distrib (x y z : X q) : x * (y + z) = x * y + x * z := by
  ext <;> dsimp <;> ring
  -- ‚ä¢ (x * (y + z)).fst = (x * y + x * z).fst
          -- ‚ä¢ x.fst * (y.fst + z.fst) + 3 * x.snd * (y.snd + z.snd) = x.fst * y.fst + 3 *  ‚Ä¶
          -- ‚ä¢ x.fst * (y.snd + z.snd) + x.snd * (y.fst + z.fst) = x.fst * y.snd + x.snd *  ‚Ä¶
                    -- üéâ no goals
                    -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.left_distrib LucasLehmer.X.left_distrib

theorem right_distrib (x y z : X q) : (x + y) * z = x * z + y * z := by
  ext <;> dsimp <;> ring
  -- ‚ä¢ ((x + y) * z).fst = (x * z + y * z).fst
          -- ‚ä¢ (x.fst + y.fst) * z.fst + 3 * (x.snd + y.snd) * z.snd = x.fst * z.fst + 3 *  ‚Ä¶
          -- ‚ä¢ (x.fst + y.fst) * z.snd + (x.snd + y.snd) * z.fst = x.fst * z.snd + x.snd *  ‚Ä¶
                    -- üéâ no goals
                    -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.right_distrib LucasLehmer.X.right_distrib

instance : Ring (X q) :=
  { inferInstanceAs (AddGroupWithOne (X q)), inferInstanceAs (AddCommGroup (X q)),
      inferInstanceAs (Monoid (X q)) with
    left_distrib := left_distrib
    right_distrib := right_distrib
    mul_zero := fun _ ‚Ü¶ by ext <;> simp
                           -- ‚ä¢ (x‚úù * 0).fst = 0.fst
                           -- ‚ä¢ (0 * x‚úù).fst = 0.fst
                                   -- üéâ no goals
                                   -- üéâ no goals
                                   -- üéâ no goals
                                   -- üéâ no goals
    zero_mul := fun _ ‚Ü¶ by ext <;> simp }

instance : CommRing (X q) :=
  { inferInstanceAs (Ring (X q)) with
    mul_comm := fun _ _ ‚Ü¶ by ext <;> dsimp <;> ring }
                             -- ‚ä¢ (x‚úù¬π * x‚úù).fst = (x‚úù * x‚úù¬π).fst
                                     -- ‚ä¢ x‚úù¬π.fst * x‚úù.fst + 3 * x‚úù¬π.snd * x‚úù.snd = x‚úù.fst * x‚úù¬π.fst + 3 * x‚úù.snd * x‚úù ‚Ä¶
                                     -- ‚ä¢ x‚úù¬π.fst * x‚úù.snd + x‚úù¬π.snd * x‚úù.fst = x‚úù.fst * x‚úù¬π.snd + x‚úù.snd * x‚úù¬π.fst
                                               -- üéâ no goals
                                               -- üéâ no goals

instance [Fact (1 < (q : ‚Ñï))] : Nontrivial (X q) :=
  ‚ü®‚ü®0, 1, ne_of_apply_ne Prod.fst zero_ne_one‚ü©‚ü©

@[simp]
theorem int_coe_fst (n : ‚Ñ§) : (n : X q).fst = (n : ZMod q) :=
  rfl
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.int_coe_fst LucasLehmer.X.int_coe_fst

@[simp]
theorem int_coe_snd (n : ‚Ñ§) : (n : X q).snd = (0 : ZMod q) :=
  rfl
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.int_coe_snd LucasLehmer.X.int_coe_snd

@[norm_cast]
theorem coe_mul (n m : ‚Ñ§) : ((n * m : ‚Ñ§) : X q) = (n : X q) * (m : X q) := by ext <;> simp
                                                                              -- ‚ä¢ (‚Üë(n * m)).fst = (‚Üën * ‚Üëm).fst
                                                                                      -- üéâ no goals
                                                                                      -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.coe_mul LucasLehmer.X.coe_mul

@[norm_cast]
theorem coe_nat (n : ‚Ñï) : ((n : ‚Ñ§) : X q) = (n : X q) := by ext <;> simp
                                                            -- ‚ä¢ (‚Üë‚Üën).fst = (‚Üën).fst
                                                                    -- üéâ no goals
                                                                    -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.coe_nat LucasLehmer.X.coe_nat

/-- The cardinality of `X` is `q^2`. -/
theorem card_eq : Fintype.card (X q) = q ^ 2 := by
  dsimp [X]
  -- ‚ä¢ Fintype.card (ZMod ‚Üëq √ó ZMod ‚Üëq) = ‚Üëq ^ 2
  rw [Fintype.card_prod, ZMod.card q, sq]
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.X_card LucasLehmer.X.card_eq

/-- There are strictly fewer than `q^2` units, since `0` is not a unit. -/
nonrec theorem card_units_lt (w : 1 < q) : Fintype.card (X q)À£ < q ^ 2 := by
  have : Fact (1 < (q : ‚Ñï)) := ‚ü®w‚ü©
  -- ‚ä¢ Fintype.card (X q)À£ < ‚Üëq ^ 2
  convert card_units_lt (X q)
  -- ‚ä¢ ‚Üëq ^ 2 = Fintype.card (X q)
  rw [card_eq]
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.units_card LucasLehmer.X.card_units_lt

/-- We define `œâ = 2 + ‚àö3`. -/
def œâ : X q := (2, 1)
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.œâ LucasLehmer.X.œâ

/-- We define `œâb = 2 - ‚àö3`, which is the inverse of `œâ`. -/
def œâb : X q := (2, -1)
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.œâb LucasLehmer.X.œâb

theorem œâ_mul_œâb (q : ‚Ñï+) : (œâ : X q) * œâb = 1 := by
  dsimp [œâ, œâb]
  -- ‚ä¢ (2, 1) * (2, -1) = 1
  ext <;> simp; ring
  -- ‚ä¢ ((2, 1) * (2, -1)).fst = 1.fst
          -- ‚ä¢ 2 * 2 + -3 = 1
          -- üéâ no goals
                -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.œâ_mul_œâb LucasLehmer.X.œâ_mul_œâb

theorem œâb_mul_œâ (q : ‚Ñï+) : (œâb : X q) * œâ = 1 := by
  rw [mul_comm, œâ_mul_œâb]
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.œâb_mul_œâ LucasLehmer.X.œâb_mul_œâ

/-- A closed form for the recurrence relation. -/
theorem closed_form (i : ‚Ñï) : (s i : X q) = (œâ : X q) ^ 2 ^ i + (œâb : X q) ^ 2 ^ i := by
  induction' i with i ih
  -- ‚ä¢ ‚Üë(s zero) = œâ ^ 2 ^ zero + œâb ^ 2 ^ zero
  ¬∑ dsimp [s, œâ, œâb]
    -- ‚ä¢ ‚Üë4 = (2, 1) ^ 1 + (2, -1) ^ 1
    ext <;> norm_num
    -- ‚ä¢ (‚Üë4).fst = ((2, 1) ^ 1 + (2, -1) ^ 1).fst
            -- üéâ no goals
            -- üéâ no goals
  ¬∑ calc
      (s (i + 1) : X q) = (s i ^ 2 - 2 : ‚Ñ§) := rfl
      _ = (s i : X q) ^ 2 - 2 := by push_cast; rfl
      _ = (œâ ^ 2 ^ i + œâb ^ 2 ^ i) ^ 2 - 2 := by rw [ih]
      _ = (œâ ^ 2 ^ i) ^ 2 + (œâb ^ 2 ^ i) ^ 2 + 2 * (œâb ^ 2 ^ i * œâ ^ 2 ^ i) - 2 := by ring
      _ = (œâ ^ 2 ^ i) ^ 2 + (œâb ^ 2 ^ i) ^ 2 := by
        rw [‚Üê mul_pow œâb œâ, œâb_mul_œâ, one_pow, mul_one, add_sub_cancel]
      _ = œâ ^ 2 ^ (i + 1) + œâb ^ 2 ^ (i + 1) := by rw [‚Üê pow_mul, ‚Üê pow_mul, _root_.pow_succ']
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.X.closed_form LucasLehmer.X.closed_form

end X

open X

/-!
Here and below, we introduce `p' = p - 2`, in order to avoid using subtraction in `‚Ñï`.
-/

/-- If `1 < p`, then `q p`, the smallest prime factor of `mersenne p`, is more than 2. -/
theorem two_lt_q (p' : ‚Ñï) : 2 < q (p' + 2) := by
  refine (minFac_prime (one_lt_mersenne ?_).ne').two_le.lt_of_ne' ?_
  -- ‚ä¢ 1 < p' + 2
  ¬∑ exact le_add_left _ _
    -- üéâ no goals
  ¬∑ rw [Ne.def, minFac_eq_two_iff, mersenne, Nat.pow_succ']
    -- ‚ä¢ ¬¨2 ‚à£ 2 * 2 ^ (p' + 1) - 1
    exact Nat.two_not_dvd_two_mul_sub_one (Nat.one_le_two_pow _)
    -- üéâ no goals
#align lucas_lehmer.two_lt_q LucasLehmer.two_lt_q

theorem œâ_pow_formula (p' : ‚Ñï) (h : lucasLehmerResidue (p' + 2) = 0) :
    ‚àÉ k : ‚Ñ§,
      (œâ : X (q (p' + 2))) ^ 2 ^ (p' + 1) =
        k * mersenne (p' + 2) * (œâ : X (q (p' + 2))) ^ 2 ^ p' - 1 := by
  dsimp [lucasLehmerResidue] at h
  -- ‚ä¢ ‚àÉ k, œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1
  rw [sZMod_eq_s p'] at h
  -- ‚ä¢ ‚àÉ k, œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1
  simp [ZMod.int_cast_zmod_eq_zero_iff_dvd] at h
  -- ‚ä¢ ‚àÉ k, œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1
  cases' h with k h
  -- ‚ä¢ ‚àÉ k, œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1
  use k
  -- ‚ä¢ œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1
  replace h := congr_arg (fun n : ‚Ñ§ => (n : X (q (p' + 2)))) h
  -- ‚ä¢ œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1
  -- coercion from ‚Ñ§ to X q
  dsimp at h
  -- ‚ä¢ œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1
  rw [closed_form] at h
  -- ‚ä¢ œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1
  replace h := congr_arg (fun x => œâ ^ 2 ^ p' * x) h
  -- ‚ä¢ œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1
  dsimp at h
  -- ‚ä¢ œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1
  have t : 2 ^ p' + 2 ^ p' = 2 ^ (p' + 1) := by ring
  -- ‚ä¢ œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1
  rw [mul_add, ‚Üê pow_add œâ, t, ‚Üê mul_pow œâ œâb (2 ^ p'), œâ_mul_œâb, one_pow] at h
  -- ‚ä¢ œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1
  rw [mul_comm, coe_mul] at h
  -- ‚ä¢ œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1
  rw [mul_comm _ (k : X (q (p' + 2)))] at h
  -- ‚ä¢ œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1
  replace h := eq_sub_of_add_eq h
  -- ‚ä¢ œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1
  have : 1 ‚â§ 2 ^ (p' + 2) := Nat.one_le_pow _ _ (by decide)
  -- ‚ä¢ œâ ^ 2 ^ (p' + 1) = ‚Üëk * ‚Üë(mersenne (p' + 2)) * œâ ^ 2 ^ p' - 1
  exact_mod_cast h
  -- üéâ no goals
#align lucas_lehmer.œâ_pow_formula LucasLehmer.œâ_pow_formula

/-- `q` is the minimum factor of `mersenne p`, so `M p = 0` in `X q`. -/
theorem mersenne_coe_X (p : ‚Ñï) : (mersenne p : X (q p)) = 0 := by
  ext <;> simp [mersenne, q, ZMod.nat_cast_zmod_eq_zero_iff_dvd, -pow_pos]
  -- ‚ä¢ (‚Üë(mersenne p)).fst = 0.fst
          -- ‚ä¢ minFac (2 ^ p - 1) ‚à£ 2 ^ p - 1
          -- üéâ no goals
  apply Nat.minFac_dvd
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align lucas_lehmer.mersenne_coe_X LucasLehmer.mersenne_coe_X

theorem œâ_pow_eq_neg_one (p' : ‚Ñï) (h : lucasLehmerResidue (p' + 2) = 0) :
    (œâ : X (q (p' + 2))) ^ 2 ^ (p' + 1) = -1 := by
  cases' œâ_pow_formula p' h with k w
  -- ‚ä¢ œâ ^ 2 ^ (p' + 1) = -1
  rw [mersenne_coe_X] at w
  -- ‚ä¢ œâ ^ 2 ^ (p' + 1) = -1
  simpa using w
  -- üéâ no goals
#align lucas_lehmer.œâ_pow_eq_neg_one LucasLehmer.œâ_pow_eq_neg_one

theorem œâ_pow_eq_one (p' : ‚Ñï) (h : lucasLehmerResidue (p' + 2) = 0) :
    (œâ : X (q (p' + 2))) ^ 2 ^ (p' + 2) = 1 :=
  calc
    (œâ : X (q (p' + 2))) ^ 2 ^ (p' + 2) = (œâ ^ 2 ^ (p' + 1)) ^ 2 := by
      rw [‚Üê pow_mul, ‚Üê Nat.pow_succ]
      -- üéâ no goals
    _ = (-1) ^ 2 := by rw [œâ_pow_eq_neg_one p' h]
                       -- üéâ no goals
    _ = 1 := by simp
                -- üéâ no goals
#align lucas_lehmer.œâ_pow_eq_one LucasLehmer.œâ_pow_eq_one

/-- `œâ` as an element of the group of units. -/
def œâUnit (p : ‚Ñï) : Units (X (q p)) where
  val := œâ
  inv := œâb
  val_inv := œâ_mul_œâb _
  inv_val := œâb_mul_œâ _
#align lucas_lehmer.œâ_unit LucasLehmer.œâUnit

@[simp]
theorem œâUnit_coe (p : ‚Ñï) : (œâUnit p : X (q p)) = œâ :=
  rfl
#align lucas_lehmer.œâ_unit_coe LucasLehmer.œâUnit_coe

/-- The order of `œâ` in the unit group is exactly `2^p`. -/
theorem order_œâ (p' : ‚Ñï) (h : lucasLehmerResidue (p' + 2) = 0) :
    orderOf (œâUnit (p' + 2)) = 2 ^ (p' + 2) := by
  apply Nat.eq_prime_pow_of_dvd_least_prime_pow
  -- the order of œâ divides 2^p
  ¬∑ exact Nat.prime_two
    -- üéâ no goals
  ¬∑ intro o
    -- ‚ä¢ False
    have œâ_pow := orderOf_dvd_iff_pow_eq_one.1 o
    -- ‚ä¢ False
    replace œâ_pow :=
      congr_arg (Units.coeHom (X (q (p' + 2))) : Units (X (q (p' + 2))) ‚Üí X (q (p' + 2))) œâ_pow
    simp at œâ_pow
    -- ‚ä¢ False
    have h : (1 : ZMod (q (p' + 2))) = -1 :=
      congr_arg Prod.fst (œâ_pow.symm.trans (œâ_pow_eq_neg_one p' h))
    haveI : Fact (2 < (q (p' + 2) : ‚Ñï)) := ‚ü®two_lt_q _‚ü©
    -- ‚ä¢ False
    apply ZMod.neg_one_ne_one h.symm
    -- üéâ no goals
  ¬∑ apply orderOf_dvd_iff_pow_eq_one.2
    -- ‚ä¢ œâUnit (p' + 2) ^ 2 ^ (p' + 1 + 1) = 1
    apply Units.ext
    -- ‚ä¢ ‚Üë(œâUnit (p' + 2) ^ 2 ^ (p' + 1 + 1)) = ‚Üë1
    push_cast
    -- ‚ä¢ ‚Üë(œâUnit (p' + 2)) ^ 2 ^ (p' + 1 + 1) = 1
    exact œâ_pow_eq_one p' h
    -- üéâ no goals
#align lucas_lehmer.order_œâ LucasLehmer.order_œâ

theorem order_ineq (p' : ‚Ñï) (h : lucasLehmerResidue (p' + 2) = 0) :
    2 ^ (p' + 2) < (q (p' + 2) : ‚Ñï) ^ 2 :=
  calc
    2 ^ (p' + 2) = orderOf (œâUnit (p' + 2)) := (order_œâ p' h).symm
    _ ‚â§ Fintype.card (X (q (p' + 2)))À£ := orderOf_le_card_univ
    _ < (q (p' + 2) : ‚Ñï) ^ 2 := card_units_lt (Nat.lt_of_succ_lt (two_lt_q _))
#align lucas_lehmer.order_ineq LucasLehmer.order_ineq

end LucasLehmer

export LucasLehmer (LucasLehmerTest lucasLehmerResidue)

open LucasLehmer

theorem lucas_lehmer_sufficiency (p : ‚Ñï) (w : 1 < p) : LucasLehmerTest p ‚Üí (mersenne p).Prime := by
  let p' := p - 2
  -- ‚ä¢ LucasLehmerTest p ‚Üí Nat.Prime (mersenne p)
  have z : p = p' + 2 := (tsub_eq_iff_eq_add_of_le w.nat_succ_le).mp rfl
  -- ‚ä¢ LucasLehmerTest p ‚Üí Nat.Prime (mersenne p)
  have w : 1 < p' + 2 := Nat.lt_of_sub_eq_succ rfl
  -- ‚ä¢ LucasLehmerTest p ‚Üí Nat.Prime (mersenne p)
  contrapose
  -- ‚ä¢ ¬¨Nat.Prime (mersenne p) ‚Üí ¬¨LucasLehmerTest p
  intro a t
  -- ‚ä¢ False
  rw [z] at a
  -- ‚ä¢ False
  rw [z] at t
  -- ‚ä¢ False
  have h‚ÇÅ := order_ineq p' t
  -- ‚ä¢ False
  have h‚ÇÇ := Nat.minFac_sq_le_self (mersenne_pos (Nat.lt_of_succ_lt w)) a
  -- ‚ä¢ False
  have h := lt_of_lt_of_le h‚ÇÅ h‚ÇÇ
  -- ‚ä¢ False
  exact not_lt_of_ge (Nat.sub_le _ _) h
  -- üéâ no goals
#align lucas_lehmer_sufficiency lucas_lehmer_sufficiency

namespace LucasLehmer

/-!
### `norm_num` extension

Next we define a `norm_num` extension that calculates `LucasLehmerTest p` for `1 < p`.
It makes use of a version of `sMod` that is specifically written to be reducible by the
Lean 4 kernel, which has the capability of efficiently reducing natural number expressions.
With this reduction in hand, it's a simple matter of applying the lemma
`LucasLehmer.residue_eq_zero_iff_sMod_eq_zero`.

See [Archive/Examples/MersennePrimes.lean] for certifications of all Mersenne primes
up through `mersenne 4423`.
-/

namespace norm_num_ext
open Qq Lean Elab.Tactic Mathlib.Meta.NormNum

/-- Version of `sMod` that is `‚Ñï`-valued. One should have `q = 2 ^ p - 1`.
This can be reduced by the kernel. -/
def sMod' (q : ‚Ñï) : ‚Ñï ‚Üí ‚Ñï
  | 0 => 4 % q
  | i + 1 => (sMod' q i ^ 2 + (q - 2)) % q

theorem sMod'_eq_sMod (p k : ‚Ñï) (hp : 2 ‚â§ p) : (sMod' (2 ^ p - 1) k : ‚Ñ§) = sMod p k := by
  have h1 := calc
    4 = 2 ^ 2 := by norm_num
    _ ‚â§ 2 ^ p := Nat.pow_le_pow_of_le_right (by norm_num) hp
  have h2 : 1 ‚â§ 2 ^ p := by linarith
  -- ‚ä¢ ‚Üë(sMod' (2 ^ p - 1) k) = sMod p k
  induction k with
  | zero =>
    rw [sMod', sMod, Int.ofNat_emod]
    simp [h2]
  | succ k ih =>
    rw [sMod', sMod, ‚Üê ih]
    have h3 : 2 ‚â§ 2 ^ p - 1 := by
      zify [h2]
      calc
        (2 : Int) ‚â§ 4 - 1 := by norm_num
        _         ‚â§ 2 ^ p - 1 := by zify at h1; exact Int.sub_le_sub_right h1 _
    zify [h2, h3]
    rw [‚Üê add_sub_assoc, sub_eq_add_neg, add_assoc, add_comm _ (-2), ‚Üê add_assoc,
      Int.add_emod_self, ‚Üê sub_eq_add_neg]

lemma testTrueHelper (p : ‚Ñï) (hp : Nat.blt 1 p = true) (h : sMod' (2 ^ p - 1) (p - 2) = 0) :
    LucasLehmerTest p := by
  rw [Nat.blt_eq] at hp
  -- ‚ä¢ LucasLehmerTest p
  rw [LucasLehmerTest, LucasLehmer.residue_eq_zero_iff_sMod_eq_zero p hp, ‚Üê sMod'_eq_sMod p _ hp, h]
  -- ‚ä¢ ‚Üë0 = 0
  rfl
  -- üéâ no goals

lemma testFalseHelper (p : ‚Ñï) (hp : Nat.blt 1 p = true)
    (h : Nat.ble 1 (sMod' (2 ^ p - 1) (p - 2))) : ¬¨ LucasLehmerTest p := by
  rw [Nat.blt_eq] at hp
  -- ‚ä¢ ¬¨LucasLehmerTest p
  rw [Nat.ble_eq, Nat.succ_le, Nat.pos_iff_ne_zero] at h
  -- ‚ä¢ ¬¨LucasLehmerTest p
  rw [LucasLehmerTest, LucasLehmer.residue_eq_zero_iff_sMod_eq_zero p hp, ‚Üê sMod'_eq_sMod p _ hp]
  -- ‚ä¢ ¬¨‚Üë(sMod' (2 ^ p - 1) (p - 2)) = 0
  simpa using h
  -- üéâ no goals

theorem isNat_lucasLehmerTest : {p np : ‚Ñï} ‚Üí
    IsNat p np ‚Üí LucasLehmerTest np ‚Üí LucasLehmerTest p
  | _, _, ‚ü®rfl‚ü©, h => h

theorem isNat_not_lucasLehmerTest : {p np : ‚Ñï} ‚Üí
    IsNat p np ‚Üí ¬¨ LucasLehmerTest np ‚Üí ¬¨ LucasLehmerTest p
  | _, _, ‚ü®rfl‚ü©, h => h

/-- Calculate `LucasLehmer.LucasLehmerTest p` for `2 ‚â§ p` by using kernel reduction for the
`sMod'` function. -/
@[norm_num LucasLehmer.LucasLehmerTest (_ : ‚Ñï)]
def evalLucasLehmerTest : NormNumExt where eval {u Œ±} e := do
  let .app _ (p : Q(‚Ñï)) ‚Üê Meta.whnfR e | failure
  let ‚ü®ep, hp‚ü© ‚Üê deriveNat p _
  let np := ep.natLit!
  unless 1 < np do
    failure
  haveI' h1ltp : Nat.blt 1 $ep =Q true := ‚ü®‚ü©
  if sMod' (2 ^ np - 1) (np - 2) = 0 then
    haveI' hs : sMod' (2 ^ $ep - 1) ($ep - 2) =Q 0 := ‚ü®‚ü©
    have pf : Q(LucasLehmerTest $ep) := q(testTrueHelper $ep $h1ltp $hs)
    have pf' : Q(LucasLehmerTest $p) := q(isNat_lucasLehmerTest $hp $pf)
    return .isTrue pf'
  else
    haveI' hs : Nat.ble 1 (sMod' (2 ^ $ep - 1) ($ep - 2)) =Q true := ‚ü®‚ü©
    have pf : Q(¬¨ LucasLehmerTest $ep) := q(testFalseHelper $ep $h1ltp $hs)
    have pf' : Q(¬¨ LucasLehmerTest $p) := q(isNat_not_lucasLehmerTest $hp $pf)
    return .isFalse pf'

end norm_num_ext

end LucasLehmer

/-!
This implementation works successfully to prove `(2^4423 - 1).Prime`,
and all the Mersenne primes up to this point appear in [Archive/Examples/MersennePrimes.lean].
These can be calculated nearly instantly, and `(2^9689 - 1).Prime` only fails due to deep
recursion.

(Note by kmill: the following notes were for the Lean 3 version. They seem like they could still
be useful, so I'm leaving them here.)

There's still low hanging fruit available to do faster computations
based on the formula
```
n ‚â° (n % 2^p) + (n / 2^p) [MOD 2^p - 1]
```
and the fact that `% 2^p` and `/ 2^p` can be very efficient on the binary representation.
Someone should do this, too!
-/

theorem modEq_mersenne (n k : ‚Ñï) : k ‚â° k / 2 ^ n + k % 2 ^ n [MOD 2 ^ n - 1] :=
  -- See https://leanprover.zulipchat.com/#narrow/stream/113489-new-members/topic/help.20finding.20a.20lemma/near/177698446
  calc
    k = 2 ^ n * (k / 2 ^ n) + k % 2 ^ n := (Nat.div_add_mod k (2 ^ n)).symm
    _ ‚â° 1 * (k / 2 ^ n) + k % 2 ^ n [MOD 2 ^ n - 1] :=
      ((Nat.modEq_sub <| Nat.succ_le_of_lt <| pow_pos zero_lt_two _).mul_right _).add_right _
    _ = k / 2 ^ n + k % 2 ^ n := by rw [one_mul]
                                    -- üéâ no goals
#align modeq_mersenne modEq_mersenne

-- It's hard to know what the limiting factor for large Mersenne primes would be.
-- In the purely computational world, I think it's the squaring operation in `s`.
