/-
Copyright (c) 2018 Robert Y. Lewis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Robert Y. Lewis
-/
import Mathlib.NumberTheory.Padics.PadicNorm
import Mathlib.Analysis.Normed.Field.Basic

#align_import number_theory.padics.padic_numbers from "leanprover-community/mathlib"@"b9b2114f7711fec1c1e055d507f082f8ceb2c3b7"

/-!
# p-adic numbers

This file defines the `p`-adic numbers (rationals) `‚Ñö_[p]` as
the completion of `‚Ñö` with respect to the `p`-adic norm.
We show that the `p`-adic norm on `‚Ñö` extends to `‚Ñö_[p]`, that `‚Ñö` is embedded in `‚Ñö_[p]`,
and that `‚Ñö_[p]` is Cauchy complete.

## Important definitions

* `Padic` : the type of `p`-adic numbers
* `padicNormE` : the rational valued `p`-adic norm on `‚Ñö_[p]`
* `Padic.addValuation` : the additive `p`-adic valuation on `‚Ñö_[p]`, with values in `WithTop ‚Ñ§`

## Notation

We introduce the notation `‚Ñö_[p]` for the `p`-adic numbers.

## Implementation notes

Much, but not all, of this file assumes that `p` is prime. This assumption is inferred automatically
by taking `[Fact p.Prime]` as a type class argument.

We use the same concrete Cauchy sequence construction that is used to construct `‚Ñù`.
`‚Ñö_[p]` inherits a field structure from this construction.
The extension of the norm on `‚Ñö` to `‚Ñö_[p]` is *not* analogous to extending the absolute value to
`‚Ñù` and hence the proof that `‚Ñö_[p]` is complete is different from the proof that ‚Ñù is complete.

A small special-purpose simplification tactic, `padic_index_simp`, is used to manipulate sequence
indices in the proof that the norm extends.

`padicNormE` is the rational-valued `p`-adic norm on `‚Ñö_[p]`.
To instantiate `‚Ñö_[p]` as a normed field, we must cast this into an `‚Ñù`-valued norm.
The `‚Ñù`-valued norm, using notation `‚Äñ ‚Äñ` from normed spaces,
is the canonical representation of this norm.

`simp` prefers `padicNorm` to `padicNormE` when possible.
Since `padicNormE` and `‚Äñ ‚Äñ` have different types, `simp` does not rewrite one to the other.

Coercions from `‚Ñö` to `‚Ñö_[p]` are set up to work with the `norm_cast` tactic.

## References

* [F. Q. Gouv√™a, *p-adic numbers*][gouvea1997]
* [R. Y. Lewis, *A formal proof of Hensel's lemma over the p-adic integers*][lewis2019]
* <https://en.wikipedia.org/wiki/P-adic_number>

## Tags

p-adic, p adic, padic, norm, valuation, cauchy, completion, p-adic completion
-/


noncomputable section

open Classical

open Nat multiplicity padicNorm CauSeq CauSeq.Completion Metric

/-- The type of Cauchy sequences of rationals with respect to the `p`-adic norm. -/
@[reducible]
def PadicSeq (p : ‚Ñï) :=
  CauSeq _ (padicNorm p)
#align padic_seq PadicSeq

namespace PadicSeq

section

variable {p : ‚Ñï} [Fact p.Prime]

/-- The `p`-adic norm of the entries of a nonzero Cauchy sequence of rationals is eventually
constant. -/
theorem stationary {f : CauSeq ‚Ñö (padicNorm p)} (hf : ¬¨f ‚âà 0) :
    ‚àÉ N, ‚àÄ m n, N ‚â§ m ‚Üí N ‚â§ n ‚Üí padicNorm p (f n) = padicNorm p (f m) :=
  have : ‚àÉ Œµ > 0, ‚àÉ N1, ‚àÄ j ‚â• N1, Œµ ‚â§ padicNorm p (f j) :=
    CauSeq.abv_pos_of_not_limZero <| not_limZero_of_not_congr_zero hf
  let ‚ü®Œµ, hŒµ, N1, hN1‚ü© := this
  let ‚ü®N2, hN2‚ü© := CauSeq.cauchy‚ÇÇ f hŒµ
  ‚ü®max N1 N2, fun n m hn hm ‚Ü¶ by
    have : padicNorm p (f n - f m) < Œµ := hN2 _ (max_le_iff.1 hn).2 _ (max_le_iff.1 hm).2
    -- ‚ä¢ padicNorm p (‚Üëf m) = padicNorm p (‚Üëf n)
    have : padicNorm p (f n - f m) < padicNorm p (f n) :=
      lt_of_lt_of_le this <| hN1 _ (max_le_iff.1 hn).1
    have : padicNorm p (f n - f m) < max (padicNorm p (f n)) (padicNorm p (f m)) :=
      lt_max_iff.2 (Or.inl this)
    by_contra hne
    -- ‚ä¢ False
    rw [‚Üê padicNorm.neg (f m)] at hne
    -- ‚ä¢ False
    have hnam := add_eq_max_of_ne hne
    -- ‚ä¢ False
    rw [padicNorm.neg, max_comm] at hnam
    -- ‚ä¢ False
    rw [‚Üê hnam, sub_eq_add_neg, add_comm] at this
    -- ‚ä¢ False
    apply _root_.lt_irrefl _ this‚ü©
    -- üéâ no goals
#align padic_seq.stationary PadicSeq.stationary

/-- For all `n ‚â• stationaryPoint f hf`, the `p`-adic norm of `f n` is the same. -/
def stationaryPoint {f : PadicSeq p} (hf : ¬¨f ‚âà 0) : ‚Ñï :=
  Classical.choose <| stationary hf
#align padic_seq.stationary_point PadicSeq.stationaryPoint

theorem stationaryPoint_spec {f : PadicSeq p} (hf : ¬¨f ‚âà 0) :
    ‚àÄ {m n},
      stationaryPoint hf ‚â§ m ‚Üí stationaryPoint hf ‚â§ n ‚Üí padicNorm p (f n) = padicNorm p (f m) :=
  @(Classical.choose_spec <| stationary hf)
#align padic_seq.stationary_point_spec PadicSeq.stationaryPoint_spec

/-- Since the norm of the entries of a Cauchy sequence is eventually stationary,
we can lift the norm to sequences. -/
def norm (f : PadicSeq p) : ‚Ñö :=
  if hf : f ‚âà 0 then 0 else padicNorm p (f (stationaryPoint hf))
#align padic_seq.norm PadicSeq.norm

theorem norm_zero_iff (f : PadicSeq p) : f.norm = 0 ‚Üî f ‚âà 0 := by
  constructor
  -- ‚ä¢ norm f = 0 ‚Üí f ‚âà 0
  ¬∑ intro h
    -- ‚ä¢ f ‚âà 0
    by_contra hf
    -- ‚ä¢ False
    unfold norm at h
    -- ‚ä¢ False
    split_ifs at h; contradiction
    -- ‚ä¢ False
                    -- ‚ä¢ False
    apply hf
    -- ‚ä¢ f ‚âà 0
    intro Œµ hŒµ
    -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí padicNorm p (‚Üë(f - 0) j) < Œµ
    exists stationaryPoint hf
    -- ‚ä¢ ‚àÄ (j : ‚Ñï), j ‚â• stationaryPoint hf ‚Üí padicNorm p (‚Üë(f - 0) j) < Œµ
    intro j hj
    -- ‚ä¢ padicNorm p (‚Üë(f - 0) j) < Œµ
    have heq := stationaryPoint_spec hf le_rfl hj
    -- ‚ä¢ padicNorm p (‚Üë(f - 0) j) < Œµ
    simpa [h, heq]
    -- üéâ no goals
  ¬∑ intro h
    -- ‚ä¢ norm f = 0
    simp [norm, h]
    -- üéâ no goals
#align padic_seq.norm_zero_iff PadicSeq.norm_zero_iff

end

section Embedding

open CauSeq

variable {p : ‚Ñï} [Fact p.Prime]

theorem equiv_zero_of_val_eq_of_equiv_zero {f g : PadicSeq p}
    (h : ‚àÄ k, padicNorm p (f k) = padicNorm p (g k)) (hf : f ‚âà 0) : g ‚âà 0 := fun Œµ hŒµ ‚Ü¶
  let ‚ü®i, hi‚ü© := hf _ hŒµ
  ‚ü®i, fun j hj ‚Ü¶ by simpa [h] using hi _ hj‚ü©
                    -- üéâ no goals
#align padic_seq.equiv_zero_of_val_eq_of_equiv_zero PadicSeq.equiv_zero_of_val_eq_of_equiv_zero

theorem norm_nonzero_of_not_equiv_zero {f : PadicSeq p} (hf : ¬¨f ‚âà 0) : f.norm ‚â† 0 :=
  hf ‚àò f.norm_zero_iff.1
#align padic_seq.norm_nonzero_of_not_equiv_zero PadicSeq.norm_nonzero_of_not_equiv_zero

theorem norm_eq_norm_app_of_nonzero {f : PadicSeq p} (hf : ¬¨f ‚âà 0) :
    ‚àÉ k, f.norm = padicNorm p k ‚àß k ‚â† 0 :=
  have heq : f.norm = padicNorm p (f <| stationaryPoint hf) := by simp [norm, hf]
                                                                  -- üéâ no goals
  ‚ü®f <| stationaryPoint hf, heq, fun h ‚Ü¶
    norm_nonzero_of_not_equiv_zero hf (by simpa [h] using heq)‚ü©
                                          -- üéâ no goals
#align padic_seq.norm_eq_norm_app_of_nonzero PadicSeq.norm_eq_norm_app_of_nonzero

theorem not_limZero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨LimZero (const (padicNorm p) q) :=
  fun h' ‚Ü¶ hq <| const_limZero.1 h'
#align padic_seq.not_lim_zero_const_of_nonzero PadicSeq.not_limZero_const_of_nonzero

theorem not_equiv_zero_const_of_nonzero {q : ‚Ñö} (hq : q ‚â† 0) : ¬¨const (padicNorm p) q ‚âà 0 :=
  fun h : LimZero (const (padicNorm p) q - 0) ‚Ü¶ not_limZero_const_of_nonzero hq <| by simpa using h
                                                                                      -- üéâ no goals
#align padic_seq.not_equiv_zero_const_of_nonzero PadicSeq.not_equiv_zero_const_of_nonzero

theorem norm_nonneg (f : PadicSeq p) : 0 ‚â§ f.norm :=
  if hf : f ‚âà 0 then by simp [hf, norm] else by simp [norm, hf, padicNorm.nonneg]
                        -- üéâ no goals
                                                -- üéâ no goals
#align padic_seq.norm_nonneg PadicSeq.norm_nonneg

/-- An auxiliary lemma for manipulating sequence indices. -/
theorem lift_index_left_left {f : PadicSeq p} (hf : ¬¨f ‚âà 0) (v2 v3 : ‚Ñï) :
    padicNorm p (f (stationaryPoint hf)) =
    padicNorm p (f (max (stationaryPoint hf) (max v2 v3))) := by
  apply stationaryPoint_spec hf
  -- ‚ä¢ stationaryPoint hf ‚â§ max (stationaryPoint hf) (max v2 v3)
  ¬∑ apply le_max_left
    -- üéâ no goals
  ¬∑ exact le_rfl
    -- üéâ no goals
#align padic_seq.lift_index_left_left PadicSeq.lift_index_left_left

/-- An auxiliary lemma for manipulating sequence indices. -/
theorem lift_index_left {f : PadicSeq p} (hf : ¬¨f ‚âà 0) (v1 v3 : ‚Ñï) :
    padicNorm p (f (stationaryPoint hf)) =
    padicNorm p (f (max v1 (max (stationaryPoint hf) v3))) := by
  apply stationaryPoint_spec hf
  -- ‚ä¢ stationaryPoint hf ‚â§ max v1 (max (stationaryPoint hf) v3)
  ¬∑ apply le_trans
    ¬∑ apply le_max_left _ v3
      -- üéâ no goals
    ¬∑ apply le_max_right
      -- üéâ no goals
  ¬∑ exact le_rfl
    -- üéâ no goals
#align padic_seq.lift_index_left PadicSeq.lift_index_left

/-- An auxiliary lemma for manipulating sequence indices. -/
theorem lift_index_right {f : PadicSeq p} (hf : ¬¨f ‚âà 0) (v1 v2 : ‚Ñï) :
    padicNorm p (f (stationaryPoint hf)) =
    padicNorm p (f (max v1 (max v2 (stationaryPoint hf)))) := by
  apply stationaryPoint_spec hf
  -- ‚ä¢ stationaryPoint hf ‚â§ max v1 (max v2 (stationaryPoint hf))
  ¬∑ apply le_trans
    ¬∑ apply le_max_right v2
      -- üéâ no goals
    ¬∑ apply le_max_right
      -- üéâ no goals
  ¬∑ exact le_rfl
    -- üéâ no goals
#align padic_seq.lift_index_right PadicSeq.lift_index_right

end Embedding

section Valuation

open CauSeq

variable {p : ‚Ñï} [Fact p.Prime]

/-! ### Valuation on `PadicSeq` -/


/-- The `p`-adic valuation on `‚Ñö` lifts to `PadicSeq p`.
`Valuation f` is defined to be the valuation of the (`‚Ñö`-valued) stationary point of `f`. -/
def valuation (f : PadicSeq p) : ‚Ñ§ :=
  if hf : f ‚âà 0 then 0 else padicValRat p (f (stationaryPoint hf))
#align padic_seq.valuation PadicSeq.valuation

theorem norm_eq_pow_val {f : PadicSeq p} (hf : ¬¨f ‚âà 0) : f.norm = (p : ‚Ñö) ^ (-f.valuation : ‚Ñ§) := by
  rw [norm, valuation, dif_neg hf, dif_neg hf, padicNorm, if_neg]
  -- ‚ä¢ ¬¨‚Üëf (stationaryPoint hf) = 0
  intro H
  -- ‚ä¢ False
  apply CauSeq.not_limZero_of_not_congr_zero hf
  -- ‚ä¢ LimZero f
  intro Œµ hŒµ
  -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí padicNorm p (‚Üëf j) < Œµ
  use stationaryPoint hf
  -- ‚ä¢ ‚àÄ (j : ‚Ñï), j ‚â• stationaryPoint hf ‚Üí padicNorm p (‚Üëf j) < Œµ
  intro n hn
  -- ‚ä¢ padicNorm p (‚Üëf n) < Œµ
  rw [stationaryPoint_spec hf le_rfl hn]
  -- ‚ä¢ padicNorm p (‚Üëf (stationaryPoint hf)) < Œµ
  simpa [H] using hŒµ
  -- üéâ no goals
#align padic_seq.norm_eq_pow_val PadicSeq.norm_eq_pow_val

theorem val_eq_iff_norm_eq {f g : PadicSeq p} (hf : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) :
    f.valuation = g.valuation ‚Üî f.norm = g.norm := by
  rw [norm_eq_pow_val hf, norm_eq_pow_val hg, ‚Üê neg_inj, zpow_inj]
  -- ‚ä¢ 0 < ‚Üëp
  ¬∑ exact_mod_cast (Fact.out : p.Prime).pos
    -- üéâ no goals
  ¬∑ exact_mod_cast (Fact.out : p.Prime).ne_one
    -- üéâ no goals
#align padic_seq.val_eq_iff_norm_eq PadicSeq.val_eq_iff_norm_eq

end Valuation

end PadicSeq

section

open PadicSeq

-- Porting note: Commented out `padic_index_simp` tactic
/-
private unsafe def index_simp_core (hh hf hg : expr)
    (at_ : Interactive.Loc := Interactive.Loc.ns [none]) : tactic Unit := do
  let [v1, v2, v3] ‚Üê [hh, hf, hg].mapM fun n => tactic.mk_app `` stationary_point [n] <|> return n
  let e1 ‚Üê tactic.mk_app `` lift_index_left_left [hh, v2, v3] <|> return q(True)
  let e2 ‚Üê tactic.mk_app `` lift_index_left [hf, v1, v3] <|> return q(True)
  let e3 ‚Üê tactic.mk_app `` lift_index_right [hg, v1, v2] <|> return q(True)
  let sl ‚Üê [e1, e2, e3].foldlM (fun s e => simp_lemmas.add s e) simp_lemmas.mk
  when at_ (tactic.simp_target sl >> tactic.skip)
  let hs ‚Üê at_.get_locals
  hs (tactic.simp_hyp sl [])
#align index_simp_core index_simp_core

/-- This is a special-purpose tactic that lifts `padicNorm (f (stationary_point f))` to
`padicNorm (f (max _ _ _))`. -/
unsafe def tactic.interactive.padic_index_simp (l : interactive.parse interactive.types.pexpr_list)
    (at_ : interactive.parse interactive.types.location) : tactic Unit := do
  let [h, f, g] ‚Üê l.mapM tactic.i_to_expr
  index_simp_core h f g at_
#align tactic.interactive.padic_index_simp tactic.interactive.padic_index_simp
-/

end

namespace PadicSeq

section Embedding

open CauSeq

variable {p : ‚Ñï} [hp : Fact p.Prime]

theorem norm_mul (f g : PadicSeq p) : (f * g).norm = f.norm * g.norm :=
  if hf : f ‚âà 0 then by
    have hg : f * g ‚âà 0 := mul_equiv_zero' _ hf
    -- ‚ä¢ norm (f * g) = norm f * norm g
    simp only [hf, hg, norm, dif_pos, zero_mul]
    -- üéâ no goals
  else
    if hg : g ‚âà 0 then by
      have hf : f * g ‚âà 0 := mul_equiv_zero _ hg
      -- ‚ä¢ norm (f * g) = norm f * norm g
      simp only [hf, hg, norm, dif_pos, mul_zero]
      -- üéâ no goals
    else by
      unfold norm
      -- ‚ä¢ (if hf : f * g ‚âà 0 then 0 else padicNorm p (‚Üë(f * g) (stationaryPoint hf)))  ‚Ä¶
      split_ifs with hfg
      -- ‚ä¢ 0 = padicNorm p (‚Üëf (stationaryPoint hf)) * padicNorm p (‚Üëg (stationaryPoint ‚Ä¶
      exact (mul_not_equiv_zero hf hg hfg).elim
      -- ‚ä¢ padicNorm p (‚Üë(f * g) (stationaryPoint hfg)) = padicNorm p (‚Üëf (stationaryPo ‚Ä¶
      -- Porting note: originally `padic_index_simp [hfg, hf, hg]`
      rw [lift_index_left_left hfg, lift_index_left hf, lift_index_right hg]
      apply padicNorm.mul
      -- üéâ no goals
#align padic_seq.norm_mul PadicSeq.norm_mul

theorem eq_zero_iff_equiv_zero (f : PadicSeq p) : mk f = 0 ‚Üî f ‚âà 0 :=
  mk_eq
#align padic_seq.eq_zero_iff_equiv_zero PadicSeq.eq_zero_iff_equiv_zero

theorem ne_zero_iff_nequiv_zero (f : PadicSeq p) : mk f ‚â† 0 ‚Üî ¬¨f ‚âà 0 :=
  not_iff_not.2 (eq_zero_iff_equiv_zero _)
#align padic_seq.ne_zero_iff_nequiv_zero PadicSeq.ne_zero_iff_nequiv_zero

theorem norm_const (q : ‚Ñö) : norm (const (padicNorm p) q) = padicNorm p q :=
  if hq : q = 0 then by
    have : const (padicNorm p) q ‚âà 0 := by simp [hq]; apply Setoid.refl (const (padicNorm p) 0)
    -- ‚ä¢ norm (const (padicNorm p) q) = padicNorm p q
    subst hq; simp [norm, this]
    -- ‚ä¢ norm (const (padicNorm p) 0) = padicNorm p 0
              -- üéâ no goals
  else by
    have : ¬¨const (padicNorm p) q ‚âà 0 := not_equiv_zero_const_of_nonzero hq
    -- ‚ä¢ norm (const (padicNorm p) q) = padicNorm p q
    simp [norm, this]
    -- üéâ no goals
#align padic_seq.norm_const PadicSeq.norm_const

theorem norm_values_discrete (a : PadicSeq p) (ha : ¬¨a ‚âà 0) : ‚àÉ z : ‚Ñ§, a.norm = (p : ‚Ñö) ^ (-z) := by
  let ‚ü®k, hk, hk'‚ü© := norm_eq_norm_app_of_nonzero ha
  -- ‚ä¢ ‚àÉ z, norm a = ‚Üëp ^ (-z)
  simpa [hk] using padicNorm.values_discrete hk'
  -- üéâ no goals
#align padic_seq.norm_values_discrete PadicSeq.norm_values_discrete

theorem norm_one : norm (1 : PadicSeq p) = 1 := by
  have h1 : ¬¨(1 : PadicSeq p) ‚âà 0 := one_not_equiv_zero _
  -- ‚ä¢ norm 1 = 1
  simp [h1, norm, hp.1.one_lt]
  -- üéâ no goals
#align padic_seq.norm_one PadicSeq.norm_one

private theorem norm_eq_of_equiv_aux {f g : PadicSeq p} (hf : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) (hfg : f ‚âà g)
    (h : padicNorm p (f (stationaryPoint hf)) ‚â† padicNorm p (g (stationaryPoint hg)))
    (hlt : padicNorm p (g (stationaryPoint hg)) < padicNorm p (f (stationaryPoint hf))) :
    False := by
  have hpn : 0 < padicNorm p (f (stationaryPoint hf)) - padicNorm p (g (stationaryPoint hg)) :=
    sub_pos_of_lt hlt
  cases' hfg _ hpn with N hN
  -- ‚ä¢ False
  let i := max N (max (stationaryPoint hf) (stationaryPoint hg))
  -- ‚ä¢ False
  have hi : N ‚â§ i := le_max_left _ _
  -- ‚ä¢ False
  have hN' := hN _ hi
  -- ‚ä¢ False
  -- Porting note: originally `padic_index_simp [N, hf, hg] at hN' h hlt`
  rw [lift_index_left hf N (stationaryPoint hg), lift_index_right hg N (stationaryPoint hf)]
    at hN' h hlt
  have hpne : padicNorm p (f i) ‚â† padicNorm p (-g i) := by rwa [‚Üê padicNorm.neg (g i)] at h
  -- ‚ä¢ False
  rw [CauSeq.sub_apply, sub_eq_add_neg, add_eq_max_of_ne hpne, padicNorm.neg, max_eq_left_of_lt hlt]
    at hN'
  have : padicNorm p (f i) < padicNorm p (f i) := by
    apply lt_of_lt_of_le hN'
    apply sub_le_self
    apply padicNorm.nonneg
  exact lt_irrefl _ this
  -- üéâ no goals

private theorem norm_eq_of_equiv {f g : PadicSeq p} (hf : ¬¨f ‚âà 0) (hg : ¬¨g ‚âà 0) (hfg : f ‚âà g) :
    padicNorm p (f (stationaryPoint hf)) = padicNorm p (g (stationaryPoint hg)) := by
  by_contra h
  -- ‚ä¢ False
  cases'
    Decidable.em
      (padicNorm p (g (stationaryPoint hg)) < padicNorm p (f (stationaryPoint hf))) with
    hlt hnlt
  ¬∑ exact norm_eq_of_equiv_aux hf hg hfg h hlt
    -- üéâ no goals
  ¬∑ apply norm_eq_of_equiv_aux hg hf (Setoid.symm hfg) (Ne.symm h)
    -- ‚ä¢ padicNorm p (‚Üëf (stationaryPoint hf)) < padicNorm p (‚Üëg (stationaryPoint hg))
    apply lt_of_le_of_ne
    -- ‚ä¢ padicNorm p (‚Üëf (stationaryPoint hf)) ‚â§ padicNorm p (‚Üëg (stationaryPoint hg))
    apply le_of_not_gt hnlt
    -- ‚ä¢ padicNorm p (‚Üëf (stationaryPoint hf)) ‚â† padicNorm p (‚Üëg (stationaryPoint hg))
    apply h
    -- üéâ no goals

theorem norm_equiv {f g : PadicSeq p} (hfg : f ‚âà g) : f.norm = g.norm :=
  if hf : f ‚âà 0 then by
    have hg : g ‚âà 0 := Setoid.trans (Setoid.symm hfg) hf
    -- ‚ä¢ norm f = norm g
    simp [norm, hf, hg]
    -- üéâ no goals
  else by
    have hg : ¬¨g ‚âà 0 := hf ‚àò Setoid.trans hfg
    -- ‚ä¢ norm f = norm g
    unfold norm; split_ifs; exact norm_eq_of_equiv hf hg hfg
    -- ‚ä¢ (if hf : f ‚âà 0 then 0 else padicNorm p (‚Üëf (stationaryPoint hf))) = if hf :  ‚Ä¶
                 -- ‚ä¢ padicNorm p (‚Üëf (stationaryPoint hf)) = padicNorm p (‚Üëg (stationaryPoint hg))
                            -- üéâ no goals
#align padic_seq.norm_equiv PadicSeq.norm_equiv

private theorem norm_nonarchimedean_aux {f g : PadicSeq p} (hfg : ¬¨f + g ‚âà 0) (hf : ¬¨f ‚âà 0)
    (hg : ¬¨g ‚âà 0) : (f + g).norm ‚â§ max f.norm g.norm := by
  unfold norm; split_ifs
  -- ‚ä¢ (if hf : f + g ‚âà 0 then 0 else padicNorm p (‚Üë(f + g) (stationaryPoint hf)))  ‚Ä¶
               -- ‚ä¢ padicNorm p (‚Üë(f + g) (stationaryPoint hfg)) ‚â§ max (padicNorm p (‚Üëf (station ‚Ä¶
  -- Porting note: originally `padic_index_simp [hfg, hf, hg]`
  rw [lift_index_left_left hfg, lift_index_left hf, lift_index_right hg]
  apply padicNorm.nonarchimedean
  -- üéâ no goals

theorem norm_nonarchimedean (f g : PadicSeq p) : (f + g).norm ‚â§ max f.norm g.norm :=
  if hfg : f + g ‚âà 0 then by
    have : 0 ‚â§ max f.norm g.norm := le_max_of_le_left (norm_nonneg _)
    -- ‚ä¢ norm (f + g) ‚â§ max (norm f) (norm g)
    simpa only [hfg, norm]
    -- üéâ no goals
  else
    if hf : f ‚âà 0 then by
      have hfg' : f + g ‚âà g := by
        change LimZero (f - 0) at hf
        show LimZero (f + g - g); ¬∑ simpa only [sub_zero, add_sub_cancel] using hf
      have hcfg : (f + g).norm = g.norm := norm_equiv hfg'
      -- ‚ä¢ norm (f + g) ‚â§ max (norm f) (norm g)
      have hcl : f.norm = 0 := (norm_zero_iff f).2 hf
      -- ‚ä¢ norm (f + g) ‚â§ max (norm f) (norm g)
      have : max f.norm g.norm = g.norm := by rw [hcl]; exact max_eq_right (norm_nonneg _)
      -- ‚ä¢ norm (f + g) ‚â§ max (norm f) (norm g)
      rw [this, hcfg]
      -- üéâ no goals
    else
      if hg : g ‚âà 0 then by
        have hfg' : f + g ‚âà f := by
          change LimZero (g - 0) at hg
          show LimZero (f + g - f); ¬∑ simpa only [add_sub_cancel', sub_zero] using hg
        have hcfg : (f + g).norm = f.norm := norm_equiv hfg'
        -- ‚ä¢ norm (f + g) ‚â§ max (norm f) (norm g)
        have hcl : g.norm = 0 := (norm_zero_iff g).2 hg
        -- ‚ä¢ norm (f + g) ‚â§ max (norm f) (norm g)
        have : max f.norm g.norm = f.norm := by rw [hcl]; exact max_eq_left (norm_nonneg _)
        -- ‚ä¢ norm (f + g) ‚â§ max (norm f) (norm g)
        rw [this, hcfg]
        -- üéâ no goals
      else norm_nonarchimedean_aux hfg hf hg
#align padic_seq.norm_nonarchimedean PadicSeq.norm_nonarchimedean

theorem norm_eq {f g : PadicSeq p} (h : ‚àÄ k, padicNorm p (f k) = padicNorm p (g k)) :
    f.norm = g.norm :=
  if hf : f ‚âà 0 then by
    have hg : g ‚âà 0 := equiv_zero_of_val_eq_of_equiv_zero h hf
    -- ‚ä¢ norm f = norm g
    simp only [hf, hg, norm, dif_pos]
    -- üéâ no goals
  else by
    have hg : ¬¨g ‚âà 0 := fun hg ‚Ü¶
      hf <| equiv_zero_of_val_eq_of_equiv_zero (by simp only [h, forall_const, eq_self_iff_true]) hg
    simp only [hg, hf, norm, dif_neg, not_false_iff]
    -- ‚ä¢ padicNorm p (‚Üëf (stationaryPoint (_ : ¬¨f ‚âà 0))) = padicNorm p (‚Üëg (stationar ‚Ä¶
    let i := max (stationaryPoint hf) (stationaryPoint hg)
    -- ‚ä¢ padicNorm p (‚Üëf (stationaryPoint (_ : ¬¨f ‚âà 0))) = padicNorm p (‚Üëg (stationar ‚Ä¶
    have hpf : padicNorm p (f (stationaryPoint hf)) = padicNorm p (f i) := by
      apply stationaryPoint_spec
      apply le_max_left
      exact le_rfl
    have hpg : padicNorm p (g (stationaryPoint hg)) = padicNorm p (g i) := by
      apply stationaryPoint_spec
      apply le_max_right
      exact le_rfl
    rw [hpf, hpg, h]
    -- üéâ no goals
#align padic_seq.norm_eq PadicSeq.norm_eq

theorem norm_neg (a : PadicSeq p) : (-a).norm = a.norm :=
  norm_eq <| by simp
                -- üéâ no goals
#align padic_seq.norm_neg PadicSeq.norm_neg

theorem norm_eq_of_add_equiv_zero {f g : PadicSeq p} (h : f + g ‚âà 0) : f.norm = g.norm := by
  have : LimZero (f + g - 0) := h
  -- ‚ä¢ norm f = norm g
  have : f ‚âà -g := show LimZero (f - -g) by simpa only [sub_zero, sub_neg_eq_add]
  -- ‚ä¢ norm f = norm g
  have : f.norm = (-g).norm := norm_equiv this
  -- ‚ä¢ norm f = norm g
  simpa only [norm_neg] using this
  -- üéâ no goals
#align padic_seq.norm_eq_of_add_equiv_zero PadicSeq.norm_eq_of_add_equiv_zero

theorem add_eq_max_of_ne {f g : PadicSeq p} (hfgne : f.norm ‚â† g.norm) :
    (f + g).norm = max f.norm g.norm :=
  have hfg : ¬¨f + g ‚âà 0 := mt norm_eq_of_add_equiv_zero hfgne
  if hf : f ‚âà 0 then by
    have : LimZero (f - 0) := hf
    -- ‚ä¢ norm (f + g) = max (norm f) (norm g)
    have : f + g ‚âà g := show LimZero (f + g - g) by simpa only [sub_zero, add_sub_cancel]
    -- ‚ä¢ norm (f + g) = max (norm f) (norm g)
    have h1 : (f + g).norm = g.norm := norm_equiv this
    -- ‚ä¢ norm (f + g) = max (norm f) (norm g)
    have h2 : f.norm = 0 := (norm_zero_iff _).2 hf
    -- ‚ä¢ norm (f + g) = max (norm f) (norm g)
    rw [h1, h2, max_eq_right (norm_nonneg _)]
    -- üéâ no goals
  else
    if hg : g ‚âà 0 then by
      have : LimZero (g - 0) := hg
      -- ‚ä¢ norm (f + g) = max (norm f) (norm g)
      have : f + g ‚âà f := show LimZero (f + g - f) by rw [add_sub_cancel']; simpa only [sub_zero]
      -- ‚ä¢ norm (f + g) = max (norm f) (norm g)
      have h1 : (f + g).norm = f.norm := norm_equiv this
      -- ‚ä¢ norm (f + g) = max (norm f) (norm g)
      have h2 : g.norm = 0 := (norm_zero_iff _).2 hg
      -- ‚ä¢ norm (f + g) = max (norm f) (norm g)
      rw [h1, h2, max_eq_left (norm_nonneg _)]
      -- üéâ no goals
    else by
      unfold norm at hfgne ‚ä¢; split_ifs at hfgne ‚ä¢
      -- ‚ä¢ (if hf : f + g ‚âà 0 then 0 else padicNorm p (‚Üë(f + g) (stationaryPoint hf)))  ‚Ä¶
                              -- ‚ä¢ padicNorm p (‚Üë(f + g) (stationaryPoint hfg)) = max (padicNorm p (‚Üëf (station ‚Ä¶
      -- Porting note: originally `padic_index_simp [hfg, hf, hg] at hfgne ‚ä¢`
      rw [lift_index_left hf, lift_index_right hg] at hfgne
      rw [lift_index_left_left hfg, lift_index_left hf, lift_index_right hg]
      exact padicNorm.add_eq_max_of_ne hfgne
      -- üéâ no goals
#align padic_seq.add_eq_max_of_ne PadicSeq.add_eq_max_of_ne

end Embedding

end PadicSeq

/-- The `p`-adic numbers `‚Ñö_[p]` are the Cauchy completion of `‚Ñö` with respect to the `p`-adic norm.
-/
def Padic (p : ‚Ñï) [Fact p.Prime] :=
  CauSeq.Completion.Cauchy (padicNorm p)
#align padic Padic

-- mathport name: ¬´expr‚Ñö_[ ]¬ª
/-- notation for p-padic rationals -/
notation "‚Ñö_[" p "]" => Padic p

namespace Padic

section Completion

variable {p : ‚Ñï} [Fact p.Prime]

instance field : Field ‚Ñö_[p] :=
  Cauchy.field

instance : Inhabited ‚Ñö_[p] :=
  ‚ü®0‚ü©

-- short circuits
instance : CommRing ‚Ñö_[p] :=
  Cauchy.commRing

instance : Ring ‚Ñö_[p] :=
  Cauchy.ring

instance : Zero ‚Ñö_[p] := by infer_instance
                            -- üéâ no goals

instance : One ‚Ñö_[p] := by infer_instance
                           -- üéâ no goals

instance : Add ‚Ñö_[p] := by infer_instance
                           -- üéâ no goals

instance : Mul ‚Ñö_[p] := by infer_instance
                           -- üéâ no goals

instance : Sub ‚Ñö_[p] := by infer_instance
                           -- üéâ no goals

instance : Neg ‚Ñö_[p] := by infer_instance
                           -- üéâ no goals

instance : Div ‚Ñö_[p] := by infer_instance
                           -- üéâ no goals

instance : AddCommGroup ‚Ñö_[p] := by infer_instance
                                    -- üéâ no goals

/-- Builds the equivalence class of a Cauchy sequence of rationals. -/
def mk : PadicSeq p ‚Üí ‚Ñö_[p] :=
  Quotient.mk'
#align padic.mk Padic.mk

variable (p)

theorem zero_def : (0 : ‚Ñö_[p]) = ‚ü¶0‚üß := rfl
#align padic.zero_def Padic.zero_def

theorem mk_eq {f g : PadicSeq p} : mk f = mk g ‚Üî f ‚âà g :=
  Quotient.eq'
#align padic.mk_eq Padic.mk_eq

theorem const_equiv {q r : ‚Ñö} : const (padicNorm p) q ‚âà const (padicNorm p) r ‚Üî q = r :=
  ‚ü®fun heq ‚Ü¶ eq_of_sub_eq_zero <| const_limZero.1 heq, fun heq ‚Ü¶ by
    rw [heq]‚ü©
    -- üéâ no goals
#align padic.const_equiv Padic.const_equiv

@[norm_cast]
theorem coe_inj {q r : ‚Ñö} : (‚Üëq : ‚Ñö_[p]) = ‚Üër ‚Üî q = r :=
  ‚ü®(const_equiv p).1 ‚àò Quotient.eq'.1, fun h ‚Ü¶ by rw [h]‚ü©
                                                  -- üéâ no goals
#align padic.coe_inj Padic.coe_inj

instance : CharZero ‚Ñö_[p] :=
  ‚ü®fun m n ‚Ü¶ by
    rw [‚Üê Rat.cast_coe_nat]
    -- ‚ä¢ ‚Üë‚Üëm = ‚Üën ‚Üí m = n
    norm_cast
    -- ‚ä¢ m = n ‚Üí m = n
    exact id‚ü©
    -- üéâ no goals

@[norm_cast]
theorem coe_add : ‚àÄ {x y : ‚Ñö}, (‚Üë(x + y) : ‚Ñö_[p]) = ‚Üëx + ‚Üëy :=
  Rat.cast_add _ _
#align padic.coe_add Padic.coe_add

@[norm_cast]
theorem coe_neg : ‚àÄ {x : ‚Ñö}, (‚Üë(-x) : ‚Ñö_[p]) = -‚Üëx :=
  Rat.cast_neg _
#align padic.coe_neg Padic.coe_neg

@[norm_cast]
theorem coe_mul : ‚àÄ {x y : ‚Ñö}, (‚Üë(x * y) : ‚Ñö_[p]) = ‚Üëx * ‚Üëy :=
  Rat.cast_mul _ _
#align padic.coe_mul Padic.coe_mul

@[norm_cast]
theorem coe_sub : ‚àÄ {x y : ‚Ñö}, (‚Üë(x - y) : ‚Ñö_[p]) = ‚Üëx - ‚Üëy :=
  Rat.cast_sub _ _
#align padic.coe_sub Padic.coe_sub

@[norm_cast]
theorem coe_div : ‚àÄ {x y : ‚Ñö}, (‚Üë(x / y) : ‚Ñö_[p]) = ‚Üëx / ‚Üëy :=
  Rat.cast_div _ _
#align padic.coe_div Padic.coe_div

@[norm_cast]
theorem coe_one : (‚Üë(1 : ‚Ñö) : ‚Ñö_[p]) = 1 := rfl
#align padic.coe_one Padic.coe_one

@[norm_cast]
theorem coe_zero : (‚Üë(0 : ‚Ñö) : ‚Ñö_[p]) = 0 := rfl
#align padic.coe_zero Padic.coe_zero

end Completion

end Padic

/-- The rational-valued `p`-adic norm on `‚Ñö_[p]` is lifted from the norm on Cauchy sequences. The
canonical form of this function is the normed space instance, with notation `‚Äñ ‚Äñ`. -/
def padicNormE {p : ‚Ñï} [hp : Fact p.Prime] : AbsoluteValue ‚Ñö_[p] ‚Ñö where
  toFun := Quotient.lift PadicSeq.norm <| @PadicSeq.norm_equiv _ _
  map_mul' q r := Quotient.inductionOn‚ÇÇ q r <| PadicSeq.norm_mul
  nonneg' q := Quotient.inductionOn q <| PadicSeq.norm_nonneg
  eq_zero' q := Quotient.inductionOn q <| fun r ‚Ü¶ by
    rw [Padic.zero_def, Quotient.eq]
    -- ‚ä¢ MulHom.toFun { toFun := Quotient.lift PadicSeq.norm (_ : ‚àÄ {f g : PadicSeq p ‚Ä¶
    exact PadicSeq.norm_zero_iff r
    -- üéâ no goals
  add_le' q r := by
    trans
      max ((Quotient.lift PadicSeq.norm <| @PadicSeq.norm_equiv _ _) q)
        ((Quotient.lift PadicSeq.norm <| @PadicSeq.norm_equiv _ _) r)
    exact Quotient.inductionOn‚ÇÇ q r <| PadicSeq.norm_nonarchimedean
    -- ‚ä¢ max (Quotient.lift PadicSeq.norm (_ : ‚àÄ {f g : PadicSeq p}, f ‚âà g ‚Üí PadicSeq ‚Ä¶
    refine' max_le_add_of_nonneg (Quotient.inductionOn q <| PadicSeq.norm_nonneg) _
    -- ‚ä¢ 0 ‚â§ Quotient.lift PadicSeq.norm (_ : ‚àÄ {f g : PadicSeq p}, f ‚âà g ‚Üí PadicSeq. ‚Ä¶
    exact Quotient.inductionOn r <| PadicSeq.norm_nonneg
    -- üéâ no goals
#align padic_norm_e padicNormE

namespace padicNormE

section Embedding

open PadicSeq

variable {p : ‚Ñï} [Fact p.Prime]

-- Porting note: Expanded `‚ü¶f‚üß` to `Padic.mk f`
theorem defn (f : PadicSeq p) {Œµ : ‚Ñö} (hŒµ : 0 < Œµ) :
    ‚àÉ N, ‚àÄ i ‚â• N, padicNormE (Padic.mk f - f i : ‚Ñö_[p]) < Œµ := by
  dsimp [padicNormE]
  -- ‚ä¢ ‚àÉ N, ‚àÄ (i : ‚Ñï), i ‚â• N ‚Üí Quotient.lift PadicSeq.norm (_ : ‚àÄ {f g : PadicSeq p ‚Ä¶
  change ‚àÉ N, ‚àÄ i ‚â• N, (f - const _ (f i)).norm < Œµ
  -- ‚ä¢ ‚àÉ N, ‚àÄ (i : ‚Ñï), i ‚â• N ‚Üí PadicSeq.norm (f - const (padicNorm p) (‚Üëf i)) < Œµ
  by_contra' h
  -- ‚ä¢ False
  cases' cauchy‚ÇÇ f hŒµ with N hN
  -- ‚ä¢ False
  rcases h N with ‚ü®i, hi, hge‚ü©
  -- ‚ä¢ False
  have hne : ¬¨f - const (padicNorm p) (f i) ‚âà 0 := by
    intro h
    unfold PadicSeq.norm at hge; split_ifs at hge
    exact not_lt_of_ge hge hŒµ
  unfold PadicSeq.norm at hge; split_ifs at hge; exact not_le_of_gt hŒµ hge
  -- ‚ä¢ False
                               -- ‚ä¢ False
                                                 -- ‚ä¢ False
  apply not_le_of_gt _ hge
  -- ‚ä¢ Œµ > padicNorm p (‚Üë(f - const (padicNorm p) (‚Üëf i)) (stationaryPoint h‚úù))
  cases' _root_.em (N ‚â§ stationaryPoint hne) with hgen hngen
  -- ‚ä¢ Œµ > padicNorm p (‚Üë(f - const (padicNorm p) (‚Üëf i)) (stationaryPoint h‚úù))
  ¬∑ apply hN _ hgen _ hi
    -- üéâ no goals
  ¬∑ have := stationaryPoint_spec hne le_rfl (le_of_not_le hngen)
    -- ‚ä¢ Œµ > padicNorm p (‚Üë(f - const (padicNorm p) (‚Üëf i)) (stationaryPoint h‚úù))
    rw [‚Üê this]
    -- ‚ä¢ Œµ > padicNorm p (‚Üë(f - const (padicNorm p) (‚Üëf i)) N)
    exact hN _ le_rfl _ hi
    -- üéâ no goals
#align padic_norm_e.defn padicNormE.defn

/-- Theorems about `padicNormE` are named with a `'` so the names do not conflict with the
equivalent theorems about `norm` (`‚Äñ ‚Äñ`). -/
theorem nonarchimedean' (q r : ‚Ñö_[p]) :
    padicNormE (q + r : ‚Ñö_[p]) ‚â§ max (padicNormE q) (padicNormE r) :=
  Quotient.inductionOn‚ÇÇ q r <| norm_nonarchimedean
#align padic_norm_e.nonarchimedean' padicNormE.nonarchimedean'

/-- Theorems about `padicNormE` are named with a `'` so the names do not conflict with the
equivalent theorems about `norm` (`‚Äñ ‚Äñ`). -/
theorem add_eq_max_of_ne' {q r : ‚Ñö_[p]} :
    padicNormE q ‚â† padicNormE r ‚Üí padicNormE (q + r : ‚Ñö_[p]) = max (padicNormE q) (padicNormE r) :=
  Quotient.inductionOn‚ÇÇ q r fun _ _ ‚Ü¶ PadicSeq.add_eq_max_of_ne
#align padic_norm_e.add_eq_max_of_ne' padicNormE.add_eq_max_of_ne'

@[simp]
theorem eq_padic_norm' (q : ‚Ñö) : padicNormE (q : ‚Ñö_[p]) = padicNorm p q :=
  norm_const _
#align padic_norm_e.eq_padic_norm' padicNormE.eq_padic_norm'

protected theorem image' {q : ‚Ñö_[p]} : q ‚â† 0 ‚Üí ‚àÉ n : ‚Ñ§, padicNormE q = (p : ‚Ñö) ^ (-n) :=
  Quotient.inductionOn q fun f hf ‚Ü¶
    have : ¬¨f ‚âà 0 := (ne_zero_iff_nequiv_zero f).1 hf
    norm_values_discrete f this
#align padic_norm_e.image' padicNormE.image'

end Embedding

end padicNormE

namespace Padic

section Complete

open PadicSeq Padic

variable {p : ‚Ñï} [Fact p.Prime] (f : CauSeq _ (@padicNormE p _))

theorem rat_dense' (q : ‚Ñö_[p]) {Œµ : ‚Ñö} (hŒµ : 0 < Œµ) : ‚àÉ r : ‚Ñö, padicNormE (q - r : ‚Ñö_[p]) < Œµ :=
  Quotient.inductionOn q fun q' ‚Ü¶
    have : ‚àÉ N, ‚àÄ (m) (_ : m ‚â• N) (n) (_ : n ‚â• N), padicNorm p (q' m - q' n) < Œµ := cauchy‚ÇÇ _ hŒµ
    let ‚ü®N, hN‚ü© := this
    ‚ü®q' N, by
      dsimp [padicNormE]
      -- ‚ä¢ Quotient.lift PadicSeq.norm (_ : ‚àÄ {f g : PadicSeq p}, f ‚âà g ‚Üí PadicSeq.norm ‚Ä¶
      -- Porting note: `change` ‚Üí `convert_to` (`change` times out!)
      -- and add `PadicSeq p` type annotation
      convert_to PadicSeq.norm (q' - const _ (q' N) : PadicSeq p) < Œµ
      -- ‚ä¢ PadicSeq.norm (q' - const (padicNorm p) (‚Üëq' N)) < Œµ
      cases' Decidable.em (q' - const (padicNorm p) (q' N) ‚âà 0) with heq hne'
      -- ‚ä¢ PadicSeq.norm (q' - const (padicNorm p) (‚Üëq' N)) < Œµ
      ¬∑ simpa only [heq, PadicSeq.norm, dif_pos]
        -- üéâ no goals
      ¬∑ simp only [PadicSeq.norm, dif_neg hne']
        -- ‚ä¢ padicNorm p (‚Üë(q' - const (padicNorm p) (‚Üëq' N)) (stationaryPoint hne')) < Œµ
        change padicNorm p (q' _ - q' _) < Œµ
        -- ‚ä¢ padicNorm p (‚Üëq' (stationaryPoint hne') - ‚Üëq' N) < Œµ
        cases' Decidable.em (stationaryPoint hne' ‚â§ N) with hle hle
        -- ‚ä¢ padicNorm p (‚Üëq' (stationaryPoint hne') - ‚Üëq' N) < Œµ
        ¬∑ -- Porting note: inlined `stationaryPoint_spec` invocation.
          have := (stationaryPoint_spec hne' le_rfl hle).symm
          -- ‚ä¢ padicNorm p (‚Üëq' (stationaryPoint hne') - ‚Üëq' N) < Œµ
          simp only [const_apply, sub_apply, padicNorm.zero, sub_self] at this
          -- ‚ä¢ padicNorm p (‚Üëq' (stationaryPoint hne') - ‚Üëq' N) < Œµ
          simpa only [this]
          -- üéâ no goals
        ¬∑ exact hN _ (lt_of_not_ge hle).le _ le_rfl‚ü©
          -- üéâ no goals
#align padic.rat_dense' Padic.rat_dense'

open Classical

private theorem div_nat_pos (n : ‚Ñï) : 0 < 1 / (n + 1 : ‚Ñö) :=
  div_pos zero_lt_one (by exact_mod_cast succ_pos _)
                          -- üéâ no goals

/-- `limSeq f`, for `f` a Cauchy sequence of `p`-adic numbers, is a sequence of rationals with the
same limit point as `f`. -/
def limSeq : ‚Ñï ‚Üí ‚Ñö :=
  fun n ‚Ü¶ Classical.choose (rat_dense' (f n) (div_nat_pos n))
#align padic.lim_seq Padic.limSeq

theorem exi_rat_seq_conv {Œµ : ‚Ñö} (hŒµ : 0 < Œµ) :
    ‚àÉ N, ‚àÄ i ‚â• N, padicNormE (f i - (limSeq f i : ‚Ñö_[p]) : ‚Ñö_[p]) < Œµ := by
  refine' (exists_nat_gt (1 / Œµ)).imp fun N hN i hi ‚Ü¶ _
  -- ‚ä¢ ‚ÜëpadicNormE (‚Üëf i - ‚Üë(limSeq f i)) < Œµ
  have h := Classical.choose_spec (rat_dense' (f i) (div_nat_pos i))
  -- ‚ä¢ ‚ÜëpadicNormE (‚Üëf i - ‚Üë(limSeq f i)) < Œµ
  refine' lt_of_lt_of_le h ((div_le_iff' <| by exact_mod_cast succ_pos _).mpr _)
  -- ‚ä¢ 1 ‚â§ (‚Üëi + 1) * Œµ
  rw [right_distrib]
  -- ‚ä¢ 1 ‚â§ ‚Üëi * Œµ + 1 * Œµ
  apply le_add_of_le_of_nonneg
  -- ‚ä¢ 1 ‚â§ ‚Üëi * Œµ
  ¬∑ exact (div_le_iff hŒµ).mp (le_trans (le_of_lt hN) (by exact_mod_cast hi))
    -- üéâ no goals
  ¬∑ apply le_of_lt
    -- ‚ä¢ 0 < 1 * Œµ
    simpa
    -- üéâ no goals
#align padic.exi_rat_seq_conv Padic.exi_rat_seq_conv

theorem exi_rat_seq_conv_cauchy : IsCauSeq (padicNorm p) (limSeq f) := fun Œµ hŒµ ‚Ü¶ by
  have hŒµ3 : 0 < Œµ / 3 := div_pos hŒµ (by norm_num)
  -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí padicNorm p (limSeq f j - limSeq f i) < Œµ
  let ‚ü®N, hN‚ü© := exi_rat_seq_conv f hŒµ3
  -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí padicNorm p (limSeq f j - limSeq f i) < Œµ
  let ‚ü®N2, hN2‚ü© := f.cauchy‚ÇÇ hŒµ3
  -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí padicNorm p (limSeq f j - limSeq f i) < Œµ
  exists max N N2
  -- ‚ä¢ ‚àÄ (j : ‚Ñï), j ‚â• max N N2 ‚Üí padicNorm p (limSeq f j - limSeq f (max N N2)) < Œµ
  intro j hj
  -- ‚ä¢ padicNorm p (limSeq f j - limSeq f (max N N2)) < Œµ
  suffices
    padicNormE (limSeq f j - f (max N N2) + (f (max N N2) - limSeq f (max N N2)) : ‚Ñö_[p]) < Œµ by
    ring_nf at this ‚ä¢
    rw [‚Üê padicNormE.eq_padic_norm']
    exact_mod_cast this
  ¬∑ apply lt_of_le_of_lt
    ¬∑ apply padicNormE.add_le
      -- üéâ no goals
    ¬∑ rw [‚Üêadd_thirds Œµ]
      -- ‚ä¢ ‚ÜëpadicNormE (‚Üë(limSeq f j) - ‚Üëf (max N N2)) + ‚ÜëpadicNormE (‚Üëf (max N N2) - ‚Üë ‚Ä¶
      apply _root_.add_lt_add
      -- ‚ä¢ ‚ÜëpadicNormE (‚Üë(limSeq f j) - ‚Üëf (max N N2)) < Œµ / 3 + Œµ / 3
      ¬∑ suffices padicNormE (limSeq f j - f j + (f j - f (max N N2)) : ‚Ñö_[p]) < Œµ / 3 + Œµ / 3 by
          simpa only [sub_add_sub_cancel]
        apply lt_of_le_of_lt
        ¬∑ apply padicNormE.add_le
          -- üéâ no goals
        ¬∑ apply _root_.add_lt_add
          -- ‚ä¢ ‚ÜëpadicNormE (‚Üë(limSeq f j) - ‚Üëf j) < Œµ / 3
          ¬∑ rw [padicNormE.map_sub]
            -- ‚ä¢ ‚ÜëpadicNormE (‚Üëf j - ‚Üë(limSeq f j)) < Œµ / 3
            apply_mod_cast hN j
            -- ‚ä¢ j ‚â• N
            exact le_of_max_le_left hj
            -- üéâ no goals
          ¬∑ exact hN2 _ (le_of_max_le_right hj) _ (le_max_right _ _)
            -- üéâ no goals
      ¬∑ apply_mod_cast hN (max N N2)
        -- ‚ä¢ max N N2 ‚â• N
        apply le_max_left
        -- üéâ no goals
#align padic.exi_rat_seq_conv_cauchy Padic.exi_rat_seq_conv_cauchy

private def lim' : PadicSeq p :=
  ‚ü®_, exi_rat_seq_conv_cauchy f‚ü©

private def lim : ‚Ñö_[p] :=
  ‚ü¶lim' f‚üß

theorem complete' : ‚àÉ q : ‚Ñö_[p], ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ i ‚â• N, padicNormE (q - f i : ‚Ñö_[p]) < Œµ :=
  ‚ü®lim f, fun Œµ hŒµ ‚Ü¶ by
    obtain ‚ü®N, hN‚ü© := exi_rat_seq_conv f (half_pos hŒµ)
    -- ‚ä¢ ‚àÉ N, ‚àÄ (i : ‚Ñï), i ‚â• N ‚Üí ‚ÜëpadicNormE (Padic.lim f - ‚Üëf i) < Œµ
    obtain ‚ü®N2, hN2‚ü© := padicNormE.defn (lim' f) (half_pos hŒµ)
    -- ‚ä¢ ‚àÉ N, ‚àÄ (i : ‚Ñï), i ‚â• N ‚Üí ‚ÜëpadicNormE (Padic.lim f - ‚Üëf i) < Œµ
    refine' ‚ü®max N N2, fun i hi ‚Ü¶ _‚ü©
    -- ‚ä¢ ‚ÜëpadicNormE (Padic.lim f - ‚Üëf i) < Œµ
    rw [‚Üê sub_add_sub_cancel _ (lim' f i : ‚Ñö_[p]) _]
    -- ‚ä¢ ‚ÜëpadicNormE (Padic.lim f - ‚Üë(‚Üë(Padic.lim' f) i) + (‚Üë(‚Üë(Padic.lim' f) i) - ‚Üëf ‚Ä¶
    refine' (padicNormE.add_le _ _).trans_lt _
    -- ‚ä¢ ‚ÜëpadicNormE (Padic.lim f - ‚Üë(‚Üë(Padic.lim' f) i)) + ‚ÜëpadicNormE (‚Üë(‚Üë(Padic.li ‚Ä¶
    rw [‚Üê add_halves Œµ]
    -- ‚ä¢ ‚ÜëpadicNormE (Padic.lim f - ‚Üë(‚Üë(Padic.lim' f) i)) + ‚ÜëpadicNormE (‚Üë(‚Üë(Padic.li ‚Ä¶
    apply _root_.add_lt_add
    -- ‚ä¢ ‚ÜëpadicNormE (Padic.lim f - ‚Üë(‚Üë(Padic.lim' f) i)) < Œµ / 2
    ¬∑ apply hN2 _ (le_of_max_le_right hi)
      -- üéâ no goals
    ¬∑ rw [padicNormE.map_sub]
      -- ‚ä¢ ‚ÜëpadicNormE (‚Üëf i - ‚Üë(‚Üë(Padic.lim' f) i)) < Œµ / 2
      exact hN _ (le_of_max_le_left hi)‚ü©
      -- üéâ no goals
#align padic.complete' Padic.complete'

theorem complete'' : ‚àÉ q : ‚Ñö_[p], ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ i ‚â• N, padicNormE (f i - q : ‚Ñö_[p]) < Œµ := by
  obtain ‚ü®x, hx‚ü© := complete' f
  -- ‚ä¢ ‚àÉ q, ‚àÄ (Œµ : ‚Ñö), Œµ > 0 ‚Üí ‚àÉ N, ‚àÄ (i : ‚Ñï), i ‚â• N ‚Üí ‚ÜëpadicNormE (‚Üëf i - q) < Œµ
  refine ‚ü®x, fun Œµ hŒµ => ?_‚ü©
  -- ‚ä¢ ‚àÉ N, ‚àÄ (i : ‚Ñï), i ‚â• N ‚Üí ‚ÜëpadicNormE (‚Üëf i - x) < Œµ
  obtain ‚ü®N, hN‚ü© := hx Œµ hŒµ
  -- ‚ä¢ ‚àÉ N, ‚àÄ (i : ‚Ñï), i ‚â• N ‚Üí ‚ÜëpadicNormE (‚Üëf i - x) < Œµ
  refine ‚ü®N, fun i hi => ?_‚ü©
  -- ‚ä¢ ‚ÜëpadicNormE (‚Üëf i - x) < Œµ
  rw [padicNormE.map_sub]
  -- ‚ä¢ ‚ÜëpadicNormE (x - ‚Üëf i) < Œµ
  exact hN i hi
  -- üéâ no goals
end Complete

section NormedSpace

variable (p : ‚Ñï) [Fact p.Prime]

instance : Dist ‚Ñö_[p] :=
  ‚ü®fun x y ‚Ü¶ padicNormE (x - y : ‚Ñö_[p])‚ü©

instance metricSpace : MetricSpace ‚Ñö_[p] where
  dist_self := by simp [dist]
                  -- üéâ no goals
  dist := dist
  dist_comm x y := by simp [dist, ‚Üê padicNormE.map_neg (x - y : ‚Ñö_[p])]
                      -- üéâ no goals
  dist_triangle x y z := by
    dsimp [dist]
    -- ‚ä¢ ‚Üë(‚ÜëpadicNormE (x - z)) ‚â§ ‚Üë(‚ÜëpadicNormE (x - y)) + ‚Üë(‚ÜëpadicNormE (y - z))
    exact_mod_cast padicNormE.sub_le x y z
    -- üéâ no goals
  eq_of_dist_eq_zero := by
    dsimp [dist]; intro _ _ h
    -- ‚ä¢ ‚àÄ {x y : ‚Ñö_[p]}, ‚Üë(‚ÜëpadicNormE (x - y)) = 0 ‚Üí x = y
                  -- ‚ä¢ x‚úù = y‚úù
    apply eq_of_sub_eq_zero
    -- ‚ä¢ x‚úù - y‚úù = 0
    apply padicNormE.eq_zero.1
                   -- ‚ä¢ (fun x y => ‚Üë{ val := ‚Üë(‚ÜëpadicNormE (x - y)), property := (_ : 0 ‚â§ ‚Üë(‚ÜëpadicN ‚Ä¶
                           -- üéâ no goals
    -- ‚ä¢ ‚ÜëpadicNormE (x‚úù - y‚úù) = 0
    exact_mod_cast h
    -- üéâ no goals
  -- Porting note: added because autoparam was not ported
  edist_dist := by intros; exact (ENNReal.ofReal_eq_coe_nnreal _).symm

instance : Norm ‚Ñö_[p] :=
  ‚ü®fun x ‚Ü¶ padicNormE x‚ü©

instance normedField : NormedField ‚Ñö_[p] :=
  { Padic.field,
    Padic.metricSpace p with
    dist_eq := fun _ _ ‚Ü¶ rfl
    norm_mul' := by simp [Norm.norm, map_mul]
                    -- üéâ no goals
    norm := norm }

instance isAbsoluteValue : IsAbsoluteValue fun a : ‚Ñö_[p] ‚Ü¶ ‚Äña‚Äñ where
  abv_nonneg' := norm_nonneg
  abv_eq_zero' := norm_eq_zero
  abv_add' := norm_add_le
  abv_mul' := by simp [Norm.norm, map_mul]
                 -- üéâ no goals
#align padic.is_absolute_value Padic.isAbsoluteValue

theorem rat_dense (q : ‚Ñö_[p]) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) : ‚àÉ r : ‚Ñö, ‚Äñq - r‚Äñ < Œµ :=
  let ‚ü®Œµ', hŒµ'l, hŒµ'r‚ü© := exists_rat_btwn hŒµ
  let ‚ü®r, hr‚ü© := rat_dense' q (Œµ := Œµ') (by simpa using hŒµ'l)
                                            -- üéâ no goals
  ‚ü®r, lt_trans (by simpa [Norm.norm] using hr) hŒµ'r‚ü©
                   -- üéâ no goals
#align padic.rat_dense Padic.rat_dense

end NormedSpace

end Padic

namespace padicNormE

section NormedSpace

variable {p : ‚Ñï} [hp : Fact p.Prime]
-- Porting note : Linter thinks this is a duplicate simp lemma, so `priority` is assigned
@[simp (high)]
protected theorem mul (q r : ‚Ñö_[p]) : ‚Äñq * r‚Äñ = ‚Äñq‚Äñ * ‚Äñr‚Äñ := by simp [Norm.norm, map_mul]
                                                                -- üéâ no goals
#align padic_norm_e.mul padicNormE.mul

protected theorem is_norm (q : ‚Ñö_[p]) : ‚Üë(padicNormE q) = ‚Äñq‚Äñ := rfl
#align padic_norm_e.is_norm padicNormE.is_norm

theorem nonarchimedean (q r : ‚Ñö_[p]) : ‚Äñq + r‚Äñ ‚â§ max ‚Äñq‚Äñ ‚Äñr‚Äñ := by
  dsimp [norm]
  -- ‚ä¢ ‚Üë(‚ÜëpadicNormE (q + r)) ‚â§ max ‚Üë(‚ÜëpadicNormE q) ‚Üë(‚ÜëpadicNormE r)
  exact_mod_cast nonarchimedean' _ _
  -- üéâ no goals
#align padic_norm_e.nonarchimedean padicNormE.nonarchimedean

theorem add_eq_max_of_ne {q r : ‚Ñö_[p]} (h : ‚Äñq‚Äñ ‚â† ‚Äñr‚Äñ) : ‚Äñq + r‚Äñ = max ‚Äñq‚Äñ ‚Äñr‚Äñ := by
  dsimp [norm] at h ‚ä¢
  -- ‚ä¢ ‚Üë(‚ÜëpadicNormE (q + r)) = max ‚Üë(‚ÜëpadicNormE q) ‚Üë(‚ÜëpadicNormE r)
  have : padicNormE q ‚â† padicNormE r := by exact_mod_cast h
  -- ‚ä¢ ‚Üë(‚ÜëpadicNormE (q + r)) = max ‚Üë(‚ÜëpadicNormE q) ‚Üë(‚ÜëpadicNormE r)
  exact_mod_cast add_eq_max_of_ne' this
  -- üéâ no goals
#align padic_norm_e.add_eq_max_of_ne padicNormE.add_eq_max_of_ne

@[simp]
theorem eq_padicNorm (q : ‚Ñö) : ‚Äñ(q : ‚Ñö_[p])‚Äñ = padicNorm p q := by
  dsimp [norm]
  -- ‚ä¢ ‚Üë(‚ÜëpadicNormE ‚Üëq) = ‚Üë(padicNorm p q)
  rw [‚Üê padicNormE.eq_padic_norm']
  -- üéâ no goals
#align padic_norm_e.eq_padic_norm padicNormE.eq_padicNorm

@[simp]
theorem norm_p : ‚Äñ(p : ‚Ñö_[p])‚Äñ = (p : ‚Ñù)‚Åª¬π := by
  rw [‚Üê @Rat.cast_coe_nat ‚Ñù _ p]
  -- ‚ä¢ ‚Äñ‚Üëp‚Äñ = (‚Üë‚Üëp)‚Åª¬π
  rw [‚Üê @Rat.cast_coe_nat ‚Ñö_[p] _ p]
  -- ‚ä¢ ‚Äñ‚Üë‚Üëp‚Äñ = (‚Üë‚Üëp)‚Åª¬π
  simp [hp.1.ne_zero, hp.1.ne_one, norm, padicNorm, padicValRat, padicValInt, zpow_neg,
    -Rat.cast_coe_nat]
#align padic_norm_e.norm_p padicNormE.norm_p

theorem norm_p_lt_one : ‚Äñ(p : ‚Ñö_[p])‚Äñ < 1 := by
  rw [norm_p]
  -- ‚ä¢ (‚Üëp)‚Åª¬π < 1
  apply inv_lt_one
  -- ‚ä¢ 1 < ‚Üëp
  exact_mod_cast hp.1.one_lt
  -- üéâ no goals
#align padic_norm_e.norm_p_lt_one padicNormE.norm_p_lt_one

-- Porting note : Linter thinks this is a duplicate simp lemma, so `priority` is assigned
@[simp (high)]
theorem norm_p_zpow (n : ‚Ñ§) : ‚Äñ(p : ‚Ñö_[p]) ^ n‚Äñ = (p : ‚Ñù) ^ (-n) := by
  rw [norm_zpow, norm_p, zpow_neg, inv_zpow]
  -- üéâ no goals
#align padic_norm_e.norm_p_zpow padicNormE.norm_p_zpow

-- Porting note : Linter thinks this is a duplicate simp lemma, so `priority` is assigned
@[simp (high)]
theorem norm_p_pow (n : ‚Ñï) : ‚Äñ(p : ‚Ñö_[p]) ^ n‚Äñ = (p : ‚Ñù) ^ (-n : ‚Ñ§) := by
  rw [‚Üê norm_p_zpow, zpow_ofNat]
  -- üéâ no goals
#align padic_norm_e.norm_p_pow padicNormE.norm_p_pow

instance : NontriviallyNormedField ‚Ñö_[p] :=
  { Padic.normedField p with
    non_trivial :=
      ‚ü®p‚Åª¬π, by
        rw [norm_inv, norm_p, inv_inv]
        -- ‚ä¢ 1 < ‚Üëp
        exact_mod_cast hp.1.one_lt‚ü© }
        -- üéâ no goals

protected theorem image {q : ‚Ñö_[p]} : q ‚â† 0 ‚Üí ‚àÉ n : ‚Ñ§, ‚Äñq‚Äñ = ‚Üë((p : ‚Ñö) ^ (-n)) :=
  Quotient.inductionOn q fun f hf ‚Ü¶
    have : ¬¨f ‚âà 0 := (PadicSeq.ne_zero_iff_nequiv_zero f).1 hf
    let ‚ü®n, hn‚ü© := PadicSeq.norm_values_discrete f this
    ‚ü®n, by rw [‚Üê hn]; rfl‚ü©
           -- ‚ä¢ ‚ÄñQuotient.mk equiv f‚Äñ = ‚Üë(PadicSeq.norm f)
                      -- üéâ no goals
#align padic_norm_e.image padicNormE.image

protected theorem is_rat (q : ‚Ñö_[p]) : ‚àÉ q' : ‚Ñö, ‚Äñq‚Äñ = q' :=
  if h : q = 0 then ‚ü®0, by simp [h]‚ü©
                           -- üéâ no goals
  else
    let ‚ü®n, hn‚ü© := padicNormE.image h
    ‚ü®_, hn‚ü©
#align padic_norm_e.is_rat padicNormE.is_rat

/-- `ratNorm q`, for a `p`-adic number `q` is the `p`-adic norm of `q`, as rational number.

The lemma `padicNormE.eq_ratNorm` asserts `‚Äñq‚Äñ = ratNorm q`. -/
def ratNorm (q : ‚Ñö_[p]) : ‚Ñö :=
  Classical.choose (padicNormE.is_rat q)
#align padic_norm_e.rat_norm padicNormE.ratNorm

theorem eq_ratNorm (q : ‚Ñö_[p]) : ‚Äñq‚Äñ = ratNorm q :=
  Classical.choose_spec (padicNormE.is_rat q)
#align padic_norm_e.eq_rat_norm padicNormE.eq_ratNorm

theorem norm_rat_le_one : ‚àÄ {q : ‚Ñö} (_ : ¬¨p ‚à£ q.den), ‚Äñ(q : ‚Ñö_[p])‚Äñ ‚â§ 1
  | ‚ü®n, d, hn, hd‚ü© => fun hq : ¬¨p ‚à£ d ‚Ü¶
    if hnz : n = 0 then by
      have : (‚ü®n, d, hn, hd‚ü© : ‚Ñö) = 0 := Rat.zero_iff_num_zero.mpr hnz
      -- ‚ä¢ ‚Äñ‚Üë(Rat.mk' n d)‚Äñ ‚â§ 1
      norm_num [this]
      -- üéâ no goals
    else by
      have hnz' : (‚ü®n, d, hn, hd‚ü© : ‚Ñö) ‚â† 0 := mt Rat.zero_iff_num_zero.1 hnz
      -- ‚ä¢ ‚Äñ‚Üë(Rat.mk' n d)‚Äñ ‚â§ 1
      rw [padicNormE.eq_padicNorm]
      -- ‚ä¢ ‚Üë(padicNorm p (Rat.mk' n d)) ‚â§ 1
      norm_cast
      -- ‚ä¢ padicNorm p (Rat.mk' n d) ‚â§ 1
      -- Porting note: `Nat.cast_zero` instead of another `norm_cast` call
      rw [padicNorm.eq_zpow_of_nonzero hnz', padicValRat, neg_sub,
        padicValNat.eq_zero_of_not_dvd hq, Nat.cast_zero, zero_sub, zpow_neg, zpow_ofNat]
      apply inv_le_one
      -- ‚ä¢ 1 ‚â§ ‚Üëp ^ padicValInt p (Rat.mk' n d).num
      ¬∑ norm_cast
        -- ‚ä¢ 1 ‚â§ p ^ padicValInt p (Rat.mk' n d).num
        apply one_le_pow
        -- ‚ä¢ 0 < p
        exact hp.1.pos
        -- üéâ no goals
#align padic_norm_e.norm_rat_le_one padicNormE.norm_rat_le_one

theorem norm_int_le_one (z : ‚Ñ§) : ‚Äñ(z : ‚Ñö_[p])‚Äñ ‚â§ 1 :=
  suffices ‚Äñ((z : ‚Ñö) : ‚Ñö_[p])‚Äñ ‚â§ 1 by simpa
                                      -- üéâ no goals
                        -- üéâ no goals
  norm_rat_le_one <| by simp [hp.1.ne_one]
#align padic_norm_e.norm_int_le_one padicNormE.norm_int_le_one

theorem norm_int_lt_one_iff_dvd (k : ‚Ñ§) : ‚Äñ(k : ‚Ñö_[p])‚Äñ < 1 ‚Üî ‚Üëp ‚à£ k := by
  constructor
  -- ‚ä¢ ‚Äñ‚Üëk‚Äñ < 1 ‚Üí ‚Üëp ‚à£ k
  ¬∑ intro h
    -- ‚ä¢ ‚Üëp ‚à£ k
    contrapose! h
    -- ‚ä¢ 1 ‚â§ ‚Äñ‚Üëk‚Äñ
    apply le_of_eq
    -- ‚ä¢ 1 = ‚Äñ‚Üëk‚Äñ
    rw [eq_comm]
    -- ‚ä¢ ‚Äñ‚Üëk‚Äñ = 1
    calc
      ‚Äñ(k : ‚Ñö_[p])‚Äñ = ‚Äñ((k : ‚Ñö) : ‚Ñö_[p])‚Äñ := by norm_cast
      _ = padicNorm p k := (padicNormE.eq_padicNorm _)
      _ = 1 := by exact_mod_cast (int_eq_one_iff k).mpr h
  ¬∑ rintro ‚ü®x, rfl‚ü©
    -- ‚ä¢ ‚Äñ‚Üë(‚Üëp * x)‚Äñ < 1
    push_cast
    -- ‚ä¢ ‚Äñ‚Üëp * ‚Üëx‚Äñ < 1
    rw [padicNormE.mul]
    -- ‚ä¢ ‚Äñ‚Üëp‚Äñ * ‚Äñ‚Üëx‚Äñ < 1
    calc
      _ ‚â§ ‚Äñ(p : ‚Ñö_[p])‚Äñ * 1 :=
        mul_le_mul le_rfl (by simpa using norm_int_le_one _) (norm_nonneg _) (norm_nonneg _)
      _ < 1 := by
        rw [mul_one, padicNormE.norm_p]
        apply inv_lt_one
        exact_mod_cast hp.1.one_lt
#align padic_norm_e.norm_int_lt_one_iff_dvd padicNormE.norm_int_lt_one_iff_dvd

theorem norm_int_le_pow_iff_dvd (k : ‚Ñ§) (n : ‚Ñï) :
    ‚Äñ(k : ‚Ñö_[p])‚Äñ ‚â§ (p : ‚Ñù) ^ (-n : ‚Ñ§) ‚Üî (p ^ n : ‚Ñ§) ‚à£ k := by
  have : (p : ‚Ñù) ^ (-n : ‚Ñ§) = (p : ‚Ñö) ^ (-n : ‚Ñ§) := by simp
  -- ‚ä¢ ‚Äñ‚Üëk‚Äñ ‚â§ ‚Üëp ^ (-‚Üën) ‚Üî ‚Üë(p ^ n) ‚à£ k
  rw [show (k : ‚Ñö_[p]) = ((k : ‚Ñö) : ‚Ñö_[p]) by norm_cast, eq_padicNorm, this]
  -- ‚ä¢ ‚Üë(padicNorm p ‚Üëk) ‚â§ ‚Üë(‚Üëp ^ (-‚Üën)) ‚Üî ‚Üë(p ^ n) ‚à£ k
  norm_cast
  -- ‚ä¢ padicNorm p ‚Üëk ‚â§ ‚Üëp ^ (-‚Üën) ‚Üî ‚Üë(p ^ n) ‚à£ k
  rw [‚Üê padicNorm.dvd_iff_norm_le]
  -- üéâ no goals
#align padic_norm_e.norm_int_le_pow_iff_dvd padicNormE.norm_int_le_pow_iff_dvd

theorem eq_of_norm_add_lt_right {z1 z2 : ‚Ñö_[p]} (h : ‚Äñz1 + z2‚Äñ < ‚Äñz2‚Äñ) : ‚Äñz1‚Äñ = ‚Äñz2‚Äñ :=
  _root_.by_contradiction fun hne ‚Ü¶
    not_lt_of_ge (by rw [padicNormE.add_eq_max_of_ne hne]; apply le_max_right) h
                     -- ‚ä¢ max ‚Äñz1‚Äñ ‚Äñz2‚Äñ ‚â• ‚Äñz2‚Äñ
                                                           -- üéâ no goals
#align padic_norm_e.eq_of_norm_add_lt_right padicNormE.eq_of_norm_add_lt_right

theorem eq_of_norm_add_lt_left {z1 z2 : ‚Ñö_[p]} (h : ‚Äñz1 + z2‚Äñ < ‚Äñz1‚Äñ) : ‚Äñz1‚Äñ = ‚Äñz2‚Äñ :=
  _root_.by_contradiction fun hne ‚Ü¶
    not_lt_of_ge (by rw [padicNormE.add_eq_max_of_ne hne]; apply le_max_left) h
                     -- ‚ä¢ max ‚Äñz1‚Äñ ‚Äñz2‚Äñ ‚â• ‚Äñz1‚Äñ
                                                           -- üéâ no goals
#align padic_norm_e.eq_of_norm_add_lt_left padicNormE.eq_of_norm_add_lt_left

end NormedSpace

end padicNormE

namespace Padic

variable {p : ‚Ñï} [hp : Fact p.Prime]

-- Porting note : remove `set_option eqn_compiler.zeta true`

instance complete : CauSeq.IsComplete ‚Ñö_[p] norm where
  isComplete := fun f => by
    have cau_seq_norm_e : IsCauSeq padicNormE f := fun Œµ hŒµ => by
      have h := isCauSeq f Œµ (by exact_mod_cast hŒµ)
      dsimp [norm] at h
      exact_mod_cast h
    -- Porting note: Padic.complete' works with `f i - q`, but the goal needs `q - f i`,
    -- using `rewrite [padicNormE.map_sub]` causes time out, so a separate lemma is created
    cases' Padic.complete'' ‚ü®f, cau_seq_norm_e‚ü© with q hq
    -- ‚ä¢ ‚àÉ b, f ‚âà const norm b
    exists q
    -- ‚ä¢ f ‚âà const norm q
    intro Œµ hŒµ
    -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí ‚Äñ‚Üë(f - const norm q) j‚Äñ < Œµ
    cases' exists_rat_btwn hŒµ with Œµ' hŒµ'
    -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí ‚Äñ‚Üë(f - const norm q) j‚Äñ < Œµ
    norm_cast at hŒµ'
    -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí ‚Äñ‚Üë(f - const norm q) j‚Äñ < Œµ
    cases' hq Œµ' hŒµ'.1 with N hN
    -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí ‚Äñ‚Üë(f - const norm q) j‚Äñ < Œµ
    exists N
    -- ‚ä¢ ‚àÄ (j : ‚Ñï), j ‚â• N ‚Üí ‚Äñ‚Üë(f - const norm q) j‚Äñ < Œµ
    intro i hi
    -- ‚ä¢ ‚Äñ‚Üë(f - const norm q) i‚Äñ < Œµ
    have h := hN i hi
    -- ‚ä¢ ‚Äñ‚Üë(f - const norm q) i‚Äñ < Œµ
    change norm (f i - q) < Œµ
    -- ‚ä¢ ‚Äñ‚Üëf i - q‚Äñ < Œµ
    refine lt_trans ?_ hŒµ'.2
    -- ‚ä¢ ‚Äñ‚Üëf i - q‚Äñ < ‚ÜëŒµ'
    dsimp [norm]
    -- ‚ä¢ ‚Üë(‚ÜëpadicNormE (‚Üëf i - q)) < ‚ÜëŒµ'
    exact_mod_cast h
    -- üéâ no goals
#align padic.complete Padic.complete

theorem padicNormE_lim_le {f : CauSeq ‚Ñö_[p] norm} {a : ‚Ñù} (ha : 0 < a) (hf : ‚àÄ i, ‚Äñf i‚Äñ ‚â§ a) :
    ‚Äñf.lim‚Äñ ‚â§ a := by
  -- Porting note: `Setoid.symm` cannot work out which `Setoid` to use, so instead swap the order
  -- now, I use a rewrite to swap it later
  obtain ‚ü®N, hN‚ü© := (CauSeq.equiv_lim f) _ ha
  -- ‚ä¢ ‚ÄñCauSeq.lim f‚Äñ ‚â§ a
  rw [‚Üêsub_add_cancel f.lim (f N)]
  -- ‚ä¢ ‚ÄñCauSeq.lim f - ‚Üëf N + ‚Üëf N‚Äñ ‚â§ a
  refine le_trans (padicNormE.nonarchimedean _ _) ?_
  -- ‚ä¢ max ‚ÄñCauSeq.lim f - ‚Üëf N‚Äñ ‚Äñ‚Üëf N‚Äñ ‚â§ a
  rw [norm_sub_rev]
  -- ‚ä¢ max ‚Äñ‚Üëf N - CauSeq.lim f‚Äñ ‚Äñ‚Üëf N‚Äñ ‚â§ a
  exact max_le (le_of_lt (hN _ le_rfl)) (hf _)
  -- üéâ no goals
  -- Porting note: the following nice `calc` block does not work
  -- exact calc
  --   ‚Äñf.lim‚Äñ = ‚Äñf.lim - f N + f N‚Äñ := sorry
  --   ‚Äñf.lim - f N + f N‚Äñ ‚â§ max ‚Äñf.lim - f N‚Äñ ‚Äñf N‚Äñ := sorry -- (padicNormE.nonarchimedean _ _)
  --   max ‚Äñf.lim - f N‚Äñ ‚Äñf N‚Äñ = max ‚Äñf N - f.lim‚Äñ ‚Äñf N‚Äñ := sorry -- by congr; rw [norm_sub_rev]
  --   max ‚Äñf N - f.lim‚Äñ ‚Äñf N‚Äñ ‚â§ a := sorry -- max_le (le_of_lt (hN _ le_rfl)) (hf _)
#align padic.padic_norm_e_lim_le Padic.padicNormE_lim_le

open Filter Set

instance : CompleteSpace ‚Ñö_[p] := by
  apply complete_of_cauchySeq_tendsto
  -- ‚ä¢ ‚àÄ (u : ‚Ñï ‚Üí ‚Ñö_[p]), CauchySeq u ‚Üí ‚àÉ a, Tendsto u atTop (nhds a)
  intro u hu
  -- ‚ä¢ ‚àÉ a, Tendsto u atTop (nhds a)
  let c : CauSeq ‚Ñö_[p] norm := ‚ü®u, Metric.cauchySeq_iff'.mp hu‚ü©
  -- ‚ä¢ ‚àÉ a, Tendsto u atTop (nhds a)
  refine' ‚ü®c.lim, fun s h ‚Ü¶ _‚ü©
  -- ‚ä¢ s ‚àà map u atTop
  rcases Metric.mem_nhds_iff.1 h with ‚ü®Œµ, Œµ0, hŒµ‚ü©
  -- ‚ä¢ s ‚àà map u atTop
  have := c.equiv_lim Œµ Œµ0
  -- ‚ä¢ s ‚àà map u atTop
  simp only [mem_map, mem_atTop_sets, mem_setOf_eq]
  -- ‚ä¢ ‚àÉ a, ‚àÄ (b : ‚Ñï), b ‚â• a ‚Üí b ‚àà u ‚Åª¬π' s
  exact this.imp fun N hN n hn ‚Ü¶ hŒµ (hN n hn)
  -- üéâ no goals

/-! ### Valuation on `‚Ñö_[p]` -/


/-- `Padic.valuation` lifts the `p`-adic valuation on rationals to `‚Ñö_[p]`. -/
def valuation : ‚Ñö_[p] ‚Üí ‚Ñ§ :=
  Quotient.lift (@PadicSeq.valuation p _) fun f g h ‚Ü¶ by
    by_cases hf : f ‚âà 0
    -- ‚ä¢ PadicSeq.valuation f = PadicSeq.valuation g
    ¬∑ have hg : g ‚âà 0 := Setoid.trans (Setoid.symm h) hf
      -- ‚ä¢ PadicSeq.valuation f = PadicSeq.valuation g
      simp [hf, hg, PadicSeq.valuation]
      -- üéâ no goals
    ¬∑ have hg : ¬¨g ‚âà 0 := fun hg ‚Ü¶ hf (Setoid.trans h hg)
      -- ‚ä¢ PadicSeq.valuation f = PadicSeq.valuation g
      rw [PadicSeq.val_eq_iff_norm_eq hf hg]
      -- ‚ä¢ PadicSeq.norm f = PadicSeq.norm g
      exact PadicSeq.norm_equiv h
      -- üéâ no goals
#align padic.valuation Padic.valuation

@[simp]
theorem valuation_zero : valuation (0 : ‚Ñö_[p]) = 0 :=
  dif_pos ((const_equiv p).2 rfl)
#align padic.valuation_zero Padic.valuation_zero

@[simp]
theorem valuation_one : valuation (1 : ‚Ñö_[p]) = 0 := by
  change dite (CauSeq.const (padicNorm p) 1 ‚âà _) _ _ = _
  -- ‚ä¢ (if h : const (padicNorm p) 1 ‚âà 0 then (fun hf => 0) h else (fun hf => padic ‚Ä¶
  have h : ¬¨CauSeq.const (padicNorm p) 1 ‚âà 0 := by
    intro H
    erw [const_equiv p] at H
    exact one_ne_zero H
  rw [dif_neg h]
  -- ‚ä¢ (fun hf => padicValRat p (‚Üë(const (padicNorm p) 1) (PadicSeq.stationaryPoint ‚Ä¶
  simp
  -- üéâ no goals
#align padic.valuation_one Padic.valuation_one

theorem norm_eq_pow_val {x : ‚Ñö_[p]} : x ‚â† 0 ‚Üí ‚Äñx‚Äñ = (p : ‚Ñù) ^ (-x.valuation) := by
  refine Quotient.inductionOn' x fun f hf => ?_
  -- ‚ä¢ ‚ÄñQuotient.mk'' f‚Äñ = ‚Üëp ^ (-valuation (Quotient.mk'' f))
  change (PadicSeq.norm _ : ‚Ñù) = (p : ‚Ñù) ^ (-PadicSeq.valuation _)
  -- ‚ä¢ ‚Üë(PadicSeq.norm f) = ‚Üëp ^ (-PadicSeq.valuation f)
  rw [PadicSeq.norm_eq_pow_val]
  -- ‚ä¢ ‚Üë(‚Üëp ^ (-PadicSeq.valuation f)) = ‚Üëp ^ (-PadicSeq.valuation f)
  change ‚Üë((p : ‚Ñö) ^ (-PadicSeq.valuation f)) = (p : ‚Ñù) ^ (-PadicSeq.valuation f)
  -- ‚ä¢ ‚Üë(‚Üëp ^ (-PadicSeq.valuation f)) = ‚Üëp ^ (-PadicSeq.valuation f)
  ¬∑ rw [Rat.cast_zpow, Rat.cast_coe_nat]
    -- üéâ no goals
  ¬∑ apply CauSeq.not_limZero_of_not_congr_zero
    -- ‚ä¢ ¬¨f - 0 ‚âà 0
    -- Porting note: was `contrapose! hf`
    intro hf'
    -- ‚ä¢ False
    apply hf
    -- ‚ä¢ Quotient.mk'' f = 0
    apply Quotient.sound
    -- ‚ä¢ f ‚âà const (padicNorm p) 0
    simpa using hf'
    -- üéâ no goals
#align padic.norm_eq_pow_val Padic.norm_eq_pow_val

@[simp]
theorem valuation_p : valuation (p : ‚Ñö_[p]) = 1 := by
  have h : (1 : ‚Ñù) < p := by exact_mod_cast (Fact.out : p.Prime).one_lt
  -- ‚ä¢ valuation ‚Üëp = 1
  refine' neg_injective ((zpow_strictMono h).injective <| (norm_eq_pow_val _).symm.trans _)
  -- ‚ä¢ ‚Üëp ‚â† 0
  ¬∑ exact_mod_cast (Fact.out : p.Prime).ne_zero
    -- üéâ no goals
  ¬∑ simp
    -- üéâ no goals
#align padic.valuation_p Padic.valuation_p

theorem valuation_map_add {x y : ‚Ñö_[p]} (hxy : x + y ‚â† 0) :
    min (valuation x) (valuation y) ‚â§ valuation (x + y : ‚Ñö_[p]) := by
  by_cases hx : x = 0
  -- ‚ä¢ min (valuation x) (valuation y) ‚â§ valuation (x + y)
  ¬∑ rw [hx, zero_add]
    -- ‚ä¢ min (valuation 0) (valuation y) ‚â§ valuation y
    exact min_le_right _ _
    -- üéâ no goals
  ¬∑ by_cases hy : y = 0
    -- ‚ä¢ min (valuation x) (valuation y) ‚â§ valuation (x + y)
    ¬∑ rw [hy, add_zero]
      -- ‚ä¢ min (valuation x) (valuation 0) ‚â§ valuation x
      exact min_le_left _ _
      -- üéâ no goals
    ¬∑ have h_norm : ‚Äñx + y‚Äñ ‚â§ max ‚Äñx‚Äñ ‚Äñy‚Äñ := padicNormE.nonarchimedean x y
      -- ‚ä¢ min (valuation x) (valuation y) ‚â§ valuation (x + y)
      have hp_one : (1 : ‚Ñù) < p := by
        rw [‚Üê Nat.cast_one, Nat.cast_lt]
        exact Nat.Prime.one_lt hp.elim
      rwa [norm_eq_pow_val hx, norm_eq_pow_val hy, norm_eq_pow_val hxy,
        zpow_le_max_iff_min_le hp_one] at h_norm
#align padic.valuation_map_add Padic.valuation_map_add

@[simp]
theorem valuation_map_mul {x y : ‚Ñö_[p]} (hx : x ‚â† 0) (hy : y ‚â† 0) :
    valuation (x * y : ‚Ñö_[p]) = valuation x + valuation y := by
  have h_norm : ‚Äñx * y‚Äñ = ‚Äñx‚Äñ * ‚Äñy‚Äñ := norm_mul x y
  -- ‚ä¢ valuation (x * y) = valuation x + valuation y
  have hp_ne_one : (p : ‚Ñù) ‚â† 1 := by
    rw [‚Üê Nat.cast_one, Ne.def, Nat.cast_inj]
    exact Nat.Prime.ne_one hp.elim
  have hp_pos : (0 : ‚Ñù) < p := by
    rw [‚Üê Nat.cast_zero, Nat.cast_lt]
    exact Nat.Prime.pos hp.elim
  rw [norm_eq_pow_val hx, norm_eq_pow_val hy, norm_eq_pow_val (mul_ne_zero hx hy), ‚Üê
    zpow_add‚ÇÄ (ne_of_gt hp_pos), zpow_inj hp_pos hp_ne_one, ‚Üê neg_add, neg_inj] at h_norm
  exact h_norm
  -- üéâ no goals
#align padic.valuation_map_mul Padic.valuation_map_mul

/-- The additive `p`-adic valuation on `‚Ñö_[p]`, with values in `WithTop ‚Ñ§`. -/
def addValuationDef : ‚Ñö_[p] ‚Üí WithTop ‚Ñ§ :=
  fun x ‚Ü¶ if x = 0 then ‚ä§ else x.valuation
#align padic.add_valuation_def Padic.addValuationDef

@[simp]
theorem AddValuation.map_zero : addValuationDef (0 : ‚Ñö_[p]) = ‚ä§ := by
  rw [addValuationDef, if_pos (Eq.refl _)]
  -- üéâ no goals
#align padic.add_valuation.map_zero Padic.AddValuation.map_zero

@[simp]
theorem AddValuation.map_one : addValuationDef (1 : ‚Ñö_[p]) = 0 := by
  rw [addValuationDef, if_neg one_ne_zero, valuation_one, WithTop.coe_zero]
  -- üéâ no goals
#align padic.add_valuation.map_one Padic.AddValuation.map_one

theorem AddValuation.map_mul (x y : ‚Ñö_[p]) :
    addValuationDef (x * y : ‚Ñö_[p]) = addValuationDef x + addValuationDef y := by
  simp only [addValuationDef]
  -- ‚ä¢ (if x * y = 0 then ‚ä§ else ‚Üë(valuation (x * y))) = (if x = 0 then ‚ä§ else ‚Üë(va ‚Ä¶
  by_cases hx : x = 0
  -- ‚ä¢ (if x * y = 0 then ‚ä§ else ‚Üë(valuation (x * y))) = (if x = 0 then ‚ä§ else ‚Üë(va ‚Ä¶
  ¬∑ rw [hx, if_pos (Eq.refl _), zero_mul, if_pos (Eq.refl _), WithTop.top_add]
    -- üéâ no goals
  ¬∑ by_cases hy : y = 0
    -- ‚ä¢ (if x * y = 0 then ‚ä§ else ‚Üë(valuation (x * y))) = (if x = 0 then ‚ä§ else ‚Üë(va ‚Ä¶
    ¬∑ rw [hy, if_pos (Eq.refl _), mul_zero, if_pos (Eq.refl _), WithTop.add_top]
      -- üéâ no goals
    ¬∑ rw [if_neg hx, if_neg hy, if_neg (mul_ne_zero hx hy), ‚Üê WithTop.coe_add, WithTop.coe_eq_coe,
        valuation_map_mul hx hy]
#align padic.add_valuation.map_mul Padic.AddValuation.map_mul

theorem AddValuation.map_add (x y : ‚Ñö_[p]) :
    min (addValuationDef x) (addValuationDef y) ‚â§ addValuationDef (x + y : ‚Ñö_[p]) := by
  simp only [addValuationDef]
  -- ‚ä¢ min (if x = 0 then ‚ä§ else ‚Üë(valuation x)) (if y = 0 then ‚ä§ else ‚Üë(valuation  ‚Ä¶
  by_cases hxy : x + y = 0
  -- ‚ä¢ min (if x = 0 then ‚ä§ else ‚Üë(valuation x)) (if y = 0 then ‚ä§ else ‚Üë(valuation  ‚Ä¶
  ¬∑ rw [hxy, if_pos (Eq.refl _)]
    -- ‚ä¢ min (if x = 0 then ‚ä§ else ‚Üë(valuation x)) (if y = 0 then ‚ä§ else ‚Üë(valuation  ‚Ä¶
    exact le_top
    -- üéâ no goals
  ¬∑ by_cases hx : x = 0
    -- ‚ä¢ min (if x = 0 then ‚ä§ else ‚Üë(valuation x)) (if y = 0 then ‚ä§ else ‚Üë(valuation  ‚Ä¶
    ¬∑ rw [hx, if_pos (Eq.refl _), min_eq_right, zero_add]
      -- ‚ä¢ (if y = 0 then ‚ä§ else ‚Üë(valuation y)) ‚â§ ‚ä§
      exact le_top
      -- üéâ no goals
    ¬∑ by_cases hy : y = 0
      -- ‚ä¢ min (if x = 0 then ‚ä§ else ‚Üë(valuation x)) (if y = 0 then ‚ä§ else ‚Üë(valuation  ‚Ä¶
      ¬∑ rw [hy, if_pos (Eq.refl _), min_eq_left, add_zero]
        -- ‚ä¢ (if x = 0 then ‚ä§ else ‚Üë(valuation x)) ‚â§ ‚ä§
        exact le_top
        -- üéâ no goals
      ¬∑ rw [if_neg hx, if_neg hy, if_neg hxy, ‚Üê WithTop.coe_min, WithTop.coe_le_coe]
        -- ‚ä¢ min (valuation x) (valuation y) ‚â§ valuation (x + y)
        exact valuation_map_add hxy
        -- üéâ no goals
#align padic.add_valuation.map_add Padic.AddValuation.map_add

/-- The additive `p`-adic valuation on `‚Ñö_[p]`, as an `addValuation`. -/
def addValuation : AddValuation ‚Ñö_[p] (WithTop ‚Ñ§) :=
  AddValuation.of addValuationDef AddValuation.map_zero AddValuation.map_one AddValuation.map_add
    AddValuation.map_mul
#align padic.add_valuation Padic.addValuation

@[simp]
theorem addValuation.apply {x : ‚Ñö_[p]} (hx : x ‚â† 0) :
    Padic.addValuation x = (x.valuation : WithTop ‚Ñ§) := by
  simp only [Padic.addValuation, AddValuation.of_apply, addValuationDef, if_neg hx]
  -- üéâ no goals
#align padic.add_valuation.apply Padic.addValuation.apply

section NormLEIff

/-! ### Various characterizations of open unit balls -/


theorem norm_le_pow_iff_norm_lt_pow_add_one (x : ‚Ñö_[p]) (n : ‚Ñ§) :
    ‚Äñx‚Äñ ‚â§ (p : ‚Ñù) ^ n ‚Üî ‚Äñx‚Äñ < (p : ‚Ñù) ^ (n + 1) := by
  have aux : ‚àÄ n : ‚Ñ§, 0 < ((p : ‚Ñù) ^ n) := by
    apply Nat.zpow_pos_of_pos
    exact hp.1.pos
  by_cases hx0 : x = 0
  -- ‚ä¢ ‚Äñx‚Äñ ‚â§ ‚Üëp ^ n ‚Üî ‚Äñx‚Äñ < ‚Üëp ^ (n + 1)
  ¬∑ simp [hx0, norm_zero, aux, le_of_lt (aux _)]
    -- üéâ no goals
  rw [norm_eq_pow_val hx0]
  -- ‚ä¢ ‚Üëp ^ (-valuation x) ‚â§ ‚Üëp ^ n ‚Üî ‚Üëp ^ (-valuation x) < ‚Üëp ^ (n + 1)
  have h1p : 1 < (p : ‚Ñù) := by exact_mod_cast hp.1.one_lt
  -- ‚ä¢ ‚Üëp ^ (-valuation x) ‚â§ ‚Üëp ^ n ‚Üî ‚Üëp ^ (-valuation x) < ‚Üëp ^ (n + 1)
  have H := zpow_strictMono h1p
  -- ‚ä¢ ‚Üëp ^ (-valuation x) ‚â§ ‚Üëp ^ n ‚Üî ‚Üëp ^ (-valuation x) < ‚Üëp ^ (n + 1)
  rw [H.le_iff_le, H.lt_iff_lt, Int.lt_add_one_iff]
  -- üéâ no goals
#align padic.norm_le_pow_iff_norm_lt_pow_add_one Padic.norm_le_pow_iff_norm_lt_pow_add_one

theorem norm_lt_pow_iff_norm_le_pow_sub_one (x : ‚Ñö_[p]) (n : ‚Ñ§) :
    ‚Äñx‚Äñ < (p : ‚Ñù) ^ n ‚Üî ‚Äñx‚Äñ ‚â§ (p : ‚Ñù) ^ (n - 1) := by
  rw [norm_le_pow_iff_norm_lt_pow_add_one, sub_add_cancel]
  -- üéâ no goals
#align padic.norm_lt_pow_iff_norm_le_pow_sub_one Padic.norm_lt_pow_iff_norm_le_pow_sub_one

theorem norm_le_one_iff_val_nonneg (x : ‚Ñö_[p]) : ‚Äñx‚Äñ ‚â§ 1 ‚Üî 0 ‚â§ x.valuation := by
  by_cases hx : x = 0
  -- ‚ä¢ ‚Äñx‚Äñ ‚â§ 1 ‚Üî 0 ‚â§ valuation x
  ¬∑ simp only [hx, norm_zero, valuation_zero, zero_le_one, le_refl]
    -- üéâ no goals
  ¬∑ rw [norm_eq_pow_val hx, ‚Üê zpow_zero (p : ‚Ñù), zpow_le_iff_le, Right.neg_nonpos_iff]
    -- ‚ä¢ 1 < ‚Üëp
    exact Nat.one_lt_cast.2 (Nat.Prime.one_lt' p).1
    -- üéâ no goals
#align padic.norm_le_one_iff_val_nonneg Padic.norm_le_one_iff_val_nonneg

end NormLEIff

end Padic
