/-
Copyright (c) 2025 Hanliu Jiang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Shanwen Wang, Hanliu Jiang
-/
import Mathlib.NumberTheory.Padics.PSAC

set_option maxHeartbeats 10000000000000
set_option synthInstance.maxHeartbeats 10000000000000


open Finset IsUltrametricDist NNReal Filter  CauSeq  zero_atBot
open scoped fwdDiff ZeroAtInfty Topology  LaurentSeries PowerSeries
variable {p : ‚Ñï} [hp : Fact p.Prime]

namespace PadicInt
lemma Tends_to_Zero'(f:(AdicCompletion (Ideal.span {(p:‚Ñ§_[p]‚∏®X‚∏©)}) (‚Ñ§_[p]‚∏®X‚∏©)))
:Tendsto (fun n ‚Ü¶ (p_sequence_coeff (p:=p) n) f) atBot (ùìù 0):=by
  have:=by
   exact AdicCompletion.mk_surjective (Ideal.span {(p:‚Ñ§_[p]‚∏®X‚∏©)}) ‚Ñ§_[p]‚∏®X‚∏©
  unfold Function.Surjective at this
  rcases (this f) with ‚ü®r,rs‚ü©
  have :(fun n ‚Ü¶  p_sequence_coeff (p:=p) n f)=
    (fun n  ‚Ü¶  cauchy_sequence_coeff (p:=p) n r) :=by
      ext n
      rw[esg n f r rs]
  rw[this]
  exact cauchy_sequence_coeff_tends_to_zero' r
lemma Tends_to_Zero_0(f:(AdicCompletion (Ideal.span {(p:‚Ñ§_[p]‚∏®X‚∏©)}) (‚Ñ§_[p]‚∏®X‚∏©)))
:Tendsto (fun n:‚Ñï ‚Ü¶  p_sequence_coeff (p:=p) (-n:‚Ñ§ ) f) atTop
(ùìù 0):=by
 have:=Tends_to_Zero' f
 rw[NormedAddCommGroup.tendsto_atBot] at this
 refine NormedAddCommGroup.tendsto_atTop.mpr ?_
 intro s rs
 choose m sm using (this s rs)
 use (-m).natAbs
 intro e de
 have: m ‚â•  (-‚Üëe):=by
   simp
   have:-(e:‚Ñ§) ‚â§ -‚Üë(-m).natAbs :=by
     simp only [ neg_le_neg_iff, sup_le_iff, Nat.cast_nonneg, and_true]
     exact Int.ofNat_le.mpr de
   have: -‚Üë(-m).natAbs ‚â§ m :=by
     simp
     exact neg_abs_le m
   (expose_names; exact Int.le_trans this_2 this)
 exact (sm (-(e:‚Ñ§)) this)
lemma Tends_to_Zero_1(f:(AdicCompletion (Ideal.span {(p:‚Ñ§_[p]‚∏®X‚∏©)}) (‚Ñ§_[p]‚∏®X‚∏©)))
:Tendsto (fun n:‚Ñï ‚Ü¶  p_sequence_coeff (p:=p) (-(n+1):‚Ñ§ ) f) atTop
(ùìù 0):=by
  have:=Tends_to_Zero_0  (p:=p) f
  rw[NormedAddCommGroup.tendsto_atTop] at this
  refine NormedAddCommGroup.tendsto_atTop.mpr ?_
  intro h sh
  simp only [sub_zero]
  choose e se using (this h sh)
  use e
  intro r sf
  have:=se (r+1) (Nat.le_add_right_of_le sf)
  simp only [sub_zero] at this
  exact this
lemma Tends_to_Zero(a:(AdicCompletion (Ideal.span {(p:‚Ñ§_[p]‚∏®X‚∏©)}) (‚Ñ§_[p]‚∏®X‚∏©)))
:Tendsto (fun n:‚Ñï ‚Ü¶  (p_sequence_coeff (p:=p) (-(n+1):‚Ñ§ ) a
-p_sequence_coeff (p:=p) (-(n+2):‚Ñ§ ) a)) atTop
(ùìù 0):=by
  have:=Tends_to_Zero_0  (p:=p) a
  rw[NormedAddCommGroup.tendsto_atTop] at this
  refine NormedAddCommGroup.tendsto_atTop.mpr ?_
  intro h sh
  simp only [sub_zero]
  choose e se using (this h sh)
  use e
  intro r sf
  rw[sub_eq_add_neg]
  have  := nonarchimedean ((p_sequence_coeff (p:=p) (-‚Üë(r+ 1))) a)  (-(p_sequence_coeff
  (p:=p) (-‚Üë(r+ 2))) a)
  have m : ‚Äñ(p_sequence_coeff (p:=p) (-‚Üë(r+ 1))) a‚Äñ ‚äî ‚Äñ-(p_sequence_coeff
  (p:=p) (-‚Üë(r+ 2))) a‚Äñ <h :=by
    refine max_lt ?_ ?_
    ¬∑ have:=se (r+1) (Nat.le_add_right_of_le sf)
      simp only [sub_zero] at this
      exact this
    ¬∑ have:=se (r+2) (Nat.le_add_right_of_le sf)
      simp only [sub_zero] at this
      simp only [norm_neg]
      exact this
  exact lt_of_le_of_lt this m

noncomputable def FunctionTrans_2: (AdicCompletion (Ideal.span {(p:‚Ñ§_[p]‚∏®X‚∏©)})
 (‚Ñ§_[p]‚∏®X‚∏©)) ‚Üí‚Çó[‚Ñ§_[p]]
 C‚ÇÄ(‚Ñï, ‚Ñ§_[p]) where
   toFun a :=‚ü®‚ü®(fun n:‚Ñï => p_sequence_coeff (p:=p) (-((n+1):‚Ñï ):‚Ñ§ ) a-
   p_sequence_coeff (p:=p) (-((n+2):‚Ñï ):‚Ñ§ ) a)
    ,continuous_of_discreteTopology‚ü©, cocompact_eq_atTop (Œ± := ‚Ñï) ‚ñ∏ Tends_to_Zero a‚ü©
   map_add'  a b:=by
     ext n
     simp
     ring
   map_smul' a b:=by
     ext s
     simp
     ring

noncomputable def asd (a:C_‚ÇÄ(‚Ñ§,‚Ñ§_[p]))(t:‚Ñï): BddBelow (Function.support
 (fun (n : ‚Ñ§) => if ‚Äña n‚Äñ‚â§(p:‚Ñù)^(-t:‚Ñ§) then 0 else (a n))) :=by

  have e:= zero_atBot a
  rw[NormedAddCommGroup.tendsto_atBot] at e
  have:(p:‚Ñù )^(-t:‚Ñ§) >0 :=by
    simp
    refine pow_pos ?_ t
    simp
    exact Nat.pos_of_neZero p
  have:=e ((p:‚Ñù )^(-t:‚Ñ§)) this
  choose m fs using this
  refine HahnSeries.forallLTEqZero_supp_BddBelow _  m ?_
  intro s js
  have:‚Äña s‚Äñ‚â§(p:‚Ñù)^(-t:‚Ñ§) :=by
    refine le_of_lt ?_
    have:=fs s (Int.le_of_lt js)
    simp only [sub_zero] at this
    exact this
  exact if_pos this

noncomputable def Adic_Complection_tofun : C_‚ÇÄ(‚Ñ§,‚Ñ§_[p]) ‚Üí
 (AdicCompletion.AdicCauchySequence (Ideal.span {(p:‚Ñ§_[p]‚∏®X‚∏©)})
 (‚Ñ§_[p]‚∏®X‚∏©)) :=fun
   | a => {
     val t :=HahnSeries.ofSuppBddBelow (fun (n : ‚Ñ§) => if ‚Äña n‚Äñ‚â§(p:‚Ñù)^(-t:‚Ñ§) then 0 else (a n))
       (asd a t)
     property :=by
       intro m n  sn
       simp only
       refine powerseries_equiv_2 m _ _ ?_
       intro s
       unfold HahnSeries.coeff_map_0
       simp only [LinearMap.coe_mk, AddHom.coe_mk,
         HahnSeries.ofSuppBddBelow_coeff]
       rcases Decidable.em (‚Äña s‚Äñ ‚â§ (p:‚Ñù)^(-m:‚Ñ§)) with r1|r2
       ¬∑ rcases Decidable.em (‚Äña s‚Äñ ‚â§ (p:‚Ñù)^(-n:‚Ñ§)) with r3|r4
         ¬∑ simp only [r1, r3]
           simp
         ¬∑ simp only[r1 ,r4]
           simp only [‚ÜìreduceIte, zero_sub, neg_mem_iff,
           Ideal.span_singleton_pow]
           rw[norm_le_pow_iff_mem_span_pow] at r1
           exact r1
       ¬∑ rcases Decidable.em (‚Äña s‚Äñ ‚â§ (p:‚Ñù)^(-n:‚Ñ§)) with r3|r4
         ¬∑ simp only[r2,r3]
           simp
           rw[norm_le_pow_iff_mem_span_pow,‚Üê Ideal.span_singleton_pow] at r3
           exact (Ideal.pow_le_pow_right sn) r3
         ¬∑ simp only[r2,r4]
           simp





   }


lemma help1 (r:
 AdicCompletion.AdicCauchySequence (Ideal.span {(p:‚Ñ§_[p]‚∏®X‚∏©)}) ‚Ñ§_[p]‚∏®X‚∏©)(s:‚Ñ§):
 IsCauSeq norm ( fun n ‚Ü¶ (r n).coeff s ) :=by
    have: ( fun n ‚Ü¶ (r n).coeff s ) =
     Cauchy_p_adic  (((AdicCompletion.mapAlg (IsLocalRing.maximalIdeal ‚Ñ§_[p])
    (Ideal.span {(p:‚Ñ§_[p]‚∏®X‚∏©)}) (HahnSeries.coeff_map_0 (p:=p) s) (CauchyHanser s))) r):=by
      unfold  HahnSeries.coeff_map_0 Cauchy_p_adic
      ext n
      simp
      rfl
    rw[this]
    rcases (Cauchy_p_adic (((AdicCompletion.mapAlg (IsLocalRing.maximalIdeal ‚Ñ§_[p])
    (Ideal.span {(p:‚Ñ§_[p]‚∏®X‚∏©)}) (HahnSeries.coeff_map_0 (p:=p) s) (CauchyHanser s))) r))
     with ‚ü®l1,l2‚ü©
    simp
    exact l2

lemma help2 (r:
 AdicCompletion.AdicCauchySequence (Ideal.span {(p:‚Ñ§_[p]‚∏®X‚∏©)}) ‚Ñ§_[p]‚∏®X‚∏©):
‚àÄ Œµ >0 , ‚àÉ N ,‚àÄ n‚â• N ,‚àÄ  (s:‚Ñ§),‚Äñ(r n).coeff s-
 CauSeq.lim ‚ü®fun n ‚Ü¶ (r n).coeff s, help1 r s‚ü©‚Äñ <  Œµ  :=by
  intro Œµ hŒµ
  obtain ‚ü®m, hm‚ü© := exists_pow_neg_lt p hŒµ
  use m
  intro s hs s_1
  have: (r s).coeff s_1-
   CauSeq.lim ‚ü®fun n ‚Ü¶ (r n).coeff s_1, help1 r s_1‚ü©=
   CauSeq.lim (const norm ((r s).coeff s_1)-‚ü® fun n ‚Ü¶ (r n).coeff s_1, help1 r s_1‚ü©) :=by
     nth_rw  2 [‚Üê Mathlib.Tactic.RingNF.add_neg]
     rw[‚Üê lim_add,lim_neg,lim_const ]
     ring
  rw[this]
  refine  lt_of_le_of_lt ?_ hm
  refine CauchyL _ _ ?_
  use m
  intro g3 sr3
  simp only [sub_apply, const_apply]
  have:=powerseries_equiv (p:=p)  m s_1
  unfold HahnSeries.coeff_map_0 at this
  simp at this
  rw[norm_le_pow_iff_mem_span_pow,‚ÜêIdeal.span_singleton_pow]
  refine this (r s) (r g3) ?_
  rcases r with ‚ü®l1,l2‚ü©
  simp
  unfold AdicCompletion.IsAdicCauchy at l2
  simp at l2
  exact SModEq.trans (id (SModEq.symm (l2 hs))) (l2 sr3)
theorem zpow_adds ( x : ‚Ñù)(hx : ¬¨ x=0)(y z:‚Ñ§)  : x ^ (y + z) = x ^ y * x ^ z := by
  have:‚àÉ r:‚ÑùÀ£, x= r :=by
    refine Units.exists_iff_ne_zero.mpr ?_
    use x
  choose r hr using this
  rw[hr]
  have(m:‚Ñ§ ): (r:‚Ñù)^m =Units.val (r^m) :=by
    simp
  rw[this]
  rw[zpow_add r y z]
  simp

lemma ds3(a:AdicCompletion (Ideal.span {(p:‚Ñ§_[p]‚∏®X‚∏©)})
 (‚Ñ§_[p]‚∏®X‚∏©)) :AdicCompletion.mk (Ideal.span {(p:‚Ñ§_[p]‚∏®X‚∏©)}) ‚Ñ§_[p]‚∏®X‚∏©
    (Adic_Complection_tofun ‚ü®‚ü®(fun n => (p_sequence_coeff (p:=p) n a)),
     continuous_of_discreteTopology‚ü©,Tends_to_Zero' a‚ü©) = a :=by
  have:=by
   exact AdicCompletion.mk_surjective (Ideal.span {(p:‚Ñ§_[p]‚∏®X‚∏©)}) ‚Ñ§_[p]‚∏®X‚∏©
  unfold Function.Surjective at this
  rcases (this a) with ‚ü®r,rs‚ü©
  rw[‚Üê sub_eq_zero,‚Üê rs,‚Üê LinearMap.map_sub]
  refine AdicCompletion.mk_zero_of (Ideal.span {(p:‚Ñ§_[p]‚∏®X‚∏©)}) ‚Ñ§_[p]‚∏®X‚∏© _ ?_
  rw[rs]
  simp only [
    AdicCompletion.AdicCauchySequence.sub_apply,‚Üê SModEq.sub_mem]
  use 0
  intro g sefg
  have: (p:‚Ñù)^(-g:‚Ñ§)>0 :=by
     simp
     refine pow_pos ?_ g
     simp
     exact Nat.pos_of_neZero p
  choose seg theg  using (help2 r ((p:‚Ñù)^(-g:‚Ñ§)) this)
  use (max g seg)
  constructor
  ¬∑ exact Nat.le_max_left g seg
  ¬∑ use g
    constructor
    ¬∑ exact Nat.le_refl g
    ¬∑ refine powerseries_equiv_2 g  _ _ ?_
      intro s
      unfold HahnSeries.coeff_map_0 Adic_Complection_tofun
      simp only [
        ZeroAtBotContinuousMap.coe_mk,  LinearMap.coe_mk, AddHom.coe_mk,
        HahnSeries.ofSuppBddBelow_coeff]
      have:=esg s a r rs
      rcases Decidable.em (‚Äñ(p_sequence_coeff (p:=p) s) a‚Äñ‚â§ (p:‚Ñù)^(-(max g seg):‚Ñ§)) with r3|r4
      ¬∑ simp only [r3]
        simp only [‚ÜìreduceIte, zero_sub, neg_mem_iff]
        rw[this] at r3
        unfold cauchy_sequence_coeff Cauchy.seq_map Cauchy_p_adic HahnSeries.coeff_map_0
         AdicCompletion.mapAlg at r3
        simp only[Ideal.span_singleton_pow, ‚Üê norm_le_pow_iff_mem_span_pow,
        LinearMap.coe_mk, AddHom.coe_mk, LinearMap.coe_comp, Function.comp_apply] at r3
        simp only[Ideal.span_singleton_pow, ‚Üê norm_le_pow_iff_mem_span_pow]
        have ln:=theg (max g seg) (Nat.le_max_right g seg) s
        have :=norm_add_le  ((r (g ‚äî seg)).coeff s -
         CauSeq.lim ‚ü®fun n ‚Ü¶ (r n).coeff s,  help1 r s‚ü©)
          (CauSeq.lim ‚ü®fun n ‚Ü¶ (r n).coeff s,  help1 r s‚ü©)
        rw[sub_add_cancel] at this
        have ln2:=add_lt_add_of_lt_of_le ln r3
        have:=lt_of_le_of_lt this ln2
        have gf:(p:‚Ñù) ^ (-g:‚Ñ§) + (p:‚Ñù)^ (-(g ‚äî seg):‚Ñ§) ‚â§ (p:‚Ñù) ^ (-(g:‚Ñ§)+ 1) :=by
          have: (p:‚Ñù)^ (-(g ‚äî seg):‚Ñ§) ‚â§ (p:‚Ñù)^ (-g:‚Ñ§) :=by
             refine (zpow_le_zpow_iff_right‚ÇÄ ?_).mpr ?_
             simp
             refine Nat.Prime.one_lt (hp.1)
             simp
          have:=add_le_add (Preorder.le_refl ((p:‚Ñù)^ (-g:‚Ñ§))) this
          refine le_trans this ?_
          rw[‚Üê (two_mul)]
          have:(p:‚Ñù) ^ (-(g:‚Ñ§)+ 1)=p *(p:‚Ñù)^ (-g:‚Ñ§) :=by
                have:¬¨ (p:‚Ñù)=0 :=by
                    simp
                    exact NeZero.ne p
                rw[(zpow_adds (p:‚Ñù) this (-(g:‚Ñ§))  1 )]
                simp
                ring
          rw[this]
          refine (mul_le_mul_iff_of_pos_right ?_).mpr ?_
          simp
          refine pow_pos ?_ g
          simp
          exact Nat.pos_of_neZero p
          simp
          exact Nat.Prime.two_le hp.1
        exact (norm_le_pow_iff_norm_lt_pow_add_one ((r (g ‚äî seg)).coeff s) (-g:‚Ñ§)).mpr
          (gt_of_ge_of_gt gf this)
      ¬∑ simp only [r4,‚ÜìreduceIte]
        rw[esg s a r rs]
        unfold cauchy_sequence_coeff Cauchy.seq_map Cauchy_p_adic HahnSeries.coeff_map_0
         AdicCompletion.mapAlg
        simp only[Ideal.span_singleton_pow, ‚Üê norm_le_pow_iff_mem_span_pow,
        LinearMap.coe_mk, AddHom.coe_mk, LinearMap.coe_comp, Function.comp_apply]
        have ln:=theg (max g seg) (Nat.le_max_right g seg) s
        rw[‚Üê (neg_sub),norm_neg] at ln
        exact le_of_lt ln

lemma helper3 (a:CauSeq ‚Ñ§_[p] norm)(b:‚Ñ§_[p])(hs :CauSeq.LimZero (a-const norm b)):
 a.lim =b:=by
  rw[‚Üê lim_eq_zero_iff ,‚Üê Mathlib.Tactic.RingNF.add_neg,‚Üê lim_add,lim_neg,lim_const ] at hs
  calc
  _=(a.lim+ (-b))+b :=by ring
  _=_:=by
    rw[hs]
    simp





end PadicInt
