/-
Copyright (c) 2020 Johan Commelin, Robert Y. Lewis. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin, Robert Y. Lewis
-/
import Mathlib.Data.ZMod.Basic
import Mathlib.NumberTheory.Padics.PadicIntegers

#align_import number_theory.padics.ring_homs from "leanprover-community/mathlib"@"565eb991e264d0db702722b4bde52ee5173c9950"

/-!

# Relating `‚Ñ§_[p]` to `ZMod (p ^ n)`

In this file we establish connections between the `p`-adic integers $\mathbb{Z}_p$
and the integers modulo powers of `p`, $\mathbb{Z}/p^n\mathbb{Z}$.

## Main declarations

We show that $\mathbb{Z}_p$ has a ring hom to $\mathbb{Z}/p^n\mathbb{Z}$ for each `n`.
The case for `n = 1` is handled separately, since it is used in the general construction
and we may want to use it without the `^1` getting in the way.
* `PadicInt.toZMod`: ring hom to `ZMod p`
* `PadicInt.toZModPow`: ring hom to `ZMod (p^n)`
* `PadicInt.ker_toZMod` / `PadicInt.ker_toZModPow`: the kernels of these maps are the ideals
  generated by `p^n`

We also establish the universal property of $\mathbb{Z}_p$ as a projective limit.
Given a family of compatible ring homs $f_k : R \to \mathbb{Z}/p^n\mathbb{Z}$,
there is a unique limit $R \to \mathbb{Z}_p$.
* `PadicInt.lift`: the limit function
* `PadicInt.lift_spec` / `PadicInt.lift_unique`: the universal property

## Implementation notes

The ring hom constructions go through an auxiliary constructor `PadicInt.toZModHom`,
which removes some boilerplate code.

-/


noncomputable section

open Classical Nat LocalRing Padic

namespace PadicInt

variable {p : ‚Ñï} [hp_prime : Fact p.Prime]

section RingHoms

/-! ### Ring homomorphisms to `ZMod p` and `ZMod (p ^ n)` -/


variable (p) (r : ‚Ñö)

/-- `modPart p r` is an integer that satisfies
`‚Äñ(r - modPart p r : ‚Ñö_[p])‚Äñ < 1` when `‚Äñ(r : ‚Ñö_[p])‚Äñ ‚â§ 1`,
see `PadicInt.norm_sub_modPart`.
It is the unique non-negative integer that is `< p` with this property.

(Note that this definition assumes `r : ‚Ñö`.
See `PadicInt.zmodRepr` for a version that takes values in `‚Ñï`
and works for arbitrary `x : ‚Ñ§_[p]`.) -/
def modPart : ‚Ñ§ :=
  r.num * gcdA r.den p % p
#align padic_int.mod_part PadicInt.modPart

variable {p}

theorem modPart_lt_p : modPart p r < p := by
  convert Int.emod_lt _ _
  -- ‚ä¢ ‚Üëp = |‚Üëp|
  ¬∑ simp
    -- üéâ no goals
  ¬∑ exact_mod_cast hp_prime.1.ne_zero
    -- üéâ no goals
#align padic_int.mod_part_lt_p PadicInt.modPart_lt_p

theorem modPart_nonneg : 0 ‚â§ modPart p r :=
  Int.emod_nonneg _ <| by exact_mod_cast hp_prime.1.ne_zero
                          -- üéâ no goals
#align padic_int.mod_part_nonneg PadicInt.modPart_nonneg

theorem isUnit_den (r : ‚Ñö) (h : ‚Äñ(r : ‚Ñö_[p])‚Äñ ‚â§ 1) : IsUnit (r.den : ‚Ñ§_[p]) := by
  rw [isUnit_iff]
  -- ‚ä¢ ‚Äñ‚Üër.den‚Äñ = 1
  apply le_antisymm (r.den : ‚Ñ§_[p]).2
  -- ‚ä¢ 1 ‚â§ ‚Äñ‚Üë‚Üër.den‚Äñ
  rw [‚Üê not_lt, coe_nat_cast]
  -- ‚ä¢ ¬¨‚Äñ‚Üër.den‚Äñ < 1
  intro norm_denom_lt
  -- ‚ä¢ False
  have hr : ‚Äñ(r * r.den : ‚Ñö_[p])‚Äñ = ‚Äñ(r.num : ‚Ñö_[p])‚Äñ := by
    congr
    rw_mod_cast [@Rat.mul_den_eq_num r]
  rw [padicNormE.mul] at hr
  -- ‚ä¢ False
  have key : ‚Äñ(r.num : ‚Ñö_[p])‚Äñ < 1 := by
    calc
      _ = _ := hr.symm
      _ < 1 * 1 := (mul_lt_mul' h norm_denom_lt (norm_nonneg _) zero_lt_one)
      _ = 1 := mul_one 1

  have : ‚Üëp ‚à£ r.num ‚àß (p : ‚Ñ§) ‚à£ r.den := by
    simp only [‚Üê norm_int_lt_one_iff_dvd, ‚Üê padic_norm_e_of_padicInt]
    exact ‚ü®key, norm_denom_lt‚ü©
  apply hp_prime.1.not_dvd_one
  -- ‚ä¢ p ‚à£ 1
  rwa [‚Üê r.reduced.gcd_eq_one, Nat.dvd_gcd_iff, ‚Üê Int.coe_nat_dvd_left, ‚Üê Int.coe_nat_dvd]
  -- üéâ no goals
#align padic_int.is_unit_denom PadicInt.isUnit_den

theorem norm_sub_modPart_aux (r : ‚Ñö) (h : ‚Äñ(r : ‚Ñö_[p])‚Äñ ‚â§ 1) :
    ‚Üëp ‚à£ r.num - r.num * r.den.gcdA p % p * ‚Üër.den := by
  rw [‚Üê ZMod.int_cast_zmod_eq_zero_iff_dvd]
  -- ‚ä¢ ‚Üë(r.num - r.num * gcdA r.den p % ‚Üëp * ‚Üër.den) = 0
  simp only [Int.cast_ofNat, ZMod.nat_cast_mod, Int.cast_mul, Int.cast_sub]
  -- ‚ä¢ ‚Üër.num - ‚Üë(r.num * gcdA r.den p % ‚Üëp) * ‚Üër.den = 0
  have := congr_arg (fun x => x % p : ‚Ñ§ ‚Üí ZMod p) (gcd_eq_gcd_ab r.den p)
  -- ‚ä¢ ‚Üër.num - ‚Üë(r.num * gcdA r.den p % ‚Üëp) * ‚Üër.den = 0
  simp only [Int.cast_ofNat, CharP.cast_eq_zero, EuclideanDomain.mod_zero, Int.cast_add,
    Int.cast_mul, zero_mul, add_zero] at this
  push_cast
  -- ‚ä¢ ‚Üër.num - ‚Üër.num * ‚Üë(gcdA r.den p) * ‚Üër.den = 0
  rw [mul_right_comm, mul_assoc, ‚Üê this]
  -- ‚ä¢ ‚Üër.num - ‚Üër.num * ‚Üë(Nat.gcd r.den p) = 0
  suffices rdcp : r.den.coprime p
  -- ‚ä¢ ‚Üër.num - ‚Üër.num * ‚Üë(Nat.gcd r.den p) = 0
  ¬∑ rw [rdcp.gcd_eq_one]
    -- ‚ä¢ ‚Üër.num - ‚Üër.num * ‚Üë1 = 0
    simp only [mul_one, cast_one, sub_self]
    -- üéâ no goals
  apply coprime.symm
  -- ‚ä¢ coprime p r.den
  apply (coprime_or_dvd_of_prime hp_prime.1 _).resolve_right
  -- ‚ä¢ ¬¨p ‚à£ r.den
  rw [‚Üê Int.coe_nat_dvd, ‚Üê norm_int_lt_one_iff_dvd, not_lt]
  -- ‚ä¢ 1 ‚â§ ‚Äñ‚Üë‚Üër.den‚Äñ
  apply ge_of_eq
  -- ‚ä¢ ‚Äñ‚Üë‚Üër.den‚Äñ = 1
  rw [‚Üê isUnit_iff]
  -- ‚ä¢ IsUnit ‚Üë‚Üër.den
  exact isUnit_den r h
  -- üéâ no goals
#align padic_int.norm_sub_mod_part_aux PadicInt.norm_sub_modPart_aux

theorem norm_sub_modPart (h : ‚Äñ(r : ‚Ñö_[p])‚Äñ ‚â§ 1) : ‚Äñ(‚ü®r, h‚ü© - modPart p r : ‚Ñ§_[p])‚Äñ < 1 := by
  let n := modPart p r
  -- ‚ä¢ ‚Äñ{ val := ‚Üër, property := h } - ‚Üë(modPart p r)‚Äñ < 1
  rw [norm_lt_one_iff_dvd, ‚Üê (isUnit_den r h).dvd_mul_right]
  -- ‚ä¢ ‚Üëp ‚à£ ({ val := ‚Üër, property := h } - ‚Üë(modPart p r)) * ‚Üër.den
  suffices ‚Üëp ‚à£ r.num - n * r.den by
    convert(Int.castRingHom ‚Ñ§_[p]).map_dvd this
    simp only [sub_mul, Int.cast_ofNat, eq_intCast, Int.cast_mul, sub_left_inj, Int.cast_sub]
    apply Subtype.coe_injective
    simp only [coe_mul, Subtype.coe_mk, coe_nat_cast]
    rw_mod_cast [@Rat.mul_den_eq_num r]
    rfl
  exact norm_sub_modPart_aux r h
  -- üéâ no goals
#align padic_int.norm_sub_mod_part PadicInt.norm_sub_modPart

theorem exists_mem_range_of_norm_rat_le_one (h : ‚Äñ(r : ‚Ñö_[p])‚Äñ ‚â§ 1) :
    ‚àÉ n : ‚Ñ§, 0 ‚â§ n ‚àß n < p ‚àß ‚Äñ(‚ü®r, h‚ü© - n : ‚Ñ§_[p])‚Äñ < 1 :=
  ‚ü®modPart p r, modPart_nonneg _, modPart_lt_p _, norm_sub_modPart _ h‚ü©
#align padic_int.exists_mem_range_of_norm_rat_le_one PadicInt.exists_mem_range_of_norm_rat_le_one

theorem zmod_congr_of_sub_mem_span_aux (n : ‚Ñï) (x : ‚Ñ§_[p]) (a b : ‚Ñ§)
    (ha : x - a ‚àà (Ideal.span {(p : ‚Ñ§_[p]) ^ n}))
    (hb : x - b ‚àà (Ideal.span {(p : ‚Ñ§_[p]) ^ n})) : (a : ZMod (p ^ n)) = b := by
  rw [Ideal.mem_span_singleton] at ha hb
  -- ‚ä¢ ‚Üëa = ‚Üëb
  rw [‚Üê sub_eq_zero, ‚Üê Int.cast_sub, ZMod.int_cast_zmod_eq_zero_iff_dvd, Int.coe_nat_pow]
  -- ‚ä¢ ‚Üëp ^ n ‚à£ a - b
  rw [‚Üê dvd_neg, neg_sub] at ha
  -- ‚ä¢ ‚Üëp ^ n ‚à£ a - b
  have := dvd_add ha hb
  -- ‚ä¢ ‚Üëp ^ n ‚à£ a - b
  rwa [sub_eq_add_neg, sub_eq_add_neg, add_assoc, neg_add_cancel_left, ‚Üê sub_eq_add_neg, ‚Üê
    Int.cast_sub, pow_p_dvd_int_iff, Nat.cast_pow] at this
#align padic_int.zmod_congr_of_sub_mem_span_aux PadicInt.zmod_congr_of_sub_mem_span_aux

theorem zmod_congr_of_sub_mem_span (n : ‚Ñï) (x : ‚Ñ§_[p]) (a b : ‚Ñï)
    (ha : x - a ‚àà (Ideal.span {(p : ‚Ñ§_[p]) ^ n}))
    (hb : x - b ‚àà (Ideal.span {(p : ‚Ñ§_[p]) ^ n})) : (a : ZMod (p ^ n)) = b := by
  simpa using zmod_congr_of_sub_mem_span_aux n x a b ha hb
  -- üéâ no goals
#align padic_int.zmod_congr_of_sub_mem_span PadicInt.zmod_congr_of_sub_mem_span

theorem zmod_congr_of_sub_mem_max_ideal (x : ‚Ñ§_[p]) (m n : ‚Ñï) (hm : x - m ‚àà maximalIdeal ‚Ñ§_[p])
    (hn : x - n ‚àà maximalIdeal ‚Ñ§_[p]) : (m : ZMod p) = n := by
  rw [maximalIdeal_eq_span_p] at hm hn
  -- ‚ä¢ ‚Üëm = ‚Üën
  have := zmod_congr_of_sub_mem_span_aux 1 x m n
  -- ‚ä¢ ‚Üëm = ‚Üën
  simp only [pow_one] at this
  -- ‚ä¢ ‚Üëm = ‚Üën
  specialize this hm hn
  -- ‚ä¢ ‚Üëm = ‚Üën
  apply_fun ZMod.castHom (show p ‚à£ p ^ 1 by rw [pow_one]) (ZMod p) at this
  -- ‚ä¢ ‚Üëm = ‚Üën
  simp only [map_intCast] at this
  -- ‚ä¢ ‚Üëm = ‚Üën
  simpa only [Int.cast_ofNat] using this
  -- üéâ no goals
#align padic_int.zmod_congr_of_sub_mem_max_ideal PadicInt.zmod_congr_of_sub_mem_max_ideal

variable (x : ‚Ñ§_[p])

theorem exists_mem_range : ‚àÉ n : ‚Ñï, n < p ‚àß x - n ‚àà maximalIdeal ‚Ñ§_[p] := by
  simp only [maximalIdeal_eq_span_p, Ideal.mem_span_singleton, ‚Üê norm_lt_one_iff_dvd]
  -- ‚ä¢ ‚àÉ n, n < p ‚àß ‚Äñx - ‚Üën‚Äñ < 1
  obtain ‚ü®r, hr‚ü© := rat_dense p (x : ‚Ñö_[p]) zero_lt_one
  -- ‚ä¢ ‚àÉ n, n < p ‚àß ‚Äñx - ‚Üën‚Äñ < 1
  have H : ‚Äñ(r : ‚Ñö_[p])‚Äñ ‚â§ 1 := by
    rw [norm_sub_rev] at hr
    calc
      _ = ‚Äñ(r : ‚Ñö_[p]) - x + x‚Äñ := by ring_nf
      _ ‚â§ _ := padicNormE.nonarchimedean _ _
      _ ‚â§ _ := max_le (le_of_lt hr) x.2

  obtain ‚ü®n, hzn, hnp, hn‚ü© := exists_mem_range_of_norm_rat_le_one r H
  -- ‚ä¢ ‚àÉ n, n < p ‚àß ‚Äñx - ‚Üën‚Äñ < 1
  lift n to ‚Ñï using hzn
  -- ‚ä¢ ‚àÉ n, n < p ‚àß ‚Äñx - ‚Üën‚Äñ < 1
  use n
  -- ‚ä¢ n < p ‚àß ‚Äñx - ‚Üën‚Äñ < 1
  constructor
  -- ‚ä¢ n < p
  ¬∑ exact_mod_cast hnp
    -- üéâ no goals
  simp only [norm_def, coe_sub, Subtype.coe_mk, coe_nat_cast] at hn ‚ä¢
  -- ‚ä¢ ‚Äñ‚Üëx - ‚Üën‚Äñ < 1
  rw [show (x - n : ‚Ñö_[p]) = x - r + (r - n) by ring]
  -- ‚ä¢ ‚Äñ‚Üëx - ‚Üër + (‚Üër - ‚Üën)‚Äñ < 1
  apply lt_of_le_of_lt (padicNormE.nonarchimedean _ _)
  -- ‚ä¢ max ‚Äñ‚Üëx - ‚Üër‚Äñ ‚Äñ‚Üër - ‚Üën‚Äñ < 1
  apply max_lt hr
  -- ‚ä¢ ‚Äñ‚Üër - ‚Üën‚Äñ < 1
  simpa using hn
  -- üéâ no goals
#align padic_int.exists_mem_range PadicInt.exists_mem_range

/-- `zmod_repr x` is the unique natural number smaller than `p`
satisfying `‚Äñ(x - zmod_repr x : ‚Ñ§_[p])‚Äñ < 1`.
-/
def zmodRepr : ‚Ñï :=
  Classical.choose (exists_mem_range x)
#align padic_int.zmod_repr PadicInt.zmodRepr

theorem zmodRepr_spec : zmodRepr x < p ‚àß x - zmodRepr x ‚àà maximalIdeal ‚Ñ§_[p] :=
  Classical.choose_spec (exists_mem_range x)
#align padic_int.zmod_repr_spec PadicInt.zmodRepr_spec

theorem zmodRepr_lt_p : zmodRepr x < p :=
  (zmodRepr_spec _).1
#align padic_int.zmod_repr_lt_p PadicInt.zmodRepr_lt_p

theorem sub_zmodRepr_mem : x - zmodRepr x ‚àà maximalIdeal ‚Ñ§_[p] :=
  (zmodRepr_spec _).2
#align padic_int.sub_zmod_repr_mem PadicInt.sub_zmodRepr_mem

/-- `toZModHom` is an auxiliary constructor for creating ring homs from `‚Ñ§_[p]` to `ZMod v`.
-/
def toZModHom (v : ‚Ñï) (f : ‚Ñ§_[p] ‚Üí ‚Ñï) (f_spec : ‚àÄ x, x - f x ‚àà (Ideal.span {‚Üëv} : Ideal ‚Ñ§_[p]))
    (f_congr :
      ‚àÄ (x : ‚Ñ§_[p]) (a b : ‚Ñï),
        x - a ‚àà (Ideal.span {‚Üëv} : Ideal ‚Ñ§_[p]) ‚Üí
          x - b ‚àà (Ideal.span {‚Üëv} : Ideal ‚Ñ§_[p]) ‚Üí (a : ZMod v) = b) :
    ‚Ñ§_[p] ‚Üí+* ZMod v where
  toFun x := f x
  map_zero' := by
    dsimp only
    -- ‚ä¢ ‚Üë(f 0) = 0
    rw [f_congr (0 : ‚Ñ§_[p]) _ 0, cast_zero]
    -- ‚ä¢ 0 - ‚Üë(f 0) ‚àà Ideal.span {‚Üëv}
    ¬∑ exact f_spec _
      -- üéâ no goals
    -- ‚ä¢ ‚Üë(f 1) = 1
    ¬∑ simp only [sub_zero, cast_zero, Submodule.zero_mem]
    -- ‚ä¢ 1 - ‚Üë(f 1) ‚àà Ideal.span {‚Üëv}
      -- üéâ no goals
      -- üéâ no goals
  map_one' := by
      -- üéâ no goals
    dsimp only
    rw [f_congr (1 : ‚Ñ§_[p]) _ 1, cast_one]
    ¬∑ exact f_spec _
    ¬∑ simp only [sub_self, cast_one, Submodule.zero_mem]
  map_add' := by
    intro x y
    -- ‚ä¢ OneHom.toFun (‚Üë{ toOneHom := { toFun := fun x => ‚Üë(f x), map_one' := (_ : (f ‚Ä¶
    dsimp only
    -- ‚ä¢ ‚Üë(f (x + y)) = ‚Üë(f x) + ‚Üë(f y)
    rw [f_congr (x + y) _ (f x + f y), cast_add]
    -- ‚ä¢ OneHom.toFun { toFun := fun x => ‚Üë(f x), map_one' := (_ : (fun x => ‚Üë(f x))  ‚Ä¶
    -- ‚ä¢ x + y - ‚Üë(f (x + y)) ‚àà Ideal.span {‚Üëv}
    -- ‚ä¢ ‚Üë(f (x * y)) = ‚Üë(f x) * ‚Üë(f y)
    ¬∑ exact f_spec _
    -- ‚ä¢ x * y - ‚Üë(f (x * y)) ‚àà Ideal.span {‚Üëv}
      -- üéâ no goals
      -- üéâ no goals
    ¬∑ convert Ideal.add_mem _ (f_spec x) (f_spec y) using 1
      -- ‚ä¢ x * y - ‚Üë(f x * f y) ‚àà Ideal.span {‚Üëv}
      -- ‚ä¢ x + y - ‚Üë(f x + f y) = x - ‚Üë(f x) + (y - ‚Üë(f y))
      -- ‚ä¢ x * y - ‚Üë(f x * f y) = x * (y - ‚Üë(f y)) + (x - ‚Üë(f x)) * ‚Üë(f y)
      rw [cast_add]
      -- ‚ä¢ x * y - ‚Üë(f x) * ‚Üë(f y) = x * (y - ‚Üë(f y)) + (x - ‚Üë(f x)) * ‚Üë(f y)
      -- ‚ä¢ x + y - (‚Üë(f x) + ‚Üë(f y)) = x - ‚Üë(f x) + (y - ‚Üë(f y))
      -- üéâ no goals
      ring
      -- üéâ no goals
  map_mul' := by
    intro x y
    dsimp only
    rw [f_congr (x * y) _ (f x * f y), cast_mul]
    ¬∑ exact f_spec _
    ¬∑ let I : Ideal ‚Ñ§_[p] := Ideal.span {‚Üëv}
      convert I.add_mem (I.mul_mem_left x (f_spec y)) (I.mul_mem_right ‚Üë(f y) (f_spec x)) using 1
      rw [cast_mul]
      ring
#align padic_int.to_zmod_hom PadicInt.toZModHom

/-- `toZMod` is a ring hom from `‚Ñ§_[p]` to `ZMod p`,
with the equality `toZMod x = (zmodRepr x : ZMod p)`.
-/
def toZMod : ‚Ñ§_[p] ‚Üí+* ZMod p :=
  toZModHom p zmodRepr
    (by
      rw [‚Üê maximalIdeal_eq_span_p]
      -- ‚ä¢ ‚àÄ (x : ‚Ñ§_[p]), x - ‚Üë(zmodRepr x) ‚àà maximalIdeal ‚Ñ§_[p]
      exact sub_zmodRepr_mem)
      -- üéâ no goals
    (by
      rw [‚Üê maximalIdeal_eq_span_p]
      -- ‚ä¢ ‚àÄ (x : ‚Ñ§_[p]) (a b : ‚Ñï), x - ‚Üëa ‚àà maximalIdeal ‚Ñ§_[p] ‚Üí x - ‚Üëb ‚àà maximalIdeal ‚Ä¶
      exact zmod_congr_of_sub_mem_max_ideal)
      -- üéâ no goals
#align padic_int.to_zmod PadicInt.toZMod

/-- `z - (toZMod z : ‚Ñ§_[p])` is contained in the maximal ideal of `‚Ñ§_[p]`, for every `z : ‚Ñ§_[p]`.

The coercion from `ZMod p` to `‚Ñ§_[p]` is `ZMod.cast`,
which coerces `ZMod p` into arbitrary rings.
This is unfortunate, but a consequence of the fact that we allow `ZMod p`
to coerce to rings of arbitrary characteristic, instead of only rings of characteristic `p`.
This coercion is only a ring homomorphism if it coerces into a ring whose characteristic divides
`p`. While this is not the case here we can still make use of the coercion.
-/
theorem toZMod_spec : x - (toZMod x : ‚Ñ§_[p]) ‚àà maximalIdeal ‚Ñ§_[p] := by
  convert sub_zmodRepr_mem x using 2
  -- ‚ä¢ ‚Üë(‚ÜëtoZMod x) = ‚Üë(zmodRepr x)
  dsimp [toZMod, toZModHom]
  -- ‚ä¢ ‚Üë‚Üë(zmodRepr x) = ‚Üë(zmodRepr x)
  rcases exists_eq_add_of_lt hp_prime.1.pos with ‚ü®p', rfl‚ü©
  -- ‚ä¢ ‚Üë‚Üë(zmodRepr x) = ‚Üë(zmodRepr x)
  change ‚Üë((_ : ZMod (0 + p' + 1)).val) = (_ : ‚Ñ§_[0 + p' + 1])
  -- ‚ä¢ ‚Üë(ZMod.val ‚Üë(zmodRepr x)) = ‚Üë(zmodRepr x)
  simp only [ZMod.val_nat_cast, add_zero, add_def, Nat.cast_inj, zero_add]
  -- ‚ä¢ zmodRepr x % (p' + 1) = zmodRepr x
  apply mod_eq_of_lt
  -- ‚ä¢ zmodRepr x < p' + 1
  simpa only [zero_add] using zmodRepr_lt_p x
  -- üéâ no goals
#align padic_int.to_zmod_spec PadicInt.toZMod_spec

theorem ker_toZMod : RingHom.ker (toZMod : ‚Ñ§_[p] ‚Üí+* ZMod p) = maximalIdeal ‚Ñ§_[p] := by
  ext x
  -- ‚ä¢ x ‚àà RingHom.ker toZMod ‚Üî x ‚àà maximalIdeal ‚Ñ§_[p]
  rw [RingHom.mem_ker]
  -- ‚ä¢ ‚ÜëtoZMod x = 0 ‚Üî x ‚àà maximalIdeal ‚Ñ§_[p]
  constructor
  -- ‚ä¢ ‚ÜëtoZMod x = 0 ‚Üí x ‚àà maximalIdeal ‚Ñ§_[p]
  ¬∑ intro h
    -- ‚ä¢ x ‚àà maximalIdeal ‚Ñ§_[p]
    simpa only [h, ZMod.cast_zero, sub_zero] using toZMod_spec x
    -- üéâ no goals
  ¬∑ intro h
    -- ‚ä¢ ‚ÜëtoZMod x = 0
    rw [‚Üê sub_zero x] at h
    -- ‚ä¢ ‚ÜëtoZMod x = 0
    dsimp [toZMod, toZModHom]
    -- ‚ä¢ ‚Üë(zmodRepr x) = 0
    convert zmod_congr_of_sub_mem_max_ideal x _ 0 _ h
    -- ‚ä¢ 0 = ‚Üë0
    norm_cast
    -- ‚ä¢ x - ‚Üë(zmodRepr x) ‚àà maximalIdeal ‚Ñ§_[p]
    apply sub_zmodRepr_mem
    -- üéâ no goals
#align padic_int.ker_to_zmod PadicInt.ker_toZMod

/-- `appr n x` gives a value `v : ‚Ñï` such that `x` and `‚Üëv : ‚Ñ§_p` are congruent mod `p^n`.
See `appr_spec`. -/
-- Porting note: removing irreducible solves a lot of problems
noncomputable def appr : ‚Ñ§_[p] ‚Üí ‚Ñï ‚Üí ‚Ñï
  | _x, 0 => 0
  | x, n + 1 =>
    let y := x - appr x n
    if hy : y = 0 then appr x n
    else
      let u := (unitCoeff hy : ‚Ñ§_[p])
      appr x n + p ^ n * (toZMod ((u * (p : ‚Ñ§_[p]) ^ (y.valuation - n).natAbs) : ‚Ñ§_[p])).val
#align padic_int.appr PadicInt.appr

theorem appr_lt (x : ‚Ñ§_[p]) (n : ‚Ñï) : x.appr n < p ^ n := by
  induction' n with n ih generalizing x
  -- ‚ä¢ appr x zero < p ^ zero
  ¬∑ simp only [appr, zero_eq, _root_.pow_zero, zero_lt_one]
    -- üéâ no goals
  simp only [appr, map_natCast, ZMod.nat_cast_self, RingHom.map_pow, Int.natAbs, RingHom.map_mul]
  -- ‚ä¢ (if h : x - ‚Üë(appr x n) = 0 then appr x n
  have hp : p ^ n < p ^ (n + 1) := by apply pow_lt_pow hp_prime.1.one_lt (lt_add_one n)
  -- ‚ä¢ (if h : x - ‚Üë(appr x n) = 0 then appr x n
  split_ifs with h
  ¬∑ apply lt_trans (ih _) hp
    -- üéâ no goals
  ¬∑ calc
      _ < p ^ n + p ^ n * (p - 1) := ?_
      _ = p ^ (n + 1) := ?_

    ¬∑ apply add_lt_add_of_lt_of_le (ih _)
      -- ‚ä¢ p ^ n *
      apply Nat.mul_le_mul_left
      -- ‚ä¢ ZMod.val
      apply le_pred_of_lt
      -- ‚ä¢ ZMod.val
      apply ZMod.val_lt
      -- üéâ no goals
    ¬∑ rw [mul_tsub, mul_one, ‚Üê _root_.pow_succ']
      -- ‚ä¢ p ^ n + (p ^ (n + 1) - p ^ n) = p ^ (n + 1)
      apply add_tsub_cancel_of_le (le_of_lt hp)
      -- üéâ no goals
#align padic_int.appr_lt PadicInt.appr_lt

theorem appr_mono (x : ‚Ñ§_[p]) : Monotone x.appr := by
  apply monotone_nat_of_le_succ
  -- ‚ä¢ ‚àÄ (n : ‚Ñï), appr x n ‚â§ appr x (n + 1)
  intro n
  -- ‚ä¢ appr x n ‚â§ appr x (n + 1)
  dsimp [appr]
  -- ‚ä¢ appr x n ‚â§ if hy : x - ‚Üë(appr x n) = 0 then appr x n else appr x n + p ^ n * ‚Ä¶
  split_ifs; ¬∑ rfl
  -- ‚ä¢ appr x n ‚â§ appr x n
               -- üéâ no goals
  apply Nat.le_add_right
  -- üéâ no goals
#align padic_int.appr_mono PadicInt.appr_mono

theorem dvd_appr_sub_appr (x : ‚Ñ§_[p]) (m n : ‚Ñï) (h : m ‚â§ n) : p ^ m ‚à£ x.appr n - x.appr m := by
  obtain ‚ü®k, rfl‚ü© := Nat.exists_eq_add_of_le h; clear h
  -- ‚ä¢ p ^ m ‚à£ appr x (m + k) - appr x m
                                                -- ‚ä¢ p ^ m ‚à£ appr x (m + k) - appr x m
  induction' k with k ih
  -- ‚ä¢ p ^ m ‚à£ appr x (m + zero) - appr x m
  ¬∑ simp only [zero_eq, add_zero, le_refl, tsub_eq_zero_of_le, ne_eq, Nat.isUnit_iff, dvd_zero]
    -- üéâ no goals
  rw [Nat.succ_eq_add_one, ‚Üê add_assoc]
  -- ‚ä¢ p ^ m ‚à£ appr x (m + k + 1) - appr x m
  dsimp [appr]
  -- ‚ä¢ p ^ m ‚à£ (if hy : x - ‚Üë(appr x (m + k)) = 0 then appr x (m + k) else appr x ( ‚Ä¶
  split_ifs with h
  -- ‚ä¢ p ^ m ‚à£ appr x (m + k) - appr x m
  ¬∑ exact ih
    -- üéâ no goals
  rw [add_comm, add_tsub_assoc_of_le (appr_mono _ (Nat.le_add_right m k))]
  -- ‚ä¢ p ^ m ‚à£ p ^ (m + k) * ZMod.val (‚ÜëtoZMod (‚Üë(unitCoeff h) * ‚Üëp ^ Int.natAbs (v ‚Ä¶
  apply dvd_add _ ih
  -- ‚ä¢ p ^ m ‚à£ p ^ (m + k) * ZMod.val (‚ÜëtoZMod (‚Üë(unitCoeff h) * ‚Üëp ^ Int.natAbs (v ‚Ä¶
  apply dvd_mul_of_dvd_left
  -- ‚ä¢ p ^ m ‚à£ p ^ (m + k)
  apply pow_dvd_pow _ (Nat.le_add_right m k)
  -- üéâ no goals
#align padic_int.dvd_appr_sub_appr PadicInt.dvd_appr_sub_appr

theorem appr_spec (n : ‚Ñï) : ‚àÄ x : ‚Ñ§_[p], x - appr x n ‚àà Ideal.span {(p : ‚Ñ§_[p]) ^ n} := by
  simp only [Ideal.mem_span_singleton]
  -- ‚ä¢ ‚àÄ (x : ‚Ñ§_[p]), ‚Üëp ^ n ‚à£ x - ‚Üë(appr x n)
  induction' n with n ih
  -- ‚ä¢ ‚àÄ (x : ‚Ñ§_[p]), ‚Üëp ^ zero ‚à£ x - ‚Üë(appr x zero)
  ¬∑ simp only [zero_eq, _root_.pow_zero, isUnit_one, IsUnit.dvd, forall_const]
    -- üéâ no goals
  intro x
  -- ‚ä¢ ‚Üëp ^ succ n ‚à£ x - ‚Üë(appr x (succ n))
  dsimp only [appr]
  -- ‚ä¢ ‚Üëp ^ succ n ‚à£ x - ‚Üë(if hy : x - ‚Üë(appr x n) = 0 then appr x n else appr x n  ‚Ä¶
  split_ifs with h
  -- ‚ä¢ ‚Üëp ^ succ n ‚à£ x - ‚Üë(appr x n)
  ¬∑ rw [h]
    -- ‚ä¢ ‚Üëp ^ succ n ‚à£ 0
    apply dvd_zero
    -- üéâ no goals
  push_cast
  -- ‚ä¢ ‚Üëp ^ succ n ‚à£ x - (‚Üë(appr x n) + ‚Üëp ^ n * ‚Üë(ZMod.val (‚ÜëtoZMod (‚Üë(unitCoeff h ‚Ä¶
  rw [sub_add_eq_sub_sub]
  -- ‚ä¢ ‚Üëp ^ succ n ‚à£ x - ‚Üë(appr x n) - ‚Üëp ^ n * ‚Üë(ZMod.val (‚ÜëtoZMod (‚Üë(unitCoeff h) ‚Ä¶
  obtain ‚ü®c, hc‚ü© := ih x
  -- ‚ä¢ ‚Üëp ^ succ n ‚à£ x - ‚Üë(appr x n) - ‚Üëp ^ n * ‚Üë(ZMod.val (‚ÜëtoZMod (‚Üë(unitCoeff h) ‚Ä¶
  simp only [map_natCast, ZMod.nat_cast_self, RingHom.map_pow, RingHom.map_mul, ZMod.nat_cast_val]
  -- ‚ä¢ ‚Üëp ^ succ n ‚à£ x - ‚Üë(appr x n) - ‚Üëp ^ n * ‚Üë(‚ÜëtoZMod ‚Üë(unitCoeff h) * 0 ^ Int. ‚Ä¶
  have hc' : c ‚â† 0 := by
    rintro rfl
    simp only [mul_zero] at hc
    contradiction
  conv_rhs =>
    congr
    simp only [hc]
  rw [show (x - (appr x n : ‚Ñ§_[p])).valuation = ((p : ‚Ñ§_[p]) ^ n * c).valuation by rw [hc]]
  -- ‚ä¢ ‚Üëp ^ succ n ‚à£ ‚Üëp ^ n * c - ‚Üëp ^ n * ‚Üë(‚ÜëtoZMod ‚Üë(unitCoeff h) * 0 ^ Int.natAb ‚Ä¶
  rw [valuation_p_pow_mul _ _ hc', add_sub_cancel', _root_.pow_succ', ‚Üê mul_sub]
  -- ‚ä¢ ‚Üëp ^ n * ‚Üëp ‚à£ ‚Üëp ^ n * (c - ‚Üë(‚ÜëtoZMod ‚Üë(unitCoeff h) * 0 ^ Int.natAbs (valua ‚Ä¶
  apply mul_dvd_mul_left
  -- ‚ä¢ ‚Üëp ‚à£ c - ‚Üë(‚ÜëtoZMod ‚Üë(unitCoeff h) * 0 ^ Int.natAbs (valuation c))
  obtain hc0 | hc0 := c.valuation.natAbs.eq_zero_or_pos
  -- ‚ä¢ ‚Üëp ‚à£ c - ‚Üë(‚ÜëtoZMod ‚Üë(unitCoeff h) * 0 ^ Int.natAbs (valuation c))
  ¬∑ simp only [hc0, mul_one, _root_.pow_zero]
    -- ‚ä¢ ‚Üëp ‚à£ c - ‚Üë(‚ÜëtoZMod ‚Üë(unitCoeff h))
    rw [mul_comm, unitCoeff_spec h] at hc
    -- ‚ä¢ ‚Üëp ‚à£ c - ‚Üë(‚ÜëtoZMod ‚Üë(unitCoeff h))
    suffices c = unitCoeff h by
      rw [‚Üê this, ‚Üê Ideal.mem_span_singleton, ‚Üê maximalIdeal_eq_span_p]
      apply toZMod_spec
    obtain ‚ü®c, rfl‚ü© : IsUnit c := by
      -- TODO: write a `CanLift` instance for units
      rw [Int.natAbs_eq_zero] at hc0
      rw [isUnit_iff, norm_eq_pow_val hc', hc0, neg_zero, zpow_zero]
    rw [DiscreteValuationRing.unit_mul_pow_congr_unit _ _ _ _ _ hc]
    -- ‚ä¢ Irreducible ‚Üëp
    exact irreducible_p
    -- üéâ no goals
  ¬∑ rw [zero_pow hc0]
    -- ‚ä¢ ‚Üëp ‚à£ c - ‚Üë(‚ÜëtoZMod ‚Üë(unitCoeff h) * 0)
    simp only [sub_zero, ZMod.cast_zero, mul_zero]
    -- ‚ä¢ ‚Üëp ‚à£ c
    rw [unitCoeff_spec hc']
    -- ‚ä¢ ‚Üëp ‚à£ ‚Üë(unitCoeff hc') * ‚Üëp ^ Int.natAbs (valuation c)
    exact (dvd_pow_self (p : ‚Ñ§_[p]) hc0.ne').mul_left _
    -- üéâ no goals
#align padic_int.appr_spec PadicInt.appr_spec

/-- A ring hom from `‚Ñ§_[p]` to `ZMod (p^n)`, with underlying function `PadicInt.appr n`. -/
def toZModPow (n : ‚Ñï) : ‚Ñ§_[p] ‚Üí+* ZMod (p ^ n) :=
  toZModHom (p ^ n) (fun x => appr x n)
    (by
      intros
      -- ‚ä¢ x‚úù - ‚Üë((fun x => appr x n) x‚úù) ‚àà Ideal.span {‚Üë(p ^ n)}
      rw [Nat.cast_pow]
      -- ‚ä¢ x‚úù - ‚Üë((fun x => appr x n) x‚úù) ‚àà Ideal.span {‚Üëp ^ n}
      exact appr_spec n _)
      -- üéâ no goals
    (by
      intro x a b ha hb
      -- ‚ä¢ ‚Üëa = ‚Üëb
      apply zmod_congr_of_sub_mem_span n x a b
      -- ‚ä¢ x - ‚Üëa ‚àà Ideal.span {‚Üëp ^ n}
      ¬∑ simpa using ha
        -- üéâ no goals
      ¬∑ simpa using hb)
        -- üéâ no goals
#align padic_int.to_zmod_pow PadicInt.toZModPow

theorem ker_toZModPow (n : ‚Ñï) :
  RingHom.ker (toZModPow n : ‚Ñ§_[p] ‚Üí+* ZMod (p ^ n)) = Ideal.span {(p : ‚Ñ§_[p]) ^ n} := by
  ext x
  -- ‚ä¢ x ‚àà RingHom.ker (toZModPow n) ‚Üî x ‚àà Ideal.span {‚Üëp ^ n}
  rw [RingHom.mem_ker]
  -- ‚ä¢ ‚Üë(toZModPow n) x = 0 ‚Üî x ‚àà Ideal.span {‚Üëp ^ n}
  constructor
  -- ‚ä¢ ‚Üë(toZModPow n) x = 0 ‚Üí x ‚àà Ideal.span {‚Üëp ^ n}
  ¬∑ intro h
    -- ‚ä¢ x ‚àà Ideal.span {‚Üëp ^ n}
    suffices x.appr n = 0 by
      convert appr_spec n x
      simp only [this, sub_zero, cast_zero]
    dsimp [toZModPow, toZModHom] at h
    -- ‚ä¢ appr x n = 0
    rw [ZMod.nat_cast_zmod_eq_zero_iff_dvd] at h
    -- ‚ä¢ appr x n = 0
    apply eq_zero_of_dvd_of_lt h (appr_lt _ _)
    -- üéâ no goals
  ¬∑ intro h
    -- ‚ä¢ ‚Üë(toZModPow n) x = 0
    rw [‚Üê sub_zero x] at h
    -- ‚ä¢ ‚Üë(toZModPow n) x = 0
    dsimp [toZModPow, toZModHom]
    -- ‚ä¢ ‚Üë(appr x n) = 0
    rw [zmod_congr_of_sub_mem_span n x _ 0 _ h, cast_zero]
    -- ‚ä¢ x - ‚Üë(appr x n) ‚àà Ideal.span {‚Üëp ^ n}
    apply appr_spec
    -- üéâ no goals
#align padic_int.ker_to_zmod_pow PadicInt.ker_toZModPow

-- @[simp] -- Porting note: not in simpNF
theorem zmod_cast_comp_toZModPow (m n : ‚Ñï) (h : m ‚â§ n) :
    (ZMod.castHom (pow_dvd_pow p h) (ZMod (p ^ m))).comp (@toZModPow p _ n) = @toZModPow p _ m := by
  apply ZMod.ringHom_eq_of_ker_eq
  -- ‚ä¢ RingHom.ker (RingHom.comp (ZMod.castHom (_ : p ^ m ‚à£ p ^ n) (ZMod (p ^ m)))  ‚Ä¶
  ext x
  -- ‚ä¢ x ‚àà RingHom.ker (RingHom.comp (ZMod.castHom (_ : p ^ m ‚à£ p ^ n) (ZMod (p ^ m ‚Ä¶
  rw [RingHom.mem_ker, RingHom.mem_ker]
  -- ‚ä¢ ‚Üë(RingHom.comp (ZMod.castHom (_ : p ^ m ‚à£ p ^ n) (ZMod (p ^ m))) (toZModPow  ‚Ä¶
  simp only [Function.comp_apply, ZMod.castHom_apply, RingHom.coe_comp]
  -- ‚ä¢ ‚Üë(‚Üë(toZModPow n) x) = 0 ‚Üî ‚Üë(toZModPow m) x = 0
  simp only [toZModPow, toZModHom, RingHom.coe_mk]
  -- ‚ä¢ ‚Üë(‚Üë{ toOneHom := { toFun := fun x => ‚Üë(appr x n), map_one' := (_ : (fun x => ‚Ä¶
  dsimp
  -- ‚ä¢ ‚Üë‚Üë(appr x n) = 0 ‚Üî ‚Üë(appr x m) = 0
  rw [ZMod.cast_nat_cast (pow_dvd_pow p h),
    zmod_congr_of_sub_mem_span m (x.appr n) (x.appr n) (x.appr m)]
  ¬∑ rw [sub_self]
    -- ‚ä¢ 0 ‚àà Ideal.span {‚Üëp ^ m}
    apply Ideal.zero_mem _
    -- üéâ no goals
  ¬∑ rw [Ideal.mem_span_singleton]
    -- ‚ä¢ ‚Üëp ^ m ‚à£ ‚Üë(appr x n) - ‚Üë(appr x m)
    rcases dvd_appr_sub_appr x m n h with ‚ü®c, hc‚ü©
    -- ‚ä¢ ‚Üëp ^ m ‚à£ ‚Üë(appr x n) - ‚Üë(appr x m)
    use c
    -- ‚ä¢ ‚Üë(appr x n) - ‚Üë(appr x m) = ‚Üëp ^ m * ‚Üëc
    rw [‚Üê Nat.cast_sub (appr_mono _ h), hc, Nat.cast_mul, Nat.cast_pow]
    -- üéâ no goals
#align padic_int.zmod_cast_comp_to_zmod_pow PadicInt.zmod_cast_comp_toZModPow

@[simp]
theorem cast_toZModPow (m n : ‚Ñï) (h : m ‚â§ n) (x : ‚Ñ§_[p]) : ‚Üë(toZModPow n x) = toZModPow m x := by
  rw [‚Üê zmod_cast_comp_toZModPow _ _ h]
  -- ‚ä¢ ‚Üë(‚Üë(toZModPow n) x) = ‚Üë(RingHom.comp (ZMod.castHom (_ : p ^ m ‚à£ p ^ n) (ZMod ‚Ä¶
  rfl
  -- üéâ no goals
#align padic_int.cast_to_zmod_pow PadicInt.cast_toZModPow

theorem denseRange_nat_cast : DenseRange (Nat.cast : ‚Ñï ‚Üí ‚Ñ§_[p]) := by
  intro x
  -- ‚ä¢ x ‚àà closure (Set.range Nat.cast)
  rw [Metric.mem_closure_range_iff]
  -- ‚ä¢ ‚àÄ (Œµ : ‚Ñù), Œµ > 0 ‚Üí ‚àÉ k, dist x ‚Üëk < Œµ
  intro Œµ hŒµ
  -- ‚ä¢ ‚àÉ k, dist x ‚Üëk < Œµ
  obtain ‚ü®n, hn‚ü© := exists_pow_neg_lt p hŒµ
  -- ‚ä¢ ‚àÉ k, dist x ‚Üëk < Œµ
  use x.appr n
  -- ‚ä¢ dist x ‚Üë(appr x n) < Œµ
  rw [dist_eq_norm]
  -- ‚ä¢ ‚Äñx - ‚Üë(appr x n)‚Äñ < Œµ
  apply lt_of_le_of_lt _ hn
  -- ‚ä¢ ‚Äñx - ‚Üë(appr x n)‚Äñ ‚â§ ‚Üëp ^ (-‚Üën)
  rw [norm_le_pow_iff_mem_span_pow]
  -- ‚ä¢ x - ‚Üë(appr x n) ‚àà Ideal.span {‚Üëp ^ n}
  apply appr_spec
  -- üéâ no goals
#align padic_int.dense_range_nat_cast PadicInt.denseRange_nat_cast

theorem denseRange_int_cast : DenseRange (Int.cast : ‚Ñ§ ‚Üí ‚Ñ§_[p]) := by
  intro x
  -- ‚ä¢ x ‚àà closure (Set.range Int.cast)
  refine DenseRange.induction_on denseRange_nat_cast x ?_ ?_
  -- ‚ä¢ IsClosed {b | b ‚àà closure (Set.range Int.cast)}
  ¬∑ exact isClosed_closure
    -- üéâ no goals
  ¬∑ intro a
    -- ‚ä¢ ‚Üëa ‚àà closure (Set.range Int.cast)
    apply subset_closure
    -- ‚ä¢ ‚Üëa ‚àà Set.range Int.cast
    exact Set.mem_range_self _
    -- üéâ no goals
#align padic_int.dense_range_int_cast PadicInt.denseRange_int_cast

end RingHoms

section lift

/-! ### Universal property as projective limit -/


open CauSeq PadicSeq

variable {R : Type*} [NonAssocSemiring R] (f : ‚àÄ k : ‚Ñï, R ‚Üí+* ZMod (p ^ k))
  (f_compat : ‚àÄ (k1 k2) (hk : k1 ‚â§ k2), (ZMod.castHom (pow_dvd_pow p hk) _).comp (f k2) = f k1)

/-- Given a family of ring homs `f : Œ† n : ‚Ñï, R ‚Üí+* ZMod (p ^ n)`,
`nthHom f r` is an integer-valued sequence
whose `n`th value is the unique integer `k` such that `0 ‚â§ k < p ^ n`
and `f n r = (k : ZMod (p ^ n))`.
-/
def nthHom (r : R) : ‚Ñï ‚Üí ‚Ñ§ := fun n => (f n r : ZMod (p ^ n)).val
#align padic_int.nth_hom PadicInt.nthHom

@[simp]
theorem nthHom_zero : nthHom f 0 = 0 := by simp [nthHom]; rfl
                                           -- ‚ä¢ (fun n => 0) = 0
                                                          -- üéâ no goals
#align padic_int.nth_hom_zero PadicInt.nthHom_zero

variable {f}

theorem pow_dvd_nthHom_sub (r : R) (i j : ‚Ñï) (h : i ‚â§ j) :
    (p : ‚Ñ§) ^ i ‚à£ nthHom f r j - nthHom f r i := by
  specialize f_compat i j h
  -- ‚ä¢ ‚Üëp ^ i ‚à£ nthHom f r j - nthHom f r i
  rw [‚Üê Int.coe_nat_pow, ‚Üê ZMod.int_cast_zmod_eq_zero_iff_dvd, Int.cast_sub]
  -- ‚ä¢ ‚Üë(nthHom f r j) - ‚Üë(nthHom f r i) = 0
  dsimp [nthHom]
  -- ‚ä¢ ‚Üë‚Üë(ZMod.val (‚Üë(f j) r)) - ‚Üë‚Üë(ZMod.val (‚Üë(f i) r)) = 0
  rw [‚Üê f_compat, RingHom.comp_apply]
  -- ‚ä¢ ‚Üë‚Üë(ZMod.val (‚Üë(f j) r)) - ‚Üë‚Üë(ZMod.val (‚Üë(ZMod.castHom (_ : p ^ i ‚à£ p ^ j) (Z ‚Ä¶
  simp only [ZMod.cast_id, ZMod.castHom_apply, sub_self, ZMod.nat_cast_val, ZMod.int_cast_cast]
  -- üéâ no goals
#align padic_int.pow_dvd_nth_hom_sub PadicInt.pow_dvd_nthHom_sub

theorem isCauSeq_nthHom (r : R) : IsCauSeq (padicNorm p) fun n => nthHom f r n := by
  intro Œµ hŒµ
  -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí padicNorm p ((fun n => ‚Üë(nthHom f r n)) j - (fun n = ‚Ä¶
  obtain ‚ü®k, hk‚ü© : ‚àÉ k : ‚Ñï, (p : ‚Ñö) ^ (-((k : ‚Ñï) : ‚Ñ§)) < Œµ := exists_pow_neg_lt_rat p hŒµ
  -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí padicNorm p ((fun n => ‚Üë(nthHom f r n)) j - (fun n = ‚Ä¶
  use k
  -- ‚ä¢ ‚àÄ (j : ‚Ñï), j ‚â• k ‚Üí padicNorm p ((fun n => ‚Üë(nthHom f r n)) j - (fun n => ‚Üë(n ‚Ä¶
  intro j hj
  -- ‚ä¢ padicNorm p ((fun n => ‚Üë(nthHom f r n)) j - (fun n => ‚Üë(nthHom f r n)) k) < Œµ
  refine' lt_of_le_of_lt _ hk
  -- ‚ä¢ padicNorm p ((fun n => ‚Üë(nthHom f r n)) j - (fun n => ‚Üë(nthHom f r n)) k) ‚â§  ‚Ä¶
  norm_cast
  -- ‚ä¢ padicNorm p ‚Üë(nthHom f r j - nthHom f r k) ‚â§ ‚Üëp ^ (-‚Üëk)
  rw [‚Üê padicNorm.dvd_iff_norm_le]
  -- ‚ä¢ ‚Üë(p ^ k) ‚à£ nthHom f r j - nthHom f r k
  exact_mod_cast pow_dvd_nthHom_sub f_compat r k j hj
  -- üéâ no goals
#align padic_int.is_cau_seq_nth_hom PadicInt.isCauSeq_nthHom

/-- `nthHomSeq f_compat r` bundles `PadicInt.nthHom f r`
as a Cauchy sequence of rationals with respect to the `p`-adic norm.
The `n`th value of the sequence is `((f n r).val : ‚Ñö)`.
-/
def nthHomSeq (r : R) : PadicSeq p :=
  ‚ü®fun n => nthHom f r n, isCauSeq_nthHom f_compat r‚ü©
#align padic_int.nth_hom_seq PadicInt.nthHomSeq

-- this lemma ran into issues after changing to `NeZero` and I'm not sure why.
theorem nthHomSeq_one : nthHomSeq f_compat 1 ‚âà 1 := by
  intro Œµ hŒµ
  -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí padicNorm p (‚Üë(nthHomSeq f_compat 1 - 1) j) < Œµ
  change _ < _ at hŒµ
  -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí padicNorm p (‚Üë(nthHomSeq f_compat 1 - 1) j) < Œµ
  use 1
  -- ‚ä¢ ‚àÄ (j : ‚Ñï), j ‚â• 1 ‚Üí padicNorm p (‚Üë(nthHomSeq f_compat 1 - 1) j) < Œµ
  intro j hj
  -- ‚ä¢ padicNorm p (‚Üë(nthHomSeq f_compat 1 - 1) j) < Œµ
  haveI : Fact (1 < p ^ j) := ‚ü®Nat.one_lt_pow _ _ (by linarith) hp_prime.1.one_lt‚ü©
  -- ‚ä¢ padicNorm p (‚Üë(nthHomSeq f_compat 1 - 1) j) < Œµ
  suffices ((1 : ZMod (p ^ j)) : ‚Ñö) = 1 by simp [nthHomSeq, nthHom, this, hŒµ]
  -- ‚ä¢ ‚Üë1 = 1
  rw [ZMod.cast_eq_val, ZMod.val_one, Nat.cast_one]
  -- üéâ no goals
#align padic_int.nth_hom_seq_one PadicInt.nthHomSeq_one

theorem nthHomSeq_add (r s : R) :
    nthHomSeq f_compat (r + s) ‚âà nthHomSeq f_compat r + nthHomSeq f_compat s := by
  intro Œµ hŒµ
  -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí padicNorm p (‚Üë(nthHomSeq f_compat (r + s) - (nthHomS ‚Ä¶
  obtain ‚ü®n, hn‚ü© := exists_pow_neg_lt_rat p hŒµ
  -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí padicNorm p (‚Üë(nthHomSeq f_compat (r + s) - (nthHomS ‚Ä¶
  use n
  -- ‚ä¢ ‚àÄ (j : ‚Ñï), j ‚â• n ‚Üí padicNorm p (‚Üë(nthHomSeq f_compat (r + s) - (nthHomSeq f_ ‚Ä¶
  intro j hj
  -- ‚ä¢ padicNorm p (‚Üë(nthHomSeq f_compat (r + s) - (nthHomSeq f_compat r + nthHomSe ‚Ä¶
  dsimp [nthHomSeq]
  -- ‚ä¢ padicNorm p (‚Üë(nthHom (fun k2 => f k2) (r + s) j) - (‚Üë(nthHom (fun k2 => f k ‚Ä¶
  apply lt_of_le_of_lt _ hn
  -- ‚ä¢ padicNorm p (‚Üë(nthHom (fun k2 => f k2) (r + s) j) - (‚Üë(nthHom (fun k2 => f k ‚Ä¶
  rw [‚Üê Int.cast_add, ‚Üê Int.cast_sub, ‚Üê padicNorm.dvd_iff_norm_le, ‚Üê
    ZMod.int_cast_zmod_eq_zero_iff_dvd]
  dsimp [nthHom]
  -- ‚ä¢ ‚Üë(‚Üë(ZMod.val (‚Üë(f j) (r + s))) - ‚Üë(ZMod.val (‚Üë(f j) r) + ZMod.val (‚Üë(f j) s) ‚Ä¶
  simp only [ZMod.nat_cast_val, RingHom.map_add, Int.cast_sub, ZMod.int_cast_cast, Int.cast_add]
  -- ‚ä¢ ‚Üë(‚Üë(f j) r + ‚Üë(f j) s) - ‚Üë‚Üë(ZMod.val (‚Üë(f j) r) + ZMod.val (‚Üë(f j) s)) = 0
  rw [ZMod.cast_add (show p ^ n ‚à£ p ^ j from pow_dvd_pow _ hj)]
  -- ‚ä¢ ‚Üë(‚Üë(f j) r) + ‚Üë(‚Üë(f j) s) - ‚Üë‚Üë(ZMod.val (‚Üë(f j) r) + ZMod.val (‚Üë(f j) s)) = 0
  simp only [cast_add, ZMod.nat_cast_val, Int.cast_add, ZMod.int_cast_cast, sub_self]
  -- üéâ no goals
#align padic_int.nth_hom_seq_add PadicInt.nthHomSeq_add

theorem nthHomSeq_mul (r s : R) :
    nthHomSeq f_compat (r * s) ‚âà nthHomSeq f_compat r * nthHomSeq f_compat s := by
  intro Œµ hŒµ
  -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí padicNorm p (‚Üë(nthHomSeq f_compat (r * s) - nthHomSe ‚Ä¶
  obtain ‚ü®n, hn‚ü© := exists_pow_neg_lt_rat p hŒµ
  -- ‚ä¢ ‚àÉ i, ‚àÄ (j : ‚Ñï), j ‚â• i ‚Üí padicNorm p (‚Üë(nthHomSeq f_compat (r * s) - nthHomSe ‚Ä¶
  use n
  -- ‚ä¢ ‚àÄ (j : ‚Ñï), j ‚â• n ‚Üí padicNorm p (‚Üë(nthHomSeq f_compat (r * s) - nthHomSeq f_c ‚Ä¶
  intro j hj
  -- ‚ä¢ padicNorm p (‚Üë(nthHomSeq f_compat (r * s) - nthHomSeq f_compat r * nthHomSeq ‚Ä¶
  dsimp [nthHomSeq]
  -- ‚ä¢ padicNorm p (‚Üë(nthHom (fun k2 => f k2) (r * s) j) - ‚Üë(nthHom (fun k2 => f k2 ‚Ä¶
  apply lt_of_le_of_lt _ hn
  -- ‚ä¢ padicNorm p (‚Üë(nthHom (fun k2 => f k2) (r * s) j) - ‚Üë(nthHom (fun k2 => f k2 ‚Ä¶
  rw [‚Üê Int.cast_mul, ‚Üê Int.cast_sub, ‚Üê padicNorm.dvd_iff_norm_le, ‚Üê
    ZMod.int_cast_zmod_eq_zero_iff_dvd]
  dsimp [nthHom]
  -- ‚ä¢ ‚Üë(‚Üë(ZMod.val (‚Üë(f j) (r * s))) - ‚Üë(ZMod.val (‚Üë(f j) r)) * ‚Üë(ZMod.val (‚Üë(f j) ‚Ä¶
  simp only [ZMod.nat_cast_val, RingHom.map_mul, Int.cast_sub, ZMod.int_cast_cast, Int.cast_mul]
  -- ‚ä¢ ‚Üë(‚Üë(f j) r * ‚Üë(f j) s) - ‚Üë(‚Üë(f j) r) * ‚Üë(‚Üë(f j) s) = 0
  rw [ZMod.cast_mul (show p ^ n ‚à£ p ^ j from pow_dvd_pow _ hj), sub_self]
  -- üéâ no goals
#align padic_int.nth_hom_seq_mul PadicInt.nthHomSeq_mul

/--
`limNthHom f_compat r` is the limit of a sequence `f` of compatible ring homs `R ‚Üí+* ZMod (p^k)`.
This is itself a ring hom: see `PadicInt.lift`.
-/
def limNthHom (r : R) : ‚Ñ§_[p] :=
  ofIntSeq (nthHom f r) (isCauSeq_nthHom f_compat r)
#align padic_int.lim_nth_hom PadicInt.limNthHom

theorem limNthHom_spec (r : R) :
    ‚àÄ Œµ : ‚Ñù, 0 < Œµ ‚Üí ‚àÉ N : ‚Ñï, ‚àÄ n ‚â• N, ‚ÄñlimNthHom f_compat r - nthHom f r n‚Äñ < Œµ := by
  intro Œµ hŒµ
  -- ‚ä¢ ‚àÉ N, ‚àÄ (n : ‚Ñï), n ‚â• N ‚Üí ‚ÄñlimNthHom f_compat r - ‚Üë(nthHom f r n)‚Äñ < Œµ
  obtain ‚ü®Œµ', hŒµ'0, hŒµ'‚ü© : ‚àÉ v : ‚Ñö, (0 : ‚Ñù) < v ‚àß ‚Üëv < Œµ := exists_rat_btwn hŒµ
  -- ‚ä¢ ‚àÉ N, ‚àÄ (n : ‚Ñï), n ‚â• N ‚Üí ‚ÄñlimNthHom f_compat r - ‚Üë(nthHom f r n)‚Äñ < Œµ
  norm_cast at hŒµ'0
  -- ‚ä¢ ‚àÉ N, ‚àÄ (n : ‚Ñï), n ‚â• N ‚Üí ‚ÄñlimNthHom f_compat r - ‚Üë(nthHom f r n)‚Äñ < Œµ
  obtain ‚ü®N, hN‚ü© := padicNormE.defn (nthHomSeq f_compat r) hŒµ'0
  -- ‚ä¢ ‚àÉ N, ‚àÄ (n : ‚Ñï), n ‚â• N ‚Üí ‚ÄñlimNthHom f_compat r - ‚Üë(nthHom f r n)‚Äñ < Œµ
  use N
  -- ‚ä¢ ‚àÄ (n : ‚Ñï), n ‚â• N ‚Üí ‚ÄñlimNthHom f_compat r - ‚Üë(nthHom f r n)‚Äñ < Œµ
  intro n hn
  -- ‚ä¢ ‚ÄñlimNthHom f_compat r - ‚Üë(nthHom f r n)‚Äñ < Œµ
  apply _root_.lt_trans _ hŒµ'
  -- ‚ä¢ ‚ÄñlimNthHom f_compat r - ‚Üë(nthHom f r n)‚Äñ < ‚ÜëŒµ'
  change (padicNormE _  : ‚Ñù) < _
  -- ‚ä¢ ‚Üë(‚ÜëpadicNormE ‚Üë(limNthHom f_compat r - ‚Üë(nthHom f r n))) < ‚ÜëŒµ'
  norm_cast
  -- ‚ä¢ ‚ÜëpadicNormE ‚Üë(limNthHom f_compat r - ‚Üë(nthHom f r n)) < Œµ'
  exact hN _ hn
  -- üéâ no goals
#align padic_int.lim_nth_hom_spec PadicInt.limNthHom_spec

theorem limNthHom_zero : limNthHom f_compat 0 = 0 := by simp [limNthHom]; rfl
                                                        -- ‚ä¢ ofIntSeq 0 (_ : IsCauSeq (padicNorm p) fun n => ‚Üë(OfNat.ofNat 0 n)) = 0
                                                                          -- üéâ no goals
#align padic_int.lim_nth_hom_zero PadicInt.limNthHom_zero

theorem limNthHom_one : limNthHom f_compat 1 = 1 :=
  Subtype.ext <| Quot.sound <| nthHomSeq_one f_compat
#align padic_int.lim_nth_hom_one PadicInt.limNthHom_one

theorem limNthHom_add (r s : R) :
    limNthHom f_compat (r + s) = limNthHom f_compat r + limNthHom f_compat s :=
  Subtype.ext <| Quot.sound <| nthHomSeq_add f_compat _ _
#align padic_int.lim_nth_hom_add PadicInt.limNthHom_add

theorem limNthHom_mul (r s : R) :
    limNthHom f_compat (r * s) = limNthHom f_compat r * limNthHom f_compat s :=
  Subtype.ext <| Quot.sound <| nthHomSeq_mul f_compat _ _
#align padic_int.lim_nth_hom_mul PadicInt.limNthHom_mul

-- TODO: generalize this to arbitrary complete discrete valuation rings
/-- `lift f_compat` is the limit of a sequence `f` of compatible ring homs `R ‚Üí+* ZMod (p^k)`,
with the equality `lift f_compat r = PadicInt.limNthHom f_compat r`.
-/
def lift : R ‚Üí+* ‚Ñ§_[p] where
  toFun := limNthHom f_compat
  map_one' := limNthHom_one f_compat
  map_mul' := limNthHom_mul f_compat
  map_zero' := limNthHom_zero f_compat
  map_add' := limNthHom_add f_compat
#align padic_int.lift PadicInt.lift

theorem lift_sub_val_mem_span (r : R) (n : ‚Ñï) :
    lift f_compat r - (f n r).val ‚àà (Ideal.span {(p : ‚Ñ§_[p]) ^ n}) := by
  obtain ‚ü®k, hk‚ü© :=
    limNthHom_spec f_compat r _
      (show (0 : ‚Ñù) < (p : ‚Ñù) ^ (-n : ‚Ñ§) from Nat.zpow_pos_of_pos hp_prime.1.pos _)
  have := le_of_lt (hk (max n k) (le_max_right _ _))
  -- ‚ä¢ ‚Üë(lift f_compat) r - ‚Üë(ZMod.val (‚Üë(f n) r)) ‚àà Ideal.span {‚Üëp ^ n}
  rw [norm_le_pow_iff_mem_span_pow] at this
  -- ‚ä¢ ‚Üë(lift f_compat) r - ‚Üë(ZMod.val (‚Üë(f n) r)) ‚àà Ideal.span {‚Üëp ^ n}
  dsimp [lift]
  -- ‚ä¢ limNthHom f_compat r - ‚Üë(ZMod.val (‚Üë(f n) r)) ‚àà Ideal.span {‚Üëp ^ n}
  rw [sub_eq_sub_add_sub (limNthHom f_compat r) _ ‚Üë(nthHom f r (max n k))]
  -- ‚ä¢ ‚Üë(nthHom f r (max n k)) - ‚Üë(ZMod.val (‚Üë(f n) r)) + (limNthHom f_compat r - ‚Üë ‚Ä¶
  apply Ideal.add_mem _ _ this
  -- ‚ä¢ ‚Üë(nthHom f r (max n k)) - ‚Üë(ZMod.val (‚Üë(f n) r)) ‚àà Ideal.span {‚Üëp ^ n}
  rw [Ideal.mem_span_singleton]
  -- ‚ä¢ ‚Üëp ^ n ‚à£ ‚Üë(nthHom f r (max n k)) - ‚Üë(ZMod.val (‚Üë(f n) r))
  convert
    (Int.castRingHom ‚Ñ§_[p]).map_dvd (pow_dvd_nthHom_sub f_compat r n (max n k) (le_max_left _ _))
  ¬∑ rw [map_pow]; rfl
    -- ‚ä¢ ‚Üëp ^ n = ‚Üë(Int.castRingHom ‚Ñ§_[p]) ‚Üëp ^ n
                  -- üéâ no goals
  ¬∑ rw [map_sub]; rfl
    -- ‚ä¢ ‚Üë(nthHom f r (max n k)) - ‚Üë(ZMod.val (‚Üë(f n) r)) = ‚Üë(Int.castRingHom ‚Ñ§_[p])  ‚Ä¶
                  -- üéâ no goals
#align padic_int.lift_sub_val_mem_span PadicInt.lift_sub_val_mem_span

/-- One part of the universal property of `‚Ñ§_[p]` as a projective limit.
See also `PadicInt.lift_unique`.
-/
theorem lift_spec (n : ‚Ñï) : (toZModPow n).comp (lift f_compat) = f n := by
  ext r
  -- ‚ä¢ ‚Üë(RingHom.comp (toZModPow n) (lift f_compat)) r = ‚Üë(f n) r
  rw [RingHom.comp_apply, ‚Üê ZMod.nat_cast_zmod_val (f n r), ‚Üê map_natCast <| toZModPow n, ‚Üê
    sub_eq_zero, ‚Üê RingHom.map_sub, ‚Üê RingHom.mem_ker, ker_toZModPow]
  apply lift_sub_val_mem_span
  -- üéâ no goals
#align padic_int.lift_spec PadicInt.lift_spec

/-- One part of the universal property of `‚Ñ§_[p]` as a projective limit.
See also `PadicInt.lift_spec`.
-/
theorem lift_unique (g : R ‚Üí+* ‚Ñ§_[p]) (hg : ‚àÄ n, (toZModPow n).comp g = f n) :
    lift f_compat = g := by
  ext1 r
  -- ‚ä¢ ‚Üë(lift f_compat) r = ‚Üëg r
  apply eq_of_forall_dist_le
  -- ‚ä¢ ‚àÄ (Œµ : ‚Ñù), Œµ > 0 ‚Üí dist (‚Üë(lift f_compat) r) (‚Üëg r) ‚â§ Œµ
  intro Œµ hŒµ
  -- ‚ä¢ dist (‚Üë(lift f_compat) r) (‚Üëg r) ‚â§ Œµ
  obtain ‚ü®n, hn‚ü© := exists_pow_neg_lt p hŒµ
  -- ‚ä¢ dist (‚Üë(lift f_compat) r) (‚Üëg r) ‚â§ Œµ
  apply le_trans _ (le_of_lt hn)
  -- ‚ä¢ dist (‚Üë(lift f_compat) r) (‚Üëg r) ‚â§ ‚Üëp ^ (-‚Üën)
  rw [dist_eq_norm, norm_le_pow_iff_mem_span_pow, ‚Üê ker_toZModPow, RingHom.mem_ker,
    RingHom.map_sub, ‚Üê RingHom.comp_apply, ‚Üê RingHom.comp_apply, lift_spec, hg, sub_self]
#align padic_int.lift_unique PadicInt.lift_unique

@[simp]
theorem lift_self (z : ‚Ñ§_[p]) : @lift p _ ‚Ñ§_[p] _ toZModPow zmod_cast_comp_toZModPow z = z := by
  show _ = RingHom.id _ z
  -- ‚ä¢ ‚Üë(lift (_ : ‚àÄ (m n : ‚Ñï) (h : m ‚â§ n), RingHom.comp (ZMod.castHom (_ : p ^ m ‚à£ ‚Ä¶
  rw [@lift_unique p _ ‚Ñ§_[p] _ _ zmod_cast_comp_toZModPow (RingHom.id ‚Ñ§_[p])]
  -- ‚ä¢ ‚àÄ (n : ‚Ñï), RingHom.comp (toZModPow n) (RingHom.id ‚Ñ§_[p]) = toZModPow n
  intro; rw [RingHom.comp_id]
  -- ‚ä¢ RingHom.comp (toZModPow n‚úù) (RingHom.id ‚Ñ§_[p]) = toZModPow n‚úù
         -- üéâ no goals
#align padic_int.lift_self PadicInt.lift_self

end lift

theorem ext_of_toZModPow {x y : ‚Ñ§_[p]} : (‚àÄ n, toZModPow n x = toZModPow n y) ‚Üî x = y := by
  constructor
  -- ‚ä¢ (‚àÄ (n : ‚Ñï), ‚Üë(toZModPow n) x = ‚Üë(toZModPow n) y) ‚Üí x = y
  ¬∑ intro h
    -- ‚ä¢ x = y
    rw [‚Üê lift_self x, ‚Üê lift_self y]
    -- ‚ä¢ ‚Üë(lift (_ : ‚àÄ (m n : ‚Ñï) (h : m ‚â§ n), RingHom.comp (ZMod.castHom (_ : p ^ m ‚à£ ‚Ä¶
    simp [lift, limNthHom, nthHom, h]
    -- üéâ no goals
  ¬∑ rintro rfl _
    -- ‚ä¢ ‚Üë(toZModPow n‚úù) x = ‚Üë(toZModPow n‚úù) x
    rfl
    -- üéâ no goals
#align padic_int.ext_of_to_zmod_pow PadicInt.ext_of_toZModPow

theorem toZModPow_eq_iff_ext {R : Type*} [NonAssocSemiring R] {g g' : R ‚Üí+* ‚Ñ§_[p]} :
    (‚àÄ n, (toZModPow n).comp g = (toZModPow n).comp g') ‚Üî g = g' := by
  constructor
  -- ‚ä¢ (‚àÄ (n : ‚Ñï), RingHom.comp (toZModPow n) g = RingHom.comp (toZModPow n) g') ‚Üí  ‚Ä¶
  ¬∑ intro hg
    -- ‚ä¢ g = g'
    ext x : 1
    -- ‚ä¢ ‚Üëg x = ‚Üëg' x
    apply ext_of_toZModPow.mp
    -- ‚ä¢ ‚àÄ (n : ‚Ñï), ‚Üë(toZModPow n) (‚Üëg x) = ‚Üë(toZModPow n) (‚Üëg' x)
    intro n
    -- ‚ä¢ ‚Üë(toZModPow n) (‚Üëg x) = ‚Üë(toZModPow n) (‚Üëg' x)
    show (toZModPow n).comp g x = (toZModPow n).comp g' x
    -- ‚ä¢ ‚Üë(RingHom.comp (toZModPow n) g) x = ‚Üë(RingHom.comp (toZModPow n) g') x
    rw [hg n]
    -- üéâ no goals
  ¬∑ rintro rfl _
    -- ‚ä¢ RingHom.comp (toZModPow n‚úù) g = RingHom.comp (toZModPow n‚úù) g
    rfl
    -- üéâ no goals
#align padic_int.to_zmod_pow_eq_iff_ext PadicInt.toZModPow_eq_iff_ext

end PadicInt
