/-
Copyright (c) 2025 X. Roblot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Xavier Roblot
-/
import Mathlib.NumberTheory.NumberField.Units.Regulator
import Mathlib.RingTheory.RootsOfUnity.Complex

/-!
# CM extension of number fields

A CM-extension of number fields is a totally complex number field that is a quadratic extension of
a totally real number field.

## Main definitions

* `IsCM`: a predicate on two number fields `F` and `K` stating that `K/F` is a CM-extension.

* `IsCM.complexConj`: the complex conjugation of a `CM`-extension.

## Main results

* `IsCM.indexRealUnits_eq_one_or_two`: the index of the subgroup generated by the real units and
  the roots of unity is equal to `1` or `2`; see `indexRealUnits_eq_two_iff` for an equivalent
  condition on when it is equal to `2`.

* `IsCM.regulator_div_regulator_eq_two_pow_mul_indexRealUnits_inv`: for `K/F` a CM-extension, the
  regulator of `K` divided by the regulator of `F` is equal to `2 ^ Units.rank K` times the index
  of the subgroup generated by the real units and the roots of unity.

-/

open NumberField InfinitePlace ComplexEmbedding

/--
An extension `K/F` of number fields is a `CM`-extension if `K` is totally complex, `F` is totally
real and the extension `K/F` is of degree `2`.
-/
class IsCM (F K : Type*) [Field F] [NumberField F] [Field K] [NumberField K]
    [Algebra F K] : Prop
  extends IsTotallyReal F, IsTotallyComplex K where
  finrank_eq_two' : Module.finrank F K = 2

namespace IsCM

noncomputable section first_results

variable (F K : Type*) [Field F] [NumberField F] [Field K] [NumberField K] [Algebra F K]

theorem isTotallyComplex [IsCM F K] :
    IsTotallyComplex K := toIsTotallyComplex F

theorem isTotallyReal [IsCM F K] :
    IsTotallyReal F := toIsTotallyReal K

theorem finrank_eq_two [IsCM F K] :
    Module.finrank F K = 2 := finrank_eq_two'

variable [IsCM F K]

instance : IsGalois F K :=
{ to_isSeparable := Algebra.IsSeparable.of_integral _ _
  to_normal := normal_of_rank_eq_two _ _ (finrank_eq_two  F K) }

theorem card_infinitePlace_eq_card_infinitePlace :
    Fintype.card (InfinitePlace K) = Fintype.card (InfinitePlace F) := by
  rw [card_eq_nrRealPlaces_add_nrComplexPlaces, card_eq_nrRealPlaces_add_nrComplexPlaces,
    nrRealPlaces_eq_zero_iff.mpr (isTotallyComplex F K), zero_add,
    nrComplexPlaces_eq_zero_iff.mpr (isTotallyReal F K), add_zero, ‚Üê IsTotallyReal.finrank,
    ‚Üê Nat.mul_left_cancel_iff zero_lt_two, ‚Üê IsTotallyComplex.finrank,
    ‚Üê Module.finrank_mul_finrank ‚Ñö F K, finrank_eq_two F K, mul_comm]

/--
The equiv between the infinite places of `K` and the infinite places of `F` induced by the
restriction to `F`, see `equivInfinitePlace_apply`.
-/
def equivInfinitePlace :
    InfinitePlace K ‚âÉ InfinitePlace F :=
  Equiv.ofBijective (fun w ‚Ü¶ w.comap (algebraMap F K))
   <| (Fintype.bijective_iff_surjective_and_card _).mpr
      ‚ü®comap_surjective, card_infinitePlace_eq_card_infinitePlace F K‚ü©

@[simp]
theorem equivInfinitePlace_apply (w : InfinitePlace K) :
    equivInfinitePlace F K w = w.comap (algebraMap F K) := rfl

@[simp]
theorem equivInfinitePlace_symm_apply (w : InfinitePlace F) (x : F) :
    (equivInfinitePlace F K).symm w (algebraMap F K x) = w x := by
  have : (equivInfinitePlace F K).symm w (algebraMap F K x) =
    ((equivInfinitePlace F K).symm w).comap (algebraMap F K) x := rfl
  rw [this, ‚Üê equivInfinitePlace_apply, Equiv.apply_symm_apply]

theorem units_rank_eq_units_rank :
    Units.rank K = Units.rank F := by
  rw [Units.rank, Units.rank, card_infinitePlace_eq_card_infinitePlace F K]

end first_results

noncomputable section complexConj

variable (F : Type*) {K : Type*} [Field F] [Field K] [NumberField K] [Algebra F K]

open scoped ComplexConjugate

variable {F} in
theorem isConj_ne_one [IsTotallyComplex K] {œÜ : K ‚Üí+* ‚ÑÇ} {œÉ : K ‚âÉ‚Çê[F] K} (hœÜ : IsConj œÜ œÉ) :
    œÉ ‚â† 1 := by
  by_contra h
  rw [h, isConj_one_iff, ‚Üê isReal_mk_iff] at hœÜ
  exact not_isComplex_iff_isReal.mpr hœÜ (IsTotallyComplex.isComplex _)

variable [NumberField F]

/--
All complex embeddings of a Galois extension of a totally complex field over a totally real field
admit a conjugation.
-/
theorem exists_isConj [IsTotallyReal F] [IsTotallyComplex K] [IsGalois F K] (œÜ : K ‚Üí+* ‚ÑÇ) :
    ‚àÉ œÉ : K ‚âÉ‚Çê[F] K, IsConj œÜ œÉ :=
  exists_isConj_of_not_isUnramified <|
    not_isUnramified_iff.mpr ‚ü®IsTotallyComplex.isComplex _, IsTotallyReal.isReal _‚ü©

variable [IsCM F K]

variable {F} in
/--
All the conjugations of a `CM`-extension are the same.
-/
theorem isConj_eq_isConj {œÜ œà : K ‚Üí+* ‚ÑÇ} {œÉ œÑ : K ‚âÉ‚Çê[F] K}
    (hœÜ : IsConj œÜ œÉ) (hœà : IsConj œà œÑ) : œÉ = œÑ := by
  have : Fintype.card (K ‚âÉ‚Çê[F] K) = 2 := (finrank_eq_two F K) ‚ñ∏ IsGalois.card_aut_eq_finrank F K
  rw [‚Üê Nat.card_eq_fintype_card, Nat.card_eq_two_iff' 1] at this
  exact ExistsUnique.unique this (isConj_ne_one hœÜ) (isConj_ne_one hœà)

/--
The complex conjugation of a `CM`-extension.
-/
def complexConj : K ‚âÉ‚Çê[F] K :=
  (exists_isConj F (Classical.choice (inferInstance : Nonempty _))).choose

/--
A variant of the complex conjugation defined as an `AlgEquiv` on the ring of integers.
-/
def ringOfIntegersComplexConj : (ùìû K) ‚âÉ‚Çê[ùìû F] (ùìû K) :=
  RingOfIntegers.mapAlgEquiv (complexConj F)

@[simp]
theorem coe_ringOfIntegersComplexConj (x : ùìû K) :
    (ringOfIntegersComplexConj F x : K) = complexConj F (x : K) := rfl

/--
The complex conjugation is the conjugation of any complex embedding of a `CM`-extension.
-/
theorem isConj_complexConj (œÜ : K ‚Üí+* ‚ÑÇ) :
    IsConj œÜ (complexConj F) := by
  obtain ‚ü®œÉ, hœÉ‚ü© := exists_isConj F œÜ
  have := (exists_isConj F (Classical.choice (inferInstance : Nonempty (K ‚Üí+* ‚ÑÇ)))).choose_spec
  rwa [isConj_eq_isConj hœÉ this] at hœÉ

variable (K) in
theorem complexConj_ne_one :
    complexConj F ‚â† (1 : K ‚âÉ‚Çê[F] K) :=
  isConj_ne_one (exists_isConj F (Classical.choice (inferInstance : Nonempty _))).choose_spec

@[simp]
theorem complexEmbedding_complexConj (œÜ : K ‚Üí+* ‚ÑÇ) (x : K) :
    œÜ (complexConj F x) = conj (œÜ x) := by
  rw [IsConj.eq (isConj_complexConj F œÜ), RCLike.star_def]

@[simp]
theorem infinitePlace_complexConj (w : InfinitePlace K) (x : K) :
    w (complexConj F x) = w x := by
  rw [‚Üê norm_embedding_eq, complexEmbedding_complexConj, Complex.norm_conj, norm_embedding_eq]

@[simp]
theorem complexConj_apply_apply (x : K) :
    complexConj F (complexConj F x) = x := by
  let œÜ : K ‚Üí+* ‚ÑÇ := Classical.choice (inferInstance : Nonempty _)
  exact isConj_apply_apply (isConj_complexConj F œÜ) x

variable (K) in
/--
The complex conjugation is an automorphism of degree `2`.
-/
theorem orderOf_complexConj :
    orderOf (complexConj F : K ‚âÉ‚Çê[F] K) = 2 :=
  orderOf_eq_prime_iff.mpr ‚ü®by ext; simp, complexConj_ne_one F K‚ü©

variable (K) in
/--
The complex conjugation generates the Galois group of `K/F`.
-/
theorem zpowers_complexConj_eq_top :
    Subgroup.zpowers (complexConj F : K ‚âÉ‚Çê[F] K) = ‚ä§ := by
  refine Subgroup.eq_top_of_card_eq _ ?_
  rw [Nat.card_zpowers, orderOf_complexConj, Nat.card_eq_fintype_card, IsGalois.card_aut_eq_finrank,
    finrank_eq_two]

/--
An element of `K` is fixed by the complex conjugation iff it comes from `F`.
-/
theorem complexConj_eq_self_iff (x : K) :
    complexConj F x = x ‚Üî x ‚àà (algebraMap F K).range := by
  convert (IntermediateField.mem_fixedField_iff (‚ä§ : Subgroup (K ‚âÉ‚Çê[F] K)) x).symm using 1
  ¬∑ rw [‚Üê zpowers_complexConj_eq_top, Subgroup.forall_mem_zpowers]
    exact (MulAction.mem_fixedBy_zpowers_iff_mem_fixedBy
      (g := (complexConj F : K ‚âÉ‚Çê[F] K)) (a := x)).symm
  ¬∑ rw [IsGalois.IntermediateField.fixedField_top, IntermediateField.mem_bot, RingHom.mem_range,
      Set.mem_range]

/--
An element of `ùìû K` is fixed by the complex conjugation iff it comes from `ùìû F`.
-/
theorem ringOfIntegersComplexConj_eq_self_iff (x : ùìû K) :
    ringOfIntegersComplexConj F x = x ‚Üî x ‚àà (algebraMap (ùìû F) (ùìû K)).range := by
  rw [‚Üê RingOfIntegers.eq_iff, coe_ringOfIntegersComplexConj, complexConj_eq_self_iff,
    RingOfIntegers.coe_eq_algebraMap, RingHom.mem_range, RingHom.mem_range]
  refine ‚ü®fun ‚ü®a, ha‚ü© ‚Ü¶ ‚ü®‚ü®a, ?_‚ü©, RingOfIntegers.eq_iff.mp ha‚ü©, ?_‚ü©
  ¬∑ exact (isIntegral_algebraMap_iff
      (FaithfulSMul.algebraMap_injective F K)).mp (ha ‚ñ∏ RingOfIntegers.isIntegral_coe x)
  ¬∑ rintro ‚ü®a, rfl‚ü©
    exact ‚ü®a, rfl‚ü©

end complexConj

noncomputable section units

variable (F : Type*) {K : Type*} [Field F] [NumberField F] [Field K] [NumberField K] [Algebra F K]
  [IsCM F K]

open NumberField.Units

/--
The complex conjugation as a `RingEquiv` on the group of units.
-/
def unitsComplexConj : (ùìû K)À£ ‚âÉ* (ùìû K)À£ :=
  Units.mapEquiv (ringOfIntegersComplexConj F).toMulEquiv

@[simp]
theorem coe_unitsComplexConj (x : (ùìû K)À£) :
    (unitsComplexConj F x : ùìû K) = ringOfIntegersComplexConj F (x : ùìû K) := rfl

theorem unitsComplexEmbedding_complexConj (œÜ : K ‚Üí+* ‚ÑÇ) (u : (ùìû K)À£) :
    Units.complexEmbedding œÜ (unitsComplexConj F u) = (
        Units.map (starRingEnd ‚ÑÇ)) (Units.complexEmbedding œÜ u) := by
  simp [Units.ext_iff]

@[simp]
theorem unitsComplexConj_torsion (Œ∂ : torsion K) :
    unitsComplexConj F (Œ∂ : (ùìû K)À£) = Œ∂‚Åª¬π := by
  let œÜ : K ‚Üí+* ‚ÑÇ := Classical.choice (inferInstance : Nonempty _)
  rw [‚Üê (Units.complexEmbedding_injective œÜ).eq_iff, unitsComplexEmbedding_complexConj,
    Units.ext_iff, Units.coe_map, MonoidHom.coe_coe, Subgroup.coe_inv, MonoidHom.map_inv,
    Complex.conj_rootsOfUnity (n := torsionOrder K)]
  exact map_complexEmbedding_torsion K  _ ‚ñ∏ Subgroup.apply_coe_mem_map _ (torsion K) Œ∂

variable (K) in
/--
The subgroup of `(ùìû K)À£` generated by the units coming from `F`. These units are exactly the units
fixed by the complex conjugation, see `unitsComplexConj_eq_self_iff`.
-/
def realUnits : Subgroup (ùìû K)À£ := (Units.map (algebraMap (ùìû F) (ùìû K)).toMonoidHom).range

theorem unitsComplexConj_eq_self_iff (u : (ùìû K)À£) :
    unitsComplexConj F u = u ‚Üî u ‚àà realUnits F K := by
  rw [‚Üê Units.eq_iff, coe_unitsComplexConj, ringOfIntegersComplexConj_eq_self_iff, realUnits,
    RingHom.mem_range, RingHom.toMonoidHom_eq_coe, MonoidHom.mem_range]
  refine ‚ü®fun ‚ü®x, hx‚ü© ‚Ü¶ ‚ü®((hx ‚ñ∏ u.isUnit).of_map).unit, by simpa [Units.ext_iff] using hx‚ü©, ?_‚ü©
  rintro ‚ü®x, rfl‚ü©
  exact ‚ü®x, rfl‚ü©

/--
The map `(ùìû K)À£ ‚Üí* torsion K` defined by `u ‚Ü¶ u * (conj u)‚Åª¬π`.
-/
def unitsMulComplexConjInv : (ùìû K)À£ ‚Üí* torsion K where
  toFun := fun u ‚Ü¶ ‚ü®u * (unitsComplexConj F u)‚Åª¬π, (mem_torsion K).mpr fun _ ‚Ü¶ by simp‚ü©
  map_one' := by simp
  map_mul' x y := by
    simp only [map_mul, mul_inv_rev, MulMemClass.mk_mul_mk, Subtype.mk.injEq]
    rw [mul_comm ((unitsComplexConj F) y)‚Åª¬π, mul_mul_mul_comm]

@[simp]
theorem unitsMulComplexConjInv_apply (u : (ùìû K)À£) :
    unitsMulComplexConjInv F u = u * (unitsComplexConj F u)‚Åª¬π := rfl

@[simp]
theorem unitsMulComplexConjInv_apply_torsion (Œ∂ : torsion K) :
    unitsMulComplexConjInv F Œ∂ = Œ∂ ^ 2 :=
  Subtype.eq <| by simp [pow_two]

variable (K)

theorem map_unitsMulComplexConjInv_torsion :
    Subgroup.map (unitsMulComplexConjInv F) (torsion K) = (powMonoidHom 2).range := by
  rw [‚Üê MonoidHom.restrict_range]
  exact congr_arg (MonoidHom.range ¬∑) (MonoidHom.ext fun _ ‚Ü¶ by simp [pow_two])

theorem unitsMulComplexConjInv_ker :
    (unitsMulComplexConjInv F).ker = realUnits F K := by
  ext
  rw [MonoidHom.mem_ker, Subtype.ext_iff_val, unitsMulComplexConjInv_apply, OneMemClass.coe_one,
    mul_inv_eq_one, eq_comm, unitsComplexConj_eq_self_iff]

theorem index_unitsMulComplexConjInv_range_dvd :
    (unitsMulComplexConjInv F : (ùìû K)À£ ‚Üí* torsion K).range.index ‚à£ 2 := by
  suffices (powMonoidHom 2 : _ ‚Üí* torsion K).range.index = 2 by
    refine this ‚ñ∏ Subgroup.index_dvd_of_le ?_
    rintro _ ‚ü®Œ∂, _, rfl‚ü©
    exact ‚ü®Œ∂, Subtype.ext_iff_val.mpr (by simp [pow_two])‚ü©
  rw [IsCyclic.index_powMonoidHom_range, Nat.gcd_eq_right_iff_dvd]
  exact Even.two_dvd <| even_torsionOrder K

/--
The index of the subgroup of `(ùìû K)À£` generated by the real units and the roots of unity. This
index is equal to `1` or `2`, see `indexRealUnits_eq_one_or_two` and `indexRealUnits_eq_two_iff`.
-/
abbrev indexRealUnits : ‚Ñï := (realUnits F K ‚äî torsion K).index

theorem indexRealUnits_mul_eq :
    indexRealUnits F K * (unitsMulComplexConjInv F : (ùìû K)À£ ‚Üí* torsion K).range.index = 2 := by
  rw [indexRealUnits, sup_comm]
  convert (Subgroup.index_map (torsion K) (unitsMulComplexConjInv F : (ùìû K)À£ ‚Üí* torsion K)).symm
  ¬∑ rw [unitsMulComplexConjInv_ker]
  ¬∑ rw [map_unitsMulComplexConjInv_torsion, IsCyclic.index_powMonoidHom_range, Nat.gcd_eq_right]
    exact even_iff_two_dvd.mp (even_torsionOrder K)

theorem indexRealUnits_eq_one_or_two :
    indexRealUnits F K = 1 ‚à® indexRealUnits F K = 2 := by
  have h‚ÇÅ := indexRealUnits_mul_eq F K
  obtain h‚ÇÇ | h‚ÇÇ := (Nat.dvd_prime Nat.prime_two).mp <| index_unitsMulComplexConjInv_range_dvd F K
  ¬∑ exact Or.inr <| by rwa [h‚ÇÇ, mul_one] at h‚ÇÅ
  ¬∑ exact Or.inl <| by rwa [h‚ÇÇ, Nat.mul_left_eq_self_iff zero_lt_two] at h‚ÇÅ

/--
The index of the subgroup of `(ùìû K)À£` generated by the real units and the roots of unity is equal
to `2` iff there exists a unit whose image by `unitsMulComplexConjInv` generates the torsion
subgroup of `K`.
-/
theorem indexRealUnits_eq_two_iff :
    indexRealUnits F K = 2 ‚Üî
      ‚àÉ u : (ùìû K)À£, Subgroup.zpowers (unitsMulComplexConjInv F u) = ‚ä§ := by
  suffices (‚àÉ u : (ùìû K)À£, Subgroup.zpowers (unitsMulComplexConjInv F u) = ‚ä§) ‚Üî
      (unitsMulComplexConjInv F : _ ‚Üí* torsion K).range.index = 1 by
    rw [this]
    have h_eq := indexRealUnits_mul_eq F K
    refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©
    ¬∑ rwa [h, Nat.mul_right_eq_self_iff zero_lt_two] at h_eq
    ¬∑ rwa [h, mul_one] at h_eq
  refine ‚ü®fun ‚ü®u, hu‚ü© ‚Ü¶ Subgroup.index_eq_one.mpr (top_le_iff.mp ?_), fun h ‚Ü¶ ?_‚ü©
  ¬∑ refine le_of_eq_of_le ?_ ((Subgroup.zpowers u).map_le_range (unitsMulComplexConjInv F))
    rw [MonoidHom.map_zpowers, ‚Üê hu]
  ¬∑ obtain ‚ü®Œ∂, hŒ∂‚ü© := exists_zpow_surjective (torsion K)
    rw [Subgroup.index_eq_one, MonoidHom.range_eq_top] at h
    obtain ‚ü®u, rfl‚ü© := h Œ∂
    exact ‚ü®u, (Subgroup.eq_top_iff' _).mpr hŒ∂‚ü©

/--
The fundamental system of units of `F` as a family of `(ùìû K)À£`.
-/
def realFundSystem : Fin (rank K) ‚Üí (ùìû K)À£ :=
  fun i ‚Ü¶ (Units.map (algebraMap (ùìû F) (ùìû K)).toMonoidHom)
    (fundSystem F (finCongr (units_rank_eq_units_rank F K) i))

theorem closure_realFundSystem_sup_torsion :
    Subgroup.closure (Set.range (realFundSystem F K)) ‚äî torsion K = realUnits F K ‚äî torsion K := by
  have : Subgroup.map (Units.map (algebraMap (ùìû F) (ùìû K))) (torsion F) ‚â§ torsion K := by
    rintro _ ‚ü®x, hx, rfl‚ü©
    exact MonoidHom.isOfFinOrder _ hx
  rw [realUnits, MonoidHom.range_eq_map, ‚Üê closure_fundSystem_sup_torsion_eq_top, Subgroup.map_sup,
    sup_assoc, RingHom.toMonoidHom_eq_coe, sup_eq_right.mpr this, MonoidHom.map_closure]
  congr; ext
  simp [realFundSystem, Equiv.exists_congr_left (finCongr (units_rank_eq_units_rank F K))]

open dirichletUnitTheorem in
theorem regulator_div_regulator_eq_two_pow_mul_indexRealUnits_inv :
    regulator K / regulator F = 2 ^ rank K * (indexRealUnits F K : ‚Ñù)‚Åª¬π := by
  classical
  have : regOfFamily (realFundSystem F K) = 2 ^ rank K * regulator F := by
    let W‚ÇÄ := (equivInfinitePlace F K).symm w‚ÇÄ
    let f : {w : InfinitePlace K  // w ‚â† W‚ÇÄ} ‚âÉ {w : InfinitePlace F // w ‚â† w‚ÇÄ} :=
      (equivInfinitePlace F K).subtypeEquiv fun w ‚Ü¶ by rw [not_iff_not, Equiv.eq_symm_apply]
    let g := ((finCongr (units_rank_eq_units_rank F K)).trans (equivFinRank F)).trans f.symm
    rw [show (2 : ‚Ñù) ^ rank K = |‚àè w : {w : InfinitePlace F // w ‚â† w‚ÇÄ}, 2| by
      rw [Finset.prod_const, abs_pow, abs_of_pos zero_lt_two, units_rank_eq_units_rank F K, rank]
      simp]
    rw [regulator_eq_regOfFamily_fundSystem, regOfFamily_eq_det _ W‚ÇÄ g.symm, regOfFamily_eq_det',
      ‚Üê abs_mul, ‚Üê Matrix.det_mul_column, ‚Üê Matrix.det_reindex_self f, Matrix.reindex_apply]
    congr; ext i w
    rw [Matrix.submatrix_apply, Matrix.of_apply, Matrix.of_apply,
      show f.symm w = (equivInfinitePlace F K).symm w.1 by rfl,
      show algebraMap (ùìû K) K _ = algebraMap F K _ by rfl, equivInfinitePlace_symm_apply]
    simp [f, g]
  rw [indexRealUnits, ‚Üê closure_realFundSystem_sup_torsion, ‚Üê regOfFamily_div_regulator
    (realFundSystem F K), this, inv_div, ‚Üê mul_div_assoc, mul_div_mul_comm,
    div_self (by positivity), one_mul]

end units

end IsCM
