/-
Copyright (c) 2021 Riccardo Brasca. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Riccardo Brasca
-/
import Mathlib.RingTheory.Polynomial.Cyclotomic.Roots
import Mathlib.NumberTheory.NumberField.Basic
import Mathlib.FieldTheory.Galois

#align_import number_theory.cyclotomic.basic from "leanprover-community/mathlib"@"4b05d3f4f0601dca8abf99c4ec99187682ed0bba"

/-!
# Cyclotomic extensions

Let `A` and `B` be commutative rings with `Algebra A B`. For `S : Set ℕ+`, we define a class
`IsCyclotomicExtension S A B` expressing the fact that `B` is obtained from `A` by adding `n`-th
primitive roots of unity, for all `n ∈ S`.

## Main definitions

* `IsCyclotomicExtension S A B` : means that `B` is obtained from `A` by adding `n`-th primitive
  roots of unity, for all `n ∈ S`.
* `CyclotomicField`: given `n : ℕ+` and a field `K`, we define `CyclotomicField n K` as the
  splitting field of `cyclotomic n K`. If `n` is nonzero in `K`, it has the instance
  `IsCyclotomicExtension {n} K (CyclotomicField n K)`.
* `CyclotomicRing` : if `A` is a domain with fraction field `K` and `n : ℕ+`, we define
  `CyclotomicRing n A K` as the `A`-subalgebra of `CyclotomicField n K` generated by the roots of
  `X ^ n - 1`. If `n` is nonzero in `A`, it has the instance
  `IsCyclotomicExtension {n} A (CyclotomicRing n A K)`.

## Main results

* `IsCyclotomicExtension.trans` : if `IsCyclotomicExtension S A B` and
  `IsCyclotomicExtension T B C`, then `IsCyclotomicExtension (S ∪ T) A C` if
  `Function.Injective (algebraMap B C)`.
* `IsCyclotomicExtension.union_right` : given `IsCyclotomicExtension (S ∪ T) A B`, then
  `IsCyclotomicExtension T (adjoin A { b : B | ∃ a : ℕ+, a ∈ S ∧ b ^ (a : ℕ) = 1 }) B`.
* `IsCyclotomicExtension.union_left` : given `IsCyclotomicExtension T A B` and `S ⊆ T`, then
  `IsCyclotomicExtension S A (adjoin A { b : B | ∃ a : ℕ+, a ∈ S ∧ b ^ (a : ℕ) = 1 })`.
* `IsCyclotomicExtension.finite` : if `S` is finite and `IsCyclotomicExtension S A B`, then
  `B` is a finite `A`-algebra.
* `IsCyclotomicExtension.numberField` : a finite cyclotomic extension of a number field is a
  number field.
* `IsCyclotomicExtension.splitting_field_X_pow_sub_one` : if `IsCyclotomicExtension {n} K L`,
  then `L` is the splitting field of `X ^ n - 1`.
* `IsCyclotomicExtension.splitting_field_cyclotomic` : if `IsCyclotomicExtension {n} K L`,
  then `L` is the splitting field of `cyclotomic n K`.

## Implementation details

Our definition of `IsCyclotomicExtension` is very general, to allow rings of any characteristic
and infinite extensions, but it will mainly be used in the case `S = {n}` and for integral domains.
All results are in the `IsCyclotomicExtension` namespace.
Note that some results, for example `IsCyclotomicExtension.trans`,
`IsCyclotomicExtension.finite`, `IsCyclotomicExtension.numberField`,
`IsCyclotomicExtension.finiteDimensional`, `IsCyclotomicExtension.isGalois` and
`CyclotomicField.algebraBase` are lemmas, but they can be made local instances. Some of them are
included in the `Cyclotomic` locale.

-/


open Polynomial Algebra FiniteDimensional Set

open scoped BigOperators

universe u v w z

variable (n : ℕ+) (S T : Set ℕ+) (A : Type u) (B : Type v) (K : Type w) (L : Type z)

variable [CommRing A] [CommRing B] [Algebra A B]

variable [Field K] [Field L] [Algebra K L]

noncomputable section

/-- Given an `A`-algebra `B` and `S : Set ℕ+`, we define `IsCyclotomicExtension S A B` requiring
that there is an `n`-th primitive root of unity in `B` for all `n ∈ S` and that `B` is generated
over `A` by the roots of `X ^ n - 1`. -/

@[mk_iff]
class IsCyclotomicExtension : Prop where
  /-- For all `n ∈ S`, there exists a primitive `n`-th root of unity in `B`. -/
  exists_prim_root {n : ℕ+} (ha : n ∈ S) : ∃ r : B, IsPrimitiveRoot r n
  /-- The `n`-th roots of unity, for `n ∈ S`, generate `B` as an `A`-algebra. -/
  adjoin_roots : ∀ x : B, x ∈ adjoin A {b : B | ∃ n : ℕ+, n ∈ S ∧ b ^ (n : ℕ) = 1}
#align is_cyclotomic_extension IsCyclotomicExtension

namespace IsCyclotomicExtension

section Basic

/-- A reformulation of `IsCyclotomicExtension` that uses `⊤`. -/
theorem iff_adjoin_eq_top :
    IsCyclotomicExtension S A B ↔
      (∀ n : ℕ+, n ∈ S → ∃ r : B, IsPrimitiveRoot r n) ∧
        adjoin A {b : B | ∃ n : ℕ+, n ∈ S ∧ b ^ (n : ℕ) = 1} = ⊤ :=
  ⟨fun h => ⟨fun _ => h.exists_prim_root, Algebra.eq_top_iff.2 h.adjoin_roots⟩, fun h =>
    ⟨h.1 _, Algebra.eq_top_iff.1 h.2⟩⟩
#align is_cyclotomic_extension.iff_adjoin_eq_top IsCyclotomicExtension.iff_adjoin_eq_top

/-- A reformulation of `IsCyclotomicExtension` in the case `S` is a singleton. -/
theorem iff_singleton :
    IsCyclotomicExtension {n} A B ↔
      (∃ r : B, IsPrimitiveRoot r n) ∧ ∀ x, x ∈ adjoin A {b : B | b ^ (n : ℕ) = 1} :=
  by simp [IsCyclotomicExtension_iff]
     -- 🎉 no goals
#align is_cyclotomic_extension.iff_singleton IsCyclotomicExtension.iff_singleton

/-- If `IsCyclotomicExtension ∅ A B`, then the image of `A` in `B` equals `B`. -/
theorem empty [h : IsCyclotomicExtension ∅ A B] : (⊥ : Subalgebra A B) = ⊤ := by
  simpa [Algebra.eq_top_iff, IsCyclotomicExtension_iff] using h
  -- 🎉 no goals
#align is_cyclotomic_extension.empty IsCyclotomicExtension.empty

/-- If `IsCyclotomicExtension {1} A B`, then the image of `A` in `B` equals `B`. -/
theorem singleton_one [h : IsCyclotomicExtension {1} A B] : (⊥ : Subalgebra A B) = ⊤ :=
  Algebra.eq_top_iff.2 fun x => by
    simpa [adjoin_singleton_one] using ((IsCyclotomicExtension_iff _ _ _).1 h).2 x
    -- 🎉 no goals
#align is_cyclotomic_extension.singleton_one IsCyclotomicExtension.singleton_one

variable {A B}

/-- If `(⊥ : SubAlgebra A B) = ⊤`, then `IsCyclotomicExtension ∅ A B`. -/
theorem singleton_zero_of_bot_eq_top (h : (⊥ : Subalgebra A B) = ⊤) :
    IsCyclotomicExtension ∅ A B := by
-- Porting note: Lean3 is able to infer `A`.
  refine' (iff_adjoin_eq_top _ A _).2
    ⟨fun s hs => by simp at hs, _root_.eq_top_iff.2 fun x hx => _⟩
  rw [← h] at hx
  -- ⊢ x ∈ adjoin A {b | ∃ n, n ∈ ∅ ∧ b ^ ↑n = 1}
  simpa using hx
  -- 🎉 no goals
#align is_cyclotomic_extension.singleton_zero_of_bot_eq_top IsCyclotomicExtension.singleton_zero_of_bot_eq_top

variable (A B)

/-- Transitivity of cyclotomic extensions. -/
theorem trans (C : Type w) [CommRing C] [Algebra A C] [Algebra B C] [IsScalarTower A B C]
    [hS : IsCyclotomicExtension S A B] [hT : IsCyclotomicExtension T B C]
    (h : Function.Injective (algebraMap B C)) : IsCyclotomicExtension (S ∪ T) A C := by
  refine' ⟨fun hn => _, fun x => _⟩
  -- ⊢ ∃ r, IsPrimitiveRoot r ↑n✝
  · cases' hn with hn hn
    -- ⊢ ∃ r, IsPrimitiveRoot r ↑n✝
    · obtain ⟨b, hb⟩ := ((IsCyclotomicExtension_iff _ _ _).1 hS).1 hn
      -- ⊢ ∃ r, IsPrimitiveRoot r ↑n✝
      refine' ⟨algebraMap B C b, _⟩
      -- ⊢ IsPrimitiveRoot (↑(algebraMap B C) b) ↑n✝
      exact hb.map_of_injective h
      -- 🎉 no goals
    · exact ((IsCyclotomicExtension_iff _ _ _).1 hT).1 hn
      -- 🎉 no goals
  · refine' adjoin_induction (((IsCyclotomicExtension_iff T B _).1 hT).2 x)
      (fun c ⟨n, hn⟩ => subset_adjoin ⟨n, Or.inr hn.1, hn.2⟩) (fun b => _)
      (fun x y hx hy => Subalgebra.add_mem _ hx hy) fun x y hx hy => Subalgebra.mul_mem _ hx hy
    · let f := IsScalarTower.toAlgHom A B C
      -- ⊢ ↑(algebraMap B C) b ∈ adjoin A {b | ∃ n, n ∈ S ∪ T ∧ b ^ ↑n = 1}
      have hb : f b ∈ (adjoin A {b : B | ∃ a : ℕ+, a ∈ S ∧ b ^ (a : ℕ) = 1}).map f :=
        ⟨b, ((IsCyclotomicExtension_iff _ _ _).1 hS).2 b, rfl⟩
      rw [IsScalarTower.toAlgHom_apply, ← adjoin_image] at hb
      -- ⊢ ↑(algebraMap B C) b ∈ adjoin A {b | ∃ n, n ∈ S ∪ T ∧ b ^ ↑n = 1}
      refine' adjoin_mono (fun y hy => _) hb
      -- ⊢ y ∈ {b | ∃ n, n ∈ S ∪ T ∧ b ^ ↑n = 1}
      obtain ⟨b₁, ⟨⟨n, hn⟩, h₁⟩⟩ := hy
      -- ⊢ y ∈ {b | ∃ n, n ∈ S ∪ T ∧ b ^ ↑n = 1}
      exact ⟨n, ⟨mem_union_left T hn.1, by rw [← h₁, ← AlgHom.map_pow, hn.2, AlgHom.map_one]⟩⟩
      -- 🎉 no goals
#align is_cyclotomic_extension.trans IsCyclotomicExtension.trans

@[nontriviality]
theorem subsingleton_iff [Subsingleton B] : IsCyclotomicExtension S A B ↔ S = { } ∨ S = {1} := by
  constructor
  -- ⊢ IsCyclotomicExtension S A B → S = ∅ ∨ S = {1}
  · rintro ⟨hprim, -⟩
    -- ⊢ S = ∅ ∨ S = {1}
    rw [← subset_singleton_iff_eq]
    -- ⊢ S ⊆ {1}
    intro t ht
    -- ⊢ t ∈ {1}
    obtain ⟨ζ, hζ⟩ := hprim ht
    -- ⊢ t ∈ {1}
    rw [mem_singleton_iff, ← PNat.coe_eq_one_iff]
    -- ⊢ ↑t = 1
    exact_mod_cast hζ.unique (IsPrimitiveRoot.of_subsingleton ζ)
    -- 🎉 no goals
  · rintro (rfl | rfl)
    -- ⊢ IsCyclotomicExtension ∅ A B
-- Porting note: `R := A` was not needed.
    · exact ⟨fun h => h.elim, fun x => by convert (mem_top (R := A) : x ∈ ⊤)⟩
      -- 🎉 no goals
    · rw [iff_singleton]
      -- ⊢ (∃ r, IsPrimitiveRoot r ↑1) ∧ ∀ (x : B), x ∈ adjoin A {b | b ^ ↑1 = 1}
      exact ⟨⟨0, IsPrimitiveRoot.of_subsingleton 0⟩,
        fun x => by convert (mem_top (R := A) : x ∈ ⊤)⟩
#align is_cyclotomic_extension.subsingleton_iff IsCyclotomicExtension.subsingleton_iff

/-- If `B` is a cyclotomic extension of `A` given by roots of unity of order in `S ∪ T`, then `B`
is a cyclotomic extension of `adjoin A { b : B | ∃ a : ℕ+, a ∈ S ∧ b ^ (a : ℕ) = 1 } ` given by
roots of unity of order in `T`. -/
theorem union_right [h : IsCyclotomicExtension (S ∪ T) A B] :
    IsCyclotomicExtension T (adjoin A {b : B | ∃ a : ℕ+, a ∈ S ∧ b ^ (a : ℕ) = 1}) B := by
  have : {b : B | ∃ n : ℕ+, n ∈ S ∪ T ∧ b ^ (n : ℕ) = 1} =
      {b : B | ∃ n : ℕ+, n ∈ S ∧ b ^ (n : ℕ) = 1} ∪
        {b : B | ∃ n : ℕ+, n ∈ T ∧ b ^ (n : ℕ) = 1} := by
    refine' le_antisymm _ _
    · rintro x ⟨n, hn₁ | hn₂, hnpow⟩
      · left; exact ⟨n, hn₁, hnpow⟩
      · right; exact ⟨n, hn₂, hnpow⟩
    · rintro x (⟨n, hn⟩ | ⟨n, hn⟩)
      · exact ⟨n, Or.inl hn.1, hn.2⟩
      · exact ⟨n, Or.inr hn.1, hn.2⟩
  refine' ⟨fun hn => ((IsCyclotomicExtension_iff _ A _).1 h).1 (mem_union_right S hn), fun b => _⟩
  -- ⊢ b ∈ adjoin { x // x ∈ adjoin A {b | ∃ a, a ∈ S ∧ b ^ ↑a = 1} } {b | ∃ n, n ∈ …
  replace h := ((IsCyclotomicExtension_iff _ _ _).1 h).2 b
  -- ⊢ b ∈ adjoin { x // x ∈ adjoin A {b | ∃ a, a ∈ S ∧ b ^ ↑a = 1} } {b | ∃ n, n ∈ …
  rwa [this, adjoin_union_eq_adjoin_adjoin, Subalgebra.mem_restrictScalars] at h
  -- 🎉 no goals
#align is_cyclotomic_extension.union_right IsCyclotomicExtension.union_right

/-- If `B` is a cyclotomic extension of `A` given by roots of unity of order in `T` and `S ⊆ T`,
then `adjoin A { b : B | ∃ a : ℕ+, a ∈ S ∧ b ^ (a : ℕ) = 1 }` is a cyclotomic extension of `B`
given by roots of unity of order in `S`. -/
theorem union_left [h : IsCyclotomicExtension T A B] (hS : S ⊆ T) :
    IsCyclotomicExtension S A (adjoin A {b : B | ∃ a : ℕ+, a ∈ S ∧ b ^ (a : ℕ) = 1}) := by
  refine' ⟨@fun n hn => _, fun b => _⟩
  -- ⊢ ∃ r, IsPrimitiveRoot r ↑n
  · obtain ⟨b, hb⟩ := ((IsCyclotomicExtension_iff _ _ _).1 h).1 (hS hn)
    -- ⊢ ∃ r, IsPrimitiveRoot r ↑n
    refine' ⟨⟨b, subset_adjoin ⟨n, hn, hb.pow_eq_one⟩⟩, _⟩
    -- ⊢ IsPrimitiveRoot { val := b, property := (_ : b ∈ ↑(adjoin A {b | ∃ a, a ∈ S  …
    rwa [← IsPrimitiveRoot.coe_submonoidClass_iff, Subtype.coe_mk]
    -- 🎉 no goals
  · convert mem_top (R := A) (x := b)
    -- ⊢ adjoin A {b | ∃ n, n ∈ S ∧ b ^ ↑n = 1} = ⊤
    rw [← adjoin_adjoin_coe_preimage, preimage_setOf_eq]
    -- ⊢ adjoin A {b | ∃ n, n ∈ S ∧ b ^ ↑n = 1} = adjoin A {a | ∃ a_1, a_1 ∈ S ∧ ↑a ^ …
    norm_cast
    -- 🎉 no goals
#align is_cyclotomic_extension.union_left IsCyclotomicExtension.union_left

variable {n S}

/-- If `∀ s ∈ S, n ∣ s` and `S` is not empty, then `IsCyclotomicExtension S A B` implies
`IsCyclotomicExtension (S ∪ {n}) A B`. -/
theorem of_union_of_dvd (h : ∀ s ∈ S, n ∣ s) (hS : S.Nonempty) [H : IsCyclotomicExtension S A B] :
    IsCyclotomicExtension (S ∪ {n}) A B := by
  refine' (iff_adjoin_eq_top _ A _).2 ⟨fun s hs => _, _⟩
  -- ⊢ ∃ r, IsPrimitiveRoot r ↑s
  · rw [mem_union, mem_singleton_iff] at hs
    -- ⊢ ∃ r, IsPrimitiveRoot r ↑s
    obtain hs | rfl := hs
    -- ⊢ ∃ r, IsPrimitiveRoot r ↑s
    · exact H.exists_prim_root hs
      -- 🎉 no goals
    · obtain ⟨m, hm⟩ := hS
      -- ⊢ ∃ r, IsPrimitiveRoot r ↑s
      obtain ⟨x, rfl⟩ := h m hm
      -- ⊢ ∃ r, IsPrimitiveRoot r ↑s
      obtain ⟨ζ, hζ⟩ := H.exists_prim_root hm
      -- ⊢ ∃ r, IsPrimitiveRoot r ↑s
      refine' ⟨ζ ^ (x : ℕ), _⟩
      -- ⊢ IsPrimitiveRoot (ζ ^ ↑x) ↑s
      convert hζ.pow_of_dvd x.ne_zero (dvd_mul_left (x : ℕ) s)
      -- ⊢ ↑s = ↑(s * x) / ↑x
      simp only [PNat.mul_coe, Nat.mul_div_left, PNat.pos]
      -- 🎉 no goals
  · refine' _root_.eq_top_iff.2 _
    -- ⊢ ⊤ ≤ adjoin A {b | ∃ n_1, n_1 ∈ S ∪ {n} ∧ b ^ ↑n_1 = 1}
    rw [← ((iff_adjoin_eq_top S A B).1 H).2]
    -- ⊢ adjoin A {b | ∃ n, n ∈ S ∧ b ^ ↑n = 1} ≤ adjoin A {b | ∃ n_1, n_1 ∈ S ∪ {n}  …
    refine' adjoin_mono fun x hx => _
    -- ⊢ x ∈ {b | ∃ n_1, n_1 ∈ S ∪ {n} ∧ b ^ ↑n_1 = 1}
    simp only [union_singleton, mem_insert_iff, mem_setOf_eq] at hx ⊢
    -- ⊢ ∃ n_1, (n_1 = n ∨ n_1 ∈ S) ∧ x ^ ↑n_1 = 1
    obtain ⟨m, hm⟩ := hx
    -- ⊢ ∃ n_1, (n_1 = n ∨ n_1 ∈ S) ∧ x ^ ↑n_1 = 1
    exact ⟨m, ⟨Or.inr hm.1, hm.2⟩⟩
    -- 🎉 no goals
#align is_cyclotomic_extension.of_union_of_dvd IsCyclotomicExtension.of_union_of_dvd

/-- If `∀ s ∈ S, n ∣ s` and `S` is not empty, then `IsCyclotomicExtension S A B` if and only if
`IsCyclotomicExtension (S ∪ {n}) A B`. -/
theorem iff_union_of_dvd (h : ∀ s ∈ S, n ∣ s) (hS : S.Nonempty) :
    IsCyclotomicExtension S A B ↔ IsCyclotomicExtension (S ∪ {n}) A B := by
  refine'
    ⟨fun H => of_union_of_dvd A B h hS, fun H => (iff_adjoin_eq_top _ A _).2 ⟨fun s hs => _, _⟩⟩
  · exact H.exists_prim_root (subset_union_left _ _ hs)
    -- 🎉 no goals
  · rw [_root_.eq_top_iff, ← ((iff_adjoin_eq_top _ A B).1 H).2]
    -- ⊢ adjoin A {b | ∃ n_1, n_1 ∈ S ∪ {n} ∧ b ^ ↑n_1 = 1} ≤ adjoin A {b | ∃ n, n ∈  …
    refine' adjoin_mono fun x hx => _
    -- ⊢ x ∈ {b | ∃ n, n ∈ S ∧ b ^ ↑n = 1}
    simp only [union_singleton, mem_insert_iff, mem_setOf_eq] at hx ⊢
    -- ⊢ ∃ n, n ∈ S ∧ x ^ ↑n = 1
    obtain ⟨m, rfl | hm, hxpow⟩ := hx
    -- ⊢ ∃ n, n ∈ S ∧ x ^ ↑n = 1
    · obtain ⟨y, hy⟩ := hS
      -- ⊢ ∃ n, n ∈ S ∧ x ^ ↑n = 1
      refine' ⟨y, ⟨hy, _⟩⟩
      -- ⊢ x ^ ↑y = 1
      obtain ⟨z, rfl⟩ := h y hy
      -- ⊢ x ^ ↑(m * z) = 1
      simp only [PNat.mul_coe, pow_mul, hxpow, one_pow]
      -- 🎉 no goals
    · exact ⟨m, ⟨hm, hxpow⟩⟩
      -- 🎉 no goals
#align is_cyclotomic_extension.iff_union_of_dvd IsCyclotomicExtension.iff_union_of_dvd

variable (n S)

/-- `IsCyclotomicExtension S A B` is equivalent to `IsCyclotomicExtension (S ∪ {1}) A B`. -/
theorem iff_union_singleton_one :
    IsCyclotomicExtension S A B ↔ IsCyclotomicExtension (S ∪ {1}) A B := by
  obtain hS | rfl := S.eq_empty_or_nonempty.symm
  -- ⊢ IsCyclotomicExtension S A B ↔ IsCyclotomicExtension (S ∪ {1}) A B
  · exact iff_union_of_dvd _ _ (fun s _ => one_dvd _) hS
    -- 🎉 no goals
  rw [empty_union]
  -- ⊢ IsCyclotomicExtension ∅ A B ↔ IsCyclotomicExtension {1} A B
  refine' ⟨fun H => _, fun H => _⟩
  -- ⊢ IsCyclotomicExtension {1} A B
  · refine' (iff_adjoin_eq_top _ A _).2 ⟨fun s hs => ⟨1, by simp [mem_singleton_iff.1 hs]⟩, _⟩
    -- ⊢ adjoin A {b | ∃ n, n ∈ {1} ∧ b ^ ↑n = 1} = ⊤
    simp [adjoin_singleton_one, empty]
    -- 🎉 no goals
  · refine' (iff_adjoin_eq_top _ A _).2 ⟨fun s hs => (not_mem_empty s hs).elim, _⟩
    -- ⊢ adjoin A {b | ∃ n, n ∈ ∅ ∧ b ^ ↑n = 1} = ⊤
    simp [@singleton_one A B _ _ _ H]
    -- 🎉 no goals
#align is_cyclotomic_extension.iff_union_singleton_one IsCyclotomicExtension.iff_union_singleton_one

variable {A B}

/-- If `(⊥ : SubAlgebra A B) = ⊤`, then `IsCyclotomicExtension {1} A B`. -/
theorem singleton_one_of_bot_eq_top (h : (⊥ : Subalgebra A B) = ⊤) :
    IsCyclotomicExtension {1} A B := by
  convert (iff_union_singleton_one _ A _).1 (singleton_zero_of_bot_eq_top h)
  -- ⊢ {1} = ∅ ∪ {1}
  simp
  -- 🎉 no goals
#align is_cyclotomic_extension.singleton_one_of_bot_eq_top IsCyclotomicExtension.singleton_one_of_bot_eq_top

/-- If `Function.Surjective (algebraMap A B)`, then `IsCyclotomicExtension {1} A B`. -/
theorem singleton_one_of_algebraMap_bijective (h : Function.Surjective (algebraMap A B)) :
    IsCyclotomicExtension {1} A B :=
  singleton_one_of_bot_eq_top (surjective_algebraMap_iff.1 h).symm
#align is_cyclotomic_extension.singleton_one_of_algebra_map_bijective IsCyclotomicExtension.singleton_one_of_algebraMap_bijective

variable (A B)

/-- Given `(f : B ≃ₐ[A] C)`, if `IsCyclotomicExtension S A B` then
`IsCyclotomicExtension S A C`. -/
protected
theorem equiv {C : Type*} [CommRing C] [Algebra A C] [h : IsCyclotomicExtension S A B]
    (f : B ≃ₐ[A] C) : IsCyclotomicExtension S A C := by
  letI : Algebra B C := f.toAlgHom.toRingHom.toAlgebra
  -- ⊢ IsCyclotomicExtension S A C
  haveI : IsCyclotomicExtension {1} B C := singleton_one_of_algebraMap_bijective f.surjective
  -- ⊢ IsCyclotomicExtension S A C
  haveI : IsScalarTower A B C := IsScalarTower.of_ring_hom f.toAlgHom
  -- ⊢ IsCyclotomicExtension S A C
  exact (iff_union_singleton_one _ _ _).2 (trans S {1} A B C f.injective)
  -- 🎉 no goals
#align is_cyclotomic_extension.equiv IsCyclotomicExtension.equiv

protected
theorem neZero [h : IsCyclotomicExtension {n} A B] [IsDomain B] : NeZero ((n : ℕ) : B) := by
  obtain ⟨⟨r, hr⟩, -⟩ := (iff_singleton n A B).1 h
  -- ⊢ NeZero ↑↑n
  exact hr.neZero'
  -- 🎉 no goals
#align is_cyclotomic_extension.ne_zero IsCyclotomicExtension.neZero

protected
theorem neZero' [IsCyclotomicExtension {n} A B] [IsDomain B] : NeZero ((n : ℕ) : A) := by
  haveI := IsCyclotomicExtension.neZero n A B
  -- ⊢ NeZero ↑↑n
  exact NeZero.nat_of_neZero (algebraMap A B)
  -- 🎉 no goals
#align is_cyclotomic_extension.ne_zero' IsCyclotomicExtension.neZero'

end Basic

section Fintype

theorem finite_of_singleton [IsDomain B] [h : IsCyclotomicExtension {n} A B] :
    Module.Finite A B := by
  classical
  rw [Module.finite_def, ← top_toSubmodule, ← ((iff_adjoin_eq_top _ _ _).1 h).2]
  refine' FG_adjoin_of_finite _ fun b hb => _
  · simp only [mem_singleton_iff, exists_eq_left]
    have : {b : B | b ^ (n : ℕ) = 1} = (nthRoots n (1 : B)).toFinset :=
      Set.ext fun x => ⟨fun h => by simpa using h, fun h => by simpa using h⟩
    rw [this]
    exact (nthRoots (↑n) 1).toFinset.finite_toSet
  · simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq] at hb
    refine' ⟨X ^ (n : ℕ) - 1, ⟨monic_X_pow_sub_C _ n.pos.ne.symm, by simp [hb]⟩⟩
#align is_cyclotomic_extension.finite_of_singleton IsCyclotomicExtension.finite_of_singleton

/-- If `S` is finite and `IsCyclotomicExtension S A B`, then `B` is a finite `A`-algebra. -/
protected
theorem finite [IsDomain B] [h₁ : Finite S] [h₂ : IsCyclotomicExtension S A B] :
    Module.Finite A B := by
  cases' nonempty_fintype S with h
  -- ⊢ Module.Finite A B
  revert h₂ A B
  -- ⊢ ∀ (A : Type u) (B : Type v) [inst : CommRing A] [inst_1 : CommRing B] [inst_ …
  refine' Set.Finite.induction_on (Set.Finite.intro h) (fun A B => _) @fun n S _ _ H A B => _
  -- ⊢ ∀ [inst : CommRing A] [inst_1 : CommRing B] [inst_2 : Algebra A B] [inst_3 : …
  · intro _ _ _ _ _
    -- ⊢ Module.Finite A B
    refine' Module.finite_def.2 ⟨({1} : Finset B), _⟩
    -- ⊢ Submodule.span A ↑{1} = ⊤
    simp [← top_toSubmodule, ← empty, toSubmodule_bot]
    -- 🎉 no goals
  · intro _ _ _ _ h
    -- ⊢ Module.Finite A B
    haveI : IsCyclotomicExtension S A (adjoin A {b : B | ∃ n : ℕ+, n ∈ S ∧ b ^ (n : ℕ) = 1}) :=
      union_left _ (insert n S) _ _ (subset_insert n S)
    haveI := H A (adjoin A {b : B | ∃ n : ℕ+, n ∈ S ∧ b ^ (n : ℕ) = 1})
    -- ⊢ Module.Finite A B
    have : Module.Finite (adjoin A {b : B | ∃ n : ℕ+, n ∈ S ∧ b ^ (n : ℕ) = 1}) B := by
      rw [← union_singleton] at h
      letI := @union_right S {n} A B _ _ _ h
      exact finite_of_singleton n _ _
    exact Module.Finite.trans (adjoin A {b : B | ∃ n : ℕ+, n ∈ S ∧ b ^ (n : ℕ) = 1}) _
    -- 🎉 no goals
#align is_cyclotomic_extension.finite IsCyclotomicExtension.finite

/-- A cyclotomic finite extension of a number field is a number field. -/
theorem numberField [h : NumberField K] [Finite S] [IsCyclotomicExtension S K L] : NumberField L :=
  { to_charZero := charZero_of_injective_algebraMap (algebraMap K L).injective
    to_finiteDimensional := by
      haveI := charZero_of_injective_algebraMap (algebraMap K L).injective
      -- ⊢ FiniteDimensional ℚ L
      haveI := IsCyclotomicExtension.finite S K L
      -- ⊢ FiniteDimensional ℚ L
      exact Module.Finite.trans K _ }
      -- 🎉 no goals
#align is_cyclotomic_extension.number_field IsCyclotomicExtension.numberField

/-- A finite cyclotomic extension of an integral noetherian domain is integral -/
theorem integral [IsDomain B] [IsNoetherianRing A] [Finite S] [IsCyclotomicExtension S A B] :
    Algebra.IsIntegral A B :=
  letI := IsCyclotomicExtension.finite S A B; isIntegral_of_noetherian <|
    isNoetherian_of_isNoetherianRing_of_finite A B
#align is_cyclotomic_extension.integral IsCyclotomicExtension.integral

/-- If `S` is finite and `IsCyclotomicExtension S K A`, then `finiteDimensional K A`. -/
theorem finiteDimensional (C : Type z) [Finite S] [CommRing C] [Algebra K C] [IsDomain C]
    [IsCyclotomicExtension S K C] : FiniteDimensional K C :=
  IsCyclotomicExtension.finite S K C
#align is_cyclotomic_extension.finite_dimensional IsCyclotomicExtension.finiteDimensional

end Fintype

section

variable {A B}

theorem adjoin_roots_cyclotomic_eq_adjoin_nth_roots [IsDomain B] {ζ : B} {n : ℕ+}
    (hζ : IsPrimitiveRoot ζ n) :
    adjoin A ((cyclotomic n A).rootSet B) =
      adjoin A {b : B | ∃ a : ℕ+, a ∈ ({n} : Set ℕ+) ∧ b ^ (a : ℕ) = 1} := by
  simp only [mem_singleton_iff, exists_eq_left, map_cyclotomic]
  -- ⊢ adjoin A (rootSet (cyclotomic (↑n) A) B) = adjoin A {b | b ^ ↑n = 1}
  refine' le_antisymm (adjoin_mono fun x hx => _) (adjoin_le fun x hx => _)
  -- ⊢ x ∈ {b | b ^ ↑n = 1}
  · rw [mem_rootSet'] at hx
    -- ⊢ x ∈ {b | b ^ ↑n = 1}
    simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq]
    -- ⊢ x ^ ↑n = 1
    rw [isRoot_of_unity_iff n.pos]
    -- ⊢ ∃ i, i ∈ Nat.divisors ↑n ∧ IsRoot (cyclotomic i B) x
    refine' ⟨n, Nat.mem_divisors_self n n.ne_zero, _⟩
    -- ⊢ IsRoot (cyclotomic (↑n) B) x
    rw [IsRoot.def, ← map_cyclotomic n (algebraMap A B), eval_map, ← aeval_def]
    -- ⊢ ↑(aeval x) (cyclotomic (↑n) A) = 0
    exact hx.2
    -- 🎉 no goals
  · simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq] at hx
    -- ⊢ x ∈ ↑(adjoin A (rootSet (cyclotomic (↑n) A) B))
    obtain ⟨i, _, rfl⟩ := hζ.eq_pow_of_pow_eq_one hx n.pos
    -- ⊢ ζ ^ i ∈ ↑(adjoin A (rootSet (cyclotomic (↑n) A) B))
    refine' SetLike.mem_coe.2 (Subalgebra.pow_mem _ (subset_adjoin _) _)
    -- ⊢ ζ ∈ rootSet (cyclotomic (↑n) A) B
    rw [mem_rootSet', map_cyclotomic, aeval_def, ← eval_map, map_cyclotomic, ← IsRoot]
    -- ⊢ cyclotomic (↑n) B ≠ 0 ∧ IsRoot (cyclotomic (↑n) B) ζ
    refine' ⟨cyclotomic_ne_zero n B, hζ.isRoot_cyclotomic n.pos⟩
    -- 🎉 no goals
#align is_cyclotomic_extension.adjoin_roots_cyclotomic_eq_adjoin_nth_roots IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_nth_roots

theorem adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic {n : ℕ+} [IsDomain B] {ζ : B}
    (hζ : IsPrimitiveRoot ζ n) : adjoin A ((cyclotomic n A).rootSet B) = adjoin A {ζ} := by
  refine' le_antisymm (adjoin_le fun x hx => _) (adjoin_mono fun x hx => _)
  -- ⊢ x ∈ ↑(adjoin A {ζ})
  · suffices hx : x ^ n.1 = 1
    -- ⊢ x ∈ ↑(adjoin A {ζ})
    obtain ⟨i, _, rfl⟩ := hζ.eq_pow_of_pow_eq_one hx n.pos
    -- ⊢ ζ ^ i ∈ ↑(adjoin A {ζ})
    exact SetLike.mem_coe.2 (Subalgebra.pow_mem _ (subset_adjoin <| mem_singleton ζ) _)
    -- ⊢ x ^ ↑n = 1
    refine' (isRoot_of_unity_iff n.pos B).2 _
    -- ⊢ ∃ i, i ∈ Nat.divisors ↑n ∧ IsRoot (cyclotomic i B) x
    refine' ⟨n, Nat.mem_divisors_self n n.ne_zero, _⟩
    -- ⊢ IsRoot (cyclotomic (↑n) B) x
    rw [mem_rootSet', aeval_def, ← eval_map, map_cyclotomic, ← IsRoot] at hx
    -- ⊢ IsRoot (cyclotomic (↑n) B) x
    exact hx.2
    -- 🎉 no goals
  · simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq] at hx
    -- ⊢ x ∈ rootSet (cyclotomic (↑n) A) B
    simpa only [hx, mem_rootSet', map_cyclotomic, aeval_def, ← eval_map, IsRoot] using
      And.intro (cyclotomic_ne_zero n B) (hζ.isRoot_cyclotomic n.pos)
#align is_cyclotomic_extension.adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic

theorem adjoin_primitive_root_eq_top {n : ℕ+} [IsDomain B] [h : IsCyclotomicExtension {n} A B]
    {ζ : B} (hζ : IsPrimitiveRoot ζ n) : adjoin A ({ζ} : Set B) = ⊤ := by
  classical
  rw [← adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic hζ]
  rw [adjoin_roots_cyclotomic_eq_adjoin_nth_roots hζ]
  exact ((iff_adjoin_eq_top {n} A B).mp h).2
#align is_cyclotomic_extension.adjoin_primitive_root_eq_top IsCyclotomicExtension.adjoin_primitive_root_eq_top

variable (A)

theorem _root_.IsPrimitiveRoot.adjoin_isCyclotomicExtension {ζ : B} {n : ℕ+}
    (h : IsPrimitiveRoot ζ n) : IsCyclotomicExtension {n} A (adjoin A ({ζ} : Set B)) :=
  { exists_prim_root := fun hi => by
      rw [Set.mem_singleton_iff] at hi
      -- ⊢ ∃ r, IsPrimitiveRoot r ↑n✝
      refine' ⟨⟨ζ, subset_adjoin <| Set.mem_singleton ζ⟩, _⟩
      -- ⊢ IsPrimitiveRoot { val := ζ, property := (_ : ζ ∈ ↑(adjoin A {ζ})) } ↑n✝
      rwa [← IsPrimitiveRoot.coe_submonoidClass_iff, Subtype.coe_mk, hi]
      -- 🎉 no goals
    adjoin_roots := fun x => by
      refine
        adjoin_induction'
          (x := x) (fun b hb => ?_) (fun a => ?_) (fun b₁ b₂ hb₁ hb₂ => ?_)
          (fun b₁ b₂ hb₁ hb₂ => ?_)
      · rw [Set.mem_singleton_iff] at hb
        -- ⊢ { val := b, property := (_ : b ∈ ↑(adjoin A {ζ})) } ∈ adjoin A {b | ∃ n_1, n …
        refine' subset_adjoin _
        -- ⊢ { val := b, property := (_ : b ∈ ↑(adjoin A {ζ})) } ∈ {b | ∃ n_1, n_1 ∈ {n}  …
        simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq, hb]
        -- ⊢ { val := ζ, property := (_ : (fun x => x ∈ adjoin A {ζ}) ζ) } ^ ↑n = 1
        rw [← Subalgebra.coe_eq_one, Subalgebra.coe_pow, Subtype.coe_mk]
        -- ⊢ ζ ^ ↑n = 1
        exact ((IsPrimitiveRoot.iff_def ζ n).1 h).1
        -- 🎉 no goals
      · exact Subalgebra.algebraMap_mem _ _
        -- 🎉 no goals
      · exact Subalgebra.add_mem _ hb₁ hb₂
        -- 🎉 no goals
      · exact Subalgebra.mul_mem _ hb₁ hb₂ }
        -- 🎉 no goals
#align is_primitive_root.adjoin_is_cyclotomic_extension IsPrimitiveRoot.adjoin_isCyclotomicExtension

end

section Field

variable {n S}

/-- A cyclotomic extension splits `X ^ n - 1` if `n ∈ S`.-/
theorem splits_X_pow_sub_one [H : IsCyclotomicExtension S K L] (hS : n ∈ S) :
    Splits (algebraMap K L) (X ^ (n : ℕ) - 1) := by
  rw [← splits_id_iff_splits, Polynomial.map_sub, Polynomial.map_one, Polynomial.map_pow,
    Polynomial.map_X]
  obtain ⟨z, hz⟩ := ((IsCyclotomicExtension_iff _ _ _).1 H).1 hS
  -- ⊢ Splits (RingHom.id L) (X ^ ↑n - 1)
  exact X_pow_sub_one_splits hz
  -- 🎉 no goals
set_option linter.uppercaseLean3 false in
#align is_cyclotomic_extension.splits_X_pow_sub_one IsCyclotomicExtension.splits_X_pow_sub_one

/-- A cyclotomic extension splits `cyclotomic n K` if `n ∈ S` and `ne_zero (n : K)`.-/
theorem splits_cyclotomic [IsCyclotomicExtension S K L] (hS : n ∈ S) :
    Splits (algebraMap K L) (cyclotomic n K) := by
  refine' splits_of_splits_of_dvd _ (X_pow_sub_C_ne_zero n.pos _) (splits_X_pow_sub_one K L hS) _
  -- ⊢ cyclotomic (↑n) K ∣ X ^ ↑n - ↑C 1
  use ∏ i : ℕ in (n : ℕ).properDivisors, Polynomial.cyclotomic i K
  -- ⊢ X ^ ↑n - ↑C 1 = cyclotomic (↑n) K * ∏ i in Nat.properDivisors ↑n, cyclotomic …
  rw [(eq_cyclotomic_iff n.pos _).1 rfl, RingHom.map_one]
  -- 🎉 no goals
#align is_cyclotomic_extension.splits_cyclotomic IsCyclotomicExtension.splits_cyclotomic

variable (n S)

section Singleton

variable [IsCyclotomicExtension {n} K L]

/-- If `IsCyclotomicExtension {n} K L`, then `L` is the splitting field of `X ^ n - 1`. -/
theorem isSplittingField_X_pow_sub_one : IsSplittingField K L (X ^ (n : ℕ) - 1) :=
  { splits' := splits_X_pow_sub_one K L (mem_singleton n)
    adjoin_rootSet' := by
      rw [← ((iff_adjoin_eq_top {n} K L).1 inferInstance).2]
      -- ⊢ adjoin K (rootSet (X ^ ↑n - 1) L) = adjoin K {b | ∃ n_1, n_1 ∈ {n} ∧ b ^ ↑n_ …
      congr
      -- ⊢ rootSet (X ^ ↑n - 1) L = {b | ∃ n_1, n_1 ∈ {n} ∧ b ^ ↑n_1 = 1}
      refine' Set.ext fun x => _
      -- ⊢ x ∈ rootSet (X ^ ↑n - 1) L ↔ x ∈ {b | ∃ n_1, n_1 ∈ {n} ∧ b ^ ↑n_1 = 1}
      simp only [Polynomial.map_pow, mem_singleton_iff, Multiset.mem_toFinset, exists_eq_left,
        mem_setOf_eq, Polynomial.map_X, Polynomial.map_one, Finset.mem_coe, Polynomial.map_sub]
      simp only [mem_rootSet', map_sub, map_pow, aeval_one, aeval_X, sub_eq_zero, map_X,
        and_iff_right_iff_imp, Polynomial.map_sub, Polynomial.map_pow, Polynomial.map_one]
      exact fun _ => X_pow_sub_C_ne_zero n.pos (1 : L) }
      -- 🎉 no goals
set_option linter.uppercaseLean3 false in
#align is_cyclotomic_extension.splitting_field_X_pow_sub_one
       IsCyclotomicExtension.isSplittingField_X_pow_sub_one

/-- Any two `n`-th cyclotomic extensions are isomorphic. -/
def algEquiv (L' : Type*) [Field L'] [Algebra K L'] [IsCyclotomicExtension {n} K L'] :
    L ≃ₐ[K] L' :=
  let h₁ := isSplittingField_X_pow_sub_one n K L
  let h₂ := isSplittingField_X_pow_sub_one n K L'
  (@IsSplittingField.algEquiv K L _ _ _ (X ^ (n : ℕ) - 1) h₁).trans
    (@IsSplittingField.algEquiv K L' _ _ _ (X ^ (n : ℕ) - 1) h₂).symm
#align is_cyclotomic_extension.alg_equiv IsCyclotomicExtension.algEquiv

scoped[Cyclotomic] attribute [instance] IsCyclotomicExtension.isSplittingField_X_pow_sub_one

theorem isGalois : IsGalois K L :=
  letI := isSplittingField_X_pow_sub_one n K L
  IsGalois.of_separable_splitting_field (X_pow_sub_one_separable_iff.2
    (IsCyclotomicExtension.neZero' n K L).1)
#align is_cyclotomic_extension.is_galois IsCyclotomicExtension.isGalois

/-- If `IsCyclotomicExtension {n} K L`, then `L` is the splitting field of `cyclotomic n K`. -/
theorem splitting_field_cyclotomic : IsSplittingField K L (cyclotomic n K) :=
  { splits' := splits_cyclotomic K L (mem_singleton n)
    adjoin_rootSet' := by
      rw [← ((iff_adjoin_eq_top {n} K L).1 inferInstance).2]
      -- ⊢ adjoin K (rootSet (cyclotomic (↑n) K) L) = adjoin K {b | ∃ n_1, n_1 ∈ {n} ∧  …
      letI := Classical.decEq L
      -- ⊢ adjoin K (rootSet (cyclotomic (↑n) K) L) = adjoin K {b | ∃ n_1, n_1 ∈ {n} ∧  …
      -- todo: make `exists_prim_root` take an explicit `L`
      obtain ⟨ζ : L, hζ⟩ := IsCyclotomicExtension.exists_prim_root K (B := L) (mem_singleton n)
      -- ⊢ adjoin K (rootSet (cyclotomic (↑n) K) L) = adjoin K {b | ∃ n_1, n_1 ∈ {n} ∧  …
      exact adjoin_roots_cyclotomic_eq_adjoin_nth_roots hζ }
      -- 🎉 no goals
#align is_cyclotomic_extension.splitting_field_cyclotomic IsCyclotomicExtension.splitting_field_cyclotomic

scoped[Cyclotomic] attribute [instance] IsCyclotomicExtension.splitting_field_cyclotomic

end Singleton

end Field

end IsCyclotomicExtension

section CyclotomicField

/-- Given `n : ℕ+` and a field `K`, we define `CyclotomicField n K` as the
splitting field of `cyclotomic n K`. If `n` is nonzero in `K`, it has
the instance `IsCyclotomicExtension {n} K (CyclotomicField n K)`. -/
def CyclotomicField : Type w :=
  (cyclotomic n K).SplittingField
#align cyclotomic_field CyclotomicField

namespace CyclotomicField

--Porting note: could not be derived
instance : Field (CyclotomicField n K) := by
  delta CyclotomicField; infer_instance
  -- ⊢ Field (SplittingField (cyclotomic (↑n) K))
                         -- 🎉 no goals

--Porting note: could not be derived
instance algebra : Algebra K (CyclotomicField n K) := by
  delta CyclotomicField; infer_instance
  -- ⊢ Algebra K (SplittingField (cyclotomic (↑n) K))
                         -- 🎉 no goals

--Porting note: could not be derived
instance : Inhabited (CyclotomicField n K) := by
  delta CyclotomicField; infer_instance
  -- ⊢ Inhabited (SplittingField (cyclotomic (↑n) K))
                         -- 🎉 no goals

instance [CharZero K] : CharZero (CyclotomicField n K) :=
  charZero_of_injective_algebraMap (algebraMap K _).injective

instance isCyclotomicExtension [NeZero ((n : ℕ) : K)] :
    IsCyclotomicExtension {n} K (CyclotomicField n K) := by
  haveI : NeZero ((n : ℕ) : CyclotomicField n K) :=
    NeZero.nat_of_injective (algebraMap K _).injective
  letI := Classical.decEq (CyclotomicField n K)
  -- ⊢ IsCyclotomicExtension {n} K (CyclotomicField n K)
  obtain ⟨ζ, hζ⟩ :=
    exists_root_of_splits (algebraMap K (CyclotomicField n K)) (SplittingField.splits _)
      (degree_cyclotomic_pos n K n.pos).ne'
  rw [← eval_map, ← IsRoot.def, map_cyclotomic, isRoot_cyclotomic_iff] at hζ
  -- ⊢ IsCyclotomicExtension {n} K (CyclotomicField n K)
-- Porting note: the first `?_` was `forall_eq.2 ⟨ζ, hζ⟩` that now fails.
  refine ⟨?_, ?_⟩
  -- ⊢ ∀ {n_1 : ℕ+}, n_1 ∈ {n} → ∃ r, IsPrimitiveRoot r ↑n_1
  · simp only [mem_singleton_iff, forall_eq]
    -- ⊢ ∃ r, IsPrimitiveRoot r ↑n
    exact ⟨ζ, hζ⟩
    -- 🎉 no goals
  · rw [← Algebra.eq_top_iff, ← SplittingField.adjoin_rootSet, eq_comm]
    -- ⊢ adjoin K (rootSet (cyclotomic (↑n) K) (SplittingField (cyclotomic (↑n) K)))  …
    exact IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_nth_roots hζ
    -- 🎉 no goals
#align cyclotomic_field.is_cyclotomic_extension CyclotomicField.isCyclotomicExtension

end CyclotomicField

end CyclotomicField

section IsDomain

variable [Algebra A K] [IsFractionRing A K]

section CyclotomicRing

/-- If `K` is the fraction field of `A`, the `A`-algebra structure on `CyclotomicField n K`.
-/
@[nolint unusedArguments]
instance CyclotomicField.algebraBase : Algebra A (CyclotomicField n K) :=
  SplittingField.algebra' (cyclotomic n K)
#align cyclotomic_field.algebra_base CyclotomicField.algebraBase

/-- Ensure there are no diamonds when `A = ℤ`. -/
example : algebraInt (CyclotomicField n ℚ) = CyclotomicField.algebraBase _ _ _ :=
  rfl

instance CyclotomicField.algebra' {R : Type*} [CommRing R] [Algebra R K] :
    Algebra R (CyclotomicField n K) :=
  SplittingField.algebra' (cyclotomic n K)
#align cyclotomic_field.algebra' CyclotomicField.algebra'

instance {R : Type*} [CommRing R] [Algebra R K] : IsScalarTower R K (CyclotomicField n K) :=
  SplittingField.isScalarTower _

instance CyclotomicField.noZeroSMulDivisors : NoZeroSMulDivisors A (CyclotomicField n K) := by
  refine' NoZeroSMulDivisors.of_algebraMap_injective _
  -- ⊢ Function.Injective ↑(algebraMap A (CyclotomicField n K))
  rw [IsScalarTower.algebraMap_eq A K (CyclotomicField n K)]
  -- ⊢ Function.Injective ↑(RingHom.comp (algebraMap K (CyclotomicField n K)) (alge …
  exact
    (Function.Injective.comp (NoZeroSMulDivisors.algebraMap_injective K (CyclotomicField n K))
      (IsFractionRing.injective A K) : _)
#align cyclotomic_field.no_zero_smul_divisors CyclotomicField.noZeroSMulDivisors

/-- If `A` is a domain with fraction field `K` and `n : ℕ+`, we define `CyclotomicRing n A K` as
the `A`-subalgebra of `CyclotomicField n K` generated by the roots of `X ^ n - 1`. If `n`
is nonzero in `A`, it has the instance `IsCyclotomicExtension {n} A (CyclotomicRing n A K)`. -/
@[nolint unusedArguments]
def CyclotomicRing : Type w :=
  adjoin A {b : CyclotomicField n K | b ^ (n : ℕ) = 1}
--deriving CommRing, IsDomain, Inhabited
#align cyclotomic_ring CyclotomicRing

namespace CyclotomicRing

--Porting note: could not be derived
instance : CommRing (CyclotomicRing n A K) := by
  delta CyclotomicRing; infer_instance
  -- ⊢ CommRing { x // x ∈ adjoin A {b | b ^ ↑n = 1} }
                        -- 🎉 no goals

--Porting note: could not be derived
instance : IsDomain (CyclotomicRing n A K) := by
  delta CyclotomicRing; infer_instance
  -- ⊢ IsDomain { x // x ∈ adjoin A {b | b ^ ↑n = 1} }
                        -- 🎉 no goals

--Porting note: could not be derived
instance : Inhabited (CyclotomicRing n A K) := by
  delta CyclotomicRing; infer_instance
  -- ⊢ Inhabited { x // x ∈ adjoin A {b | b ^ ↑n = 1} }
                        -- 🎉 no goals

/-- The `A`-algebra structure on `CyclotomicRing n A K`. -/
instance algebraBase : Algebra A (CyclotomicRing n A K) :=
  (adjoin A _).algebra
#align cyclotomic_ring.algebra_base CyclotomicRing.algebraBase

-- Ensure that there is no diamonds with ℤ.
example {n : ℕ+} : CyclotomicRing.algebraBase n ℤ ℚ = algebraInt _ :=
  rfl

instance : NoZeroSMulDivisors A (CyclotomicRing n A K) :=
  (adjoin A _).noZeroSMulDivisors_bot

theorem algebraBase_injective : Function.Injective <| algebraMap A (CyclotomicRing n A K) :=
  NoZeroSMulDivisors.algebraMap_injective _ _
#align cyclotomic_ring.algebra_base_injective CyclotomicRing.algebraBase_injective

instance : Algebra (CyclotomicRing n A K) (CyclotomicField n K) :=
  (adjoin A _).toAlgebra

theorem adjoin_algebra_injective :
    Function.Injective <| algebraMap (CyclotomicRing n A K) (CyclotomicField n K) :=
  Subtype.val_injective
#align cyclotomic_ring.adjoin_algebra_injective CyclotomicRing.adjoin_algebra_injective

instance : NoZeroSMulDivisors (CyclotomicRing n A K) (CyclotomicField n K) :=
  NoZeroSMulDivisors.of_algebraMap_injective (adjoin_algebra_injective n A K)

instance : IsScalarTower A (CyclotomicRing n A K) (CyclotomicField n K) :=
  IsScalarTower.subalgebra' _ _ _ _

instance isCyclotomicExtension [NeZero ((n : ℕ) : A)] :
    IsCyclotomicExtension {n} A (CyclotomicRing n A K) where
  exists_prim_root := @fun a han => by
    rw [mem_singleton_iff] at han
    -- ⊢ ∃ r, IsPrimitiveRoot r ↑a
    subst a
    -- ⊢ ∃ r, IsPrimitiveRoot r ↑n
    haveI := NeZero.of_noZeroSMulDivisors A K n
    -- ⊢ ∃ r, IsPrimitiveRoot r ↑n
    haveI := NeZero.of_noZeroSMulDivisors A (CyclotomicField n K) n
    -- ⊢ ∃ r, IsPrimitiveRoot r ↑n
    obtain ⟨μ, hμ⟩ := (CyclotomicField.isCyclotomicExtension n K).exists_prim_root (mem_singleton n)
    -- ⊢ ∃ r, IsPrimitiveRoot r ↑n
    refine' ⟨⟨μ, subset_adjoin _⟩, _⟩
    -- ⊢ μ ∈ {b | b ^ ↑n = 1}
    · apply (isRoot_of_unity_iff n.pos (CyclotomicField n K)).mpr
      -- ⊢ ∃ i, i ∈ Nat.divisors ↑n ∧ IsRoot (cyclotomic i (CyclotomicField n K)) μ
      refine' ⟨n, Nat.mem_divisors_self _ n.ne_zero, _⟩
      -- ⊢ IsRoot (cyclotomic (↑n) (CyclotomicField n K)) μ
      rwa [← isRoot_cyclotomic_iff] at hμ
      -- 🎉 no goals
    · rwa [← IsPrimitiveRoot.coe_submonoidClass_iff, Subtype.coe_mk]
      -- 🎉 no goals
  adjoin_roots x := by
    refine'
      adjoin_induction' (fun y hy => _) (fun a => _) (fun y z hy hz => _) (fun y z hy hz => _) x
    · refine' subset_adjoin _
      -- ⊢ { val := y, property := (_ : y ∈ ↑(adjoin A {b | b ^ ↑n = 1})) } ∈ {b | ∃ n_ …
      simp only [mem_singleton_iff, exists_eq_left, mem_setOf_eq]
      -- ⊢ { val := y, property := (_ : y ∈ ↑(adjoin A {b | b ^ ↑n = 1})) } ^ ↑n = 1
      rwa [← Subalgebra.coe_eq_one, Subalgebra.coe_pow, Subtype.coe_mk]
      -- 🎉 no goals
    · exact Subalgebra.algebraMap_mem _ a
      -- 🎉 no goals
    · exact Subalgebra.add_mem _ hy hz
      -- 🎉 no goals
    · exact Subalgebra.mul_mem _ hy hz
      -- 🎉 no goals
#align cyclotomic_ring.is_cyclotomic_extension CyclotomicRing.isCyclotomicExtension

instance [IsDomain A] [NeZero ((n : ℕ) : A)] :
    IsFractionRing (CyclotomicRing n A K) (CyclotomicField n K) where
  map_units' := fun ⟨x, hx⟩ => by
    rw [isUnit_iff_ne_zero]
    -- ⊢ ↑(algebraMap (CyclotomicRing n A K) (CyclotomicField n K)) ↑{ val := x, prop …
    apply map_ne_zero_of_mem_nonZeroDivisors
    -- ⊢ Function.Injective ↑(algebraMap (CyclotomicRing n A K) (CyclotomicField n K))
    apply adjoin_algebra_injective
    -- ⊢ ↑{ val := x, property := hx } ∈ nonZeroDivisors (CyclotomicRing n A K)
    exact hx
    -- 🎉 no goals
  surj' x := by
    letI : NeZero ((n : ℕ) : K) := NeZero.nat_of_injective (IsFractionRing.injective A K)
    -- ⊢ ∃ x_1, x * ↑(algebraMap (CyclotomicRing n A K) (CyclotomicField n K)) ↑x_1.s …
    refine
      Algebra.adjoin_induction
        (((IsCyclotomicExtension.iff_singleton n K (CyclotomicField n K)).1
              (CyclotomicField.isCyclotomicExtension n K)).2
          x)
        (fun y hy => ?_) (fun k => ?_) ?_ ?_
-- Porting note: the last goal was `by simpa` that now fails.
    · exact ⟨⟨⟨y, subset_adjoin hy⟩, 1⟩, by simp; rfl⟩
      -- 🎉 no goals
    · have : IsLocalization (nonZeroDivisors A) K := inferInstance
      -- ⊢ ∃ x, ↑(algebraMap K (CyclotomicField n K)) k * ↑(algebraMap (CyclotomicRing  …
      replace := this.surj
      -- ⊢ ∃ x, ↑(algebraMap K (CyclotomicField n K)) k * ↑(algebraMap (CyclotomicRing  …
      obtain ⟨⟨z, w⟩, hw⟩ := this k
      -- ⊢ ∃ x, ↑(algebraMap K (CyclotomicField n K)) k * ↑(algebraMap (CyclotomicRing  …
      refine' ⟨⟨algebraMap A (CyclotomicRing n A K) z, algebraMap A (CyclotomicRing n A K) w,
        map_mem_nonZeroDivisors _ (algebraBase_injective n A K) w.2⟩, _⟩
      letI : IsScalarTower A K (CyclotomicField n K) :=
        IsScalarTower.of_algebraMap_eq (congr_fun rfl)
      rw [← IsScalarTower.algebraMap_apply, ← IsScalarTower.algebraMap_apply,
        @IsScalarTower.algebraMap_apply A K _ _ _ _ _ (_root_.CyclotomicField.algebra n K) _ _ w,
        ← RingHom.map_mul, hw, ← IsScalarTower.algebraMap_apply]
    · rintro y z ⟨a, ha⟩ ⟨b, hb⟩
      -- ⊢ ∃ x, (y + z) * ↑(algebraMap (CyclotomicRing n A K) (CyclotomicField n K)) ↑x …
      refine' ⟨⟨a.1 * b.2 + b.1 * a.2, a.2 * b.2, mul_mem_nonZeroDivisors.2 ⟨a.2.2, b.2.2⟩⟩, _⟩
      -- ⊢ (y + z) * ↑(algebraMap (CyclotomicRing n A K) (CyclotomicField n K)) ↑(a.fst …
      rw [RingHom.map_mul, add_mul, ← mul_assoc, ha,
        mul_comm ((algebraMap (CyclotomicRing n A K) _) ↑a.2), ← mul_assoc, hb]
      simp only [map_add, map_mul]
      -- 🎉 no goals
    · rintro y z ⟨a, ha⟩ ⟨b, hb⟩
      -- ⊢ ∃ x, y * z * ↑(algebraMap (CyclotomicRing n A K) (CyclotomicField n K)) ↑x.s …
      refine' ⟨⟨a.1 * b.1, a.2 * b.2, mul_mem_nonZeroDivisors.2 ⟨a.2.2, b.2.2⟩⟩, _⟩
      -- ⊢ y * z * ↑(algebraMap (CyclotomicRing n A K) (CyclotomicField n K)) ↑(a.fst * …
      rw [RingHom.map_mul, mul_comm ((algebraMap (CyclotomicRing n A K) _) ↑a.2), mul_assoc, ←
        mul_assoc z, hb, ← mul_comm ((algebraMap (CyclotomicRing n A K) _) ↑a.2), ← mul_assoc, ha]
      simp only [map_mul]
      -- 🎉 no goals
  eq_iff_exists' := @fun x y =>
    ⟨fun h => ⟨1, by rw [adjoin_algebra_injective n A K h]⟩, fun ⟨c, hc⟩ => by
                     -- 🎉 no goals
      rw [mul_left_cancel₀ (nonZeroDivisors.ne_zero c.prop) hc]⟩
      -- 🎉 no goals

theorem eq_adjoin_primitive_root {μ : CyclotomicField n K} (h : IsPrimitiveRoot μ n) :
    CyclotomicRing n A K = adjoin A ({μ} : Set (CyclotomicField n K)) := by
  rw [← IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_root_cyclotomic h,
    IsCyclotomicExtension.adjoin_roots_cyclotomic_eq_adjoin_nth_roots h]
  simp [CyclotomicRing]
  -- 🎉 no goals
#align cyclotomic_ring.eq_adjoin_primitive_root CyclotomicRing.eq_adjoin_primitive_root

end CyclotomicRing

end CyclotomicRing

end IsDomain

section IsAlgClosed

variable [IsAlgClosed K]

/-- Algebraically closed fields are `S`-cyclotomic extensions over themselves if
`NeZero ((a : ℕ) : K))` for all `a ∈ S`. -/
theorem IsAlgClosed.isCyclotomicExtension (h : ∀ a ∈ S, NeZero ((a : ℕ) : K)) :
    IsCyclotomicExtension S K K := by
  refine' ⟨@fun a ha => _, Algebra.eq_top_iff.mp <| Subsingleton.elim _ _⟩
  -- ⊢ ∃ r, IsPrimitiveRoot r ↑a
  obtain ⟨r, hr⟩ := IsAlgClosed.exists_aeval_eq_zero K _ (degree_cyclotomic_pos a K a.pos).ne'
  -- ⊢ ∃ r, IsPrimitiveRoot r ↑a
  refine' ⟨r, _⟩
  -- ⊢ IsPrimitiveRoot r ↑a
  haveI := h a ha
  -- ⊢ IsPrimitiveRoot r ↑a
  rwa [coe_aeval_eq_eval, ← IsRoot.def, isRoot_cyclotomic_iff] at hr
  -- 🎉 no goals
#align is_alg_closed.is_cyclotomic_extension IsAlgClosed.isCyclotomicExtension

instance IsAlgClosedOfCharZero.isCyclotomicExtension [CharZero K] :
    ∀ S, IsCyclotomicExtension S K K := fun S =>
  IsAlgClosed.isCyclotomicExtension S K fun _ _ => inferInstance
#align is_alg_closed_of_char_zero.is_cyclotomic_extension IsAlgClosedOfCharZero.isCyclotomicExtension

end IsAlgClosed
