import Mathlib
import Mathlib.NumberTheory.KroneckerWeber.EigenSpace
import Mathlib.NumberTheory.KroneckerWeber.Discriminant
import Mathlib.NumberTheory.KroneckerWeber.IsInvariant
import Mathlib.NumberTheory.KroneckerWeber.KummersLemma


lemma IsPrimitiveRoot.pow_mod {R : Type*} [CommMonoid R] {Œ∂ : R} {p : ‚Ñï}
    (hŒ∂ : IsPrimitiveRoot Œ∂ p) (k : ‚Ñï) : Œ∂ ^ (k % p) = Œ∂ ^ k := by
  conv_rhs => rw [‚Üê Nat.div_add_mod k p]
  simp [pow_add, pow_mul, hŒ∂.pow_eq_one]

section IsSplittingField

open Polynomial

variable {K : Type*} [Field K]
variable {n : ‚Ñï} [NeZero n] (hŒ∂ : (primitiveRoots n K).Nonempty)
variable {a : K} (H : Irreducible (X ^ n - C a))
variable (L : Type*) [Field L] [Algebra K L] [IsSplittingField K L (X ^ n - C a)]
variable {Œ± : L} (hŒ± : Œ± ^ n = algebraMap K L a)

@[simps gen]
noncomputable
def powerBasisOfSplittingFieldXPowSubC : PowerBasis K L where
  __ := (AdjoinRoot.powerBasis' (monic_X_pow_sub_C a (NeZero.ne n))).map
    (adjoinRootXPowSubCEquiv hŒ∂ H hŒ±)
  gen := Œ±
  basis_eq_pow i := by
    simp only [PowerBasis.basis_eq_pow]
    simp [adjoinRootXPowSubCEquiv_root]

@[simp]
lemma powerBasisOfSplittingFieldXPowSubC_dim :
    (powerBasisOfSplittingFieldXPowSubC hŒ∂ H L hŒ±).dim = n := by
  simp [powerBasisOfSplittingFieldXPowSubC]

include hŒ± in
lemma autEquivZmod_symm_apply {Œ∂ : K} (hŒ∂ : IsPrimitiveRoot Œ∂ n) (m : ZMod n) :
    (autEquivZmod H L hŒ∂).symm (Multiplicative.ofAdd m) Œ± = Œ∂ ^ m.val ‚Ä¢ Œ± := by
  obtain ‚ü®m, rfl‚ü© := ZMod.natCast_zmod_surjective m
  rw [autEquivZmod_symm_apply_natCast (hŒ± := hŒ±), ZMod.val_natCast, hŒ∂.pow_mod]

include hŒ± in
lemma autEquivZmod_symm_hasEigenvector (Œ∂ : K) (hŒ∂ : IsPrimitiveRoot Œ∂ n) (l : ZMod n) (i : ‚Ñï)
    (hn : n ‚â† 1) :
    Module.End.HasEigenvector ((autEquivZmod H L hŒ∂).symm (.ofAdd l)).toLinearMap
      ((Œ∂ ^ l.val) ^ i) (Œ± ^ i) := by
  have hŒ±' : Œ± ‚â† 0 := by
    rintro rfl
    obtain rfl : a = 0 := by simpa [NeZero.ne n] using hŒ±.symm
    exact ne_zero_of_irreducible_X_pow_sub_C' hn H rfl
  refine ‚ü®?_, by simp [hŒ±']‚ü©
  simp [autEquivZmod_symm_apply (H := H) (hŒ± := hŒ±), _root_.smul_pow]

end IsSplittingField

section IsGalois

variable {A K L B : Type*} [CommRing A] [CommRing B] [Algebra A B] [Field K] [Field L]
    [Algebra A K] [IsFractionRing A K] [Algebra B L]
    [Algebra K L] [Algebra A L] [IsScalarTower A B L] [IsScalarTower A K L]
    [IsIntegralClosure B A L] (p : Ideal A) (P : Ideal B) [P.LiesOver p]

-- theorem foo (K' : IntermediateField K L)



section foobar

open NumberField

open scoped NumberTheory

class IsAbelianGalois (K L : Type*) [Field K] [Field L] [Algebra K L] extends
  IsGalois K L, Std.Commutative (Œ± := L ‚âÉ‚Çê[K] L) (¬∑ * ¬∑)

instance (K L : Type*) [Field K] [Field L] [Algebra K L] [IsAbelianGalois K L] :
    CommGroup (L ‚âÉ‚Çê[K] L) where
  mul_comm := Std.Commutative.comm

lemma IsAbelianGalois.tower_bot (K L M : Type*) [Field K] [Field L] [Algebra K L]
  [Field M] [Field M] [Algebra K M] [Algebra L M] [IsScalarTower K L M] [IsAbelianGalois K M] :
  IsAbelianGalois K L := sorry

lemma IsAbelianGalois.tower_top (K L M : Type*) [Field K] [Field L] [Algebra K L]
  [Field M] [Field M] [Algebra K M] [Algebra L M] [IsScalarTower K L M] [IsAbelianGalois K M] :
  IsAbelianGalois L M := sorry

instance (K L : Type*) [Field K] [Field L] [Algebra K L] [IsAbelianGalois K L]
    (K' : IntermediateField K L) : IsAbelianGalois K K' :=
  .tower_bot K _ L

instance (K L : Type*) [Field K] [Field L] [Algebra K L] [IsAbelianGalois K L]
    (K' : IntermediateField K L) : IsAbelianGalois K' L :=
  .tower_top K _ L

-- variable (p : ‚Ñï+) [Fact (p : ‚Ñï).Prime] (hp : Odd p.1)
variable {K L : Type*} [Field K] [Field L] [Algebra K L] [CharZero K] [NumberField L]
variable [IsAbelianGalois ‚Ñö L]

variable (P : Ideal ‚Ñ§) [P.IsMaximal]
-- variable (HL‚ÇÉ : (P.primesOver (ùìû K)).ncard ‚â§ 1)


instance IsIntegralClosure.faithfulSMul (A K L B : Type*)
    [CommRing A] [CommRing B] [Field K] [Field L] [Algebra A K] [Algebra B L] [IsFractionRing A K]
    [Algebra A B]
    [Algebra K L] [Algebra A L] [IsScalarTower A K L] [IsScalarTower A B L]
    [IsIntegralClosure B A L]
    [Algebra.IsAlgebraic K L] :
    letI := IsIntegralClosure.MulSemiringAction A K L B
    FaithfulSMul (L ‚âÉ‚Çê[K] L) B := by
  letI := IsIntegralClosure.MulSemiringAction A K L B
  constructor
  intro œÉ‚ÇÅ œÉ‚ÇÇ H
  apply (galRestrict A K L B).injective
  ext a
  exact H a

instance IsIntegralClosure.smulCommClass (A K L B : Type*)
    [CommRing A] [CommRing B] [Field K] [Field L] [Algebra A K] [Algebra B L] [IsFractionRing A K]
    [Algebra A B]
    [Algebra K L] [Algebra A L] [IsScalarTower A K L] [IsScalarTower A B L]
    [IsIntegralClosure B A L]
    [Algebra.IsAlgebraic K L] :
    letI := IsIntegralClosure.MulSemiringAction A K L B
    SMulCommClass (L ‚âÉ‚Çê[K] L) A B :=
  letI := IsIntegralClosure.MulSemiringAction A K L B
  ‚ü®fun œÉ ‚Ü¶ map_smul (galRestrict A K L B œÉ)‚ü©

example {G : Type*} [Group G] (N : Subgroup G) (x : G) [N.Normal] : (x : G ‚ß∏ N) = 1 ‚Üî x ‚àà N := by
  exact QuotientGroup.eq_one_iff x

attribute [local instance] Ideal.Quotient.field

attribute [local instance] Ideal.Quotient.field in
instance {R S : Type*} [CommRing R] [CommRing S] [Algebra R S] [Algebra.IsIntegral ‚Ñ§ S]
    (p : Ideal R) (q : Ideal S) [q.LiesOver p] [q.IsMaximal] :
    Algebra.IsSeparable (R ‚ß∏ p) (S ‚ß∏ q) := by
  have : Algebra.IsIntegral R S := .tower_top (R := ‚Ñ§)
  have : p.IsMaximal := ‚Äπq.LiesOver p‚Ä∫.over ‚ñ∏
    Ideal.isMaximal_comap_of_isIntegral_of_isMaximal (R := R) q
  by_cases hp : p.under ‚Ñ§ = ‚ä•
  ¬∑ have : CharZero (R ‚ß∏ p) := by
      refine charZero_of_injective_algebraMap (R := ‚Ñ§) ?_
      rwa [RingHom.injective_iff_ker_eq_bot, ‚Üê Ideal.Quotient.mk_comp_algebraMap,
        RingHom.ker_eq_comap_bot, ‚Üê Ideal.comap_comap, ‚Üê RingHom.ker_eq_comap_bot,
        Ideal.mk_ker]
    exact Algebra.IsSeparable.of_integral _ _
  have : q.LiesOver (p.under ‚Ñ§) := ‚ü®by rw [‚Äπq.LiesOver p‚Ä∫.over, Ideal.under_under]‚ü©
  have : IsScalarTower (‚Ñ§ ‚ß∏ p.under ‚Ñ§) (R ‚ß∏ p) (S ‚ß∏ q) := IsScalarTower.of_algebraMap_eq <| by
    rintro ‚ü®x‚ü©; exact congr_arg _ (IsScalarTower.algebraMap_apply ‚Ñ§ R S x)
  have := Ideal.fintypeQuotientOfFreeOfNeBot _ hp
  have : (p.under ‚Ñ§).IsMaximal := Ideal.IsPrime.isMaximal inferInstance hp
  exact Algebra.isSeparable_tower_top_of_isSeparable (‚Ñ§ ‚ß∏ p.under ‚Ñ§) (R ‚ß∏ p) (S ‚ß∏ q)

theorem surjective_of_isUnramified
  (HL‚ÇÅ : ‚àÄ (I : Ideal (ùìû L)) (_ : I.IsMaximal),
    I.under ‚Ñ§ = P ‚Üí Algebra.IsUnramifiedAt (ùìû K) I)
  (HL‚ÇÇ : ‚àÄ (I : Ideal (ùìû L)) (_ : I.IsMaximal),
    I.under ‚Ñ§ ‚â† P ‚Üí Algebra.IsUnramifiedAt ‚Ñ§ I) : Function.Surjective (algebraMap K L) := by
  by_contra hKL
  obtain ‚ü®Q, hQ‚ÇÅ, hQ‚ÇÇ‚ü© :=
    Ideal.exists_ideal_over_maximal_of_isIntegral (S := ùìû L) P (fun _ ‚Ü¶ by simp +contextual)
  have := Ideal.LiesOver.mk hQ‚ÇÇ.symm
  have hQ : Q ‚â† ‚ä• := fun e ‚Ü¶ by
    obtain hP : ‚ä• = P := by simpa [e, SetLike.ext_iff] using hQ‚ÇÇ
    exact Ring.ne_bot_of_isMaximal_of_not_isField ‚ÄπP.IsMaximal‚Ä∫ Int.not_isField hP.symm
  letI := IsIntegralClosure.MulSemiringAction ‚Ñ§ ‚Ñö L (ùìû L)
  letI := Algebra.isInvariant_of_isGalois ‚Ñ§ ‚Ñö L (ùìû L)
  let I : Subgroup (L ‚âÉ‚Çê[‚Ñö] L) := Q.toAddSubgroup.inertia (L ‚âÉ‚Çê[‚Ñö] L)
  let LI : IntermediateField ‚Ñö L := .fixedField I
  have : NumberField LI := ‚ü®‚ü©
  have : 1 < Module.finrank ‚Ñö LI := by
    by_contra! H
    have := Module.finrank_pos (R := ‚Ñö) (M := LI)
    have : LI = ‚ä• := IntermediateField.finrank_eq_one_iff.mp (by linarith)
    apply_fun IntermediateField.fixingSubgroup at this
    have HI : I = ‚ä§ := by simpa [LI, IntermediateField.fixingSubgroup_fixedField] using this
    have : FiniteDimensional K L := Module.Finite.of_restrictScalars_finite ‚Ñö _ _
    have : FiniteDimensional ‚Ñö K := Module.Finite.of_injective
      (IsScalarTower.toAlgHom ‚Ñö K L).toLinearMap (algebraMap K L).injective
    have : IsGalois K L := IsGalois.tower_top_of_isGalois ‚Ñö K L
    have : NumberField K := ‚ü®‚ü©
    have hQ' : Q.under (ùìû K) ‚â† ‚ä• := mt Ideal.eq_bot_of_comap_eq_bot hQ
    letI := IsIntegralClosure.MulSemiringAction (ùìû K) K L (ùìû L)
    letI := Algebra.isInvariant_of_isGalois (ùìû K) K L (ùìû L)
    have : Algebra.IsUnramifiedAt (ùìû K) Q := HL‚ÇÅ _ hQ‚ÇÅ hQ‚ÇÇ
    have := Algebra.IsInvariant.card_inertia (L ‚âÉ‚Çê[K] L) (Q.under (ùìû K)) hQ' Q
    rw [Ideal.ramificationIdx_eq_one_of_isUnramifiedAt (hp := hQ), Subgroup.card_eq_one] at this
    have hKL : (Algebra.ofId K L).fieldRange ‚â† ‚ä§ := by rwa [ne_eq, AlgHom.fieldRange_eq_top]
    apply hKL
    apply IsGalois.intermediateFieldEquivSubgroup.injective
    apply OrderDual.ofDual.injective
    rw [map_top, OrderDual.ofDual_top, ‚Üê le_bot_iff, ‚Üê this]
    intro œÉ hœÉ x
    exact HI.ge (Subgroup.mem_top (œÉ.restrictScalars ‚Ñö)) x
  obtain ‚ü®q, hq, H‚ü© := NumberField.exists_ramified_of_isGalois (K := LI) (ùí™ := ùìû LI) this
  by_cases h : Ideal.span {q} = P
  ¬∑ have : Algebra.IsInvariant (ùìû LI) (ùìû L) I := by
      refine ‚ü®fun x H ‚Ü¶ ‚ü®‚ü®‚ü®(x : L), fun œÉ ‚Ü¶ ?_‚ü©, ?_‚ü©, rfl‚ü©‚ü©
      ¬∑ conv_rhs => rw [‚Üê H œÉ]
        exact (algebraMap_galRestrict_apply ‚Ñ§ œÉ.1 x).symm
      ¬∑ rw [mem_integralClosure_iff, ‚Üê isIntegral_algHom_iff (IsScalarTower.toAlgHom ‚Ñ§ LI L)]
        ¬∑ exact x.2
        ¬∑ exact (algebraMap LI L).injective
    have : SMulCommClass I (ùìû LI) (ùìû L) := by
      refine ‚ü®fun œÉ s t ‚Ü¶ ?_‚ü©
      rw [Algebra.smul_def, smul_mul', Algebra.smul_def]
      congr 1
      ext1
      exact (algebraMap_galRestrict_apply ‚Ñ§ œÉ.1 (algebraMap (ùìû LI) (ùìû L) s)).trans (s.1.2 œÉ)
    apply H (Q.under _) inferInstance (by rw [Ideal.under_under, h, ‚Üê hQ‚ÇÇ])
    exact Algebra.IsInvariant.isUnramifiedAt_of_isInvariant_inertia
      (R := ‚Ñ§) (S := ùìû LI) (T := ùìû L) (G := L ‚âÉ‚Çê[‚Ñö] L) Q hQ
  have : (Ideal.span {q}).IsMaximal :=
    ((Ideal.span_singleton_prime hq.ne_zero).mpr hq).isMaximal (by simpa using hq.ne_zero)
  obtain ‚ü®Q', hQ'‚ÇÅ, hQ'‚ÇÇ‚ü© := Ideal.exists_ideal_over_maximal_of_isIntegral (S := ùìû L) (.span {q})
      (fun _ ‚Ü¶ by simp +contextual)
  have : Q'.LiesOver (.span {q}) := ‚ü®hQ'‚ÇÇ.symm‚ü©
  have : Module.Finite ‚Ñ§ (ùìû L) :=
    IsIntegralClosure.finite ‚Ñ§ ‚Ñö L (ùìû L)
  have : Algebra.IsUnramifiedAt ‚Ñ§ Q' := by
    refine HL‚ÇÇ Q' hQ'‚ÇÅ ?_
    contrapose! h
    rw [‚Üê h, ‚Üê hQ'‚ÇÇ]
  apply H (Q'.under _) inferInstance (by rw [Ideal.under_under, ‚Üê hQ'‚ÇÇ])
  exact .of_liesOver ‚Ñ§ _ Q'

open IntermediateField

attribute [local instance] FractionRing.liftAlgebra FractionRing.isScalarTower_liftAlgebra in
lemma IsIntegrallyClosed.algebraMap_dvd_iff
    {R S : Type*} [CommRing R] [CommRing S] [IsDomain R] [IsDomain S] [Algebra R S]
    [Algebra.IsIntegral R S] [IsIntegrallyClosed R] [FaithfulSMul R S] {x y : R}
    (H : algebraMap R S x ‚à£ algebraMap R S y) : x ‚à£ y := by
  by_cases hx : x = 0
  ¬∑ obtain rfl : y = 0 := by simpa [hx] using H
    simp [hx]
  let K := FractionRing R
  let L := FractionRing S
  suffices IsIntegral R (algebraMap R K y / algebraMap R K x) by
    obtain ‚ü®z, hz‚ü© := IsIntegralClosure.isIntegral_iff (A := R).mp this
    rw [eq_div_iff (by simpa), ‚Üê map_mul, (FaithfulSMul.algebraMap_injective R K).eq_iff] at hz
    exact ‚ü®z, mul_comm x z ‚ñ∏ hz.symm‚ü©
  rw [‚Üê isIntegral_algHom_iff (IsScalarTower.toAlgHom R K L) (algebraMap K L).injective, map_div‚ÇÄ]
  obtain ‚ü®z, hz‚ü© := H
  convert (Algebra.IsIntegral.isIntegral (R := R) z).map (IsScalarTower.toAlgHom R S L)
  simpa [div_eq_iff, hx] using congr(algebraMap S L $(hz.trans (mul_comm _ _)))


lemma RingHom.IsIntegral.isLocalHom
    {R S : Type*} [CommRing R] [CommRing S] {f : R ‚Üí+* S} (hf : f.IsIntegral)
    (hf' : Function.Injective f) : IsLocalHom f where
  map_nonunit x := by
    simpa [Ideal.map_span] using (Ideal.map_eq_top_iff f (I := .span {x}) hf' hf).mp

instance {R S : Type*} [CommRing R] [CommRing S] [Algebra R S] [FaithfulSMul R S]
    [Algebra.IsIntegral R S] : IsLocalHom (algebraMap R S) :=
  RingHom.IsIntegral.isLocalHom Algebra.IsIntegral.isIntegral
    (FaithfulSMul.algebraMap_injective R S)

lemma Subalgebra.map_le_map_iff_of_injective
    {F K L : Type*} [CommRing F] [CommRing K] [CommRing L] [Algebra F K]
    [Algebra F L] (f : K ‚Üí‚Çê[F] L) (hf : Function.Injective f) {A B : Subalgebra F K} :
    A.map f ‚â§ B.map f ‚Üî A ‚â§ B :=
  Submodule.map_le_map_iff_of_injective (f := f.toLinearMap) hf A.toSubmodule B.toSubmodule

set_option maxHeartbeats 0 in
set_option synthInstance.maxHeartbeats 0 in
theorem mem_adjoin_of_isPrimitiveRoot_of_isUnramifiedAt
    (p : ‚Ñï) (hp : p.Prime) (hp' : p ‚â† 2) (Œ∂ : ùìû L) (hŒ∂ : IsPrimitiveRoot Œ∂ (p ^ 2))
    (HL‚ÇÅ : ‚àÄ (I : Ideal (ùìû L)) (_ : I.IsMaximal),
      I.under ‚Ñ§ ‚â† .span {(p : ‚Ñ§)} ‚Üí Algebra.IsUnramifiedAt ‚Ñ§ I)
    (Œ± : L) (a : ùìû L) (haŒ∂ : a.1 ‚àà ‚Ñö‚üÆŒ∂.1‚üØ) (hŒ± : Œ± ^ p = a) (ha : (Œ∂ ^ p - 1) ^ p ‚à£ a - 1) :
    Œ± ‚àà ‚Ñö‚üÆŒ∂.1‚üØ := by
  have := hp.pos
  let l : ùìû L := Œ∂ ^ p - 1
  let Œ∂' : ùìû ‚Ñö‚üÆŒ∂.1‚üØ := ‚ü®‚ü®Œ∂, mem_adjoin_simple_self _ _‚ü©,
      (isIntegral_algebraMap_iff Subtype.val_injective).mp Œ∂.2‚ü©
  let a' : ùìû ‚Ñö‚üÆŒ∂.1‚üØ := ‚ü®‚ü®a.1, haŒ∂‚ü©, (isIntegral_algebraMap_iff Subtype.val_injective).mp a.2‚ü©
  have hŒ∂' : IsPrimitiveRoot Œ∂' (p ^ 2) := hŒ∂.of_map_of_injective (f := algebraMap _ (ùìû L))
    (FaithfulSMul.algebraMap_injective _ _)
  have hŒ∂'' : IsPrimitiveRoot (Œ∂' ^ p : ‚Ñö‚üÆŒ∂.1‚üØ) p :=
    (hŒ∂'.map_of_injective (FaithfulSMul.algebraMap_injective (ùìû ‚Ñö‚üÆŒ∂.1‚üØ) ‚Ñö‚üÆŒ∂.1‚üØ)).pow
      (show 0 < p ^ 2 by positivity) (pow_two _)
  have : Fact (PNat.Prime ‚ü®p, hp.pos‚ü©) := ‚ü®hp‚ü©
  have ha' : ((hŒ∂''.unit' (p := ‚ü®p, hp.pos‚ü©)).1 - 1) ^ p ‚à£ a' - 1 := by
    apply IsIntegrallyClosed.algebraMap_dvd_iff (S := ùìû L)
    simpa using ha
  have : IsAbelianGalois ‚Ñö ‚Ñö‚üÆŒ∂.1‚üØ‚üÆŒ±‚üØ := .tower_bot ‚Ñö _ L
  have : (Ideal.span {(p : ‚Ñ§)}).IsMaximal := Ideal.IsPrime.isMaximal
    ((Ideal.span_singleton_prime (by simp [hp.ne_zero])).mpr
    (Nat.prime_iff_prime_int.mp hp)) (by simp [hp.ne_zero])
  have ‚ü®‚ü®Œ±'', h‚ÇÅ‚ü©, h‚ÇÇ‚ü© := surjective_of_isUnramified (K := ‚Ñö‚üÆŒ∂.1‚üØ) (L := ‚Ñö‚üÆŒ∂.1‚üØ‚üÆŒ±‚üØ)
    (.span {(p : ‚Ñ§)}) ?_ ?_ ‚ü®Œ±, mem_adjoin_simple_self _ Œ±‚ü©
  ¬∑ obtain rfl : Œ±'' = Œ± := congr($(h‚ÇÇ).1)
    exact h‚ÇÅ
  ¬∑ simp_rw [‚Üê not_dvd_differentIdeal_iff, Ideal.dvd_iff_le]
    intro P hP H hP'
    let Œ±' := KummersLemma.polyRoot (p := ‚ü®p, hp.pos‚ü©) (by simpa [‚Üê PNat.coe_inj] using hp')
      hŒ∂'' a' ha' (L := ‚Ñö‚üÆŒ∂.1‚üØ‚üÆŒ±‚üØ) ‚ü®Œ±, mem_adjoin_simple_self _ _‚ü© (by ext; exact hŒ±) 1
    have hŒ±'' : IsIntegral ‚Ñö‚üÆŒ∂.1‚üØ Œ± := by
      refine .of_pow hp.pos ?_
      rw [hŒ±]
      exact isIntegral_algebraMap (R := ‚Ñö‚üÆŒ∂.1‚üØ) (x := ‚ü®a, haŒ∂‚ü©)
    have := hP' (aeval_derivative_mem_differentIdeal (ùìû ‚Ñö‚üÆŒ∂.1‚üØ) ‚Ñö‚üÆŒ∂.1‚üØ ‚Ñö‚üÆŒ∂.1‚üØ‚üÆŒ±‚üØ
      (B := ùìû ‚Ñö‚üÆŒ∂.1‚üØ‚üÆŒ±‚üØ) Œ±' ?_)
    ¬∑ refine KummersLemma.aeval_derivative_minpoly_not_in (p := ‚ü®p, hp.pos‚ü©)
        (by simpa [‚Üê PNat.coe_inj] using hp') hŒ∂'' a' ha' (L := ‚Ñö‚üÆŒ∂.1‚üØ‚üÆŒ±‚üØ)
        ‚ü®Œ±, mem_adjoin_simple_self _ _‚ü© (by ext; exact hŒ±) P ?_ _ this
      have : algebraMap _ _ (((hŒ∂''.unit' (p := ‚ü®p, hp.pos‚ü©)).1 - 1) ^ p) ‚àà P := by
        conv_rhs => enter [2, 2]; rw [‚Üê tsub_add_cancel_of_le hp.one_le]
        obtain ‚ü®u, hu‚ü© := (associated_zeta_sub_one_pow_prime (p := ‚ü®p, hp.pos‚ü©) hŒ∂'').symm
        simp only [PNat.mk_coe] at hu
        rw [pow_succ, ‚Üê hu, mul_assoc, map_mul, map_natCast, ‚Üê map_natCast (algebraMap ‚Ñ§ _)]
        refine Ideal.mul_mem_right _ _ ?_
        show (p : ‚Ñ§) ‚àà P.under ‚Ñ§
        exact H.ge (Ideal.mem_span_singleton_self _)
      have : algebraMap _ _ (a' - 1) ‚àà P :=
        Ideal.mem_of_dvd _ (RingHom.map_dvd _ ha') this
      simp only [‚Üê Ideal.Quotient.eq_zero_iff_mem, map_sub, sub_eq_zero, map_one] at this
      have : Ideal.Quotient.mk (P.under _) a' = 1 :=
        (FaithfulSMul.algebraMap_eq_one_iff _ (ùìû ‚Ñö‚üÆŒ∂.1‚üØ‚üÆŒ±‚üØ ‚ß∏ P)).mp this
      rw [this]
      exact isUnit_one
    ¬∑ rw [‚Üê top_le_iff]
      have := KummersLemma.mem_adjoin_polyRoot (p := ‚ü®p, hp.pos‚ü©)
        (by simpa [‚Üê PNat.coe_inj] using hp')
        hŒ∂'' a' ha' (L := ‚Ñö‚üÆŒ∂.1‚üØ‚üÆŒ±‚üØ) ‚ü®Œ±, mem_adjoin_simple_self _ _‚ü© (by ext; exact hŒ±) 1
      rw [‚Üê SetLike.mem_coe, ‚Üê Set.singleton_subset_iff, ‚Üê Algebra.adjoin_le_iff] at this
      refine le_trans ?_ this
      rw [‚Üê Subalgebra.map_le_map_iff_of_injective (IntermediateField.val _) (RingHom.injective _)]
      simp only [Algebra.map_top, range_val, AlgHom.map_adjoin, Set.image_singleton]
      rw [IntermediateField.adjoin_simple_toSubalgebra_of_integral hŒ±'']
      rfl
  ¬∑ intro P hP H
    obtain ‚ü®Q, hQ‚ÇÅ, hQ‚ÇÇ‚ü© :=
      Ideal.exists_ideal_over_maximal_of_isIntegral (S := ùìû L) P (fun _ ‚Ü¶ by simp +contextual)
    have := Ideal.LiesOver.mk hQ‚ÇÇ.symm
    have := HL‚ÇÅ Q hQ‚ÇÅ (by rwa [‚Üê hQ‚ÇÇ, Ideal.under_under] at H)
    exact Algebra.IsUnramifiedAt.of_liesOver _ _ Q

open Polynomial in
lemma isSplittingField_X_pow_sub_C_of_root_adjoin_eq_top'
    {K : Type*} [Field K] {L : Type*} [Field L]
    [Algebra K L] [FiniteDimensional K L] (n : ‚Ñï) (hn : 0 < n)
    (hK : (primitiveRoots n K).Nonempty)
    {a : K} {Œ± : L} (ha : Œ± ^ n = algebraMap K L a) (hŒ± : K‚üÆŒ±‚üØ = ‚ä§) :
    IsSplittingField K L (X ^ n - C a) := by
  constructor
  ¬∑ rw [‚Üê splits_id_iff_splits, Polynomial.map_sub, Polynomial.map_pow, Polynomial.map_C,
      Polynomial.map_X]
    have ‚ü®_, hŒ∂‚ü© := hK
    rw [mem_primitiveRoots hn] at hŒ∂
    exact X_pow_sub_C_splits_of_isPrimitiveRoot (hŒ∂.map_of_injective (algebraMap K _).injective) ha
  ¬∑ rw [eq_top_iff, ‚Üê IntermediateField.top_toSubalgebra, ‚Üê hŒ±,
      IntermediateField.adjoin_simple_toSubalgebra_of_integral (IsIntegral.of_finite K Œ±)]
    apply Algebra.adjoin_mono
    rw [Set.singleton_subset_iff, mem_rootSet_of_ne (X_pow_sub_C_ne_zero hn a),
      aeval_def, eval‚ÇÇ_sub, eval‚ÇÇ_X_pow, eval‚ÇÇ_C, ha, sub_self]

lemma IntermediateField.adjoin_adjoinSimpleGen (K : Type*)
    {L : Type*} [Field K] [Field L] [Algebra K L] (x : L) : K‚üÆAdjoinSimple.gen K x‚üØ = ‚ä§ := by
  apply map_injective (val _)
  simp [adjoin_map, ‚Üê AlgHom.fieldRange_eq_map]

set_option maxHeartbeats 0 in
set_option synthInstance.maxHeartbeats 0 in
theorem IsAbelianGalois.exists_apply_eq_mul_pow
    (p : ‚Ñï) (hp : p.Prime) (hp' : p ‚â† 2) (Œ∂ : ùìû L) (hŒ∂ : IsPrimitiveRoot Œ∂ (p ^ 2))
    (Œ± : L) (a : ùìû L) (haŒ∂ : a.1 ‚àà ‚Ñö‚üÆŒ∂.1‚üØ) (hŒ± : Œ± ^ p = a)
    (œÉ œÑ : L ‚âÉ‚Çê[‚Ñö] L) (l : ‚Ñï) (hœÉ : œÉ Œ± = Œ∂ ^ p * Œ±) (hœÉ' : œÉ Œ∂ = Œ∂) (hœÑ : œÑ Œ∂ = Œ∂ ^ l) :
    ‚àÉ c ‚àà ‚Ñö‚üÆŒ∂.1‚üØ, œÑ Œ± = c * Œ± ^ l := by
  by_cases hŒ±0 : Œ± = 0
  ¬∑ exact ‚ü®0, zero_mem _, by simp [hŒ±0]‚ü©
  have := hp.pos
  let Œ∂' : ùìû ‚Ñö‚üÆŒ∂.1‚üØ := ‚ü®‚ü®Œ∂, mem_adjoin_simple_self _ _‚ü©,
      (isIntegral_algebraMap_iff Subtype.val_injective).mp Œ∂.2‚ü©
  let a' : ùìû ‚Ñö‚üÆŒ∂.1‚üØ := ‚ü®‚ü®a.val, haŒ∂‚ü©, (isIntegral_algebraMap_iff Subtype.val_injective).mp a.2‚ü©
  have hŒ∂' : IsPrimitiveRoot Œ∂' (p ^ 2) := hŒ∂.of_map_of_injective (f := algebraMap _ (ùìû L))
    (FaithfulSMul.algebraMap_injective _ _)
  have hŒ∂'' : IsPrimitiveRoot (Œ∂' ^ p : ‚Ñö‚üÆŒ∂.1‚üØ) p :=
    (hŒ∂'.map_of_injective (FaithfulSMul.algebraMap_injective (ùìû ‚Ñö‚üÆŒ∂.1‚üØ) ‚Ñö‚üÆŒ∂.1‚üØ)).pow
      (show 0 < p ^ 2 by positivity) (pow_two _)
  have inst := isSplittingField_X_pow_sub_C_of_root_adjoin_eq_top' p hp.pos
    ‚ü®(Œ∂'.1 ^ p : ‚Ñö‚üÆŒ∂.1‚üØ), by simpa [hp.pos]‚ü© (a := a')
    (Œ± := AdjoinSimple.gen ‚Ñö‚üÆŒ∂.1‚üØ Œ±) (by ext; exact hŒ±)
    (IntermediateField.adjoin_adjoinSimpleGen _ _)
  have : NeZero p := ‚ü®hp.ne_zero‚ü©
  have : IsAbelianGalois ‚Ñö ‚Ñö‚üÆŒ∂.1‚üØ‚üÆŒ±‚üØ := .tower_bot _ _ L
  let œÉ‚ÇÅ : L ‚âÉ‚Çê[‚Ñö‚üÆŒ∂.1‚üØ] L :=
    { __ := œÉ
      commutes' r := by
        obtain ‚ü®r, hr‚ü© := r
        induction hr using IntermediateField.adjoin_induction with
        | mem x hx =>
          obtain rfl : x = _ := hx
          simpa using hœÉ'
        | algebraMap x => simp
        | add x y hx hy _ _ => simp_all
        | inv x hx _ => simp_all
        | mul x y hx hy _ _ => simp_all }
  have hX : Irreducible (Polynomial.X ^ p - Polynomial.C (a' : ‚Ñö‚üÆŒ∂.1‚üØ)) := by
    rw [‚Üê pow_one p]
    refine X_pow_sub_C_irreducible_of_prime_pow hp hp' _ ?_
    intro b hb
    have : b.1 ^ p = a := congr($(hb).1)
    obtain ‚ü®i, -, hi‚ü© := (hŒ∂.map_of_injective
      (FaithfulSMul.algebraMap_injective _ L)).eq_pow_of_pow_eq_one
      (Œæ := Œ± / b.1) (by rw [pow_two, pow_mul, div_pow, this, ‚Üê hŒ±, div_self, one_pow]; simp [hŒ±0])
    have : Œ± ‚àà ‚Ñö‚üÆŒ∂.1‚üØ := by
      rw [eq_div_iff_mul_eq] at hi
      ¬∑ rw [‚Üê hi]
        exact mul_mem (pow_mem (mem_adjoin_simple_self _ _) _) b.2
      ¬∑ intro e
        rw [e, zero_pow hp.pos.ne'] at this
        simp [‚Üê this, hŒ±0] at hŒ±
    have : (Œ∂ : L) ^ p = 1 := by
      simpa [mul_eq_right‚ÇÄ hŒ±0] using hœÉ.symm.trans (œÉ‚ÇÅ.commutes ‚ü®Œ±, this‚ü©)
    have := (hŒ∂.map_of_injective (FaithfulSMul.algebraMap_injective _ L)).dvd_of_pow_eq_one _ this
    replace this : p * p ‚à£ p * 1 := by simpa [pow_two] using this
    rw [mul_dvd_mul_iff_left hp.ne_zero, ‚Üê isUnit_iff_dvd_one, Nat.isUnit_iff] at this
    exact hp.ne_one this
  let œÉ‚ÇÇ := œÉ‚ÇÅ.restrictNormal ‚Ñö‚üÆŒ∂.1‚üØ‚üÆŒ±‚üØ
  have hœÉ‚ÇÇ (x) : (œÉ‚ÇÇ x).1 = œÉ x := œÉ‚ÇÅ.restrictNormal_commutes ‚Ñö‚üÆŒ∂.1‚üØ‚üÆŒ±‚üØ x
  have H (i : ‚Ñï) : Module.End.HasEigenvector œÉ‚ÇÇ.toLinearMap ((Œ∂' ^ p : ‚Ñö‚üÆŒ∂.1‚üØ) ^ i)
      (AdjoinSimple.gen ‚Ñö‚üÆŒ∂.1‚üØ Œ± ^ i) := by
    refine ‚ü®?_, by simp [Subtype.ext_iff, hŒ±0]‚ü©
    simp only [Module.End.mem_genEigenspace_one, AlgEquiv.toLinearMap_apply, map_pow]
    ext1
    simp [hœÉ‚ÇÇ, hœÉ, mul_pow, IntermediateField.smul_def, Œ∂']
  have := Module.End.eigenspace_eq_span_singleton
    (powerBasisOfSplittingFieldXPowSubC ‚ü®(Œ∂' ^ p : ‚Ñö‚üÆŒ∂.1‚üØ), by simpa [hp.pos]‚ü© hX ‚Ñö‚üÆŒ∂.1‚üØ‚üÆŒ±‚üØ
      (Œ± := AdjoinSimple.gen ‚Ñö‚üÆŒ∂.1‚üØ Œ±) (by ext; exact hŒ±)).basis
    (fun i ‚Ü¶ (Œ∂' ^ p : ‚Ñö‚üÆŒ∂.1‚üØ) ^ i.1) œÉ‚ÇÇ.toLinearMap (fun i ‚Ü¶ by
      simpa only [id_eq, eq_mpr_eq_cast, PowerBasis.coe_basis,
        powerBasisOfSplittingFieldXPowSubC_gen] using H i)
    ‚ü®l % p, by simpa using Nat.mod_lt _ hp.pos‚ü©
    (by simpa only [Function.Injective, id_eq, eq_mpr_eq_cast, Fin.forall_iff,
      powerBasisOfSplittingFieldXPowSubC_dim, Fin.mk.injEq, Finset.coe_range] using hŒ∂''.injOn_pow)
  have hœÑ' : (œÑ.restrictNormal _ (AdjoinSimple.gen ‚Ñö‚üÆŒ∂.1‚üØ Œ±)).1 = œÑ Œ± :=
    œÑ.restrictNormal_commutes ‚Ñö‚üÆŒ∂.1‚üØ‚üÆŒ±‚üØ (AdjoinSimple.gen ‚Ñö‚üÆŒ∂.1‚üØ Œ±)
  have hŒ±‚ÇÅ : œÑ.restrictNormal _ (AdjoinSimple.gen ‚Ñö‚üÆŒ∂.1‚üØ Œ±) ‚àà
      Module.End.eigenspace œÉ‚ÇÇ.toLinearMap ((Œ∂' ^ p) ^ (l % p)) := by
    rw [hŒ∂''.pow_mod]
    have : œÉ (œÑ Œ±) = (‚ÜëŒ∂ ^ l) ^ p * œÑ Œ± := by
      simpa [hœÉ, hœÑ] using DFunLike.congr_fun (mul_comm œÉ œÑ) Œ±
    simp only [adjoin_toSubfield, Module.End.mem_genEigenspace_one, AlgEquiv.toLinearMap_apply,
      Subtype.ext_iff, hœÉ‚ÇÇ, hœÑ', SetLike.val_smul, Œ∂', this, RingOfIntegers.val, smul_eq_mul,
      RingOfIntegers.map_mk, SubmonoidClass.mk_pow, Œ∂', IntermediateField.smul_def, ‚Üê pow_mul,
      mul_comm l p]
  obtain ‚ü®c, hc‚ü© := Submodule.mem_span_singleton.mp (this.le hŒ±‚ÇÅ)
  replace hc := congr($(hc).1).trans
    (œÑ.restrictNormal_commutes ‚Ñö‚üÆŒ∂.1‚üØ‚üÆŒ±‚üØ (AdjoinSimple.gen ‚Ñö‚üÆŒ∂.1‚üØ Œ±))
  replace hc : c ‚Ä¢ Œ± ^ (l % p) = œÑ Œ± := by simpa using hc
  refine ‚ü®_, (c / a'.1 ^ (l / p)).2, hc.symm.trans ?_‚ü©
  simp only [‚Üê hŒ±, SubmonoidClass.mk_pow, ‚Üê pow_mul, div_eq_mul_inv, MulMemClass.coe_mul, a',
    IntermediateField.smul_def, smul_eq_mul, Subtype.coe_mk, IntermediateField.coe_inv]
  conv_rhs => enter [2]; rw [‚Üê l.div_add_mod p]
  rw [mul_assoc, pow_add, inv_mul_cancel_left‚ÇÄ]
  simp [hŒ±0]

theorem IsLocalization.exists_reduced_fraction_of_WfDvdMonoid
    {R S : Type*} [CommRing R] [CommRing S] [Algebra R S] (M : Submonoid R)
    (hM : ‚àÄ x y, x * y ‚àà M ‚Üí x ‚àà M)
    [IsLocalization M S] [WfDvdMonoid R] (x : S) (p : R) (hp : ¬¨ IsUnit p) :
    ‚àÉ (y : R) (s : M), x = IsLocalization.mk' S y s ‚àß (p ‚à£ y ‚Üí p ‚à£ s ‚Üí False) := by
  obtain ‚ü®y, ‚ü®s, hs‚ü©, rfl‚ü© := IsLocalization.mk'_surjective M x
  by_cases hy : y = 0
  ¬∑ exact ‚ü®0, 1, by simp [hy], by simpa [‚Üê isUnit_iff_dvd_one]‚ü©
  by_cases hs' : s = 0
  ¬∑ refine ‚ü®0, 1, ?_, by simpa [‚Üê isUnit_iff_dvd_one]‚ü©
    simp only [mk'_zero, mk'_eq_zero_iff, Subtype.exists, exists_prop]
    exact ‚ü®0, hs' ‚ñ∏ hs, zero_mul _‚ü©
  obtain ‚ü®m, a, hm, rfl‚ü© := WfDvdMonoid.max_power_factor' hy hp
  obtain ‚ü®n, b, hn, rfl‚ü© := WfDvdMonoid.max_power_factor' hs' hp
  refine ‚ü®p ^ (m - min m n) * a, ‚ü®p ^ (n - min m n) * b, ?_‚ü©, ?_, ?_‚ü©
  ¬∑ apply hM (y := p ^ (min m n))
    rwa [mul_right_comm, ‚Üê pow_add, tsub_add_cancel_of_le inf_le_right]
  ¬∑ rw [mk'_eq_iff_eq]
    congr 1
    simp only
    rw [mul_mul_mul_comm, ‚Üê pow_add, mul_mul_mul_comm, ‚Üê pow_add]
    congr 2
    omega
  ¬∑ cases le_total m n with
  | inl h => simp [h, hm]
  | inr h => simp [h, hn]

open nonZeroDivisors in
theorem IsFractionRing.exists_reduced_fraction_of_WfDvdMonoid
    {R S : Type*} [CommRing R] [CommRing S] [Algebra R S]
    [IsFractionRing R S] [WfDvdMonoid R] (x : S) (p : R) (hp : ¬¨ IsUnit p) :
    ‚àÉ (y : R) (s : R‚Å∞), x = IsLocalization.mk' S y s ‚àß (p ‚à£ y ‚Üí p ‚à£ s ‚Üí False) :=
  IsLocalization.exists_reduced_fraction_of_WfDvdMonoid _
    (by simp +contextual [mul_mem_nonZeroDivisors]) _ _ hp

theorem IsAbelianGalois.exists_apply_eq_mul_powe
    (p : ‚Ñï) (hp : p.Prime) (hp' : p ‚â† 2) (Œ∂ : ùìû L) (hŒ∂ : IsPrimitiveRoot Œ∂ (p ^ 2))
    (Œ± : L) (a : ùìû L) (haŒ∂ : a.1 ‚àà ‚Ñö‚üÆŒ∂.1‚üØ) (hŒ± : Œ± ^ p = a)
    (œÉ œÑ : L ‚âÉ‚Çê[‚Ñö] L) (l : ‚Ñï) (hœÉ : œÉ Œ± = Œ∂ ^ p * Œ±) (hœÉ' : œÉ Œ∂ = Œ∂) (hœÑ : œÑ Œ∂ = Œ∂ ^ l) :
    ‚àÉ c ‚àà ‚Ñö‚üÆŒ∂.1‚üØ, œÑ Œ± = c * Œ± ^ l := by
  obtain ‚ü®m, a, hyp1, hyp2‚ü© := WfDvdMonoid.max_power_factor ha‚ÇÄ hx


set_option maxHeartbeats 0 in
set_option synthInstance.maxHeartbeats 0 in
theorem pow_sub_pow_dvd_sub
    (p : ‚Ñï) (hp : p.Prime) (hp' : p ‚â† 2) (Œ∂ : ùìû L) (hŒ∂ : IsPrimitiveRoot Œ∂ (p ^ 2))
    (Œ± : L) (a : ùìû L) (haŒ∂ : a.1 ‚àà ‚Ñö‚üÆŒ∂.1‚üØ) (hŒ± : Œ± ^ p = a) (ha : Œ∂ ^ p - 1 ‚à£ a - 1)
    (œÉ œÑ : L ‚âÉ‚Çê[‚Ñö] L) (l : ‚Ñï) (hl : ¬¨p ‚à£ l)
    (hœÉ : œÉ Œ± = Œ∂ ^ p * Œ±) (hœÉ' : œÉ Œ∂ = Œ∂) (hœÑ : œÑ Œ∂ = Œ∂ ^ l) :
    (Œ∂ ^ p - 1) ^ p ‚à£ a - 1 := by
  have := hp.pos
  obtain ‚ü®c, hc, hc'‚ü© := IsAbelianGalois.exists_apply_eq_mul_pow
    p hp hp' Œ∂ hŒ∂ Œ± a haŒ∂ hŒ± œÉ œÑ l hœÉ hœÉ' hœÑ
  obtain ‚ü®c‚ÇÅ, ‚ü®c‚ÇÇ, hc‚ÇÇ‚ü©, rfl, hc''‚ü© :=
    IsFractionRing.exists_reduced_fraction_of_WfDvdMonoid c (Œ∂ ^ p - 1) sorry
  simp only [mem_nonZeroDivisors_iff_ne_zero] at hc‚ÇÇ
  let œÑ' := galRestrict ‚Ñ§ ‚Ñö L (ùìû L) œÑ
  have hc' : c‚ÇÇ ^ p * œÑ' a = c‚ÇÅ ^ p * a ^ l := by sorry
    -- apply FaithfulSMul.algebraMap_injective _ L
    -- replace hc' := congr((c‚ÇÇ * $hc') ^ p)
    -- simp only [IsFractionRing.mk'_eq_div, ‚Üê mul_assoc, ne_eq,
    --   FaithfulSMul.algebraMap_eq_zero_iff, hc‚ÇÇ, not_false_eq_true, mul_div_cancel‚ÇÄ,
    --   mul_pow, ‚Üê map_pow, pow_right_comm Œ± l, hŒ±] at hc'
    -- simpa [œÑ', algebraMap_galRestrict_apply] using hc'
  let Œõ := Œ∂ ^ p - 1
  have H : Associated Œõ (œÑ' Œõ) := by sorry
    -- have : œÑ' Œ∂ = Œ∂ ^ l := by ext; exact ((algebraMap_galRestrict_apply _ _ _).trans hœÑ)
    -- simp only [map_sub, map_pow, this, map_one, Œõ]
    -- apply (hŒ∂.pow (show 0 < p ^ 2 by positivity) (pow_two _)).associated_sub_one hp ?_
    --   (by simp [hp.pos])
    -- ¬∑ rwa [‚Üê pow_mul, ne_eq, hŒ∂.pow_eq_one_iff_dvd, pow_two, mul_dvd_mul_iff_right hp.ne_zero]
    -- ¬∑ simp only [hp.pos, Polynomial.mem_nthRootsFinset, ‚Üê pow_mul]
    --   rw [mul_assoc, ‚Üê pow_two, mul_comm, pow_mul, hŒ∂.pow_eq_one, one_pow]
  let œÑ'' : ùìû L ‚ß∏ Ideal.span {Œõ} ‚Üí+* ùìû L ‚ß∏ Ideal.span {Œõ} :=
    Ideal.quotientMap _ œÑ'.toRingHom <| by
      suffices œÑ' Œõ ‚àà Ideal.span {Œõ} by simpa [Ideal.span_le] using this
      rw [Ideal.span_singleton_eq_span_singleton.mpr H]
      exact Ideal.mem_span_singleton_self _
  have : œÑ'' (Ideal.Quotient.mk _ 1) = Ideal.Quotient.mk _ 1 := œÑ''.map_one

  obtain ‚ü®c‚ÇÉ, hc‚ÇÉ‚ü© : Œ∂ ^ p - 1 ‚à£ œÑ' a - 1 := by simpa using H.dvd.trans (œÑ'.map_dvd ha)
  obtain ‚ü®c‚ÇÑ, hc‚ÇÑ‚ü© : Œ∂ ^ p - 1 ‚à£ a ^ l - 1 := by simpa using ha.trans (sub_dvd_pow_sub_pow _ _ l)
  rw [sub_eq_iff_eq_add] at hc‚ÇÉ hc‚ÇÑ
  -- rw [hc‚ÇÉ, hc‚ÇÑ] at
  sorry

end foobar

lemma fooo
    (p : ‚Ñï) (hp : p.Prime) (hp' : p ‚â† 2)
    (L : Type*) [Field L] [NumberField L] [IsAbelianGalois ‚Ñö L]
    (Œ∂ : ùìû L) (hŒ∂ : IsPrimitiveRoot Œ∂ (p ^ 2)) (K : IntermediateField ‚Ñö L)
    (HL : ‚àÄ (I : Ideal (ùìû L)) (_ : I.IsMaximal),
      I.under ‚Ñ§ ‚â† .span {(p : ‚Ñ§)} ‚Üí Algebra.IsUnramifiedAt ‚Ñ§ I) :


-- Let `p` be an odd prime and `Œ∂` be a primitive `p`-th root of unity.
-- Given `L/‚Ñö(Œ∂)/‚Ñö` such that `L/‚Ñö(Œ∂)` is (galois and) cyclic of order `p`, and `L/‚Ñö` is abelian.
variable (p : ‚Ñï+) (hp : (p : ‚Ñï).Prime) (hp' : p.1 ‚â† 2)
variable {L K : Type*} [Field K] [Field L] [Algebra K L] [CharZero K] [CharZero L]
variable [IsCyclotomicExtension {p ^ 2} ‚Ñö K] [IsAbelianGalois ‚Ñö L]
variable [FiniteDimensional K L] [IsGalois ‚Ñö L] [IsCyclic (L ‚âÉ‚Çê[K] L)]
variable (hrank : Module.finrank K L = p)

open Module (finrank)
open IntermediateField NumberField

include hp hp' hrank

lemma foo1 : ‚àÉ (Œ± : ùìû L),
    (Œ± : L) ^ (p : ‚Ñï) ‚àà Set.range (algebraMap K L) ‚àß ¬¨ (p : ùìû L) ‚à£ Œ± ‚àß K‚üÆ(Œ± : L)‚üØ = ‚ä§ := by
  have := Fact.mk hp
  have : FiniteDimensional ‚Ñö K := IsCyclotomicExtension.finiteDimensional {p ^ 2} _ _
  have : IsGalois ‚Ñö K := IsCyclotomicExtension.isGalois (p ^ 2) _ _
  have : IsGalois K L := IsGalois.tower_top_of_isGalois ‚Ñö K L
  let Œ∂ := IsCyclotomicExtension.zeta (p ^ 2) ‚Ñö K
  have hŒ∂ : IsPrimitiveRoot Œ∂ (p ^ 2) := IsCyclotomicExtension.zeta_spec (p ^ 2) ‚Ñö K
  have hŒ∂' : IsPrimitiveRoot (Œ∂ ^ p.1) p := hŒ∂.pow (p ^ 2).2 (pow_two _)
  have ‚ü®Œ±‚ÇÅ, ‚ü®a, ha‚ü©, hŒ±‚ü© := exists_root_adjoin_eq_top_of_isCyclic K L
    ‚ü®Œ∂ ^ p.1, by simpa [hrank]‚ü©
  have hX := irreducible_X_pow_sub_C_of_root_adjoin_eq_top ha.symm hŒ±
  have inst := isSplittingField_X_pow_sub_C_of_root_adjoin_eq_top ‚ü®Œ∂ ^ p.1, by simpa [hrank]‚ü©
    ha.symm hŒ±
  simp_rw [hrank] at hX inst ha
  have : FiniteDimensional ‚Ñö K := IsCyclotomicExtension.finiteDimensional {p ^ 2} _ _
  have : IsCyclic (ZMod ‚Üë(p ^ 2))À£ := sorry
  obtain ‚ü®l, hl‚ü© := IsCyclic.exists_monoid_generator (Œ± := (ZMod ‚Üë(p ^ 2))À£)
  let œÑ := (IsCyclotomicExtension.autEquivPow K
    (Polynomial.cyclotomic.irreducible_rat (p ^ 2).2)).symm l
  have hœÑ‚ÇÅ : œÑ = IsCyclotomicExtension.fromZetaAut
      (hŒ∂.pow_of_coprime _ (ZMod.val_coe_unit_coprime l))
      (Polynomial.cyclotomic.irreducible_rat p.2) := by
    dsimp [œÑ, IsCyclotomicExtension.fromZetaAut]
    congr 2
    generalize_proofs h
    refine h.choose_spec.2.symm.trans ?_
    rw [ZMod.val_natCast, hŒ∂.pow_mod]
  have hœÑ : œÑ Œ∂ = Œ∂ ^ l.1.val := by
    rw [hœÑ‚ÇÅ, IsCyclotomicExtension.fromZetaAut_spec]
  let œÉ := (autEquivZmod hX L hŒ∂).symm (Multiplicative.ofAdd 1)
  have hœÉ : œÉ Œ±‚ÇÅ = Œ∂ ‚Ä¢ Œ±‚ÇÅ := by
    simpa using autEquivZmod_symm_apply_intCast hX L ha.symm hŒ∂ 1
  have := IsAbelianGalois.exists_apply_eq_mul_pow p hp hp' Œ∂
  -- obtain ‚ü®c, hc‚ü© : ‚àÉ c : K, c ‚Ä¢ Œ±‚ÇÅ ^ l.1.val = œÑ.liftNormal L Œ±‚ÇÅ := by sorry
  --   -- have := Std.Commutative.comm (op := (¬∑ * ¬∑)) (œÉ.restrictScalars ‚Ñö) (œÑ.liftNormal L)
  --   -- have hŒ±‚ÇÅ : œÑ.liftNormal L Œ±‚ÇÅ ‚àà Module.End.eigenspace œÉ.toLinearMap (Œ∂ ^ l.1.val) := by
  --   --   simpa [hœÉ, Algebra.smul_def, hœÑ] using DFunLike.congr_fun this Œ±‚ÇÅ
  --   -- have := Module.End.eigenspace_eq_span_singleton
  --   --   (powerBasisOfSplittingFieldXPowSubC ‚ü®Œ∂, (mem_primitiveRoots p.pos).mpr hŒ∂‚ü© hX L ha.symm).basis
  --   --   (fun i ‚Ü¶ Œ∂ ^ i.1) œÉ.toLinearMap (fun i ‚Ü¶ by
  --   --     simpa [ZMod.val_one] using autEquivZmod_symm_hasEigenvector
  --   --       hX L ha.symm Œ∂ hŒ∂ 1 i.1 ‚ÄπFact (p : ‚Ñï).Prime‚Ä∫.1.ne_one)
  --   --   ‚ü®l.1.val, by simpa [‚Üê PowerBasis.finrank, hrank] using ZMod.val_lt l.1‚ü©
  --   --   (by simpa [‚Üê PowerBasis.finrank, hrank, Function.Injective, Fin.forall_iff] using hŒ∂.injOn_pow)
  --   -- obtain ‚ü®c, hc‚ü© := Submodule.mem_span_singleton.mp (this.le hŒ±‚ÇÅ)
  --   -- exact ‚ü®c, by simpa using hc‚ü©
