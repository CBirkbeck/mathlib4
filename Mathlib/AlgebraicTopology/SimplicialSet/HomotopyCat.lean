/-
Copyright (c) 2024 Mario Carneiro and Emily Riehl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mario Carneiro, Emily Riehl, Jo√´l Riou
-/

import Mathlib.AlgebraicTopology.SimplicialSet.Coskeletal
import Mathlib.CategoryTheory.Category.ReflQuiv
import Mathlib.Combinatorics.Quiver.ReflQuiver


/-!

# The homotopy category of a simplicial set

The homotopy category of a simplicial set is defined as a quotient of the free category on its
underlying reflexive quiver (equivalently its one truncation). The quotient imposes an additional
hom relation on this free category, asserting that `f ‚â´ g = h` whenever `f`, `g`, and `h` are
respectively the 2nd, 0th, and 1st faces of a 2-simplex.

In fact, the associated functor

`SSet.hoFunctor : SSet.{u} ‚•§ Cat.{u, u} := SSet.truncation 2 ‚ãô SSet.hoFunctor‚ÇÇ`

is defined by first restricting from simplicial sets to 2-truncated simplicial sets (throwing away
the data that is not used for the construction of the homotopy category) and then composing with an
analogously defined `SSet.hoFunctor‚ÇÇ : SSet.Truncated.{u} 2 ‚•§ Cat.{u,u}` implemented relative to
the syntax of the 2-truncated simplex category.

The functor `SSet.hoFunctor` is shown to be left adjoint to the nerve by providing an analogous
decomposition of the nerve functor, made by possible by the fact that nerves of categories are
2-coskeletal, and then composing a pair of adjunctions, which factor through the category of
2-truncated simplicial sets.
-/

namespace CategoryTheory
namespace SSet
open Category Limits Functor Opposite Simplicial Nerve
universe v u

section

local macro:1000 (priority := high) X:term " _[" n:term "]‚ÇÇ" : term =>
    `(($X : SSet.Truncated 2).obj (Opposite.op ‚ü®SimplexCategory.mk $n, by decide‚ü©))

-- FIXME why doesn't this work?
-- local notation3:1000 (priority := high) (prettyPrint := false) " _[" n "]‚ÇÇ" =>
--     (X : SSet.Truncated 2).obj (Opposite.op ‚ü®SimplexCategory.mk n, by decide‚ü©)

set_option quotPrecheck false
local macro:max (priority := high) "[" n:term "]‚ÇÇ" : term =>
  `((‚ü®SimplexCategory.mk $n, by decide‚ü© : SimplexCategory.Truncated 2))

/-- A 2-truncated simplicial set `S` has an underlying refl quiver with `S _[0]‚ÇÇ` as its underlying
type. -/
def OneTruncation‚ÇÇ (S : SSet.Truncated 2) := S _[0]‚ÇÇ

/-- Abbreviations for face maps in the 2-truncated simplex category. -/
abbrev Œ¥‚ÇÇ {n} (i : Fin (n + 2)) (hn := by decide) (hn' := by decide) :
    (‚ü®[n], hn‚ü© : SimplexCategory.Truncated 2) ‚ü∂ ‚ü®[n + 1], hn'‚ü© := SimplexCategory.Œ¥ i

/-- Abbreviations for degeneracy maps in the 2-truncated simplex category. -/
abbrev œÉ‚ÇÇ {n} (i : Fin (n + 1)) (hn := by decide) (hn' := by decide) :
    (‚ü®[n+1], hn‚ü© : SimplexCategory.Truncated 2) ‚ü∂ ‚ü®[n], hn'‚ü© := SimplexCategory.œÉ i

@[reassoc (attr := simp)]
lemma Œ¥‚ÇÇ_zero_comp_œÉ‚ÇÇ_zero : Œ¥‚ÇÇ (0 : Fin 2) ‚â´ œÉ‚ÇÇ 0 = ùüô _ := SimplexCategory.Œ¥_comp_œÉ_self

@[reassoc (attr := simp)]
lemma Œ¥‚ÇÇ_one_comp_œÉ‚ÇÇ_zero : Œ¥‚ÇÇ (1 : Fin 2) ‚â´ œÉ‚ÇÇ 0 = ùüô _ := SimplexCategory.Œ¥_comp_œÉ_succ

/-- The hom-types of the refl quiver underlying a simplicial set `S` are types of edges in `S _[1]‚ÇÇ`
together with source and target equalities. -/
@[ext]
structure OneTruncation‚ÇÇ.Hom {S : SSet.Truncated 2} (X Y : OneTruncation‚ÇÇ S) where
  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes the data of a 1-simplex. -/
  edge : S _[1]‚ÇÇ
  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes a source equality. -/
  src_eq : S.map (Œ¥‚ÇÇ 1).op edge = X
  /-- An arrow in `OneTruncation‚ÇÇ.Hom X Y` includes a target equality. -/
  tgt_eq : S.map (Œ¥‚ÇÇ 0).op edge = Y

/-- A 2-truncated simplicial set `S` has an underlying refl quiver `SSet.OneTruncation‚ÇÇ S`. -/
instance (S : SSet.Truncated 2) : ReflQuiver (OneTruncation‚ÇÇ S) where
  Hom X Y := SSet.OneTruncation‚ÇÇ.Hom X Y
  id X :=
    { edge := S.map (SSet.œÉ‚ÇÇ (n := 0) 0).op X
      src_eq := by
        simp only [‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, Œ¥‚ÇÇ_one_comp_œÉ‚ÇÇ_zero,
          op_id, FunctorToTypes.map_id_apply]
      tgt_eq := by
        simp only [‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, Œ¥‚ÇÇ_zero_comp_œÉ‚ÇÇ_zero,
          op_id, FunctorToTypes.map_id_apply] }

@[simp]
lemma OneTruncation‚ÇÇ.id_edge {S : SSet.Truncated 2} (X : OneTruncation‚ÇÇ S) :
    OneTruncation‚ÇÇ.Hom.edge (ùüôrq X) = S.map (SSet.œÉ‚ÇÇ 0).op X := rfl

/-- The functor that carries a 2-truncated simplicial set to its underlying refl quiver. -/
@[simps]
def oneTruncation‚ÇÇ : SSet.Truncated.{u} 2 ‚•§ ReflQuiv.{u, u} where
  obj S := ReflQuiv.of (OneTruncation‚ÇÇ S)
  map {S T} F := {
    obj := F.app (op [0]‚ÇÇ)
    map := fun f ‚Ü¶
      { edge := F.app _ f.edge
        src_eq := by rw [‚Üê FunctorToTypes.naturality, f.src_eq]
        tgt_eq := by rw [‚Üê FunctorToTypes.naturality, f.tgt_eq] }
    map_id := fun X ‚Ü¶ OneTruncation‚ÇÇ.Hom.ext (by
      dsimp
      rw [‚Üê FunctorToTypes.naturality]) }

@[ext] lemma hom‚ÇÇ_ext {S : SSet.Truncated 2} {x y : OneTruncation‚ÇÇ S} {f g : x ‚ü∂ y} :
    f.edge = g.edge ‚Üí f = g := OneTruncation‚ÇÇ.Hom.ext

section
variable {C : Type u} [Category.{v} C]

/-- An equivalence between the type of objects underlying a category and the type of 0-simplices in
the 2-truncated nerve. -/
@[simps]
def OneTruncation‚ÇÇ.nerveEquiv :
    C ‚âÉ OneTruncation‚ÇÇ ((SSet.truncation 2).obj (nerve C)) where
  toFun X := .mk‚ÇÄ X
  invFun X := X.obj' 0
  left_inv _ := rfl
  right_inv _ := ComposableArrows.ext‚ÇÄ rfl

/-- A hom equivalence over the function `OneTruncation‚ÇÇ.nerveEquiv.toFun`. -/
def OneTruncation‚ÇÇ.nerveHomEquiv {X Y : C} : (X ‚ü∂ Y) ‚âÉ (nerveEquiv X ‚ü∂ nerveEquiv Y) where
  toFun f :=
    { edge := ComposableArrows.mk‚ÇÅ f
      src_eq := ComposableArrows.ext‚ÇÄ rfl
      tgt_eq := ComposableArrows.ext‚ÇÄ rfl }
  invFun œÜ := eqToHom (congr_arg ComposableArrows.left œÜ.src_eq.symm) ‚â´ œÜ.edge.hom ‚â´
      eqToHom (congr_arg ComposableArrows.left œÜ.tgt_eq)
  left_inv f := by dsimp; simp only [comp_id, id_comp]; rfl
  right_inv œÜ := by
    ext
    exact ComposableArrows.ext‚ÇÅ (congr_arg ComposableArrows.left œÜ.src_eq).symm
      (congr_arg ComposableArrows.left œÜ.tgt_eq).symm rfl

/-- A hom equivalence over the function `OneTruncation‚ÇÇ.nerveEquiv.invFun`. -/
def OneTruncation‚ÇÇ.nerveHomEquivInv {X Y : OneTruncation‚ÇÇ ((SSet.truncation 2).obj (nerve C))} :
  (X ‚ü∂ Y) ‚âÉ (nerveEquiv.invFun X ‚ü∂ nerveEquiv.invFun Y) where
  toFun œÜ := eqToHom (congr_arg ComposableArrows.left œÜ.src_eq.symm) ‚â´ œÜ.edge.hom ‚â´
      eqToHom (congr_arg ComposableArrows.left œÜ.tgt_eq)
  invFun f :=
    { edge := ComposableArrows.mk‚ÇÅ f
      src_eq := ComposableArrows.ext‚ÇÄ rfl
      tgt_eq := ComposableArrows.ext‚ÇÄ rfl }
  left_inv œÜ := by
    ext
    exact ComposableArrows.ext‚ÇÅ (congr_arg ComposableArrows.left œÜ.src_eq).symm
      (congr_arg ComposableArrows.left œÜ.tgt_eq).symm rfl
  right_inv f := by dsimp; simp only [comp_id, id_comp]; rfl

/-- The refl prefunctor from the refl quiver underlying a nerve to the refl quiver underlying a
category. -/
def OneTruncation‚ÇÇ.ofNerve‚ÇÇ.hom : OneTruncation‚ÇÇ ((SSet.truncation 2).obj (nerve C)) ‚•§rq C where
  obj := nerveEquiv.invFun
  map := nerveHomEquivInv
  map_id := fun X : ComposableArrows _ 0 => by
    obtain ‚ü®x, rfl‚ü© := X.mk‚ÇÄ_surjective
    simp [map, nerveHomEquivInv]; rfl

/-- The refl prefunctor from the refl quiver underlying a category to the refl quiver underlying
a nerve. -/
def OneTruncation‚ÇÇ.ofNerve‚ÇÇ.inv : C ‚•§rq OneTruncation‚ÇÇ (nerveFunctor‚ÇÇ.obj (Cat.of C)) where
  obj := (.mk‚ÇÄ ¬∑)
  map := fun f => by
    refine ‚ü®.mk‚ÇÅ f, ?_, ?_‚ü© <;> apply ComposableArrows.ext‚ÇÄ <;> simp <;> rfl
  map_id _ := by ext; apply ComposableArrows.ext‚ÇÅ <;> simp <;> rfl

/-- The refl quiver underlying a nerve is isomorphic to the refl quiver underlying the category. -/
def OneTruncation‚ÇÇ.ofNerve‚ÇÇ (C : Type u) [Category.{u} C] :
    ReflQuiv.of (OneTruncation‚ÇÇ (nerveFunctor‚ÇÇ.obj (Cat.of C))) ‚âÖ ReflQuiv.of C := by
  refine {
    hom := ofNerve‚ÇÇ.hom
    inv := ofNerve‚ÇÇ.inv (C := C)
    hom_inv_id := ?_
    inv_hom_id := ?_
  }
  ¬∑ have H1 {X X' Y : OneTruncation‚ÇÇ (nerveFunctor‚ÇÇ.obj (Cat.of C))}
        (f : X ‚ü∂ Y) (h : X = X') : (Eq.rec f h : X' ‚ü∂ Y).edge = f.edge := by cases h; rfl
    have H2 {X Y Y' : OneTruncation‚ÇÇ (nerveFunctor‚ÇÇ.obj (Cat.of C))}
        (f : X ‚ü∂ Y) (h : Y = Y') : (Eq.rec f h : X ‚ü∂ Y').edge = f.edge := by cases h; rfl
    fapply ReflPrefunctor.ext <;> simp
    ¬∑ exact fun _ ‚Ü¶ ComposableArrows.ext‚ÇÄ rfl
    ¬∑ intro X Y f
      obtain ‚ü®f, rfl, rfl‚ü© := f
      apply OneTruncation‚ÇÇ.Hom.ext
      simp [ReflQuiv.comp_eq_comp]
      refine ((H2 _ _).trans ((H1 _ _).trans (ComposableArrows.ext‚ÇÅ ?_ ?_ ?_))).symm
      ¬∑ rfl
      ¬∑ rfl
      ¬∑ simp [ofNerve‚ÇÇ.inv, ofNerve‚ÇÇ.hom, nerveHomEquivInv]; rfl
  ¬∑ fapply ReflPrefunctor.ext <;> simp
    ¬∑ exact fun _ ‚Ü¶ rfl
    ¬∑ intro X Y f
      simp [ReflQuiv.comp_eq_comp, ReflQuiv.id_eq_id, ofNerve‚ÇÇ.inv, ofNerve‚ÇÇ.hom, nerveHomEquivInv,
        SimplexCategory.Truncated.inclusion]

/-- The refl quiver underlying a nerve is naturally isomorphic to the refl quiver underlying the
category. -/
@[simps! hom_app_obj hom_app_map inv_app_obj_obj inv_app_obj_map inv_app_map]
def OneTruncation‚ÇÇ.ofNerve‚ÇÇ.natIso :
    nerveFunctor‚ÇÇ.{u,u} ‚ãô SSet.oneTruncation‚ÇÇ ‚âÖ ReflQuiv.forget := by
  refine NatIso.ofComponents (fun C => OneTruncation‚ÇÇ.ofNerve‚ÇÇ C) ?nat
  ¬∑ intro C D F
    fapply ReflPrefunctor.ext <;> simp
    ¬∑ exact fun _ ‚Ü¶ rfl
    ¬∑ intro X Y f
      obtain ‚ü®f, rfl, rfl‚ü© := f
      unfold SSet.oneTruncation‚ÇÇ nerveFunctor‚ÇÇ SSet.truncation SimplicialObject.truncation
        nerveFunctor mapComposableArrows toReflPrefunctor
      simp [ReflQuiv.comp_eq_comp, ofNerve‚ÇÇ, ofNerve‚ÇÇ.hom, nerveHomEquivInv]

end

section

private lemma map_map_of_eq.{w}  {C : Type u} [Category.{v} C] (V : C·µí·µñ ‚•§ Type w) {X Y Z : C}
    {Œ± : X ‚ü∂ Y} {Œ≤ : Y ‚ü∂ Z} {Œ≥ : X ‚ü∂ Z} {œÜ} :
    Œ± ‚â´ Œ≤ = Œ≥ ‚Üí V.map Œ±.op (V.map Œ≤.op œÜ) = V.map Œ≥.op œÜ := by
  rintro rfl
  change (V.map _ ‚â´ V.map _) _ = _
  rw [‚Üê map_comp]; rfl

variable {V : SSet}

open SSet

namespace Truncated

local notation (priority := high) "[" n "]" => SimplexCategory.mk n

/-- The map that picks up the initial vertex of a 2-simplex, as a morphism in the 2-truncated
simplex category. -/
def Œπ0‚ÇÇ : [0]‚ÇÇ ‚ü∂ [2]‚ÇÇ := Œ¥‚ÇÇ (n := 0) 1 ‚â´ Œ¥‚ÇÇ (n := 1) 1

/-- The map that picks up the middle vertex of a 2-simplex, as a morphism in the 2-truncated
simplex category. -/
def Œπ1‚ÇÇ : [0]‚ÇÇ ‚ü∂ [2]‚ÇÇ := Œ¥‚ÇÇ (n := 0) 0 ‚â´ Œ¥‚ÇÇ (n := 1) 2

/-- The map that picks up the final vertex of a 2-simplex, as a morphism in the 2-truncated
simplex category. -/
def Œπ2‚ÇÇ : [0]‚ÇÇ ‚ü∂ [2]‚ÇÇ := Œ¥‚ÇÇ (n := 0) 0 ‚â´ Œ¥‚ÇÇ (n := 1) 1

/-- The initial vertex of a 2-simplex in a 2-truncated simplicial set. -/
def ev0‚ÇÇ {V : SSet.Truncated 2} (œÜ : V _[2]‚ÇÇ) : OneTruncation‚ÇÇ V := V.map Œπ0‚ÇÇ.op œÜ

/-- The middle vertex of a 2-simplex in a 2-truncated simplicial set. -/
def ev1‚ÇÇ {V : SSet.Truncated 2} (œÜ : V _[2]‚ÇÇ) : OneTruncation‚ÇÇ V := V.map Œπ1‚ÇÇ.op œÜ

/-- The final vertex of a 2-simplex in a 2-truncated simplicial set. -/
def ev2‚ÇÇ {V : SSet.Truncated 2} (œÜ : V _[2]‚ÇÇ) : OneTruncation‚ÇÇ V := V.map Œπ2‚ÇÇ.op œÜ

/-- The 0th face of a 2-simplex, as a morphism in the 2-truncated simplex category. -/
def Œ¥0‚ÇÇ : [1]‚ÇÇ ‚ü∂ [2]‚ÇÇ := Œ¥‚ÇÇ (n := 1) 0

/-- The 1st face of a 2-simplex, as a morphism in the 2-truncated simplex category. -/
def Œ¥1‚ÇÇ : [1]‚ÇÇ ‚ü∂ [2]‚ÇÇ := Œ¥‚ÇÇ (n := 1) 1

/-- The 2nd face of a 2-simplex, as a morphism in the 2-truncated simplex category. -/
def Œ¥2‚ÇÇ : [1]‚ÇÇ ‚ü∂ [2]‚ÇÇ := Œ¥‚ÇÇ (n := 1) 2

/-- The arrow in the ReflQuiver `OneTruncation‚ÇÇ V` of a 2-truncated simplicial set arising from the
0th face of a 2-simplex. -/
def ev12‚ÇÇ {V : SSet.Truncated 2} (œÜ : V _[2]‚ÇÇ) : ev1‚ÇÇ œÜ ‚ü∂ ev2‚ÇÇ œÜ :=
  ‚ü®V.map Œ¥0‚ÇÇ.op œÜ,
    map_map_of_eq V (SimplexCategory.Œ¥_comp_Œ¥ (i := 0) (j := 1) (by decide)).symm,
    map_map_of_eq V rfl‚ü©

/-- The arrow in the ReflQuiver `OneTruncation‚ÇÇ V` of a 2-truncated simplicial set arising from the
1st face of a 2-simplex. -/
def ev02‚ÇÇ {V : SSet.Truncated 2} (œÜ : V _[2]‚ÇÇ) : ev0‚ÇÇ œÜ ‚ü∂ ev2‚ÇÇ œÜ :=
  ‚ü®V.map Œ¥1‚ÇÇ.op œÜ, map_map_of_eq V rfl, map_map_of_eq V rfl‚ü©

/-- The arrow in the ReflQuiver `OneTruncation‚ÇÇ V` of a 2-truncated simplicial set arising from the
2nd face of a 2-simplex. -/
def ev01‚ÇÇ {V : SSet.Truncated 2} (œÜ : V _[2]‚ÇÇ) : ev0‚ÇÇ œÜ ‚ü∂ ev1‚ÇÇ œÜ :=
  ‚ü®V.map Œ¥2‚ÇÇ.op œÜ, map_map_of_eq V (SimplexCategory.Œ¥_comp_Œ¥ (j := 1) le_rfl), map_map_of_eq V rfl‚ü©

end Truncated
open Truncated

/-- The 2-simplices in a 2-truncated simplicial set `V` generate a hom relation on the free
category on the underlying refl quiver of `V`. -/
inductive HoRel‚ÇÇ {V : SSet.Truncated 2} :
    (X Y : Cat.FreeRefl (OneTruncation‚ÇÇ V)) ‚Üí (f g : X ‚ü∂ Y) ‚Üí Prop
  | mk (œÜ : V _[2]‚ÇÇ) :
    HoRel‚ÇÇ _ _
      (Quot.mk _ (Quiver.Hom.toPath (ev02‚ÇÇ œÜ)))
      (Quot.mk _ ((Quiver.Hom.toPath (ev01‚ÇÇ œÜ)).comp
        (Quiver.Hom.toPath (ev12‚ÇÇ œÜ))))

theorem HoRel‚ÇÇ.ext_triangle {V} (X X' Y Y' Z Z' : OneTruncation‚ÇÇ V)
    (hX : X = X') (hY : Y = Y') (hZ : Z = Z')
    (f : X ‚ü∂ Z) (f' : X' ‚ü∂ Z') (hf : f.edge = f'.edge)
    (g : X ‚ü∂ Y) (g' : X' ‚ü∂ Y') (hg : g.edge = g'.edge)
    (h : Y ‚ü∂ Z) (h' : Y' ‚ü∂ Z') (hh : h.edge = h'.edge) :
    HoRel‚ÇÇ _ _
      ((Quotient.functor _).map (.cons .nil f))
      ((Quotient.functor _).map (.cons (.cons .nil g) h)) ‚Üî
    HoRel‚ÇÇ _ _
      ((Quotient.functor _).map (.cons .nil f'))
      ((Quotient.functor _).map (.cons (.cons .nil g') h')) := by
  cases hX
  cases hY
  cases hZ
  congr! <;> apply OneTruncation‚ÇÇ.Hom.ext <;> assumption

/-- The type underlying the homotopy category of a 2-truncated simplicial set `V`. -/
def _root_.SSet.Truncated.homotopyCategory (V : SSet.Truncated.{u} 2) : Type u :=
  Quotient (HoRel‚ÇÇ (V := V))

instance (V : SSet.Truncated.{u} 2) : Category.{u} (SSet.hoFunctor‚ÇÇObj V) :=
  inferInstanceAs (Category (Quotient ..))

/-- A canonical functor from the free category on the refl quiver underlying a 2-truncated
simplicial set `V` to its homotopy category. -/
def _root_.SSet.Truncated.HomotopyCategory.quotientFunctor (V : SSet.Truncated.{u} 2) :
    Cat.FreeRefl (OneTruncation‚ÇÇ V) ‚•§ V.HomotopyCategory :=
  Quotient.functor _

/-- By `Quotient.lift_unique'` (not `Quotient.lift`) we have that `quotientFunctor V` is an
epimorphism. -/
theorem hoFunctor‚ÇÇObj.lift_unique' (V : SSet.Truncated.{u} 2)
    {D} [Category D] (F‚ÇÅ F‚ÇÇ : hoFunctor‚ÇÇObj V ‚•§ D)
    (h : quotientFunctor V ‚ãô F‚ÇÅ = quotientFunctor V ‚ãô F‚ÇÇ) : F‚ÇÅ = F‚ÇÇ :=
  Quotient.lift_unique' (C := Cat.freeRefl.obj (ReflQuiv.of (OneTruncation‚ÇÇ V)))
    (HoRel‚ÇÇ (V := V)) _ _ h

/-- A map of 2-truncated simplicial sets induces a functor between homotopy categories. -/
def hoFunctor‚ÇÇMap {V W : SSet.Truncated.{u} 2} (F : V ‚ü∂ W) : hoFunctor‚ÇÇObj V ‚•§ hoFunctor‚ÇÇObj W :=
  Quotient.lift _
    ((by exact (oneTruncation‚ÇÇ ‚ãô Cat.freeRefl).map F) ‚ãô hoFunctor‚ÇÇObj.quotientFunctor _)
    (fun X Y f g hfg => by
      let .mk œÜ := hfg
      apply Quotient.sound
      convert HoRel‚ÇÇ.mk (F.app (op _) œÜ) using 0
      apply HoRel‚ÇÇ.ext_triangle
      ¬∑ exact congrFun (F.naturality Œπ0‚ÇÇ.op) œÜ
      ¬∑ exact congrFun (F.naturality Œπ1‚ÇÇ.op) œÜ
      ¬∑ exact congrFun (F.naturality Œπ2‚ÇÇ.op) œÜ
      ¬∑ exact congrFun (F.naturality Œ¥1‚ÇÇ.op) œÜ
      ¬∑ exact congrFun (F.naturality Œ¥2‚ÇÇ.op) œÜ
      ¬∑ exact congrFun (F.naturality Œ¥0‚ÇÇ.op) œÜ)

/-- The functor that takes a 2-truncated simplicial set to its homotopy category. -/
def hoFunctor‚ÇÇ : SSet.Truncated.{u} 2 ‚•§ Cat.{u,u} where
  obj V := Cat.of (hoFunctor‚ÇÇObj V)
  map {S T} F := hoFunctor‚ÇÇMap F
  map_id S := by
    apply Quotient.lift_unique'
    simp [hoFunctor‚ÇÇMap, Quotient.lift_spec]
    exact Eq.trans (Functor.id_comp ..) (Functor.comp_id _).symm
  map_comp {S T U} F G := by
    apply Quotient.lift_unique'
    simp [hoFunctor‚ÇÇMap, SSet.hoFunctor‚ÇÇObj.quotientFunctor]
    rw [Quotient.lift_spec, Cat.comp_eq_comp, Cat.comp_eq_comp, ‚Üê Functor.assoc, Functor.assoc,
      Quotient.lift_spec, Functor.assoc, Quotient.lift_spec]

theorem hoFunctor‚ÇÇ_naturality {X Y : SSet.Truncated.{u} 2} (f : X ‚ü∂ Y) :
    (oneTruncation‚ÇÇ ‚ãô Cat.freeRefl).map f ‚ãô hoFunctor‚ÇÇObj.quotientFunctor Y =
      hoFunctor‚ÇÇObj.quotientFunctor X ‚ãô hoFunctor‚ÇÇMap f := rfl

/-- The functor that takes a simplicial set to its homotopy category by passing through the
2-truncation. -/
def hoFunctor : SSet.{u} ‚•§ Cat.{u, u} := SSet.truncation 2 ‚ãô hoFunctor‚ÇÇ

end

end

end SSet
end CategoryTheory
