/-
Copyright (c) 2020 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau
-/
import Mathlib.Algebra.DirectLimit
import Mathlib.Algebra.CharP.Algebra
import Mathlib.FieldTheory.IsAlgClosed.Basic
import Mathlib.FieldTheory.SplittingField.Construction

#align_import field_theory.is_alg_closed.algebraic_closure from "leanprover-community/mathlib"@"df76f43357840485b9d04ed5dee5ab115d420e87"

/-!
# Algebraic Closure

In this file we construct the algebraic closure of a field

## Main Definitions

- `AlgebraicClosure k` is an algebraic closure of `k` (in the same universe).
  It is constructed by taking the polynomial ring generated by indeterminates `x_f`
  corresponding to monic irreducible polynomials `f` with coefficients in `k`, and quotienting
  out by a maximal ideal containing every `f(x_f)`, and then repeating this step countably
  many times. See Exercise 1.13 in Atiyah--Macdonald.

## Tags

algebraic closure, algebraically closed
-/


universe u v w

noncomputable section

open scoped Classical BigOperators Polynomial

open Polynomial

variable (k : Type u) [Field k]

namespace AlgebraicClosure

open MvPolynomial

/-- The subtype of monic irreducible polynomials -/
@[reducible]
def MonicIrreducible : Type u :=
  { f : k[X] // Monic f ‚àß Irreducible f }
#align algebraic_closure.monic_irreducible AlgebraicClosure.MonicIrreducible

/-- Sends a monic irreducible polynomial `f` to `f(x_f)` where `x_f` is a formal indeterminate. -/
def evalXSelf (f : MonicIrreducible k) : MvPolynomial (MonicIrreducible k) k :=
  Polynomial.eval‚ÇÇ MvPolynomial.C (X f) f
set_option linter.uppercaseLean3 false in
#align algebraic_closure.eval_X_self AlgebraicClosure.evalXSelf

/-- The span of `f(x_f)` across monic irreducible polynomials `f` where `x_f` is an
indeterminate. -/
def spanEval : Ideal (MvPolynomial (MonicIrreducible k) k) :=
  Ideal.span <| Set.range <| evalXSelf k
#align algebraic_closure.span_eval AlgebraicClosure.spanEval

/-- Given a finset of monic irreducible polynomials, construct an algebra homomorphism to the
splitting field of the product of the polynomials sending each indeterminate `x_f` represented by
the polynomial `f` in the finset to a root of `f`. -/
def toSplittingField (s : Finset (MonicIrreducible k)) :
    MvPolynomial (MonicIrreducible k) k ‚Üí‚Çê[k] SplittingField (‚àè x in s, x : k[X]) :=
  MvPolynomial.aeval fun f =>
    if hf : f ‚àà s then
      rootOfSplits _
        ((splits_prod_iff _ fun (j : MonicIrreducible k) _ => j.2.2.ne_zero).1
          (SplittingField.splits _) f hf)
        (mt isUnit_iff_degree_eq_zero.2 f.2.2.not_unit)
    else 37
#align algebraic_closure.to_splitting_field AlgebraicClosure.toSplittingField

theorem toSplittingField_evalXSelf {s : Finset (MonicIrreducible k)} {f} (hf : f ‚àà s) :
    toSplittingField k s (evalXSelf k f) = 0 := by
  rw [toSplittingField, evalXSelf, ‚Üê AlgHom.coe_toRingHom, hom_eval‚ÇÇ, AlgHom.coe_toRingHom,
    MvPolynomial.aeval_X, dif_pos hf, ‚Üê algebraMap_eq, AlgHom.comp_algebraMap]
  exact map_rootOfSplits _ _ _
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align algebraic_closure.to_splitting_field_eval_X_self AlgebraicClosure.toSplittingField_evalXSelf

theorem spanEval_ne_top : spanEval k ‚â† ‚ä§ := by
  rw [Ideal.ne_top_iff_one, spanEval, Ideal.span, ‚Üê Set.image_univ,
    Finsupp.mem_span_image_iff_total]
  rintro ‚ü®v, _, hv‚ü©
  -- ‚ä¢ False
  replace hv := congr_arg (toSplittingField k v.support) hv
  -- ‚ä¢ False
  rw [AlgHom.map_one, Finsupp.total_apply, Finsupp.sum, AlgHom.map_sum, Finset.sum_eq_zero] at hv
  -- ‚ä¢ False
  ¬∑ exact zero_ne_one hv
    -- üéâ no goals
  intro j hj
  -- ‚ä¢ ‚Üë(toSplittingField k v.support) (‚Üëv j ‚Ä¢ evalXSelf k j) = 0
  rw [smul_eq_mul, AlgHom.map_mul, toSplittingField_evalXSelf (s := v.support) hj,
    mul_zero]
#align algebraic_closure.span_eval_ne_top AlgebraicClosure.spanEval_ne_top

/-- A random maximal ideal that contains `spanEval k` -/
def maxIdeal : Ideal (MvPolynomial (MonicIrreducible k) k) :=
  Classical.choose <| Ideal.exists_le_maximal _ <| spanEval_ne_top k
#align algebraic_closure.max_ideal AlgebraicClosure.maxIdeal

instance maxIdeal.isMaximal : (maxIdeal k).IsMaximal :=
  (Classical.choose_spec <| Ideal.exists_le_maximal _ <| spanEval_ne_top k).1
#align algebraic_closure.max_ideal.is_maximal AlgebraicClosure.maxIdeal.isMaximal

theorem le_maxIdeal : spanEval k ‚â§ maxIdeal k :=
  (Classical.choose_spec <| Ideal.exists_le_maximal _ <| spanEval_ne_top k).2
#align algebraic_closure.le_max_ideal AlgebraicClosure.le_maxIdeal

/-- The first step of constructing `AlgebraicClosure`: adjoin a root of all monic polynomials -/
def AdjoinMonic : Type u :=
  MvPolynomial (MonicIrreducible k) k ‚ß∏ maxIdeal k
#align algebraic_closure.adjoin_monic AlgebraicClosure.AdjoinMonic

instance AdjoinMonic.field : Field (AdjoinMonic k) :=
  Ideal.Quotient.field _
#align algebraic_closure.adjoin_monic.field AlgebraicClosure.AdjoinMonic.field

instance AdjoinMonic.inhabited : Inhabited (AdjoinMonic k) :=
  ‚ü®37‚ü©
#align algebraic_closure.adjoin_monic.inhabited AlgebraicClosure.AdjoinMonic.inhabited

/-- The canonical ring homomorphism to `AdjoinMonic k`. -/
def toAdjoinMonic : k ‚Üí+* AdjoinMonic k :=
  (Ideal.Quotient.mk _).comp C
#align algebraic_closure.to_adjoin_monic AlgebraicClosure.toAdjoinMonic

instance AdjoinMonic.algebra : Algebra k (AdjoinMonic k) :=
  (toAdjoinMonic k).toAlgebra
#align algebraic_closure.adjoin_monic.algebra AlgebraicClosure.AdjoinMonic.algebra

-- Porting note: In the statement, the type of `C` had to be made explicit.
theorem AdjoinMonic.algebraMap : algebraMap k (AdjoinMonic k) = (Ideal.Quotient.mk _).comp
  (C : k ‚Üí+* MvPolynomial (MonicIrreducible k) k) := rfl
#align algebraic_closure.adjoin_monic.algebra_map AlgebraicClosure.AdjoinMonic.algebraMap

theorem AdjoinMonic.isIntegral (z : AdjoinMonic k) : IsIntegral k z := by
  let ‚ü®p, hp‚ü© := Ideal.Quotient.mk_surjective z
  -- ‚ä¢ IsIntegral k z
  rw [‚Üê hp]
  -- ‚ä¢ IsIntegral k (‚Üë(Ideal.Quotient.mk (maxIdeal k)) p)
  induction p using MvPolynomial.induction_on generalizing z with
    | h_C => exact isIntegral_algebraMap
    | h_add _ _ ha hb => exact isIntegral_add (ha _ rfl) (hb _ rfl)
    | h_X p f ih =>
      ¬∑ refine @isIntegral_mul k _ _ _ _ _ (Ideal.Quotient.mk (maxIdeal k) _) (ih _ rfl) ?_
        refine ‚ü®f, f.2.1, ?_‚ü©
        erw [AdjoinMonic.algebraMap, ‚Üê hom_eval‚ÇÇ, Ideal.Quotient.eq_zero_iff_mem]
        exact le_maxIdeal k (Ideal.subset_span ‚ü®f, rfl‚ü©)
#align algebraic_closure.adjoin_monic.is_integral AlgebraicClosure.AdjoinMonic.isIntegral

theorem AdjoinMonic.exists_root {f : k[X]} (hfm : f.Monic) (hfi : Irreducible f) :
    ‚àÉ x : AdjoinMonic k, f.eval‚ÇÇ (toAdjoinMonic k) x = 0 :=
  ‚ü®Ideal.Quotient.mk _ <| X (‚ü®f, hfm, hfi‚ü© : MonicIrreducible k), by
    rw [toAdjoinMonic, ‚Üê hom_eval‚ÇÇ, Ideal.Quotient.eq_zero_iff_mem]
    -- ‚ä¢ Polynomial.eval‚ÇÇ MvPolynomial.C (MvPolynomial.X { val := f, property := (_ : ‚Ä¶
    exact le_maxIdeal k (Ideal.subset_span <| ‚ü®_, rfl‚ü©)‚ü©
    -- üéâ no goals
#align algebraic_closure.adjoin_monic.exists_root AlgebraicClosure.AdjoinMonic.exists_root

/-- The `n`th step of constructing `AlgebraicClosure`, together with its `Field` instance. -/
def stepAux (n : ‚Ñï) : Œ£ Œ± : Type u, Field Œ± :=
  Nat.recOn n ‚ü®k, inferInstance‚ü© fun _ ih => ‚ü®@AdjoinMonic ih.1 ih.2, @AdjoinMonic.field ih.1 ih.2‚ü©
#align algebraic_closure.step_aux AlgebraicClosure.stepAux

/-- The `n`th step of constructing `AlgebraicClosure`. -/
def Step (n : ‚Ñï) : Type u :=
  (stepAux k n).1
#align algebraic_closure.step AlgebraicClosure.Step

-- Porting note: added during the port to help in the proof of `Step.isIntegral` below.
theorem Step.zero : Step k 0 = k := rfl

instance Step.field (n : ‚Ñï) : Field (Step k n) :=
  (stepAux k n).2
#align algebraic_closure.step.field AlgebraicClosure.Step.field

-- Porting note: added during the port to help in the proof of `Step.isIntegral` below.
theorem Step.succ (n : ‚Ñï) : Step k (n + 1) = AdjoinMonic (Step k n) := rfl

instance Step.inhabited (n) : Inhabited (Step k n) :=
  ‚ü®37‚ü©
#align algebraic_closure.step.inhabited AlgebraicClosure.Step.inhabited

/-- The canonical inclusion to the `0`th step. -/
def toStepZero : k ‚Üí+* Step k 0 :=
  RingHom.id k
#align algebraic_closure.to_step_zero AlgebraicClosure.toStepZero

/-- The canonical ring homomorphism to the next step. -/
def toStepSucc (n : ‚Ñï) : Step k n ‚Üí+* (Step k (n + 1)) :=
  @toAdjoinMonic (Step k n) (Step.field k n)
#align algebraic_closure.to_step_succ AlgebraicClosure.toStepSucc

instance Step.algebraSucc (n) : Algebra (Step k n) (Step k (n + 1)) :=
  (toStepSucc k n).toAlgebra
#align algebraic_closure.step.algebra_succ AlgebraicClosure.Step.algebraSucc

theorem toStepSucc.exists_root {n} {f : Polynomial (Step k n)} (hfm : f.Monic)
    (hfi : Irreducible f) : ‚àÉ x : Step k (n + 1), f.eval‚ÇÇ (toStepSucc k n) x = 0 := by
-- Porting note: original proof was `@AdjoinMonic.exists_root _ (Step.field k n) _ hfm hfi`,
-- but it timeouts.
  obtain ‚ü®x, hx‚ü© := @AdjoinMonic.exists_root _ (Step.field k n) _ hfm hfi
  -- ‚ä¢ ‚àÉ x, Polynomial.eval‚ÇÇ (toStepSucc k n) x f = 0
-- Porting note: using `hx` instead of `by apply hx` timeouts.
  exact ‚ü®x, by apply hx‚ü©
  -- üéâ no goals
#align algebraic_closure.to_step_succ.exists_root AlgebraicClosure.toStepSucc.exists_root

-- Porting note: the following two declarations were added during the port to be used in the
-- definition of toStepOfLE
private def toStepOfLE' (m n : ‚Ñï) (h : m ‚â§ n) : Step k m ‚Üí Step k n :=
Nat.leRecOn h @fun a => toStepSucc k a

private theorem toStepOfLE'.succ (m n : ‚Ñï) (h : m ‚â§ n) :
    toStepOfLE' k m (Nat.succ n) (h.trans n.le_succ) =
    (toStepSucc k n) ‚àò toStepOfLE' k m n h := by
  ext x
  -- ‚ä¢ AlgebraicClosure.toStepOfLE' k m (Nat.succ n) (_ : m ‚â§ Nat.succ n) x = (‚Üë(to ‚Ä¶
  convert Nat.leRecOn_succ h x
  -- ‚ä¢ m ‚â§ n + 1
  exact h.trans n.le_succ
  -- üéâ no goals

/-- The canonical ring homomorphism to a step with a greater index. -/
def toStepOfLE (m n : ‚Ñï) (h : m ‚â§ n) : Step k m ‚Üí+* Step k n where
  toFun := toStepOfLE' k m n h
  map_one' := by
-- Porting note: original proof was `induction' h with n h ih; ¬∑ exact Nat.leRecOn_self 1`
--                                   `rw [Nat.leRecOn_succ h, ih, RingHom.map_one]`
    induction' h with a h ih
    -- ‚ä¢ AlgebraicClosure.toStepOfLE' k m m (_ : Nat.le m m) 1 = 1
    ¬∑ exact Nat.leRecOn_self 1
      -- üéâ no goals
    ¬∑ rw [toStepOfLE'.succ k m a h]; simp [ih]
      -- ‚ä¢ (‚Üë(toStepSucc k a) ‚àò AlgebraicClosure.toStepOfLE' k m a h) 1 = 1
                                     -- üéâ no goals
  map_mul' x y := by
-- Porting note: original proof was `induction' h with n h ih; ¬∑ simp_rw [Nat.leRecOn_self]`
--                                   `simp_rw [Nat.leRecOn_succ h, ih, RingHom.map_mul]`
    induction' h with a h ih
    -- ‚ä¢ OneHom.toFun { toFun := AlgebraicClosure.toStepOfLE' k m m (_ : Nat.le m m), ‚Ä¶
    ¬∑ dsimp [toStepOfLE']; simp_rw [Nat.leRecOn_self]
      -- ‚ä¢ Nat.leRecOn (_ : Nat.le m m) (fun a => ‚Üë(toStepSucc k a)) (x * y) = Nat.leRe ‚Ä¶
                           -- üéâ no goals
    ¬∑ simp_rw [toStepOfLE'.succ k m a h]; simp only at ih; simp [ih]
      -- ‚ä¢ (‚Üë(toStepSucc k a) ‚àò AlgebraicClosure.toStepOfLE' k m a h) (x * y) = (‚Üë(toSt ‚Ä¶
                                          -- ‚ä¢ (‚Üë(toStepSucc k a) ‚àò AlgebraicClosure.toStepOfLE' k m a h) (x * y) = (‚Üë(toSt ‚Ä¶
                                                           -- üéâ no goals
-- Porting note: original proof was `induction' h with n h ih; ¬∑ exact Nat.leRecOn_self 0`
--                                   `rw [Nat.leRecOn_succ h, ih, RingHom.map_zero]`
  map_zero' := by
    induction' h with a h ih
    -- ‚ä¢ OneHom.toFun (‚Üë{ toOneHom := { toFun := AlgebraicClosure.toStepOfLE' k m m ( ‚Ä¶
    ¬∑ exact Nat.leRecOn_self 0
      -- üéâ no goals
    ¬∑ simp_rw [toStepOfLE'.succ k m a h]; simp only at ih; simp [ih]
      -- ‚ä¢ (‚Üë(toStepSucc k a) ‚àò AlgebraicClosure.toStepOfLE' k m a h) 0 = 0
                                          -- ‚ä¢ (‚Üë(toStepSucc k a) ‚àò AlgebraicClosure.toStepOfLE' k m a h) 0 = 0
                                                           -- üéâ no goals
  map_add' x y := by
-- Porting note: original proof was `induction' h with n h ih; ¬∑ simp_rw [Nat.leRecOn_self]`
--                                   `simp_rw [Nat.leRecOn_succ h, ih, RingHom.map_add]`
    induction' h with a h ih
    -- ‚ä¢ OneHom.toFun (‚Üë{ toOneHom := { toFun := AlgebraicClosure.toStepOfLE' k m m ( ‚Ä¶
    ¬∑ dsimp [toStepOfLE']; simp_rw [Nat.leRecOn_self]
      -- ‚ä¢ Nat.leRecOn (_ : Nat.le m m) (fun a => ‚Üë(toStepSucc k a)) (x + y) = Nat.leRe ‚Ä¶
                           -- üéâ no goals
    ¬∑ simp_rw [toStepOfLE'.succ k m a h]; simp only at ih; simp [ih]
      -- ‚ä¢ (‚Üë(toStepSucc k a) ‚àò AlgebraicClosure.toStepOfLE' k m a h) (x + y) = (‚Üë(toSt ‚Ä¶
                                          -- ‚ä¢ (‚Üë(toStepSucc k a) ‚àò AlgebraicClosure.toStepOfLE' k m a h) (x + y) = (‚Üë(toSt ‚Ä¶
                                                           -- üéâ no goals
#align algebraic_closure.to_step_of_le AlgebraicClosure.toStepOfLE

@[simp]
theorem coe_toStepOfLE (m n : ‚Ñï) (h : m ‚â§ n) :
    (toStepOfLE k m n h : Step k m ‚Üí Step k n) = Nat.leRecOn h @fun n => toStepSucc k n :=
  rfl
#align algebraic_closure.coe_to_step_of_le AlgebraicClosure.coe_toStepOfLE

instance Step.algebra (n) : Algebra k (Step k n) :=
  (toStepOfLE k 0 n n.zero_le).toAlgebra
#align algebraic_closure.step.algebra AlgebraicClosure.Step.algebra

instance Step.scalar_tower (n) : IsScalarTower k (Step k n) (Step k (n + 1)) :=
  IsScalarTower.of_algebraMap_eq fun z =>
    @Nat.leRecOn_succ (Step k) 0 n n.zero_le (n + 1).zero_le (@fun n => toStepSucc k n) z
#align algebraic_closure.step.scalar_tower AlgebraicClosure.Step.scalar_tower

--Porting Note: Added to make `Step.isIntegral` faster
private theorem toStepOfLE.succ (n : ‚Ñï) (h : 0 ‚â§ n) :
    toStepOfLE k 0 (n + 1) (h.trans n.le_succ) =
    (toStepSucc k n).comp (toStepOfLE k 0 n h) := by
    ext1 x
    -- ‚ä¢ ‚Üë(toStepOfLE k 0 (n + 1) (_ : 0 ‚â§ n + 1)) x = ‚Üë(RingHom.comp (toStepSucc k n ‚Ä¶
    rw [RingHom.comp_apply]
    -- ‚ä¢ ‚Üë(toStepOfLE k 0 (n + 1) (_ : 0 ‚â§ n + 1)) x = ‚Üë(toStepSucc k n) (‚Üë(toStepOfL ‚Ä¶
    simp only [toStepOfLE, RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk]
    -- ‚ä¢ AlgebraicClosure.toStepOfLE' k 0 (n + 1) (_ : 0 ‚â§ n + 1) x = ‚Üë(toStepSucc k  ‚Ä¶
    change _ = (_ ‚àò _) x
    -- ‚ä¢ AlgebraicClosure.toStepOfLE' k 0 (n + 1) (_ : 0 ‚â§ n + 1) x = (‚Üë(toStepSucc k ‚Ä¶
    rw [toStepOfLE'.succ k 0 n h]
    -- üéâ no goals

theorem Step.isIntegral (n) : ‚àÄ z : Step k n, IsIntegral k z := by
  induction' n with a h
  -- ‚ä¢ ‚àÄ (z : Step k Nat.zero), IsIntegral k z
  ¬∑ intro z
    -- ‚ä¢ IsIntegral k z
    exact isIntegral_algebraMap
    -- üéâ no goals
  ¬∑ intro z
    -- ‚ä¢ IsIntegral k z
    change RingHom.IsIntegralElem _ _
    -- ‚ä¢ RingHom.IsIntegralElem (algebraMap k (Step k (Nat.succ a))) z
    revert z
    -- ‚ä¢ ‚àÄ (z : Step k (Nat.succ a)), RingHom.IsIntegralElem (algebraMap k (Step k (N ‚Ä¶
    change RingHom.IsIntegral _
    -- ‚ä¢ RingHom.IsIntegral (algebraMap k (Step k (Nat.succ a)))
    unfold algebraMap
    -- ‚ä¢ RingHom.IsIntegral Algebra.toRingHom
    unfold Algebra.toRingHom
    -- ‚ä¢ RingHom.IsIntegral (algebra k (Nat.succ a)).2
    unfold algebra
    -- ‚ä¢ RingHom.IsIntegral (RingHom.toAlgebra (toStepOfLE k 0 (Nat.succ a) (_ : 0 ‚â§  ‚Ä¶
    unfold RingHom.toAlgebra
    -- ‚ä¢ RingHom.IsIntegral (RingHom.toAlgebra' (toStepOfLE k 0 (Nat.succ a) (_ : 0 ‚â§ ‚Ä¶
    unfold RingHom.toAlgebra'
    -- ‚ä¢ RingHom.IsIntegral (Algebra.mk (toStepOfLE k 0 (Nat.succ a) (_ : 0 ‚â§ Nat.suc ‚Ä¶
    simp only
    -- ‚ä¢ RingHom.IsIntegral (toStepOfLE k 0 (Nat.succ a) (_ : 0 ‚â§ Nat.succ a))
    rw [toStepOfLE.succ k a a.zero_le]
    -- ‚ä¢ RingHom.IsIntegral (RingHom.comp (toStepSucc k a) (toStepOfLE k 0 a (_ : 0 ‚â§ ‚Ä¶
    apply @RingHom.isIntegral_trans (Step k 0) (Step k a) (Step k (a + 1)) _ _ _
        (toStepOfLE k 0 a (a.zero_le : 0 ‚â§ a)) (toStepSucc k a) _
    ¬∑ intro z
      -- ‚ä¢ RingHom.IsIntegralElem (toStepSucc k a) z
      have := AdjoinMonic.isIntegral (Step k a) (z : Step k (a + 1))
      -- ‚ä¢ RingHom.IsIntegralElem (toStepSucc k a) z
      convert this
      -- üéâ no goals
    ¬∑ convert h --Porting Note: This times out at 500000
      -- üéâ no goals
#align algebraic_closure.step.is_integral AlgebraicClosure.Step.isIntegral

instance toStepOfLE.directedSystem : DirectedSystem (Step k) fun i j h => toStepOfLE k i j h :=
  ‚ü®fun _ x _ => Nat.leRecOn_self x, fun h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ x => (Nat.leRecOn_trans h‚ÇÅ‚ÇÇ h‚ÇÇ‚ÇÉ x).symm‚ü©
#align algebraic_closure.to_step_of_le.directed_system AlgebraicClosure.toStepOfLE.directedSystem

end AlgebraicClosure

/-- The canonical algebraic closure of a field, the direct limit of adding roots to the field for
each polynomial over the field. -/
def AlgebraicClosure : Type u :=
  Ring.DirectLimit (AlgebraicClosure.Step k) fun i j h => AlgebraicClosure.toStepOfLE k i j h
#align algebraic_closure AlgebraicClosure

namespace AlgebraicClosure

instance : Field (AlgebraicClosure k) :=
  Field.DirectLimit.field _ _

instance : Inhabited (AlgebraicClosure k) :=
  ‚ü®37‚ü©

/-- The canonical ring embedding from the `n`th step to the algebraic closure. -/
def ofStep (n : ‚Ñï) : Step k n ‚Üí+* AlgebraicClosure k :=
  Ring.DirectLimit.of _ _ _
#align algebraic_closure.of_step AlgebraicClosure.ofStep

instance algebraOfStep (n) : Algebra (Step k n) (AlgebraicClosure k) :=
  (ofStep k n).toAlgebra
#align algebraic_closure.algebra_of_step AlgebraicClosure.algebraOfStep

theorem ofStep_succ (n : ‚Ñï) : (ofStep k (n + 1)).comp (toStepSucc k n) = ofStep k n := by
  ext x
  -- ‚ä¢ ‚Üë(RingHom.comp (ofStep k (n + 1)) (toStepSucc k n)) x = ‚Üë(ofStep k n) x
  have hx : toStepOfLE' k n (n+1) n.le_succ x = toStepSucc k n x:= Nat.leRecOn_succ' x
  -- ‚ä¢ ‚Üë(RingHom.comp (ofStep k (n + 1)) (toStepSucc k n)) x = ‚Üë(ofStep k n) x
  unfold ofStep
  -- ‚ä¢ ‚Üë(RingHom.comp (Ring.DirectLimit.of (Step k) (fun i j h => ‚Üë(toStepOfLE k i  ‚Ä¶
  rw [RingHom.comp_apply]
  -- ‚ä¢ ‚Üë(Ring.DirectLimit.of (Step k) (fun i j h => ‚Üë(toStepOfLE k i j h)) (n + 1)) ‚Ä¶
  dsimp [toStepOfLE]
  -- ‚ä¢ ‚Üë(Ring.DirectLimit.of (Step k) (fun i j h => AlgebraicClosure.toStepOfLE' k  ‚Ä¶
  rw [‚Üê hx]
  -- ‚ä¢ ‚Üë(Ring.DirectLimit.of (Step k) (fun i j h => AlgebraicClosure.toStepOfLE' k  ‚Ä¶
  change Ring.DirectLimit.of (Step k) (toStepOfLE' k) (n + 1) (_) =
      Ring.DirectLimit.of (Step k) (toStepOfLE' k) n x
  convert Ring.DirectLimit.of_f n.le_succ x
  -- üéâ no goals
  -- Porting Note: Original proof timed out at 2 mil. Heartbeats. The problem was likely
  -- in comparing `toStepOfLE'` with `toStepSucc`. In the above, I made some things more explicit
  -- Original proof:
  -- RingHom.ext fun x =>
  --   show Ring.DirectLimit.of (Step k) (fun i j h => toStepOfLE k i j h) _ _ = _ by
  --     convert Ring.DirectLimit.of_f n.le_succ x; ext x; exact (Nat.leRecOn_succ' x).symm
#align algebraic_closure.of_step_succ AlgebraicClosure.ofStep_succ

theorem exists_ofStep (z : AlgebraicClosure k) : ‚àÉ n x, ofStep k n x = z :=
  Ring.DirectLimit.exists_of z
#align algebraic_closure.exists_of_step AlgebraicClosure.exists_ofStep

theorem exists_root {f : Polynomial (AlgebraicClosure k)} (hfm : f.Monic) (hfi : Irreducible f) :
    ‚àÉ x : AlgebraicClosure k, f.eval x = 0 := by
  have : ‚àÉ n p, Polynomial.map (ofStep k n) p = f := by
    convert Ring.DirectLimit.Polynomial.exists_of f
  obtain ‚ü®n, p, rfl‚ü© := this
  -- ‚ä¢ ‚àÉ x, eval x (map (ofStep k n) p) = 0
  rw [monic_map_iff] at hfm
  -- ‚ä¢ ‚àÉ x, eval x (map (ofStep k n) p) = 0
  have := hfm.irreducible_of_irreducible_map (ofStep k n) p hfi
  -- ‚ä¢ ‚àÉ x, eval x (map (ofStep k n) p) = 0
  obtain ‚ü®x, hx‚ü© := toStepSucc.exists_root k hfm this
  -- ‚ä¢ ‚àÉ x, eval x (map (ofStep k n) p) = 0
  refine' ‚ü®ofStep k (n + 1) x, _‚ü©
  -- ‚ä¢ eval (‚Üë(ofStep k (n + 1)) x) (map (ofStep k n) p) = 0
  rw [‚Üê ofStep_succ k n, eval_map, ‚Üê hom_eval‚ÇÇ, hx, RingHom.map_zero]
  -- üéâ no goals
#align algebraic_closure.exists_root AlgebraicClosure.exists_root

instance instIsAlgClosed : IsAlgClosed (AlgebraicClosure k) :=
  IsAlgClosed.of_exists_root _ fun _ => exists_root k
#align algebraic_closure.is_alg_closed AlgebraicClosure.instIsAlgClosed

instance instAlgebra {R : Type*} [CommSemiring R] [alg : Algebra R k] :
    Algebra R (AlgebraicClosure k) :=
  ((ofStep k 0).comp (@algebraMap _ _ _ _ alg)).toAlgebra

theorem algebraMap_def {R : Type*} [CommSemiring R] [alg : Algebra R k] :
    algebraMap R (AlgebraicClosure k) = (ofStep k 0 : k ‚Üí+* _).comp (@algebraMap _ _ _ _ alg) :=
  rfl
#align algebraic_closure.algebra_map_def AlgebraicClosure.algebraMap_def


instance {R S : Type*} [CommSemiring R] [CommSemiring S] [Algebra R S] [Algebra S k] [Algebra R k]
    [IsScalarTower R S k] : IsScalarTower R S (AlgebraicClosure k) := by
  apply IsScalarTower.of_algebraMap_eq _
  -- ‚ä¢ ‚àÄ (x : R), ‚Üë(algebraMap R (AlgebraicClosure k)) x = ‚Üë(algebraMap S (Algebrai ‚Ä¶
  intro x
  -- ‚ä¢ ‚Üë(algebraMap R (AlgebraicClosure k)) x = ‚Üë(algebraMap S (AlgebraicClosure k) ‚Ä¶
  simp only [algebraMap_def]
  -- ‚ä¢ ‚Üë(RingHom.comp (ofStep k 0) (algebraMap R (Step k 0))) x = ‚Üë(RingHom.comp (o ‚Ä¶
  rw [RingHom.comp_apply, RingHom.comp_apply]
  -- ‚ä¢ ‚Üë(ofStep k 0) (‚Üë(algebraMap R (Step k 0)) x) = ‚Üë(ofStep k 0) (‚Üë(algebraMap S ‚Ä¶
  exact RingHom.congr_arg _ (IsScalarTower.algebraMap_apply R S k x : _)
  -- üéâ no goals
  -- Porting Note: Original proof (without `by`) didn't work anymore, I think it couldn't figure
  -- out `algebraMap_def`. Orignally:
  -- IsScalarTower.of_algebraMap_eq fun x =>
  --   RingHom.congr_arg _ (IsScalarTower.algebraMap_apply R S k x : _)

/-- Canonical algebra embedding from the `n`th step to the algebraic closure. -/
def ofStepHom (n) : Step k n ‚Üí‚Çê[k] AlgebraicClosure k :=
  { ofStep k n with
    commutes' := by
    --Porting Note: Originally `(fun x => Ring.DirectLimit.of_f n.zero_le x)`
    -- I think one problem was in recognizing that we want `toStepOfLE` in `of_f`
      intro x
      -- ‚ä¢ OneHom.toFun (‚Üë‚Üë{ toMonoidHom := ‚Üësrc‚úù, map_zero' := (_ : OneHom.toFun (‚Üë‚Üësr ‚Ä¶
      simp only [RingHom.toMonoidHom_eq_coe, OneHom.toFun_eq_coe, MonoidHom.toOneHom_coe,
          MonoidHom.coe_coe]
      convert @Ring.DirectLimit.of_f ‚Ñï _ (Step k) _ (fun m n h => (toStepOfLE k m n h : _ ‚Üí _))
          0 n n.zero_le x }
#align algebraic_closure.of_step_hom AlgebraicClosure.ofStepHom

theorem isAlgebraic : Algebra.IsAlgebraic k (AlgebraicClosure k) := fun z =>
  isAlgebraic_iff_isIntegral.2 <|
    let ‚ü®n, x, hx‚ü© := exists_ofStep k z
    hx ‚ñ∏ map_isIntegral (ofStepHom k n) (Step.isIntegral k n x)
#align algebraic_closure.is_algebraic AlgebraicClosure.isAlgebraic

instance : IsAlgClosure k (AlgebraicClosure k) :=
  ‚ü®AlgebraicClosure.instIsAlgClosed k, isAlgebraic k‚ü©

end AlgebraicClosure
