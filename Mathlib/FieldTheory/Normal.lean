/-
Copyright (c) 2020 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Thomas Browning, Patrick Lutz
-/
import Mathlib.FieldTheory.Adjoin
import Mathlib.FieldTheory.Tower
import Mathlib.GroupTheory.Solvable
import Mathlib.RingTheory.PowerBasis

#align_import field_theory.normal from "leanprover-community/mathlib"@"9fb8964792b4237dac6200193a0d533f1b3f7423"

/-!
# Normal field extensions

In this file we define normal field extensions and prove that for a finite extension, being normal
is the same as being a splitting field (`Normal.of_isSplittingField` and
`Normal.exists_isSplittingField`).

## Main Definitions

- `Normal F K` where `K` is a field extension of `F`.
-/


noncomputable section

open scoped BigOperators

open scoped Classical Polynomial

open Polynomial IsScalarTower

variable (F K : Type*) [Field F] [Field K] [Algebra F K]

/-- Typeclass for normal field extension: `K` is a normal extension of `F` iff the minimal
polynomial of every element `x` in `K` splits in `K`, i.e. every conjugate of `x` is in `K`. -/
class Normal : Prop where
  isAlgebraic' : Algebra.IsAlgebraic F K
  splits' (x : K) : Splits (algebraMap F K) (minpoly F x)
#align normal Normal

variable {F K}

theorem Normal.isAlgebraic (_ : Normal F K) (x : K) : IsAlgebraic F x :=
  Normal.isAlgebraic' x
#align normal.is_algebraic Normal.isAlgebraic

theorem Normal.isIntegral (h : Normal F K) (x : K) : IsIntegral F x :=
  isAlgebraic_iff_isIntegral.mp (h.isAlgebraic' x)
#align normal.is_integral Normal.isIntegral

theorem Normal.splits (_ : Normal F K) (x : K) : Splits (algebraMap F K) (minpoly F x) :=
  Normal.splits' x
#align normal.splits Normal.splits

theorem normal_iff : Normal F K ‚Üî ‚àÄ x : K, IsIntegral F x ‚àß Splits (algebraMap F K) (minpoly F x) :=
  ‚ü®fun h x => ‚ü®h.isIntegral x, h.splits x‚ü©, fun h =>
    ‚ü®fun x => (h x).1.isAlgebraic F, fun x => (h x).2‚ü©‚ü©
#align normal_iff normal_iff

theorem Normal.out : Normal F K ‚Üí ‚àÄ x : K, IsIntegral F x ‚àß Splits (algebraMap F K) (minpoly F x) :=
  normal_iff.1
#align normal.out Normal.out

variable (F K)

instance normal_self : Normal F F :=
  ‚ü®fun _ => isIntegral_algebraMap.isAlgebraic F, fun x =>
    (minpoly.eq_X_sub_C' x).symm ‚ñ∏ splits_X_sub_C _‚ü©
#align normal_self normal_self

variable {K}

variable (K)

theorem Normal.exists_isSplittingField [h : Normal F K] [FiniteDimensional F K] :
    ‚àÉ p : F[X], IsSplittingField F K p := by
  let s := Basis.ofVectorSpace F K
  -- ‚ä¢ ‚àÉ p, IsSplittingField F K p
  refine'
    ‚ü®‚àè x, minpoly F (s x), splits_prod _ fun x _ => h.splits (s x),
      Subalgebra.toSubmodule.injective _‚ü©
  rw [Algebra.top_toSubmodule, eq_top_iff, ‚Üê s.span_eq, Submodule.span_le, Set.range_subset_iff]
  -- ‚ä¢ ‚àÄ (y : ‚Üë(Basis.ofVectorSpaceIndex F K)), ‚Üës y ‚àà ‚Üë(‚ÜëSubalgebra.toSubmodule (A ‚Ä¶
  refine' fun x =>
    Algebra.subset_adjoin
      (Multiset.mem_toFinset.mpr <|
        (mem_roots <|
              mt (Polynomial.map_eq_zero <| algebraMap F K).1 <|
                Finset.prod_ne_zero_iff.2 fun x _ => _).2 _)
  ¬∑ exact minpoly.ne_zero (h.isIntegral (s x))
    -- üéâ no goals
  rw [IsRoot.def, eval_map, ‚Üê aeval_def, AlgHom.map_prod]
  -- ‚ä¢ ‚àè x_1 : ‚Üë(Basis.ofVectorSpaceIndex F K), ‚Üë(aeval (‚Üës x)) (minpoly F (‚Üës x_1) ‚Ä¶
  exact Finset.prod_eq_zero (Finset.mem_univ _) (minpoly.aeval _ _)
  -- üéâ no goals
#align normal.exists_is_splitting_field Normal.exists_isSplittingField

section NormalTower

variable (E : Type*) [Field E] [Algebra F E] [Algebra K E] [IsScalarTower F K E]

theorem Normal.tower_top_of_normal [h : Normal F E] : Normal K E :=
  normal_iff.2 fun x => by
    cases' h.out x with hx hhx
    -- ‚ä¢ IsIntegral K x ‚àß Splits (algebraMap K E) (minpoly K x)
    rw [algebraMap_eq F K E] at hhx
    -- ‚ä¢ IsIntegral K x ‚àß Splits (algebraMap K E) (minpoly K x)
    exact
      ‚ü®isIntegral_of_isScalarTower hx,
        Polynomial.splits_of_splits_of_dvd (algebraMap K E)
          (Polynomial.map_ne_zero (minpoly.ne_zero hx))
          ((Polynomial.splits_map_iff (algebraMap F K) (algebraMap K E)).mpr hhx)
          (minpoly.dvd_map_of_isScalarTower F K x)‚ü©
#align normal.tower_top_of_normal Normal.tower_top_of_normal

theorem AlgHom.normal_bijective [h : Normal F E] (œï : E ‚Üí‚Çê[F] K) : Function.Bijective œï :=
  ‚ü®œï.toRingHom.injective, fun x => by
    letI : Algebra E K := œï.toRingHom.toAlgebra
    -- ‚ä¢ ‚àÉ a, ‚Üëœï a = x
    obtain ‚ü®h1, h2‚ü© := h.out (algebraMap K E x)
    -- ‚ä¢ ‚àÉ a, ‚Üëœï a = x
    cases'
      minpoly.mem_range_of_degree_eq_one E x
        (h2.def.resolve_left (minpoly.ne_zero h1)
          (minpoly.irreducible
            (isIntegral_of_isScalarTower
              ((isIntegral_algebraMap_iff (algebraMap K E).injective).mp h1)))
          (minpoly.dvd E x
            ((algebraMap K E).injective
              (by
                rw [RingHom.map_zero, aeval_map_algebraMap, ‚Üê aeval_algebraMap_apply]
                exact minpoly.aeval F (algebraMap K E x))))) with
      y hy
    exact ‚ü®y, hy‚ü©‚ü©
    -- üéâ no goals
#align alg_hom.normal_bijective AlgHom.normal_bijective

-- Porting note: `[Field F] [Field E] [Algebra F E]` added by hand.
variable {F} {E} {E' : Type*} [Field F] [Field E] [Algebra F E] [Field E'] [Algebra F E']

theorem Normal.of_algEquiv [h : Normal F E] (f : E ‚âÉ‚Çê[F] E') : Normal F E' :=
  normal_iff.2 fun x => by
    cases' h.out (f.symm x) with hx hhx
    -- ‚ä¢ IsIntegral F x ‚àß Splits (algebraMap F E') (minpoly F x)
    have H := map_isIntegral f.toAlgHom hx
    -- ‚ä¢ IsIntegral F x ‚àß Splits (algebraMap F E') (minpoly F x)
    simp [AlgEquiv.toAlgHom_eq_coe] at H
    -- ‚ä¢ IsIntegral F x ‚àß Splits (algebraMap F E') (minpoly F x)
    use H
    -- ‚ä¢ Splits (algebraMap F E') (minpoly F x)
    apply Polynomial.splits_of_splits_of_dvd (algebraMap F E') (minpoly.ne_zero hx)
    -- ‚ä¢ Splits (algebraMap F E') (minpoly F (‚Üë(AlgEquiv.symm f) x))
    ¬∑ rw [‚Üê AlgHom.comp_algebraMap f.toAlgHom]
      -- ‚ä¢ Splits (RingHom.comp (‚Üë‚Üëf) (algebraMap F E)) (minpoly F (‚Üë(AlgEquiv.symm f)  ‚Ä¶
      exact Polynomial.splits_comp_of_splits (algebraMap F E) f.toAlgHom.toRingHom hhx
      -- üéâ no goals
    ¬∑ apply minpoly.dvd _ _
      -- ‚ä¢ ‚Üë(aeval x) (minpoly F (‚Üë(AlgEquiv.symm f) x)) = 0
      rw [‚Üê AddEquiv.map_eq_zero_iff f.symm.toAddEquiv]
      -- ‚ä¢ ‚Üë(AlgEquiv.toAddEquiv (AlgEquiv.symm f)) (‚Üë(aeval x) (minpoly F (‚Üë(AlgEquiv. ‚Ä¶
      exact
        Eq.trans (Polynomial.aeval_algHom_apply f.symm.toAlgHom x (minpoly F (f.symm x))).symm
          (minpoly.aeval _ _)
#align normal.of_alg_equiv Normal.of_algEquiv

theorem AlgEquiv.transfer_normal (f : E ‚âÉ‚Çê[F] E') : Normal F E ‚Üî Normal F E' :=
  ‚ü®fun _ => Normal.of_algEquiv f, fun _ => Normal.of_algEquiv f.symm‚ü©
#align alg_equiv.transfer_normal AlgEquiv.transfer_normal

-- seems to be causing a diamond in the below proof
-- however, this may be a fluke and the proof below uses non-canonical `Algebra` instances:
-- when I replaced all the instances inside the proof with the "canonical" instances we have,
-- I had the (unprovable) goal (of the form) `AdjoinRoot.mk f (C x) = AdjoinRoot.mk f X`
-- for some `x, f`. So maybe this is indeed the correct approach and rewriting this proof is
-- salient in the future, or at least taking a closer look at the algebra instances it uses.
attribute [-instance] AdjoinRoot.instSMulAdjoinRoot

theorem Normal.of_isSplittingField (p : F[X]) [hFEp : IsSplittingField F E p] : Normal F E := by
  rcases eq_or_ne p 0 with (rfl | hp)
  -- ‚ä¢ Normal F E
  ¬∑ have := hFEp.adjoin_rootSet
    -- ‚ä¢ Normal F E
    simp only [rootSet_zero, Algebra.adjoin_empty] at this
    -- ‚ä¢ Normal F E
    exact
      Normal.of_algEquiv
        (AlgEquiv.ofBijective (Algebra.ofId F E) (Algebra.bijective_algebraMap_iff.2 this.symm))
  refine' normal_iff.2 fun x => _
  -- ‚ä¢ IsIntegral F x ‚àß Splits (algebraMap F E) (minpoly F x)
  have hFE : FiniteDimensional F E := IsSplittingField.finiteDimensional E p
  -- ‚ä¢ IsIntegral F x ‚àß Splits (algebraMap F E) (minpoly F x)
  have Hx : IsIntegral F x := isIntegral_of_noetherian (IsNoetherian.iff_fg.2 hFE) x
  -- ‚ä¢ IsIntegral F x ‚àß Splits (algebraMap F E) (minpoly F x)
  refine' ‚ü®Hx, Or.inr _‚ü©
  -- ‚ä¢ ‚àÄ {g : E[X]}, Irreducible g ‚Üí g ‚à£ map (algebraMap F E) (minpoly F x) ‚Üí degre ‚Ä¶
  rintro q q_irred ‚ü®r, hr‚ü©
  -- ‚ä¢ degree q = 1
  let D := AdjoinRoot q
  -- ‚ä¢ degree q = 1
  haveI := Fact.mk q_irred
  -- ‚ä¢ degree q = 1
  let pbED := AdjoinRoot.powerBasis q_irred.ne_zero
  -- ‚ä¢ degree q = 1
  haveI : FiniteDimensional E D := PowerBasis.finiteDimensional pbED
  -- ‚ä¢ degree q = 1
  have finrankED : FiniteDimensional.finrank E D = q.natDegree := by
    rw [PowerBasis.finrank pbED, AdjoinRoot.powerBasis_dim]
  haveI : FiniteDimensional F D := FiniteDimensional.trans F E D
  -- ‚ä¢ degree q = 1
  rsuffices ‚ü®œï‚ü© : Nonempty (D ‚Üí‚Çê[F] E)
  -- ‚ä¢ degree q = 1
  --Porting note: the `change` was `rw [‚Üê WithBot.coe_one]`
  ¬∑ change degree q = ‚Üë(1 : ‚Ñï)
    -- ‚ä¢ degree q = ‚Üë1
    rw [degree_eq_iff_natDegree_eq q_irred.ne_zero, ‚Üê finrankED]
    -- ‚ä¢ FiniteDimensional.finrank E D = 1
    have nat_lemma : ‚àÄ a b c : ‚Ñï, a * b = c ‚Üí c ‚â§ a ‚Üí 0 < c ‚Üí b = 1 := by
      intro a b c h1 h2 h3
      nlinarith
    exact
      nat_lemma _ _ _ (FiniteDimensional.finrank_mul_finrank F E D)
        (LinearMap.finrank_le_finrank_of_injective
          (show Function.Injective œï.toLinearMap from œï.toRingHom.injective))
        FiniteDimensional.finrank_pos
  let C := AdjoinRoot (minpoly F x)
  -- ‚ä¢ Nonempty (D ‚Üí‚Çê[F] E)
  haveI Hx_irred := Fact.mk (minpoly.irreducible Hx)
  -- ‚ä¢ Nonempty (D ‚Üí‚Çê[F] E)
-- Porting note: `heval` added since now Lean wants the proof explicitly in several places.
  have heval : eval‚ÇÇ (algebraMap F D) (AdjoinRoot.root q) (minpoly F x) = 0 := by
    rw [algebraMap_eq F E D, ‚Üê eval‚ÇÇ_map, hr, AdjoinRoot.algebraMap_eq, eval‚ÇÇ_mul,
      AdjoinRoot.eval‚ÇÇ_root, zero_mul]
  letI : Algebra C D :=
    RingHom.toAlgebra (AdjoinRoot.lift (algebraMap F D) (AdjoinRoot.root q) heval)
  letI : Algebra C E := RingHom.toAlgebra (AdjoinRoot.lift (algebraMap F E) x (minpoly.aeval F x))
  -- ‚ä¢ Nonempty (D ‚Üí‚Çê[F] E)
  haveI : IsScalarTower F C D := of_algebraMap_eq fun y => (AdjoinRoot.lift_of heval).symm
  -- ‚ä¢ Nonempty (D ‚Üí‚Çê[F] E)
  haveI : IsScalarTower F C E := by
    refine' of_algebraMap_eq fun y => (AdjoinRoot.lift_of _).symm
-- Porting note: the following proof was just `_`.
    rw [‚Üê aeval_def, minpoly.aeval]
  suffices Nonempty (D ‚Üí‚Çê[C] E) by exact Nonempty.map (AlgHom.restrictScalars F) this
  -- ‚ä¢ Nonempty (D ‚Üí‚Çê[C] E)
  let S : Set D := ((p.map (algebraMap F E)).roots.map (algebraMap E D)).toFinset
  -- ‚ä¢ Nonempty (D ‚Üí‚Çê[C] E)
  suffices ‚ä§ ‚â§ IntermediateField.adjoin C S by
    refine' IntermediateField.algHom_mk_adjoin_splits' (top_le_iff.mp this) fun y hy => _
    rcases Multiset.mem_map.mp (Multiset.mem_toFinset.mp hy) with ‚ü®z, hz1, hz2‚ü©
    have Hz : IsIntegral F z := isIntegral_of_noetherian (IsNoetherian.iff_fg.2 hFE) z
    use
      show IsIntegral C y from
        isIntegral_of_noetherian (IsNoetherian.iff_fg.2 (FiniteDimensional.right F C D)) y
    apply splits_of_splits_of_dvd (algebraMap C E) (map_ne_zero (minpoly.ne_zero Hz))
    ¬∑ rw [splits_map_iff, ‚Üê algebraMap_eq F C E]
      exact
        splits_of_splits_of_dvd _ hp hFEp.splits
          (minpoly.dvd F z (Eq.trans (eval‚ÇÇ_eq_eval_map _) ((mem_roots (map_ne_zero hp)).mp hz1)))
    ¬∑ apply minpoly.dvd
      rw [‚Üê hz2, aeval_def, eval‚ÇÇ_map, ‚Üê algebraMap_eq F C D, algebraMap_eq F E D, ‚Üê hom_eval‚ÇÇ, ‚Üê
        aeval_def, minpoly.aeval F z, RingHom.map_zero]
  rw [‚Üê IntermediateField.toSubalgebra_le_toSubalgebra, IntermediateField.top_toSubalgebra]
  -- ‚ä¢ ‚ä§ ‚â§ (IntermediateField.adjoin C S).toSubalgebra
  apply ge_trans (IntermediateField.algebra_adjoin_le_adjoin C S)
  -- ‚ä¢ Algebra.adjoin C S ‚â• ‚ä§
  suffices
    (Algebra.adjoin C S).restrictScalars F =
      (Algebra.adjoin E {AdjoinRoot.root q}).restrictScalars F by
    rw [AdjoinRoot.adjoinRoot_eq_top, Subalgebra.restrictScalars_top, ‚Üê
      @Subalgebra.restrictScalars_top F C] at this
    exact top_le_iff.mpr (Subalgebra.restrictScalars_injective F this)
/- Porting note: the `change` was `dsimp only [S]`. This is the step that requires increasing
`maxHeartbeats`. Using `set S ... with hS` doesn't work. -/
  change Subalgebra.restrictScalars F (Algebra.adjoin C
    (((p.map (algebraMap F E)).roots.map (algebraMap E D)).toFinset : Set D)) = _
  rw [‚Üê Finset.image_toFinset, Finset.coe_image]
  -- ‚ä¢ Subalgebra.restrictScalars F (Algebra.adjoin C (‚Üë(algebraMap E D) '' ‚Üë(Multi ‚Ä¶
  apply
    Eq.trans
      (Algebra.adjoin_res_eq_adjoin_res F E C D hFEp.adjoin_rootSet AdjoinRoot.adjoinRoot_eq_top)
  rw [Set.image_singleton, RingHom.algebraMap_toAlgebra, AdjoinRoot.lift_root]
  -- üéâ no goals
#align normal.of_is_splitting_field Normal.of_isSplittingField

end NormalTower

namespace IntermediateField

/-- A compositum of normal extensions is normal -/
instance normal_iSup {Œπ : Type*} (t : Œπ ‚Üí IntermediateField F K) [h : ‚àÄ i, Normal F (t i)] :
    Normal F (‚®Ü i, t i : IntermediateField F K) := by
  refine' ‚ü®isAlgebraic_iSup fun i => (h i).1, fun x => _‚ü©
  -- ‚ä¢ Splits (algebraMap F { x // x ‚àà ‚®Ü (i : Œπ), t i }) (minpoly F x)
  obtain ‚ü®s, hx‚ü© := exists_finset_of_mem_supr'' (fun i => (h i).1) x.2
  -- ‚ä¢ Splits (algebraMap F { x // x ‚àà ‚®Ü (i : Œπ), t i }) (minpoly F x)
  let E : IntermediateField F K := ‚®Ü i ‚àà s, adjoin F ((minpoly F (i.2 : _)).rootSet K)
  -- ‚ä¢ Splits (algebraMap F { x // x ‚àà ‚®Ü (i : Œπ), t i }) (minpoly F x)
  have hF : Normal F E := by
    haveI : IsSplittingField F E (‚àè i in s, minpoly F i.snd) := by
      refine' isSplittingField_iSup _ fun i _ => adjoin_rootSet_isSplittingField _
      ¬∑ exact Finset.prod_ne_zero_iff.mpr fun i _ => minpoly.ne_zero ((h i.1).isIntegral i.2)
      ¬∑ exact Polynomial.splits_comp_of_splits _ (algebraMap (t i.1) K) ((h i.1).splits i.2)
    apply Normal.of_isSplittingField (‚àè i in s, minpoly F i.2)
  have hE : E ‚â§ ‚®Ü i, t i := by
    refine' iSup_le fun i => iSup_le fun _ => le_iSup_of_le i.1 _
    rw [adjoin_le_iff, ‚Üê image_rootSet ((h i.1).splits i.2) (t i.1).val]
    exact fun _ ‚ü®a, _, h‚ü© => h ‚ñ∏ a.2
  have := hF.splits ‚ü®x, hx‚ü©
  -- ‚ä¢ Splits (algebraMap F { x // x ‚àà ‚®Ü (i : Œπ), t i }) (minpoly F x)
  rw [minpoly_eq, Subtype.coe_mk, ‚Üê minpoly_eq] at this
  -- ‚ä¢ Splits (algebraMap F { x // x ‚àà ‚®Ü (i : Œπ), t i }) (minpoly F x)
  exact Polynomial.splits_comp_of_splits _ (inclusion hE).toRingHom this
  -- üéâ no goals
#align intermediate_field.normal_supr IntermediateField.normal_iSup

instance normal_sup
    (E E' : IntermediateField F K) [Normal F E] [Normal F E'] :
    Normal F (E ‚äî E' : IntermediateField F K) :=
  iSup_bool_eq (f := Bool.rec E' E) ‚ñ∏ normal_iSup (h := by intro i; cases i <;> infer_instance)
                                                           -- ‚ä¢ Normal F { x // x ‚àà Bool.rec E' E i }
                                                                    -- ‚ä¢ Normal F { x // x ‚àà Bool.rec E' E false }
                                                                                -- üéâ no goals
                                                                                -- üéâ no goals

-- Porting note `[Field F] [Field K] [Algebra F K]` added by hand.
variable {F K} {L : Type*} [Field F] [Field K] [Field L] [Algebra F L] [Algebra K L]
  [Algebra F K] [IsScalarTower F K L]

@[simp]
theorem restrictScalars_normal {E : IntermediateField K L} :
    Normal F (E.restrictScalars F) ‚Üî Normal F E :=
  Iff.rfl
#align intermediate_field.restrict_scalars_normal IntermediateField.restrictScalars_normal

end IntermediateField

-- Porting note `[Field F]` added by hand.
variable {F} {K} {K‚ÇÅ K‚ÇÇ K‚ÇÉ : Type*} [Field F] [Field K‚ÇÅ] [Field K‚ÇÇ] [Field K‚ÇÉ] [Algebra F K‚ÇÅ]
  [Algebra F K‚ÇÇ] [Algebra F K‚ÇÉ] (œï : K‚ÇÅ ‚Üí‚Çê[F] K‚ÇÇ) (œá : K‚ÇÅ ‚âÉ‚Çê[F] K‚ÇÇ) (œà : K‚ÇÇ ‚Üí‚Çê[F] K‚ÇÉ)
  (œâ : K‚ÇÇ ‚âÉ‚Çê[F] K‚ÇÉ)

section Restrict

variable (E : Type*) [Field E] [Algebra F E] [Algebra E K‚ÇÅ] [Algebra E K‚ÇÇ] [Algebra E K‚ÇÉ]
  [IsScalarTower F E K‚ÇÅ] [IsScalarTower F E K‚ÇÇ] [IsScalarTower F E K‚ÇÉ]

/-- Restrict algebra homomorphism to image of normal subfield -/
def AlgHom.restrictNormalAux [h : Normal F E] :
    (toAlgHom F E K‚ÇÅ).range ‚Üí‚Çê[F] (toAlgHom F E K‚ÇÇ).range where
  toFun x :=
    ‚ü®œï x, by
      suffices (toAlgHom F E K‚ÇÅ).range.map œï ‚â§ _ by exact this ‚ü®x, Subtype.mem x, rfl‚ü©
      -- ‚ä¢ Subalgebra.map œï (AlgHom.range (toAlgHom F E K‚ÇÅ)) ‚â§ AlgHom.range (toAlgHom F ‚Ä¶
      rintro x ‚ü®y, ‚ü®z, hy‚ü©, hx‚ü©
      -- ‚ä¢ x ‚àà AlgHom.range (toAlgHom F E K‚ÇÇ)
      rw [‚Üê hx, ‚Üê hy]
      -- ‚ä¢ ‚Üë‚Üëœï (‚Üë‚Üë(toAlgHom F E K‚ÇÅ) z) ‚àà AlgHom.range (toAlgHom F E K‚ÇÇ)
      apply minpoly.mem_range_of_degree_eq_one E
      -- ‚ä¢ degree (minpoly E (‚Üë‚Üëœï (‚Üë‚Üë(toAlgHom F E K‚ÇÅ) z))) = 1
      refine'
        Or.resolve_left (h.splits z).def (minpoly.ne_zero (h.isIntegral z)) (minpoly.irreducible _)
          (minpoly.dvd E _ (by simp [aeval_algHom_apply]))
      simp only [AlgHom.toRingHom_eq_coe, AlgHom.coe_toRingHom]
      -- ‚ä¢ IsIntegral E (‚Üëœï (‚Üë(toAlgHom F E K‚ÇÅ) z))
      suffices IsIntegral F _ by exact isIntegral_of_isScalarTower this
      -- ‚ä¢ IsIntegral F (‚Üëœï (‚Üë(toAlgHom F E K‚ÇÅ) z))
      exact map_isIntegral œï (map_isIntegral (toAlgHom F E K‚ÇÅ) (h.isIntegral z))‚ü©
      -- üéâ no goals
  map_zero' := Subtype.ext œï.map_zero
  map_one' := Subtype.ext œï.map_one
  map_add' x y := Subtype.ext (œï.map_add x y)
  map_mul' x y := Subtype.ext (œï.map_mul x y)
  commutes' x := Subtype.ext (œï.commutes x)
#align alg_hom.restrict_normal_aux AlgHom.restrictNormalAux

/-- Restrict algebra homomorphism to normal subfield -/
def AlgHom.restrictNormal [Normal F E] : E ‚Üí‚Çê[F] E :=
  ((AlgEquiv.ofInjectiveField (IsScalarTower.toAlgHom F E K‚ÇÇ)).symm.toAlgHom.comp
        (œï.restrictNormalAux E)).comp
    (AlgEquiv.ofInjectiveField (IsScalarTower.toAlgHom F E K‚ÇÅ)).toAlgHom
#align alg_hom.restrict_normal AlgHom.restrictNormal

/-- Restrict algebra homomorphism to normal subfield (`AlgEquiv` version) -/
def AlgHom.restrictNormal' [Normal F E] : E ‚âÉ‚Çê[F] E :=
  AlgEquiv.ofBijective (AlgHom.restrictNormal œï E) (AlgHom.normal_bijective F E E _)
#align alg_hom.restrict_normal' AlgHom.restrictNormal'

@[simp]
theorem AlgHom.restrictNormal_commutes [Normal F E] (x : E) :
    algebraMap E K‚ÇÇ (œï.restrictNormal E x) = œï (algebraMap E K‚ÇÅ x) :=
  Subtype.ext_iff.mp
    (AlgEquiv.apply_symm_apply (AlgEquiv.ofInjectiveField (IsScalarTower.toAlgHom F E K‚ÇÇ))
      (œï.restrictNormalAux E ‚ü®IsScalarTower.toAlgHom F E K‚ÇÅ x, x, rfl‚ü©))
#align alg_hom.restrict_normal_commutes AlgHom.restrictNormal_commutes

theorem AlgHom.restrictNormal_comp [Normal F E] :
    (œà.restrictNormal E).comp (œï.restrictNormal E) = (œà.comp œï).restrictNormal E :=
  AlgHom.ext fun _ =>
    (algebraMap E K‚ÇÉ).injective (by simp only [AlgHom.comp_apply, AlgHom.restrictNormal_commutes])
                                    -- üéâ no goals
#align alg_hom.restrict_normal_comp AlgHom.restrictNormal_comp

-- Porting note `[Algebra F K]` added by hand.
theorem AlgHom.fieldRange_of_normal [Algebra F K] {E : IntermediateField F K} [Normal F E]
    (f : E ‚Üí‚Çê[F] K) : f.fieldRange = E := by
-- Porting note: this was `IsScalarTower F E E := by infer_instance`.
  letI : Algebra E E := Algebra.id E
  -- ‚ä¢ fieldRange f = E
  let g := f.restrictNormal' E
  -- ‚ä¢ fieldRange f = E
  rw [‚Üê show E.val.comp ‚Üëg = f from FunLike.ext_iff.mpr (f.restrictNormal_commutes E), ‚Üê
    IntermediateField.AlgHom.map_fieldRange, IntermediateField.AlgEquiv.fieldRange_eq_top g,
      ‚Üê IntermediateField.AlgHom.fieldRange_eq_map, IntermediateField.fieldRange_val]
#align alg_hom.field_range_of_normal AlgHom.fieldRange_of_normal

/-- Restrict algebra isomorphism to a normal subfield -/
def AlgEquiv.restrictNormal [Normal F E] : E ‚âÉ‚Çê[F] E :=
  AlgHom.restrictNormal' œá.toAlgHom E
#align alg_equiv.restrict_normal AlgEquiv.restrictNormal

@[simp]
theorem AlgEquiv.restrictNormal_commutes [Normal F E] (x : E) :
    algebraMap E K‚ÇÇ (œá.restrictNormal E x) = œá (algebraMap E K‚ÇÅ x) :=
  œá.toAlgHom.restrictNormal_commutes E x
#align alg_equiv.restrict_normal_commutes AlgEquiv.restrictNormal_commutes

theorem AlgEquiv.restrictNormal_trans [Normal F E] :
    (œá.trans œâ).restrictNormal E = (œá.restrictNormal E).trans (œâ.restrictNormal E) :=
  AlgEquiv.ext fun _ =>
    (algebraMap E K‚ÇÉ).injective
      (by simp only [AlgEquiv.trans_apply, AlgEquiv.restrictNormal_commutes])
          -- üéâ no goals
#align alg_equiv.restrict_normal_trans AlgEquiv.restrictNormal_trans

/-- Restriction to a normal subfield as a group homomorphism -/
def AlgEquiv.restrictNormalHom [Normal F E] : (K‚ÇÅ ‚âÉ‚Çê[F] K‚ÇÅ) ‚Üí* E ‚âÉ‚Çê[F] E :=
  MonoidHom.mk' (fun œá => œá.restrictNormal E) fun œâ œá => œá.restrictNormal_trans œâ E
#align alg_equiv.restrict_normal_hom AlgEquiv.restrictNormalHom

variable (F K‚ÇÅ)

/-- If `K‚ÇÅ/E/F` is a tower of fields with `E/F` normal then `AlgHom.restrictNormal'` is an
 equivalence. -/
@[simps]
def Normal.algHomEquivAut [Normal F E] : (E ‚Üí‚Çê[F] K‚ÇÅ) ‚âÉ E ‚âÉ‚Çê[F] E where
  toFun œÉ := AlgHom.restrictNormal' œÉ E
  invFun œÉ := (IsScalarTower.toAlgHom F E K‚ÇÅ).comp œÉ.toAlgHom
  left_inv œÉ := by
    ext
    -- ‚ä¢ ‚Üë((fun œÉ => AlgHom.comp (toAlgHom F E K‚ÇÅ) ‚ÜëœÉ) ((fun œÉ => AlgHom.restrictNorm ‚Ä¶
    simp [AlgHom.restrictNormal']
    -- üéâ no goals
  right_inv œÉ := by
    ext
    -- ‚ä¢ ‚Üë((fun œÉ => AlgHom.restrictNormal' œÉ E) ((fun œÉ => AlgHom.comp (toAlgHom F E ‚Ä¶
    simp only [AlgHom.restrictNormal', AlgEquiv.toAlgHom_eq_coe, AlgEquiv.coe_ofBijective]
    -- ‚ä¢ ‚Üë(AlgHom.restrictNormal (AlgHom.comp (toAlgHom F E K‚ÇÅ) ‚ÜëœÉ) E) a‚úù = ‚ÜëœÉ a‚úù
    apply NoZeroSMulDivisors.algebraMap_injective E K‚ÇÅ
    -- ‚ä¢ ‚Üë(algebraMap E K‚ÇÅ) (‚Üë(AlgHom.restrictNormal (AlgHom.comp (toAlgHom F E K‚ÇÅ) ‚Üë ‚Ä¶
    rw [AlgHom.restrictNormal_commutes]
    -- ‚ä¢ ‚Üë(AlgHom.comp (toAlgHom F E K‚ÇÅ) ‚ÜëœÉ) (‚Üë(algebraMap E E) a‚úù) = ‚Üë(algebraMap E  ‚Ä¶
    simp
    -- üéâ no goals
#align normal.alg_hom_equiv_aut Normal.algHomEquivAut

end Restrict

section lift

variable (E : Type*) [Field E] [Algebra F E] [Algebra K‚ÇÅ E] [Algebra K‚ÇÇ E] [IsScalarTower F K‚ÇÅ E]
  [IsScalarTower F K‚ÇÇ E]

/-- If `E/K·µ¢/F` are towers of fields with `E/F` normal then we can lift
  an algebra homomorphism `œï : K‚ÇÅ ‚Üí‚Çê[F] K‚ÇÇ` to `œï.liftNormal E : E ‚Üí‚Çê[F] E`. -/
noncomputable def AlgHom.liftNormal [h : Normal F E] : E ‚Üí‚Çê[F] E :=
  @AlgHom.restrictScalars F K‚ÇÅ E E _ _ _ _ _ _
      ((IsScalarTower.toAlgHom F K‚ÇÇ E).comp œï).toRingHom.toAlgebra _ _ _ _ <|
    Nonempty.some <|
      @IntermediateField.algHom_mk_adjoin_splits' _ _ _ _ _ _ _
        ((IsScalarTower.toAlgHom F K‚ÇÇ E).comp œï).toRingHom.toAlgebra _
        (IntermediateField.adjoin_univ _ _) fun x _ =>
        ‚ü®isIntegral_of_isScalarTower (h.out x).1,
          splits_of_splits_of_dvd _ (map_ne_zero (minpoly.ne_zero (h.out x).1))
            -- Porting note: had to override typeclass inference below using `(_)`
            (by rw [splits_map_iff, ‚Üê @IsScalarTower.algebraMap_eq _ _ _ _ _ _ (_) (_) (_)];
                -- ‚ä¢ Splits (algebraMap F E) (minpoly F x)
                exact (h.out x).2)
                -- üéâ no goals
            (minpoly.dvd_map_of_isScalarTower F K‚ÇÅ x)‚ü©
#align alg_hom.lift_normal AlgHom.liftNormal

@[simp]
theorem AlgHom.liftNormal_commutes [Normal F E] (x : K‚ÇÅ) :
    œï.liftNormal E (algebraMap K‚ÇÅ E x) = algebraMap K‚ÇÇ E (œï x) :=
  -- Porting note: This seems to have been some sort of typeclass override trickery using `by apply`
  -- Now we explicitly specify which typeclass to override, using `(_)` instead of `_`
  @AlgHom.commutes K‚ÇÅ E E _ _ _ _ (_) _ _
#align alg_hom.lift_normal_commutes AlgHom.liftNormal_commutes

@[simp]
theorem AlgHom.restrict_liftNormal (œï : K‚ÇÅ ‚Üí‚Çê[F] K‚ÇÅ) [Normal F K‚ÇÅ] [Normal F E] :
    (œï.liftNormal E).restrictNormal K‚ÇÅ = œï :=
  AlgHom.ext fun x =>
    (algebraMap K‚ÇÅ E).injective
      (Eq.trans (AlgHom.restrictNormal_commutes _ K‚ÇÅ x) (œï.liftNormal_commutes E x))
#align alg_hom.restrict_lift_normal AlgHom.restrict_liftNormal

/-- If `E/K·µ¢/F` are towers of fields with `E/F` normal then we can lift
  an algebra isomorphism `œï : K‚ÇÅ ‚âÉ‚Çê[F] K‚ÇÇ` to `œï.liftNormal E : E ‚âÉ‚Çê[F] E`. -/
noncomputable def AlgEquiv.liftNormal [Normal F E] : E ‚âÉ‚Çê[F] E :=
  AlgEquiv.ofBijective (œá.toAlgHom.liftNormal E) (AlgHom.normal_bijective F E E _)
#align alg_equiv.lift_normal AlgEquiv.liftNormal

@[simp]
theorem AlgEquiv.liftNormal_commutes [Normal F E] (x : K‚ÇÅ) :
    œá.liftNormal E (algebraMap K‚ÇÅ E x) = algebraMap K‚ÇÇ E (œá x) :=
  œá.toAlgHom.liftNormal_commutes E x
#align alg_equiv.lift_normal_commutes AlgEquiv.liftNormal_commutes

@[simp]
theorem AlgEquiv.restrict_liftNormal (œá : K‚ÇÅ ‚âÉ‚Çê[F] K‚ÇÅ) [Normal F K‚ÇÅ] [Normal F E] :
    (œá.liftNormal E).restrictNormal K‚ÇÅ = œá :=
  AlgEquiv.ext fun x =>
    (algebraMap K‚ÇÅ E).injective
      (Eq.trans (AlgEquiv.restrictNormal_commutes _ K‚ÇÅ x) (œá.liftNormal_commutes E x))
#align alg_equiv.restrict_lift_normal AlgEquiv.restrict_liftNormal

theorem AlgEquiv.restrictNormalHom_surjective [Normal F K‚ÇÅ] [Normal F E] :
    Function.Surjective (AlgEquiv.restrictNormalHom K‚ÇÅ : (E ‚âÉ‚Çê[F] E) ‚Üí K‚ÇÅ ‚âÉ‚Çê[F] K‚ÇÅ) := fun œá =>
  ‚ü®œá.liftNormal E, œá.restrict_liftNormal E‚ü©
#align alg_equiv.restrict_normal_hom_surjective AlgEquiv.restrictNormalHom_surjective

variable (F) (K‚ÇÅ)

theorem isSolvable_of_isScalarTower [Normal F K‚ÇÅ] [h1 : IsSolvable (K‚ÇÅ ‚âÉ‚Çê[F] K‚ÇÅ)]
    [h2 : IsSolvable (E ‚âÉ‚Çê[K‚ÇÅ] E)] : IsSolvable (E ‚âÉ‚Çê[F] E) := by
  let f : (E ‚âÉ‚Çê[K‚ÇÅ] E) ‚Üí* E ‚âÉ‚Çê[F] E :=
    { toFun := fun œï =>
        AlgEquiv.ofAlgHom (œï.toAlgHom.restrictScalars F) (œï.symm.toAlgHom.restrictScalars F)
          (AlgHom.ext fun x => œï.apply_symm_apply x) (AlgHom.ext fun x => œï.symm_apply_apply x)
      map_one' := AlgEquiv.ext fun _ => rfl
      map_mul' := fun _ _ => AlgEquiv.ext fun _ => rfl }
  refine'
    solvable_of_ker_le_range f (AlgEquiv.restrictNormalHom K‚ÇÅ) fun œï hœï =>
      ‚ü®{ œï with commutes' := fun x => _ }, AlgEquiv.ext fun _ => rfl‚ü©
  exact Eq.trans (œï.restrictNormal_commutes K‚ÇÅ x).symm (congr_arg _ (AlgEquiv.ext_iff.mp hœï x))
  -- üéâ no goals
#align is_solvable_of_is_scalar_tower isSolvable_of_isScalarTower

end lift
