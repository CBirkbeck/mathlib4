/-
Copyright (c) 2021 Hunter Monroe. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Hunter Monroe, Kyle Miller, Alena Gusakov
-/
import Mathlib.Combinatorics.SimpleGraph.Basic

#align_import combinatorics.simple_graph.subgraph from "leanprover-community/mathlib"@"c6ef6387ede9983aee397d442974e61f89dfd87b"

/-!
# Subgraphs of a simple graph

A subgraph of a simple graph consists of subsets of the graph's vertices and edges such that the
endpoints of each edge are present in the vertex subset. The edge subset is formalized as a
sub-relation of the adjacency relation of the simple graph.

## Main definitions

* `Subgraph G` is the type of subgraphs of a `G : SimpleGraph V`.

* `Subgraph.neighborSet`, `Subgraph.incidenceSet`, and `Subgraph.degree` are like their
  `SimpleGraph` counterparts, but they refer to vertices from `G` to avoid subtype coercions.

* `Subgraph.coe` is the coercion from a `G' : Subgraph G` to a `SimpleGraph G'.verts`.
  (In Lean 3 this could not be a `Coe` instance since the destination type depends on `G'`.)

* `Subgraph.IsSpanning` for whether a subgraph is a spanning subgraph and
  `Subgraph.IsInduced` for whether a subgraph is an induced subgraph.

* Instances for `Lattice (Subgraph G)` and `BoundedOrder (Subgraph G)`.

* `SimpleGraph.toSubgraph`: If a `SimpleGraph` is a subgraph of another, then you can turn it
  into a member of the larger graph's `SimpleGraph.Subgraph` type.

* Graph homomorphisms from a subgraph to a graph (`Subgraph.map_top`) and between subgraphs
  (`Subgraph.map`).

## Implementation notes

* Recall that subgraphs are not determined by their vertex sets, so `SetLike` does not apply to
  this kind of subobject.

## Todo

* Images of graph homomorphisms as subgraphs.

-/


universe u v

namespace SimpleGraph

/-- A subgraph of a `SimpleGraph` is a subset of vertices along with a restriction of the adjacency
relation that is symmetric and is supported by the vertex subset.  They also form a bounded lattice.

Thinking of `V ‚Üí V ‚Üí Prop` as `Set (V √ó V)`, a set of darts (i.e., half-edges), then
`Subgraph.adj_sub` is that the darts of a subgraph are a subset of the darts of `G`. -/
@[ext]
structure Subgraph {V : Type u} (G : SimpleGraph V) where
  verts : Set V
  Adj : V ‚Üí V ‚Üí Prop
  adj_sub : ‚àÄ {v w : V}, Adj v w ‚Üí G.Adj v w
  edge_vert : ‚àÄ {v w : V}, Adj v w ‚Üí v ‚àà verts
  symm : Symmetric Adj := by aesop_graph -- Porting note: Originally `by obviously`
#align simple_graph.subgraph SimpleGraph.Subgraph

variable {Œπ : Sort*} {V : Type u} {W : Type v}

/-- The one-vertex subgraph. -/
@[simps]
protected def singletonSubgraph (G : SimpleGraph V) (v : V) : G.Subgraph where
  verts := {v}
  Adj := ‚ä•
  adj_sub := False.elim
  edge_vert := False.elim
  symm _ _ := False.elim
#align simple_graph.singleton_subgraph SimpleGraph.singletonSubgraph

/-- The one-edge subgraph. -/
@[simps]
def subgraphOfAdj (G : SimpleGraph V) {v w : V} (hvw : G.Adj v w) : G.Subgraph where
  verts := {v, w}
  Adj a b := ‚ü¶(v, w)‚üß = ‚ü¶(a, b)‚üß
  adj_sub h := by
    rw [‚Üê G.mem_edgeSet, ‚Üê h]
    -- ‚ä¢ Quotient.mk (Sym2.Rel.setoid V) (v, w) ‚àà edgeSet G
    exact hvw
    -- üéâ no goals
  edge_vert {a b} h := by
    apply_fun fun e ‚Ü¶ a ‚àà e at h
    -- ‚ä¢ a ‚àà {v, w}
    simp only [Sym2.mem_iff, true_or, eq_iff_iff, iff_true] at h
    -- ‚ä¢ a ‚àà {v, w}
    exact h
    -- üéâ no goals
#align simple_graph.subgraph_of_adj SimpleGraph.subgraphOfAdj

namespace Subgraph

variable {G : SimpleGraph V} {G‚ÇÅ G‚ÇÇ : G.Subgraph} {a b : V}

protected theorem loopless (G' : Subgraph G) : Irreflexive G'.Adj :=
  fun v h ‚Ü¶ G.loopless v (G'.adj_sub h)
#align simple_graph.subgraph.loopless SimpleGraph.Subgraph.loopless

theorem adj_comm (G' : Subgraph G) (v w : V) : G'.Adj v w ‚Üî G'.Adj w v :=
  ‚ü®fun x ‚Ü¶ G'.symm x, fun x ‚Ü¶ G'.symm x‚ü©
#align simple_graph.subgraph.adj_comm SimpleGraph.Subgraph.adj_comm

@[symm]
theorem adj_symm (G' : Subgraph G) {u v : V} (h : G'.Adj u v) : G'.Adj v u :=
  G'.symm h
#align simple_graph.subgraph.adj_symm SimpleGraph.Subgraph.adj_symm

protected theorem Adj.symm {G' : Subgraph G} {u v : V} (h : G'.Adj u v) : G'.Adj v u :=
  G'.symm h
#align simple_graph.subgraph.adj.symm SimpleGraph.Subgraph.Adj.symm

protected theorem Adj.adj_sub {H : G.Subgraph} {u v : V} (h : H.Adj u v) : G.Adj u v :=
  H.adj_sub h
#align simple_graph.subgraph.adj.adj_sub SimpleGraph.Subgraph.Adj.adj_sub

protected theorem Adj.fst_mem {H : G.Subgraph} {u v : V} (h : H.Adj u v) : u ‚àà H.verts :=
  H.edge_vert h
#align simple_graph.subgraph.adj.fst_mem SimpleGraph.Subgraph.Adj.fst_mem

protected theorem Adj.snd_mem {H : G.Subgraph} {u v : V} (h : H.Adj u v) : v ‚àà H.verts :=
  h.symm.fst_mem
#align simple_graph.subgraph.adj.snd_mem SimpleGraph.Subgraph.Adj.snd_mem

protected theorem Adj.ne {H : G.Subgraph} {u v : V} (h : H.Adj u v) : u ‚â† v :=
  h.adj_sub.ne
#align simple_graph.subgraph.adj.ne SimpleGraph.Subgraph.Adj.ne

/-- Coercion from `G' : Subgraph G` to a `SimpleGraph G'.verts`. -/
@[simps]
protected def coe (G' : Subgraph G) : SimpleGraph G'.verts where
  Adj v w := G'.Adj v w
  symm _ _ h := G'.symm h
  loopless v h := loopless G v (G'.adj_sub h)
#align simple_graph.subgraph.coe SimpleGraph.Subgraph.coe

@[simp]
theorem coe_adj_sub (G' : Subgraph G) (u v : G'.verts) (h : G'.coe.Adj u v) : G.Adj u v :=
  G'.adj_sub h
#align simple_graph.subgraph.coe_adj_sub SimpleGraph.Subgraph.coe_adj_sub

-- Given `h : H.Adj u v`, then `h.coe : H.coe.Adj ‚ü®u, _‚ü© ‚ü®v, _‚ü©`.
protected theorem Adj.coe {H : G.Subgraph} {u v : V} (h : H.Adj u v) :
    H.coe.Adj ‚ü®u, H.edge_vert h‚ü© ‚ü®v, H.edge_vert h.symm‚ü© := h
#align simple_graph.subgraph.adj.coe SimpleGraph.Subgraph.Adj.coe

/-- A subgraph is called a *spanning subgraph* if it contains all the vertices of `G`. -/
def IsSpanning (G' : Subgraph G) : Prop :=
  ‚àÄ v : V, v ‚àà G'.verts
#align simple_graph.subgraph.is_spanning SimpleGraph.Subgraph.IsSpanning

theorem isSpanning_iff {G' : Subgraph G} : G'.IsSpanning ‚Üî G'.verts = Set.univ :=
  Set.eq_univ_iff_forall.symm
#align simple_graph.subgraph.is_spanning_iff SimpleGraph.Subgraph.isSpanning_iff

/-- Coercion from `Subgraph G` to `SimpleGraph V`.  If `G'` is a spanning
subgraph, then `G'.spanningCoe` yields an isomorphic graph.
In general, this adds in all vertices from `V` as isolated vertices. -/
@[simps]
protected def spanningCoe (G' : Subgraph G) : SimpleGraph V where
  Adj := G'.Adj
  symm := G'.symm
  loopless v hv := G.loopless v (G'.adj_sub hv)
#align simple_graph.subgraph.spanning_coe SimpleGraph.Subgraph.spanningCoe

@[simp]
theorem Adj.of_spanningCoe {G' : Subgraph G} {u v : G'.verts} (h : G'.spanningCoe.Adj u v) :
    G.Adj u v :=
  G'.adj_sub h
#align simple_graph.subgraph.adj.of_spanning_coe SimpleGraph.Subgraph.Adj.of_spanningCoe

theorem spanningCoe_inj : G‚ÇÅ.spanningCoe = G‚ÇÇ.spanningCoe ‚Üî G‚ÇÅ.Adj = G‚ÇÇ.Adj := by
  simp [Subgraph.spanningCoe]
  -- üéâ no goals
#align simple_graph.subgraph.spanning_coe_inj SimpleGraph.Subgraph.spanningCoe_inj

/-- `spanningCoe` is equivalent to `coe` for a subgraph that `IsSpanning`. -/
@[simps]
def spanningCoeEquivCoeOfSpanning (G' : Subgraph G) (h : G'.IsSpanning) : G'.spanningCoe ‚âÉg G'.coe
    where
  toFun v := ‚ü®v, h v‚ü©
  invFun v := v
  left_inv _ := rfl
  right_inv _ := rfl
  map_rel_iff' := Iff.rfl
#align simple_graph.subgraph.spanning_coe_equiv_coe_of_spanning SimpleGraph.Subgraph.spanningCoeEquivCoeOfSpanning

/-- A subgraph is called an *induced subgraph* if vertices of `G'` are adjacent if
they are adjacent in `G`. -/
def IsInduced (G' : Subgraph G) : Prop :=
  ‚àÄ {v w : V}, v ‚àà G'.verts ‚Üí w ‚àà G'.verts ‚Üí G.Adj v w ‚Üí G'.Adj v w
#align simple_graph.subgraph.is_induced SimpleGraph.Subgraph.IsInduced

/-- `H.support` is the set of vertices that form edges in the subgraph `H`. -/
def support (H : Subgraph G) : Set V := Rel.dom H.Adj
#align simple_graph.subgraph.support SimpleGraph.Subgraph.support

theorem mem_support (H : Subgraph G) {v : V} : v ‚àà H.support ‚Üî ‚àÉ w, H.Adj v w := Iff.rfl
#align simple_graph.subgraph.mem_support SimpleGraph.Subgraph.mem_support

theorem support_subset_verts (H : Subgraph G) : H.support ‚äÜ H.verts :=
  fun _ ‚ü®_, h‚ü© ‚Ü¶ H.edge_vert h
#align simple_graph.subgraph.support_subset_verts SimpleGraph.Subgraph.support_subset_verts

/-- `G'.neighborSet v` is the set of vertices adjacent to `v` in `G'`. -/
def neighborSet (G' : Subgraph G) (v : V) : Set V := {w | G'.Adj v w}
#align simple_graph.subgraph.neighbor_set SimpleGraph.Subgraph.neighborSet

theorem neighborSet_subset (G' : Subgraph G) (v : V) : G'.neighborSet v ‚äÜ G.neighborSet v :=
  fun _ ‚Ü¶ G'.adj_sub
#align simple_graph.subgraph.neighbor_set_subset SimpleGraph.Subgraph.neighborSet_subset

theorem neighborSet_subset_verts (G' : Subgraph G) (v : V) : G'.neighborSet v ‚äÜ G'.verts :=
  fun _ h ‚Ü¶ G'.edge_vert (adj_symm G' h)
#align simple_graph.subgraph.neighbor_set_subset_verts SimpleGraph.Subgraph.neighborSet_subset_verts

@[simp]
theorem mem_neighborSet (G' : Subgraph G) (v w : V) : w ‚àà G'.neighborSet v ‚Üî G'.Adj v w := Iff.rfl
#align simple_graph.subgraph.mem_neighbor_set SimpleGraph.Subgraph.mem_neighborSet

/-- A subgraph as a graph has equivalent neighbor sets. -/
def coeNeighborSetEquiv {G' : Subgraph G} (v : G'.verts) : G'.coe.neighborSet v ‚âÉ G'.neighborSet v
    where
  toFun w := ‚ü®w, w.2‚ü©
  invFun w := ‚ü®‚ü®w, G'.edge_vert (G'.adj_symm w.2)‚ü©, w.2‚ü©
  left_inv _ := rfl
  right_inv _ := rfl
#align simple_graph.subgraph.coe_neighbor_set_equiv SimpleGraph.Subgraph.coeNeighborSetEquiv

/-- The edge set of `G'` consists of a subset of edges of `G`. -/
def edgeSet (G' : Subgraph G) : Set (Sym2 V) := Sym2.fromRel G'.symm
#align simple_graph.subgraph.edge_set SimpleGraph.Subgraph.edgeSet

theorem edgeSet_subset (G' : Subgraph G) : G'.edgeSet ‚äÜ G.edgeSet :=
  Sym2.ind (fun _ _ ‚Ü¶ G'.adj_sub)
#align simple_graph.subgraph.edge_set_subset SimpleGraph.Subgraph.edgeSet_subset

@[simp]
theorem mem_edgeSet {G' : Subgraph G} {v w : V} : ‚ü¶(v, w)‚üß ‚àà G'.edgeSet ‚Üî G'.Adj v w := Iff.rfl
#align simple_graph.subgraph.mem_edge_set SimpleGraph.Subgraph.mem_edgeSet

theorem mem_verts_if_mem_edge {G' : Subgraph G} {e : Sym2 V} {v : V} (he : e ‚àà G'.edgeSet)
    (hv : v ‚àà e) : v ‚àà G'.verts := by
  revert hv
  -- ‚ä¢ v ‚àà e ‚Üí v ‚àà G'.verts
  refine' Sym2.ind (fun v w he ‚Ü¶ _) e he
  -- ‚ä¢ v‚úù ‚àà Quotient.mk (Sym2.Rel.setoid V) (v, w) ‚Üí v‚úù ‚àà G'.verts
  intro hv
  -- ‚ä¢ v‚úù ‚àà G'.verts
  rcases Sym2.mem_iff.mp hv with (rfl | rfl)
  -- ‚ä¢ v ‚àà G'.verts
  ¬∑ exact G'.edge_vert he
    -- üéâ no goals
  ¬∑ exact G'.edge_vert (G'.symm he)
    -- üéâ no goals
#align simple_graph.subgraph.mem_verts_if_mem_edge SimpleGraph.Subgraph.mem_verts_if_mem_edge

/-- The `incidenceSet` is the set of edges incident to a given vertex. -/
def incidenceSet (G' : Subgraph G) (v : V) : Set (Sym2 V) := {e ‚àà G'.edgeSet | v ‚àà e}
#align simple_graph.subgraph.incidence_set SimpleGraph.Subgraph.incidenceSet

theorem incidenceSet_subset_incidenceSet (G' : Subgraph G) (v : V) :
    G'.incidenceSet v ‚äÜ G.incidenceSet v :=
  fun _ h ‚Ü¶ ‚ü®G'.edgeSet_subset h.1, h.2‚ü©
#align simple_graph.subgraph.incidence_set_subset_incidence_set SimpleGraph.Subgraph.incidenceSet_subset_incidenceSet

theorem incidenceSet_subset (G' : Subgraph G) (v : V) : G'.incidenceSet v ‚äÜ G'.edgeSet :=
  fun _ h ‚Ü¶ h.1
#align simple_graph.subgraph.incidence_set_subset SimpleGraph.Subgraph.incidenceSet_subset

/-- Give a vertex as an element of the subgraph's vertex type. -/
@[reducible]
def vert (G' : Subgraph G) (v : V) (h : v ‚àà G'.verts) : G'.verts := ‚ü®v, h‚ü©
#align simple_graph.subgraph.vert SimpleGraph.Subgraph.vert

/--
Create an equal copy of a subgraph (see `copy_eq`) with possibly different definitional equalities.
See Note [range copy pattern].
-/
def copy (G' : Subgraph G) (V'' : Set V) (hV : V'' = G'.verts)
    (adj' : V ‚Üí V ‚Üí Prop) (hadj : adj' = G'.Adj) : Subgraph G where
  verts := V''
  Adj := adj'
  adj_sub := hadj.symm ‚ñ∏ G'.adj_sub
  edge_vert := hV.symm ‚ñ∏ hadj.symm ‚ñ∏ G'.edge_vert
  symm := hadj.symm ‚ñ∏ G'.symm
#align simple_graph.subgraph.copy SimpleGraph.Subgraph.copy

theorem copy_eq (G' : Subgraph G) (V'' : Set V) (hV : V'' = G'.verts)
    (adj' : V ‚Üí V ‚Üí Prop) (hadj : adj' = G'.Adj) : G'.copy V'' hV adj' hadj = G' :=
  Subgraph.ext _ _ hV hadj
#align simple_graph.subgraph.copy_eq SimpleGraph.Subgraph.copy_eq

/-- The union of two subgraphs. -/
instance : Sup G.Subgraph where
  sup G‚ÇÅ G‚ÇÇ :=
    { verts := G‚ÇÅ.verts ‚à™ G‚ÇÇ.verts
      Adj := G‚ÇÅ.Adj ‚äî G‚ÇÇ.Adj
      adj_sub := fun hab => Or.elim hab (fun h => G‚ÇÅ.adj_sub h) fun h => G‚ÇÇ.adj_sub h
      edge_vert := Or.imp (fun h => G‚ÇÅ.edge_vert h) fun h => G‚ÇÇ.edge_vert h
      symm := fun _ _ => Or.imp G‚ÇÅ.adj_symm G‚ÇÇ.adj_symm }

/-- The intersection of two subgraphs. -/
instance : Inf G.Subgraph where
  inf G‚ÇÅ G‚ÇÇ :=
    { verts := G‚ÇÅ.verts ‚à© G‚ÇÇ.verts
      Adj := G‚ÇÅ.Adj ‚äì G‚ÇÇ.Adj
      adj_sub := fun hab => G‚ÇÅ.adj_sub hab.1
      edge_vert := And.imp (fun h => G‚ÇÅ.edge_vert h) fun h => G‚ÇÇ.edge_vert h
      symm := fun _ _ => And.imp G‚ÇÅ.adj_symm G‚ÇÇ.adj_symm }

/-- The `top` subgraph is `G` as a subgraph of itself. -/
instance : Top G.Subgraph where
  top :=
    { verts := Set.univ
      Adj := G.Adj
      adj_sub := id
      edge_vert := @fun v _ _ => Set.mem_univ v
      symm := G.symm }

/-- The `bot` subgraph is the subgraph with no vertices or edges. -/
instance : Bot G.Subgraph where
  bot :=
    { verts := ‚àÖ
      Adj := ‚ä•
      adj_sub := False.elim
      edge_vert := False.elim
      symm := fun _ _ => id }

instance : SupSet G.Subgraph where
  sSup s :=
    { verts := ‚ãÉ G' ‚àà s, verts G'
      Adj := fun a b => ‚àÉ G' ‚àà s, Adj G' a b
      adj_sub := by
        rintro a b ‚ü®G', -, hab‚ü©
        -- ‚ä¢ SimpleGraph.Adj G a b
        exact G'.adj_sub hab
        -- üéâ no goals
      edge_vert := by
        rintro a b ‚ü®G', hG', hab‚ü©
        -- ‚ä¢ a ‚àà ‚ãÉ (G' : Subgraph G) (_ : G' ‚àà s), G'.verts
        exact Set.mem_iUnion‚ÇÇ_of_mem hG' (G'.edge_vert hab)
        -- üéâ no goals
      symm := fun a b h => by simpa [adj_comm] using h }
                              -- üéâ no goals

instance : InfSet G.Subgraph where
  sInf s :=
    { verts := ‚ãÇ G' ‚àà s, verts G'
      Adj := fun a b => (‚àÄ ‚¶ÉG'‚¶Ñ, G' ‚àà s ‚Üí Adj G' a b) ‚àß G.Adj a b
      adj_sub := And.right
      edge_vert := fun hab => Set.mem_iInter‚ÇÇ_of_mem fun G' hG' => G'.edge_vert <| hab.1 hG'
      symm := fun _ _ => And.imp (forall‚ÇÇ_imp fun _ _ => Adj.symm) G.adj_symm }

@[simp]
theorem sup_adj : (G‚ÇÅ ‚äî G‚ÇÇ).Adj a b ‚Üî G‚ÇÅ.Adj a b ‚à® G‚ÇÇ.Adj a b :=
  Iff.rfl
#align simple_graph.subgraph.sup_adj SimpleGraph.Subgraph.sup_adj

@[simp]
theorem inf_adj : (G‚ÇÅ ‚äì G‚ÇÇ).Adj a b ‚Üî G‚ÇÅ.Adj a b ‚àß G‚ÇÇ.Adj a b :=
  Iff.rfl
#align simple_graph.subgraph.inf_adj SimpleGraph.Subgraph.inf_adj

@[simp]
theorem top_adj : (‚ä§ : Subgraph G).Adj a b ‚Üî G.Adj a b :=
  Iff.rfl
#align simple_graph.subgraph.top_adj SimpleGraph.Subgraph.top_adj

@[simp]
theorem not_bot_adj : ¬¨ (‚ä• : Subgraph G).Adj a b :=
  not_false
#align simple_graph.subgraph.not_bot_adj SimpleGraph.Subgraph.not_bot_adj

@[simp]
theorem verts_sup (G‚ÇÅ G‚ÇÇ : G.Subgraph) : (G‚ÇÅ ‚äî G‚ÇÇ).verts = G‚ÇÅ.verts ‚à™ G‚ÇÇ.verts :=
  rfl
#align simple_graph.subgraph.verts_sup SimpleGraph.Subgraph.verts_sup

@[simp]
theorem verts_inf (G‚ÇÅ G‚ÇÇ : G.Subgraph) : (G‚ÇÅ ‚äì G‚ÇÇ).verts = G‚ÇÅ.verts ‚à© G‚ÇÇ.verts :=
  rfl
#align simple_graph.subgraph.verts_inf SimpleGraph.Subgraph.verts_inf

@[simp]
theorem verts_top : (‚ä§ : G.Subgraph).verts = Set.univ :=
  rfl
#align simple_graph.subgraph.verts_top SimpleGraph.Subgraph.verts_top

@[simp]
theorem verts_bot : (‚ä• : G.Subgraph).verts = ‚àÖ :=
  rfl
#align simple_graph.subgraph.verts_bot SimpleGraph.Subgraph.verts_bot

@[simp]
theorem sSup_adj {s : Set G.Subgraph} : (sSup s).Adj a b ‚Üî ‚àÉ G ‚àà s, Adj G a b :=
  Iff.rfl
#align simple_graph.subgraph.Sup_adj SimpleGraph.Subgraph.sSup_adj

@[simp]
theorem sInf_adj {s : Set G.Subgraph} : (sInf s).Adj a b ‚Üî (‚àÄ G' ‚àà s, Adj G' a b) ‚àß G.Adj a b :=
  Iff.rfl
#align simple_graph.subgraph.Inf_adj SimpleGraph.Subgraph.sInf_adj

@[simp]
theorem iSup_adj {f : Œπ ‚Üí G.Subgraph} : (‚®Ü i, f i).Adj a b ‚Üî ‚àÉ i, (f i).Adj a b := by
  simp [iSup]
  -- üéâ no goals
#align simple_graph.subgraph.supr_adj SimpleGraph.Subgraph.iSup_adj

@[simp]
theorem iInf_adj {f : Œπ ‚Üí G.Subgraph} : (‚®Ö i, f i).Adj a b ‚Üî (‚àÄ i, (f i).Adj a b) ‚àß G.Adj a b := by
  simp [iInf]
  -- üéâ no goals
#align simple_graph.subgraph.infi_adj SimpleGraph.Subgraph.iInf_adj

theorem sInf_adj_of_nonempty {s : Set G.Subgraph} (hs : s.Nonempty) :
    (sInf s).Adj a b ‚Üî ‚àÄ G' ‚àà s, Adj G' a b :=
  sInf_adj.trans <|
    and_iff_left_of_imp <| by
      obtain ‚ü®G', hG'‚ü© := hs
      -- ‚ä¢ (‚àÄ (G' : Subgraph G), G' ‚àà s ‚Üí Adj G' a b) ‚Üí SimpleGraph.Adj G a b
      exact fun h => G'.adj_sub (h _ hG')
      -- üéâ no goals
#align simple_graph.subgraph.Inf_adj_of_nonempty SimpleGraph.Subgraph.sInf_adj_of_nonempty

theorem iInf_adj_of_nonempty [Nonempty Œπ] {f : Œπ ‚Üí G.Subgraph} :
    (‚®Ö i, f i).Adj a b ‚Üî ‚àÄ i, (f i).Adj a b := by
  rw [iInf, sInf_adj_of_nonempty (Set.range_nonempty _)]
  -- ‚ä¢ (‚àÄ (G' : Subgraph G), (G' ‚àà Set.range fun i => f i) ‚Üí Adj G' a b) ‚Üî ‚àÄ (i : Œπ ‚Ä¶
  simp
  -- üéâ no goals
#align simple_graph.subgraph.infi_adj_of_nonempty SimpleGraph.Subgraph.iInf_adj_of_nonempty

@[simp]
theorem verts_sSup (s : Set G.Subgraph) : (sSup s).verts = ‚ãÉ G' ‚àà s, verts G' :=
  rfl
#align simple_graph.subgraph.verts_Sup SimpleGraph.Subgraph.verts_sSup

@[simp]
theorem verts_sInf (s : Set G.Subgraph) : (sInf s).verts = ‚ãÇ G' ‚àà s, verts G' :=
  rfl
#align simple_graph.subgraph.verts_Inf SimpleGraph.Subgraph.verts_sInf

@[simp]
theorem verts_iSup {f : Œπ ‚Üí G.Subgraph} : (‚®Ü i, f i).verts = ‚ãÉ i, (f i).verts := by simp [iSup]
                                                                                    -- üéâ no goals
#align simple_graph.subgraph.verts_supr SimpleGraph.Subgraph.verts_iSup

@[simp]
theorem verts_iInf {f : Œπ ‚Üí G.Subgraph} : (‚®Ö i, f i).verts = ‚ãÇ i, (f i).verts := by simp [iInf]
                                                                                    -- üéâ no goals
#align simple_graph.subgraph.verts_infi SimpleGraph.Subgraph.verts_iInf

theorem verts_spanningCoe_injective :
    (fun G' : Subgraph G => (G'.verts, G'.spanningCoe)).Injective := by
  intro G‚ÇÅ G‚ÇÇ h
  -- ‚ä¢ G‚ÇÅ = G‚ÇÇ
  rw [Prod.ext_iff] at h
  -- ‚ä¢ G‚ÇÅ = G‚ÇÇ
  exact Subgraph.ext _ _ h.1 (spanningCoe_inj.1 h.2)
  -- üéâ no goals

/-- For subgraphs `G‚ÇÅ`, `G‚ÇÇ`, `G‚ÇÅ ‚â§ G‚ÇÇ` iff `G‚ÇÅ.verts ‚äÜ G‚ÇÇ.verts` and
`‚àÄ a b, G‚ÇÅ.adj a b ‚Üí G‚ÇÇ.adj a b`. -/
instance distribLattice : DistribLattice G.Subgraph :=
  { show DistribLattice G.Subgraph from
      verts_spanningCoe_injective.distribLattice _
        (fun _ _ => rfl) fun _ _ => rfl with
    le := fun x y => x.verts ‚äÜ y.verts ‚àß ‚àÄ ‚¶Év w : V‚¶Ñ, x.Adj v w ‚Üí y.Adj v w }

instance : BoundedOrder (Subgraph G) where
  top := ‚ä§
  bot := ‚ä•
  le_top x := ‚ü®Set.subset_univ _, fun _ _ => x.adj_sub‚ü©
  bot_le _ := ‚ü®Set.empty_subset _, fun _ _ => False.elim‚ü©

-- Note that subgraphs do not form a Boolean algebra, because of `verts`.
instance : CompletelyDistribLattice G.Subgraph :=
  { Subgraph.distribLattice with
    le := (¬∑ ‚â§ ¬∑)
    sup := (¬∑ ‚äî ¬∑)
    inf := (¬∑ ‚äì ¬∑)
    top := ‚ä§
    bot := ‚ä•
    le_top := fun G' => ‚ü®Set.subset_univ _, fun a b => G'.adj_sub‚ü©
    bot_le := fun G' => ‚ü®Set.empty_subset _, fun a b => False.elim‚ü©
    sSup := sSup
    -- porting note: needed `apply` here to modify elaboration; previously the term itself was fine.
    le_sSup := fun s G' hG' => ‚ü®by apply Set.subset_iUnion‚ÇÇ G' hG', fun a b hab => ‚ü®G', hG', hab‚ü©‚ü©
                                   -- üéâ no goals
    sSup_le := fun s G' hG' =>
      ‚ü®Set.iUnion‚ÇÇ_subset fun H hH => (hG' _ hH).1, by
        rintro a b ‚ü®H, hH, hab‚ü©
        -- ‚ä¢ Adj G' a b
        exact (hG' _ hH).2 hab‚ü©
        -- üéâ no goals
    sInf := sInf
    sInf_le := fun s G' hG' => ‚ü®Set.iInter‚ÇÇ_subset G' hG', fun a b hab => hab.1 hG'‚ü©
    le_sInf := fun s G' hG' =>
      ‚ü®Set.subset_iInter‚ÇÇ fun H hH => (hG' _ hH).1, fun a b hab =>
        ‚ü®fun H hH => (hG' _ hH).2 hab, G'.adj_sub hab‚ü©‚ü©
    iInf_iSup_eq := fun f => Subgraph.ext _ _ (by simpa using iInf_iSup_eq)
                                                  -- üéâ no goals
      (by ext; simp [Classical.skolem]) }
          -- ‚ä¢ Adj (‚®Ö (a : Œπ‚úù), ‚®Ü (b : Œ∫‚úù a), f a b) x‚úù¬π x‚úù ‚Üî Adj (‚®Ü (g : (a : Œπ‚úù) ‚Üí Œ∫‚úù a), ‚Ä¶
               -- üéâ no goals

@[simps]
instance subgraphInhabited : Inhabited (Subgraph G) := ‚ü®‚ä•‚ü©
#align simple_graph.subgraph.subgraph_inhabited SimpleGraph.Subgraph.subgraphInhabited

@[simp]
theorem neighborSet_sup {H H' : G.Subgraph} (v : V) :
    (H ‚äî H').neighborSet v = H.neighborSet v ‚à™ H'.neighborSet v := rfl
#align simple_graph.subgraph.neighbor_set_sup SimpleGraph.Subgraph.neighborSet_sup

@[simp]
theorem neighborSet_inf {H H' : G.Subgraph} (v : V) :
    (H ‚äì H').neighborSet v = H.neighborSet v ‚à© H'.neighborSet v := rfl
#align simple_graph.subgraph.neighbor_set_inf SimpleGraph.Subgraph.neighborSet_inf

@[simp]
theorem neighborSet_top (v : V) : (‚ä§ : G.Subgraph).neighborSet v = G.neighborSet v := rfl
#align simple_graph.subgraph.neighbor_set_top SimpleGraph.Subgraph.neighborSet_top

@[simp]
theorem neighborSet_bot (v : V) : (‚ä• : G.Subgraph).neighborSet v = ‚àÖ := rfl
#align simple_graph.subgraph.neighbor_set_bot SimpleGraph.Subgraph.neighborSet_bot

@[simp]
theorem neighborSet_sSup (s : Set G.Subgraph) (v : V) :
    (sSup s).neighborSet v = ‚ãÉ G' ‚àà s, neighborSet G' v := by
  ext
  -- ‚ä¢ x‚úù ‚àà neighborSet (sSup s) v ‚Üî x‚úù ‚àà ‚ãÉ (G' : Subgraph G) (_ : G' ‚àà s), neighbo ‚Ä¶
  simp
  -- üéâ no goals
#align simple_graph.subgraph.neighbor_set_Sup SimpleGraph.Subgraph.neighborSet_sSup

@[simp]
theorem neighborSet_sInf (s : Set G.Subgraph) (v : V) :
    (sInf s).neighborSet v = (‚ãÇ G' ‚àà s, neighborSet G' v) ‚à© G.neighborSet v := by
  ext
  -- ‚ä¢ x‚úù ‚àà neighborSet (sInf s) v ‚Üî x‚úù ‚àà (‚ãÇ (G' : Subgraph G) (_ : G' ‚àà s), neighb ‚Ä¶
  simp
  -- üéâ no goals
#align simple_graph.subgraph.neighbor_set_Inf SimpleGraph.Subgraph.neighborSet_sInf

@[simp]
theorem neighborSet_iSup (f : Œπ ‚Üí G.Subgraph) (v : V) :
    (‚®Ü i, f i).neighborSet v = ‚ãÉ i, (f i).neighborSet v := by simp [iSup]
                                                              -- üéâ no goals
#align simple_graph.subgraph.neighbor_set_supr SimpleGraph.Subgraph.neighborSet_iSup

@[simp]
theorem neighborSet_iInf (f : Œπ ‚Üí G.Subgraph) (v : V) :
    (‚®Ö i, f i).neighborSet v = (‚ãÇ i, (f i).neighborSet v) ‚à© G.neighborSet v := by simp [iInf]
                                                                                  -- üéâ no goals
#align simple_graph.subgraph.neighbor_set_infi SimpleGraph.Subgraph.neighborSet_iInf

@[simp]
theorem edgeSet_top : (‚ä§ : Subgraph G).edgeSet = G.edgeSet := rfl
#align simple_graph.subgraph.edge_set_top SimpleGraph.Subgraph.edgeSet_top

@[simp]
theorem edgeSet_bot : (‚ä• : Subgraph G).edgeSet = ‚àÖ :=
  Set.ext <| Sym2.ind (by simp)
                          -- üéâ no goals
#align simple_graph.subgraph.edge_set_bot SimpleGraph.Subgraph.edgeSet_bot

@[simp]
theorem edgeSet_inf {H‚ÇÅ H‚ÇÇ : Subgraph G} : (H‚ÇÅ ‚äì H‚ÇÇ).edgeSet = H‚ÇÅ.edgeSet ‚à© H‚ÇÇ.edgeSet :=
  Set.ext <| Sym2.ind (by simp)
                          -- üéâ no goals
#align simple_graph.subgraph.edge_set_inf SimpleGraph.Subgraph.edgeSet_inf

@[simp]
theorem edgeSet_sup {H‚ÇÅ H‚ÇÇ : Subgraph G} : (H‚ÇÅ ‚äî H‚ÇÇ).edgeSet = H‚ÇÅ.edgeSet ‚à™ H‚ÇÇ.edgeSet :=
  Set.ext <| Sym2.ind (by simp)
                          -- üéâ no goals
#align simple_graph.subgraph.edge_set_sup SimpleGraph.Subgraph.edgeSet_sup

@[simp]
theorem edgeSet_sSup (s : Set G.Subgraph) : (sSup s).edgeSet = ‚ãÉ G' ‚àà s, edgeSet G' := by
  ext e
  -- ‚ä¢ e ‚àà edgeSet (sSup s) ‚Üî e ‚àà ‚ãÉ (G' : Subgraph G) (_ : G' ‚àà s), edgeSet G'
  induction e using Sym2.ind
  -- ‚ä¢ Quotient.mk (Sym2.Rel.setoid V) (x‚úù, y‚úù) ‚àà edgeSet (sSup s) ‚Üî Quotient.mk (S ‚Ä¶
  simp
  -- üéâ no goals
#align simple_graph.subgraph.edge_set_Sup SimpleGraph.Subgraph.edgeSet_sSup

@[simp]
theorem edgeSet_sInf (s : Set G.Subgraph) :
    (sInf s).edgeSet = (‚ãÇ G' ‚àà s, edgeSet G') ‚à© G.edgeSet := by
  ext e
  -- ‚ä¢ e ‚àà edgeSet (sInf s) ‚Üî e ‚àà (‚ãÇ (G' : Subgraph G) (_ : G' ‚àà s), edgeSet G') ‚à©  ‚Ä¶
  induction e using Sym2.ind
  -- ‚ä¢ Quotient.mk (Sym2.Rel.setoid V) (x‚úù, y‚úù) ‚àà edgeSet (sInf s) ‚Üî Quotient.mk (S ‚Ä¶
  simp
  -- üéâ no goals
#align simple_graph.subgraph.edge_set_Inf SimpleGraph.Subgraph.edgeSet_sInf

@[simp]
theorem edgeSet_iSup (f : Œπ ‚Üí G.Subgraph) :
    (‚®Ü i, f i).edgeSet = ‚ãÉ i, (f i).edgeSet := by simp [iSup]
                                                  -- üéâ no goals
#align simple_graph.subgraph.edge_set_supr SimpleGraph.Subgraph.edgeSet_iSup

@[simp]
theorem edgeSet_iInf (f : Œπ ‚Üí G.Subgraph) :
    (‚®Ö i, f i).edgeSet = (‚ãÇ i, (f i).edgeSet) ‚à© G.edgeSet := by
  simp [iInf]
  -- üéâ no goals
#align simple_graph.subgraph.edge_set_infi SimpleGraph.Subgraph.edgeSet_iInf

@[simp]
theorem spanningCoe_top : (‚ä§ : Subgraph G).spanningCoe = G := rfl
#align simple_graph.subgraph.spanning_coe_top SimpleGraph.Subgraph.spanningCoe_top

@[simp]
theorem spanningCoe_bot : (‚ä• : Subgraph G).spanningCoe = ‚ä• := rfl
#align simple_graph.subgraph.spanning_coe_bot SimpleGraph.Subgraph.spanningCoe_bot

/-- Turn a subgraph of a `SimpleGraph` into a member of its subgraph type. -/
@[simps]
def _root_.SimpleGraph.toSubgraph (H : SimpleGraph V) (h : H ‚â§ G) : G.Subgraph where
  verts := Set.univ
  Adj := H.Adj
  adj_sub e := h e
  edge_vert _ := Set.mem_univ _
  symm := H.symm
#align simple_graph.to_subgraph SimpleGraph.toSubgraph

theorem support_mono {H H' : Subgraph G} (h : H ‚â§ H') : H.support ‚äÜ H'.support :=
  Rel.dom_mono h.2
#align simple_graph.subgraph.support_mono SimpleGraph.Subgraph.support_mono

theorem _root_.SimpleGraph.toSubgraph.isSpanning (H : SimpleGraph V) (h : H ‚â§ G) :
    (toSubgraph H h).IsSpanning :=
  Set.mem_univ
#align simple_graph.to_subgraph.is_spanning SimpleGraph.toSubgraph.isSpanning

theorem spanningCoe_le_of_le {H H' : Subgraph G} (h : H ‚â§ H') : H.spanningCoe ‚â§ H'.spanningCoe :=
  h.2
#align simple_graph.subgraph.spanning_coe_le_of_le SimpleGraph.Subgraph.spanningCoe_le_of_le

/-- The top of the `Subgraph G` lattice is equivalent to the graph itself. -/
def topEquiv : (‚ä§ : Subgraph G).coe ‚âÉg G where
  toFun v := ‚Üëv
  invFun v := ‚ü®v, trivial‚ü©
  left_inv _ := rfl
  right_inv _ := rfl
  map_rel_iff' := Iff.rfl
#align simple_graph.subgraph.top_equiv SimpleGraph.Subgraph.topEquiv

/-- The bottom of the `Subgraph G` lattice is equivalent to the empty graph on the empty
vertex type. -/
def botEquiv : (‚ä• : Subgraph G).coe ‚âÉg (‚ä• : SimpleGraph Empty) where
  toFun v := v.property.elim
  invFun v := v.elim
  left_inv := fun ‚ü®_, h‚ü© ‚Ü¶ h.elim
  right_inv v := v.elim
  map_rel_iff' := Iff.rfl
#align simple_graph.subgraph.bot_equiv SimpleGraph.Subgraph.botEquiv

theorem edgeSet_mono {H‚ÇÅ H‚ÇÇ : Subgraph G} (h : H‚ÇÅ ‚â§ H‚ÇÇ) : H‚ÇÅ.edgeSet ‚â§ H‚ÇÇ.edgeSet :=
  Sym2.ind h.2
#align simple_graph.subgraph.edge_set_mono SimpleGraph.Subgraph.edgeSet_mono

theorem _root_.Disjoint.edgeSet {H‚ÇÅ H‚ÇÇ : Subgraph G} (h : Disjoint H‚ÇÅ H‚ÇÇ) :
    Disjoint H‚ÇÅ.edgeSet H‚ÇÇ.edgeSet :=
  disjoint_iff_inf_le.mpr <| by simpa using edgeSet_mono h.le_bot
                                -- üéâ no goals
#align disjoint.edge_set Disjoint.edgeSet

/-- Graph homomorphisms induce a covariant function on subgraphs. -/
@[simps]
protected def map {G' : SimpleGraph W} (f : G ‚Üíg G') (H : G.Subgraph) : G'.Subgraph where
  verts := f '' H.verts
  Adj := Relation.Map H.Adj f f
  adj_sub := by
    rintro _ _ ‚ü®u, v, h, rfl, rfl‚ü©
    -- ‚ä¢ SimpleGraph.Adj G' (‚Üëf u) (‚Üëf v)
    exact f.map_rel (H.adj_sub h)
    -- üéâ no goals
  edge_vert := by
    rintro _ _ ‚ü®u, v, h, rfl, rfl‚ü©
    -- ‚ä¢ ‚Üëf u ‚àà ‚Üëf '' H.verts
    exact Set.mem_image_of_mem _ (H.edge_vert h)
    -- üéâ no goals
  symm := by
    rintro _ _ ‚ü®u, v, h, rfl, rfl‚ü©
    -- ‚ä¢ Relation.Map H.Adj (‚Üëf) (‚Üëf) (‚Üëf v) (‚Üëf u)
    exact ‚ü®v, u, H.symm h, rfl, rfl‚ü©
    -- üéâ no goals
#align simple_graph.subgraph.map SimpleGraph.Subgraph.map

theorem map_monotone {G' : SimpleGraph W} (f : G ‚Üíg G') : Monotone (Subgraph.map f) := by
  intro H H' h
  -- ‚ä¢ Subgraph.map f H ‚â§ Subgraph.map f H'
  constructor
  -- ‚ä¢ (Subgraph.map f H).verts ‚äÜ (Subgraph.map f H').verts
  ¬∑ intro
    -- ‚ä¢ a‚úù ‚àà (Subgraph.map f H).verts ‚Üí a‚úù ‚àà (Subgraph.map f H').verts
    simp only [map_verts, Set.mem_image, forall_exists_index, and_imp]
    -- ‚ä¢ ‚àÄ (x : V), x ‚àà H.verts ‚Üí ‚Üëf x = a‚úù ‚Üí ‚àÉ x, x ‚àà H'.verts ‚àß ‚Üëf x = a‚úù
    rintro v hv rfl
    -- ‚ä¢ ‚àÉ x, x ‚àà H'.verts ‚àß ‚Üëf x = ‚Üëf v
    exact ‚ü®_, h.1 hv, rfl‚ü©
    -- üéâ no goals
  ¬∑ rintro _ _ ‚ü®u, v, ha, rfl, rfl‚ü©
    -- ‚ä¢ Adj (Subgraph.map f H') (‚Üëf u) (‚Üëf v)
    exact ‚ü®_, _, h.2 ha, rfl, rfl‚ü©
    -- üéâ no goals
#align simple_graph.subgraph.map_monotone SimpleGraph.Subgraph.map_monotone

theorem map_sup {G : SimpleGraph V} {G' : SimpleGraph W} (f : G ‚Üíg G') {H H' : G.Subgraph} :
    (H ‚äî H').map f = H.map f ‚äî H'.map f := by
  ext1
  -- ‚ä¢ (Subgraph.map f (H ‚äî H')).verts = (Subgraph.map f H ‚äî Subgraph.map f H').verts
  ¬∑ simp only [Set.image_union, map_verts, verts_sup]
    -- üéâ no goals
  ¬∑ ext
    -- ‚ä¢ Adj (Subgraph.map f (H ‚äî H')) x‚úù¬π x‚úù ‚Üî Adj (Subgraph.map f H ‚äî Subgraph.map  ‚Ä¶
    simp only [Relation.Map, map_Adj, sup_adj]
    -- ‚ä¢ (‚àÉ a b, (Adj H a b ‚à® Adj H' a b) ‚àß ‚Üëf a = x‚úù¬π ‚àß ‚Üëf b = x‚úù) ‚Üî (‚àÉ a b, Adj H a ‚Ä¶
    constructor
    -- ‚ä¢ (‚àÉ a b, (Adj H a b ‚à® Adj H' a b) ‚àß ‚Üëf a = x‚úù¬π ‚àß ‚Üëf b = x‚úù) ‚Üí (‚àÉ a b, Adj H a ‚Ä¶
    ¬∑ rintro ‚ü®a, b, h | h, rfl, rfl‚ü©
      -- ‚ä¢ (‚àÉ a_1 b_1, Adj H a_1 b_1 ‚àß ‚Üëf a_1 = ‚Üëf a ‚àß ‚Üëf b_1 = ‚Üëf b) ‚à® ‚àÉ a_1 b_1, Adj  ‚Ä¶
      ¬∑ exact Or.inl ‚ü®_, _, h, rfl, rfl‚ü©
        -- üéâ no goals
      ¬∑ exact Or.inr ‚ü®_, _, h, rfl, rfl‚ü©
        -- üéâ no goals
    ¬∑ rintro (‚ü®a, b, h, rfl, rfl‚ü© | ‚ü®a, b, h, rfl, rfl‚ü©)
      -- ‚ä¢ ‚àÉ a_1 b_1, (Adj H a_1 b_1 ‚à® Adj H' a_1 b_1) ‚àß ‚Üëf a_1 = ‚Üëf a ‚àß ‚Üëf b_1 = ‚Üëf b
      ¬∑ exact ‚ü®_, _, Or.inl h, rfl, rfl‚ü©
        -- üéâ no goals
      ¬∑ exact ‚ü®_, _, Or.inr h, rfl, rfl‚ü©
        -- üéâ no goals
#align simple_graph.subgraph.map_sup SimpleGraph.Subgraph.map_sup

/-- Graph homomorphisms induce a contravariant function on subgraphs. -/
@[simps]
protected def comap {G' : SimpleGraph W} (f : G ‚Üíg G') (H : G'.Subgraph) : G.Subgraph where
  verts := f ‚Åª¬π' H.verts
  Adj u v := G.Adj u v ‚àß H.Adj (f u) (f v)
  adj_sub h := h.1
  edge_vert h := Set.mem_preimage.1 (H.edge_vert h.2)
  symm _ _ h := ‚ü®G.symm h.1, H.symm h.2‚ü©
#align simple_graph.subgraph.comap SimpleGraph.Subgraph.comap

theorem comap_monotone {G' : SimpleGraph W} (f : G ‚Üíg G') : Monotone (Subgraph.comap f) := by
  intro H H' h
  -- ‚ä¢ Subgraph.comap f H ‚â§ Subgraph.comap f H'
  constructor
  -- ‚ä¢ (Subgraph.comap f H).verts ‚äÜ (Subgraph.comap f H').verts
  ¬∑ intro
    -- ‚ä¢ a‚úù ‚àà (Subgraph.comap f H).verts ‚Üí a‚úù ‚àà (Subgraph.comap f H').verts
    simp only [comap_verts, Set.mem_preimage]
    -- ‚ä¢ ‚Üëf a‚úù ‚àà H.verts ‚Üí ‚Üëf a‚úù ‚àà H'.verts
    apply h.1
    -- üéâ no goals
  ¬∑ intro v w
    -- ‚ä¢ Adj (Subgraph.comap f H) v w ‚Üí Adj (Subgraph.comap f H') v w
    simp (config := { contextual := true }) only [comap_Adj, and_imp, true_and_iff]
    -- ‚ä¢ SimpleGraph.Adj G v w ‚Üí Adj H (‚Üëf v) (‚Üëf w) ‚Üí Adj H' (‚Üëf v) (‚Üëf w)
    intro
    -- ‚ä¢ Adj H (‚Üëf v) (‚Üëf w) ‚Üí Adj H' (‚Üëf v) (‚Üëf w)
    apply h.2
    -- üéâ no goals
#align simple_graph.subgraph.comap_monotone SimpleGraph.Subgraph.comap_monotone

theorem map_le_iff_le_comap {G' : SimpleGraph W} (f : G ‚Üíg G') (H : G.Subgraph) (H' : G'.Subgraph) :
    H.map f ‚â§ H' ‚Üî H ‚â§ H'.comap f := by
  refine' ‚ü®fun h ‚Ü¶ ‚ü®fun v hv ‚Ü¶ _, fun v w hvw ‚Ü¶ _‚ü©, fun h ‚Ü¶ ‚ü®fun v ‚Ü¶ _, fun v w ‚Ü¶ _‚ü©‚ü©
  ¬∑ simp only [comap_verts, Set.mem_preimage]
    -- ‚ä¢ ‚Üëf v ‚àà H'.verts
    exact h.1 ‚ü®v, hv, rfl‚ü©
    -- üéâ no goals
  ¬∑ simp only [H.adj_sub hvw, comap_Adj, true_and_iff]
    -- ‚ä¢ Adj H' (‚Üëf v) (‚Üëf w)
    exact h.2 ‚ü®v, w, hvw, rfl, rfl‚ü©
    -- üéâ no goals
  ¬∑ simp only [map_verts, Set.mem_image, forall_exists_index, and_imp]
    -- ‚ä¢ ‚àÄ (x : V), x ‚àà H.verts ‚Üí ‚Üëf x = v ‚Üí v ‚àà H'.verts
    rintro w hw rfl
    -- ‚ä¢ ‚Üëf w ‚àà H'.verts
    exact h.1 hw
    -- üéâ no goals
  ¬∑ simp only [Relation.Map, map_Adj, forall_exists_index, and_imp]
    -- ‚ä¢ ‚àÄ (x x_1 : V), Adj H x x_1 ‚Üí ‚Üëf x = v ‚Üí ‚Üëf x_1 = w ‚Üí Adj H' v w
    rintro u u' hu rfl rfl
    -- ‚ä¢ Adj H' (‚Üëf u) (‚Üëf u')
    exact (h.2 hu).2
    -- üéâ no goals
#align simple_graph.subgraph.map_le_iff_le_comap SimpleGraph.Subgraph.map_le_iff_le_comap

/-- Given two subgraphs, one a subgraph of the other, there is an induced injective homomorphism of
the subgraphs as graphs. -/
@[simps]
def inclusion {x y : Subgraph G} (h : x ‚â§ y) : x.coe ‚Üíg y.coe where
  toFun v := ‚ü®‚Üëv, And.left h v.property‚ü©
  map_rel' hvw := h.2 hvw
#align simple_graph.subgraph.inclusion SimpleGraph.Subgraph.inclusion

theorem inclusion.injective {x y : Subgraph G} (h : x ‚â§ y) : Function.Injective (inclusion h) := by
  intro v w h
  -- ‚ä¢ v = w
  rw [inclusion, FunLike.coe, Subtype.mk_eq_mk] at h
  -- ‚ä¢ v = w
  exact Subtype.ext h
  -- üéâ no goals
#align simple_graph.subgraph.inclusion.injective SimpleGraph.Subgraph.inclusion.injective

/-- There is an induced injective homomorphism of a subgraph of `G` into `G`. -/
@[simps]
protected def hom (x : Subgraph G) : x.coe ‚Üíg G where
  toFun v := v
  map_rel' := x.adj_sub
#align simple_graph.subgraph.hom SimpleGraph.Subgraph.hom

@[simp] lemma coe_hom (x : Subgraph G) :
    (x.hom : x.verts ‚Üí V) = (fun (v : x.verts) => (v : V)) := rfl

theorem hom.injective {x : Subgraph G} : Function.Injective x.hom :=
  fun _ _ ‚Ü¶ Subtype.ext
#align simple_graph.subgraph.hom.injective SimpleGraph.Subgraph.hom.injective

/-- There is an induced injective homomorphism of a subgraph of `G` as
a spanning subgraph into `G`. -/
@[simps]
def spanningHom (x : Subgraph G) : x.spanningCoe ‚Üíg G where
  toFun := id
  map_rel' := x.adj_sub
#align simple_graph.subgraph.spanning_hom SimpleGraph.Subgraph.spanningHom

theorem spanningHom.injective {x : Subgraph G} : Function.Injective x.spanningHom :=
  fun _ _ ‚Ü¶ id
#align simple_graph.subgraph.spanning_hom.injective SimpleGraph.Subgraph.spanningHom.injective

theorem neighborSet_subset_of_subgraph {x y : Subgraph G} (h : x ‚â§ y) (v : V) :
    x.neighborSet v ‚äÜ y.neighborSet v :=
  fun _ h' ‚Ü¶ h.2 h'
#align simple_graph.subgraph.neighbor_set_subset_of_subgraph SimpleGraph.Subgraph.neighborSet_subset_of_subgraph

instance neighborSet.decidablePred (G' : Subgraph G) [h : DecidableRel G'.Adj] (v : V) :
    DecidablePred (¬∑ ‚àà G'.neighborSet v) :=
  h v
#align simple_graph.subgraph.neighbor_set.decidable_pred SimpleGraph.Subgraph.neighborSet.decidablePred

/-- If a graph is locally finite at a vertex, then so is a subgraph of that graph. -/
instance finiteAt {G' : Subgraph G} (v : G'.verts) [DecidableRel G'.Adj]
    [Fintype (G.neighborSet v)] : Fintype (G'.neighborSet v) :=
  Set.fintypeSubset (G.neighborSet v) (G'.neighborSet_subset v)
#align simple_graph.subgraph.finite_at SimpleGraph.Subgraph.finiteAt

/-- If a subgraph is locally finite at a vertex, then so are subgraphs of that subgraph.

This is not an instance because `G''` cannot be inferred. -/
def finiteAtOfSubgraph {G' G'' : Subgraph G} [DecidableRel G'.Adj] (h : G' ‚â§ G'') (v : G'.verts)
    [Fintype (G''.neighborSet v)] : Fintype (G'.neighborSet v) :=
  Set.fintypeSubset (G''.neighborSet v) (neighborSet_subset_of_subgraph h v)
#align simple_graph.subgraph.finite_at_of_subgraph SimpleGraph.Subgraph.finiteAtOfSubgraph

instance (G' : Subgraph G) [Fintype G'.verts] (v : V) [DecidablePred (¬∑ ‚àà G'.neighborSet v)] :
    Fintype (G'.neighborSet v) :=
  Set.fintypeSubset G'.verts (neighborSet_subset_verts G' v)

instance coeFiniteAt {G' : Subgraph G} (v : G'.verts) [Fintype (G'.neighborSet v)] :
    Fintype (G'.coe.neighborSet v) :=
  Fintype.ofEquiv _ (coeNeighborSetEquiv v).symm
#align simple_graph.subgraph.coe_finite_at SimpleGraph.Subgraph.coeFiniteAt

theorem IsSpanning.card_verts [Fintype V] {G' : Subgraph G} [Fintype G'.verts] (h : G'.IsSpanning) :
    G'.verts.toFinset.card = Fintype.card V := by
  simp only [isSpanning_iff.1 h, Set.toFinset_univ]
  -- ‚ä¢ Finset.card Finset.univ = Fintype.card V
  congr
  -- üéâ no goals
#align simple_graph.subgraph.is_spanning.card_verts SimpleGraph.Subgraph.IsSpanning.card_verts

/-- The degree of a vertex in a subgraph. It's zero for vertices outside the subgraph. -/
def degree (G' : Subgraph G) (v : V) [Fintype (G'.neighborSet v)] : ‚Ñï :=
  Fintype.card (G'.neighborSet v)
#align simple_graph.subgraph.degree SimpleGraph.Subgraph.degree

theorem finset_card_neighborSet_eq_degree {G' : Subgraph G} {v : V} [Fintype (G'.neighborSet v)] :
    (G'.neighborSet v).toFinset.card = G'.degree v := by
  rw [degree, Set.toFinset_card]
  -- üéâ no goals
#align simple_graph.subgraph.finset_card_neighbor_set_eq_degree SimpleGraph.Subgraph.finset_card_neighborSet_eq_degree

theorem degree_le (G' : Subgraph G) (v : V) [Fintype (G'.neighborSet v)]
    [Fintype (G.neighborSet v)] : G'.degree v ‚â§ G.degree v := by
  rw [‚Üê card_neighborSet_eq_degree]
  -- ‚ä¢ degree G' v ‚â§ Fintype.card ‚Üë(SimpleGraph.neighborSet G v)
  exact Set.card_le_of_subset (G'.neighborSet_subset v)
  -- üéâ no goals
#align simple_graph.subgraph.degree_le SimpleGraph.Subgraph.degree_le

theorem degree_le' (G' G'' : Subgraph G) (h : G' ‚â§ G'') (v : V) [Fintype (G'.neighborSet v)]
    [Fintype (G''.neighborSet v)] : G'.degree v ‚â§ G''.degree v :=
  Set.card_le_of_subset (neighborSet_subset_of_subgraph h v)
#align simple_graph.subgraph.degree_le' SimpleGraph.Subgraph.degree_le'

@[simp]
theorem coe_degree (G' : Subgraph G) (v : G'.verts) [Fintype (G'.coe.neighborSet v)]
    [Fintype (G'.neighborSet v)] : G'.coe.degree v = G'.degree v := by
  rw [‚Üê card_neighborSet_eq_degree]
  -- ‚ä¢ Fintype.card ‚Üë(SimpleGraph.neighborSet (Subgraph.coe G') v) = degree G' ‚Üëv
  exact Fintype.card_congr (coeNeighborSetEquiv v)
  -- üéâ no goals
#align simple_graph.subgraph.coe_degree SimpleGraph.Subgraph.coe_degree

@[simp]
theorem degree_spanningCoe {G' : G.Subgraph} (v : V) [Fintype (G'.neighborSet v)]
    [Fintype (G'.spanningCoe.neighborSet v)] : G'.spanningCoe.degree v = G'.degree v := by
  rw [‚Üê card_neighborSet_eq_degree, Subgraph.degree]
  -- ‚ä¢ Fintype.card ‚Üë(SimpleGraph.neighborSet (Subgraph.spanningCoe G') v) = Fintyp ‚Ä¶
  congr!
  -- üéâ no goals
#align simple_graph.subgraph.degree_spanning_coe SimpleGraph.Subgraph.degree_spanningCoe

theorem degree_eq_one_iff_unique_adj {G' : Subgraph G} {v : V} [Fintype (G'.neighborSet v)] :
    G'.degree v = 1 ‚Üî ‚àÉ! w : V, G'.Adj v w := by
  rw [‚Üê finset_card_neighborSet_eq_degree, Finset.card_eq_one, Finset.singleton_iff_unique_mem]
  -- ‚ä¢ (‚àÉ! a, a ‚àà Set.toFinset (neighborSet G' v)) ‚Üî ‚àÉ! w, Adj G' v w
  simp only [Set.mem_toFinset, mem_neighborSet]
  -- üéâ no goals
#align simple_graph.subgraph.degree_eq_one_iff_unique_adj SimpleGraph.Subgraph.degree_eq_one_iff_unique_adj

end Subgraph

section MkProperties

/-! ### Properties of `singletonSubgraph` and `subgraphOfAdj` -/


variable {G : SimpleGraph V} {G' : SimpleGraph W}

instance nonempty_singletonSubgraph_verts (v : V) : Nonempty (G.singletonSubgraph v).verts :=
  ‚ü®‚ü®v, Set.mem_singleton v‚ü©‚ü©
#align simple_graph.nonempty_singleton_subgraph_verts SimpleGraph.nonempty_singletonSubgraph_verts

@[simp]
theorem singletonSubgraph_le_iff (v : V) (H : G.Subgraph) :
    G.singletonSubgraph v ‚â§ H ‚Üî v ‚àà H.verts := by
  refine' ‚ü®fun h ‚Ü¶ h.1 (Set.mem_singleton v), _‚ü©
  -- ‚ä¢ v ‚àà H.verts ‚Üí SimpleGraph.singletonSubgraph G v ‚â§ H
  intro h
  -- ‚ä¢ SimpleGraph.singletonSubgraph G v ‚â§ H
  constructor
  -- ‚ä¢ (SimpleGraph.singletonSubgraph G v).verts ‚äÜ H.verts
  ¬∑ rwa [singletonSubgraph_verts, Set.singleton_subset_iff]
    -- üéâ no goals
  ¬∑ exact fun _ _ ‚Ü¶ False.elim
    -- üéâ no goals
#align simple_graph.singleton_subgraph_le_iff SimpleGraph.singletonSubgraph_le_iff

@[simp]
theorem map_singletonSubgraph (f : G ‚Üíg G') {v : V} :
    Subgraph.map f (G.singletonSubgraph v) = G'.singletonSubgraph (f v) := by
  ext <;> simp only [Relation.Map, Subgraph.map_Adj, singletonSubgraph_Adj, Pi.bot_apply,
  -- ‚ä¢ x‚úù ‚àà (Subgraph.map f (SimpleGraph.singletonSubgraph G v)).verts ‚Üî x‚úù ‚àà (Simp ‚Ä¶
    exists_and_left, and_iff_left_iff_imp, IsEmpty.forall_iff, Subgraph.map_verts,
    singletonSubgraph_verts, Set.image_singleton]
  exact False.elim
  -- üéâ no goals
#align simple_graph.map_singleton_subgraph SimpleGraph.map_singletonSubgraph

@[simp]
theorem neighborSet_singletonSubgraph (v w : V) : (G.singletonSubgraph v).neighborSet w = ‚àÖ :=
  rfl
#align simple_graph.neighbor_set_singleton_subgraph SimpleGraph.neighborSet_singletonSubgraph

@[simp]
theorem edgeSet_singletonSubgraph (v : V) : (G.singletonSubgraph v).edgeSet = ‚àÖ :=
  Sym2.fromRel_bot
#align simple_graph.edge_set_singleton_subgraph SimpleGraph.edgeSet_singletonSubgraph

theorem eq_singletonSubgraph_iff_verts_eq (H : G.Subgraph) {v : V} :
    H = G.singletonSubgraph v ‚Üî H.verts = {v} := by
  refine' ‚ü®fun h ‚Ü¶ by rw [h, singletonSubgraph_verts], fun h ‚Ü¶ _‚ü©
  -- ‚ä¢ H = SimpleGraph.singletonSubgraph G v
  ext
  -- ‚ä¢ x‚úù ‚àà H.verts ‚Üî x‚úù ‚àà (SimpleGraph.singletonSubgraph G v).verts
  ¬∑ rw [h, singletonSubgraph_verts]
    -- üéâ no goals
  ¬∑ simp only [Prop.bot_eq_false, singletonSubgraph_Adj, Pi.bot_apply, iff_false_iff]
    -- ‚ä¢ ¬¨Subgraph.Adj H x‚úù¬π x‚úù
    intro ha
    -- ‚ä¢ False
    have ha1 := ha.fst_mem
    -- ‚ä¢ False
    have ha2 := ha.snd_mem
    -- ‚ä¢ False
    rw [h, Set.mem_singleton_iff] at ha1 ha2
    -- ‚ä¢ False
    subst_vars
    -- ‚ä¢ False
    exact ha.ne rfl
    -- üéâ no goals
#align simple_graph.eq_singleton_subgraph_iff_verts_eq SimpleGraph.eq_singletonSubgraph_iff_verts_eq

instance nonempty_subgraphOfAdj_verts {v w : V} (hvw : G.Adj v w) :
    Nonempty (G.subgraphOfAdj hvw).verts :=
  ‚ü®‚ü®v, by simp‚ü©‚ü©
          -- üéâ no goals
#align simple_graph.nonempty_subgraph_of_adj_verts SimpleGraph.nonempty_subgraphOfAdj_verts

@[simp]
theorem edgeSet_subgraphOfAdj {v w : V} (hvw : G.Adj v w) :
    (G.subgraphOfAdj hvw).edgeSet = {‚ü¶(v, w)‚üß} := by
  ext e
  -- ‚ä¢ e ‚àà Subgraph.edgeSet (subgraphOfAdj G hvw) ‚Üî e ‚àà {Quotient.mk (Sym2.Rel.seto ‚Ä¶
  refine' e.ind _
  -- ‚ä¢ ‚àÄ (x y : V), Quotient.mk (Sym2.Rel.setoid V) (x, y) ‚àà Subgraph.edgeSet (subg ‚Ä¶
  simp only [eq_comm, Set.mem_singleton_iff, Subgraph.mem_edgeSet, subgraphOfAdj_Adj, iff_self_iff,
    forall‚ÇÇ_true_iff]
#align simple_graph.edge_set_subgraph_of_adj SimpleGraph.edgeSet_subgraphOfAdj

set_option autoImplicit true in
lemma subgraphOfAdj_le_of_adj (H : G.Subgraph) (h : H.Adj v w) :
    G.subgraphOfAdj (H.adj_sub h) ‚â§ H := by
  constructor
  -- ‚ä¢ (subgraphOfAdj G (_ : Adj G v w)).verts ‚äÜ H.verts
  ¬∑ intro x
    -- ‚ä¢ x ‚àà (subgraphOfAdj G (_ : Adj G v w)).verts ‚Üí x ‚àà H.verts
    rintro (rfl | rfl) <;> simp [H.edge_vert h, H.edge_vert h.symm]
    -- ‚ä¢ x ‚àà H.verts
                           -- üéâ no goals
                           -- üéâ no goals
  ¬∑ simp only [subgraphOfAdj_Adj, Quotient.eq, Sym2.rel_iff]
    -- ‚ä¢ ‚àÄ ‚¶Év_1 w_1 : V‚¶Ñ, v = v_1 ‚àß w = w_1 ‚à® v = w_1 ‚àß w = v_1 ‚Üí Subgraph.Adj H v_1  ‚Ä¶
    rintro _ _ (‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©) <;> simp [h, h.symm]
    -- ‚ä¢ Subgraph.Adj H v w
                                             -- üéâ no goals
                                             -- üéâ no goals

theorem subgraphOfAdj_symm {v w : V} (hvw : G.Adj v w) :
    G.subgraphOfAdj hvw.symm = G.subgraphOfAdj hvw := by
  ext <;> simp [or_comm, and_comm]
  -- ‚ä¢ x‚úù ‚àà (subgraphOfAdj G (_ : Adj G w v)).verts ‚Üî x‚úù ‚àà (subgraphOfAdj G hvw).ve ‚Ä¶
          -- üéâ no goals
          -- üéâ no goals
#align simple_graph.subgraph_of_adj_symm SimpleGraph.subgraphOfAdj_symm

@[simp]
theorem map_subgraphOfAdj (f : G ‚Üíg G') {v w : V} (hvw : G.Adj v w) :
    Subgraph.map f (G.subgraphOfAdj hvw) = G'.subgraphOfAdj (f.map_adj hvw) := by
  ext
  -- ‚ä¢ x‚úù ‚àà (Subgraph.map f (subgraphOfAdj G hvw)).verts ‚Üî x‚úù ‚àà (subgraphOfAdj G' ( ‚Ä¶
  ¬∑ simp only [Subgraph.map_verts, subgraphOfAdj_verts, Set.mem_image, Set.mem_insert_iff,
      Set.mem_singleton_iff]
    constructor
    -- ‚ä¢ (‚àÉ x, (x = v ‚à® x = w) ‚àß ‚Üëf x = x‚úù) ‚Üí x‚úù = ‚Üëf v ‚à® x‚úù = ‚Üëf w
    ¬∑ rintro ‚ü®u, rfl | rfl, rfl‚ü© <;> simp
      -- ‚ä¢ ‚Üëf u = ‚Üëf u ‚à® ‚Üëf u = ‚Üëf w
                                     -- üéâ no goals
                                     -- üéâ no goals
    ¬∑ rintro (rfl | rfl)
      -- ‚ä¢ ‚àÉ x, (x = v ‚à® x = w) ‚àß ‚Üëf x = ‚Üëf v
      ¬∑ use v
        -- ‚ä¢ (v = v ‚à® v = w) ‚àß ‚Üëf v = ‚Üëf v
        simp
        -- üéâ no goals
      ¬∑ use w
        -- ‚ä¢ (w = v ‚à® w = w) ‚àß ‚Üëf w = ‚Üëf w
        simp
        -- üéâ no goals
  ¬∑ simp only [Relation.Map, Subgraph.map_Adj, subgraphOfAdj_Adj, Quotient.eq, Sym2.rel_iff]
    -- ‚ä¢ (‚àÉ a b, (v = a ‚àß w = b ‚à® v = b ‚àß w = a) ‚àß ‚Üëf a = x‚úù¬π ‚àß ‚Üëf b = x‚úù) ‚Üî ‚Üëf v = x ‚Ä¶
    constructor
    -- ‚ä¢ (‚àÉ a b, (v = a ‚àß w = b ‚à® v = b ‚àß w = a) ‚àß ‚Üëf a = x‚úù¬π ‚àß ‚Üëf b = x‚úù) ‚Üí ‚Üëf v = x ‚Ä¶
    ¬∑ rintro ‚ü®a, b, ‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©, rfl, rfl‚ü© <;> simp
      -- ‚ä¢ ‚Üëf v = ‚Üëf v ‚àß ‚Üëf w = ‚Üëf w ‚à® ‚Üëf v = ‚Üëf w ‚àß ‚Üëf w = ‚Üëf v
                                                           -- üéâ no goals
                                                           -- üéâ no goals
    ¬∑ rintro (‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©)
      -- ‚ä¢ ‚àÉ a b, (v = a ‚àß w = b ‚à® v = b ‚àß w = a) ‚àß ‚Üëf a = ‚Üëf v ‚àß ‚Üëf b = ‚Üëf w
      ¬∑ use v, w
        -- ‚ä¢ (v = v ‚àß w = w ‚à® v = w ‚àß w = v) ‚àß ‚Üëf v = ‚Üëf v ‚àß ‚Üëf w = ‚Üëf w
        simp
        -- üéâ no goals
      ¬∑ use w, v
        -- ‚ä¢ (v = w ‚àß w = v ‚à® v = v ‚àß w = w) ‚àß ‚Üëf w = ‚Üëf w ‚àß ‚Üëf v = ‚Üëf v
        simp
        -- üéâ no goals
#align simple_graph.map_subgraph_of_adj SimpleGraph.map_subgraphOfAdj

theorem neighborSet_subgraphOfAdj_subset {u v w : V} (hvw : G.Adj v w) :
    (G.subgraphOfAdj hvw).neighborSet u ‚äÜ {v, w} :=
  (G.subgraphOfAdj hvw).neighborSet_subset_verts _
#align simple_graph.neighbor_set_subgraph_of_adj_subset SimpleGraph.neighborSet_subgraphOfAdj_subset

@[simp]
theorem neighborSet_fst_subgraphOfAdj {v w : V} (hvw : G.Adj v w) :
    (G.subgraphOfAdj hvw).neighborSet v = {w} := by
  ext u
  -- ‚ä¢ u ‚àà Subgraph.neighborSet (subgraphOfAdj G hvw) v ‚Üî u ‚àà {w}
  suffices w = u ‚Üî u = w by simpa [hvw.ne.symm] using this
  -- ‚ä¢ w = u ‚Üî u = w
  rw [eq_comm]
  -- üéâ no goals
#align simple_graph.neighbor_set_fst_subgraph_of_adj SimpleGraph.neighborSet_fst_subgraphOfAdj

@[simp]
theorem neighborSet_snd_subgraphOfAdj {v w : V} (hvw : G.Adj v w) :
    (G.subgraphOfAdj hvw).neighborSet w = {v} := by
  rw [subgraphOfAdj_symm hvw.symm]
  -- ‚ä¢ Subgraph.neighborSet (subgraphOfAdj G (_ : Adj G w v)) w = {v}
  exact neighborSet_fst_subgraphOfAdj hvw.symm
  -- üéâ no goals
#align simple_graph.neighbor_set_snd_subgraph_of_adj SimpleGraph.neighborSet_snd_subgraphOfAdj

@[simp]
theorem neighborSet_subgraphOfAdj_of_ne_of_ne {u v w : V} (hvw : G.Adj v w) (hv : u ‚â† v)
    (hw : u ‚â† w) : (G.subgraphOfAdj hvw).neighborSet u = ‚àÖ := by
  ext
  -- ‚ä¢ x‚úù ‚àà Subgraph.neighborSet (subgraphOfAdj G hvw) u ‚Üî x‚úù ‚àà ‚àÖ
  simp [hv.symm, hw.symm]
  -- üéâ no goals
#align simple_graph.neighbor_set_subgraph_of_adj_of_ne_of_ne SimpleGraph.neighborSet_subgraphOfAdj_of_ne_of_ne

theorem neighborSet_subgraphOfAdj [DecidableEq V] {u v w : V} (hvw : G.Adj v w) :
    (G.subgraphOfAdj hvw).neighborSet u = (if u = v then {w} else ‚àÖ) ‚à™ if u = w then {v} else ‚àÖ :=
  by split_ifs <;> subst_vars <;> simp [*]
                   -- ‚ä¢ Subgraph.neighborSet (subgraphOfAdj G hvw) w = {w} ‚à™ {w}
                   -- ‚ä¢ Subgraph.neighborSet (subgraphOfAdj G hvw) v = {w} ‚à™ ‚àÖ
                   -- ‚ä¢ Subgraph.neighborSet (subgraphOfAdj G hvw) w = ‚àÖ ‚à™ {v}
                   -- ‚ä¢ Subgraph.neighborSet (subgraphOfAdj G hvw) u = ‚àÖ ‚à™ ‚àÖ
                                  -- üéâ no goals
                                  -- üéâ no goals
                                  -- üéâ no goals
                                  -- üéâ no goals
#align simple_graph.neighbor_set_subgraph_of_adj SimpleGraph.neighborSet_subgraphOfAdj

theorem singletonSubgraph_fst_le_subgraphOfAdj {u v : V} {h : G.Adj u v} :
    G.singletonSubgraph u ‚â§ G.subgraphOfAdj h := by
  constructor <;> simp [-Set.bot_eq_empty]
  -- ‚ä¢ (SimpleGraph.singletonSubgraph G u).verts ‚äÜ (subgraphOfAdj G h).verts
                  -- üéâ no goals
                  -- ‚ä¢ ‚àÄ ‚¶Év_1 w : V‚¶Ñ, ‚ä• ‚Üí u = v_1 ‚àß v = w ‚à® u = w ‚àß v = v_1
  exact fun _ _ ‚Ü¶ False.elim
  -- üéâ no goals
#align simple_graph.singleton_subgraph_fst_le_subgraph_of_adj SimpleGraph.singletonSubgraph_fst_le_subgraphOfAdj

theorem singletonSubgraph_snd_le_subgraphOfAdj {u v : V} {h : G.Adj u v} :
    G.singletonSubgraph v ‚â§ G.subgraphOfAdj h := by
  constructor <;> simp [-Set.bot_eq_empty]
  -- ‚ä¢ (SimpleGraph.singletonSubgraph G v).verts ‚äÜ (subgraphOfAdj G h).verts
                  -- üéâ no goals
                  -- ‚ä¢ ‚àÄ ‚¶Év_1 w : V‚¶Ñ, ‚ä• ‚Üí u = v_1 ‚àß v = w ‚à® u = w ‚àß v = v_1
  exact fun _ _ ‚Ü¶ False.elim
  -- üéâ no goals
#align simple_graph.singleton_subgraph_snd_le_subgraph_of_adj SimpleGraph.singletonSubgraph_snd_le_subgraphOfAdj

end MkProperties

namespace Subgraph

variable {G : SimpleGraph V}

/-! ### Subgraphs of subgraphs -/


/-- Given a subgraph of a subgraph of `G`, construct a subgraph of `G`. -/
@[reducible]
protected def coeSubgraph {G' : G.Subgraph} : G'.coe.Subgraph ‚Üí G.Subgraph :=
  Subgraph.map G'.hom
#align simple_graph.subgraph.coe_subgraph SimpleGraph.Subgraph.coeSubgraph

/-- Given a subgraph of `G`, restrict it to being a subgraph of another subgraph `G'` by
taking the portion of `G` that intersects `G'`. -/
@[reducible]
protected def restrict {G' : G.Subgraph} : G.Subgraph ‚Üí G'.coe.Subgraph :=
  Subgraph.comap G'.hom
#align simple_graph.subgraph.restrict SimpleGraph.Subgraph.restrict

lemma coeSubgraph_Adj {G' : G.Subgraph} (G'' : G'.coe.Subgraph) (v w : V) :
    (G'.coeSubgraph G'').Adj v w ‚Üî
      ‚àÉ (hv : v ‚àà G'.verts) (hw : w ‚àà G'.verts), G''.Adj ‚ü®v, hv‚ü© ‚ü®w, hw‚ü© := by
  simp [Relation.Map]
  -- üéâ no goals

lemma restrict_Adj {G' G'' : G.Subgraph} (v w : G'.verts) :
    (G'.restrict G'').Adj v w ‚Üî G'.Adj v w ‚àß G''.Adj v w := Iff.rfl

theorem restrict_coeSubgraph {G' : G.Subgraph} (G'' : G'.coe.Subgraph) :
    Subgraph.restrict (Subgraph.coeSubgraph G'') = G'' := by
  ext
  -- ‚ä¢ x‚úù ‚àà (Subgraph.restrict (Subgraph.coeSubgraph G'')).verts ‚Üî x‚úù ‚àà G''.verts
  ¬∑ simp
    -- üéâ no goals
  ¬∑ rw [restrict_Adj, coeSubgraph_Adj]
    -- ‚ä¢ (Adj G' ‚Üëx‚úù¬π ‚Üëx‚úù ‚àß ‚àÉ hv hw, Adj G'' { val := ‚Üëx‚úù¬π, property := hv } { val := ‚Ä¶
    simpa using G''.adj_sub
    -- üéâ no goals
#align simple_graph.subgraph.restrict_coe_subgraph SimpleGraph.Subgraph.restrict_coeSubgraph

theorem coeSubgraph_injective (G' : G.Subgraph) :
    Function.Injective (Subgraph.coeSubgraph : G'.coe.Subgraph ‚Üí G.Subgraph) :=
  Function.LeftInverse.injective restrict_coeSubgraph
#align simple_graph.subgraph.coe_subgraph_injective SimpleGraph.Subgraph.coeSubgraph_injective

lemma coeSubgraph_le {H : G.Subgraph} (H' : H.coe.Subgraph) :
    Subgraph.coeSubgraph H' ‚â§ H := by
  constructor
  -- ‚ä¢ (Subgraph.coeSubgraph H').verts ‚äÜ H.verts
  ¬∑ simp
    -- üéâ no goals
  ¬∑ rintro v w ‚ü®_, _, h, rfl, rfl‚ü©
    -- ‚ä¢ Adj H (‚Üë(Subgraph.hom H) w‚úù¬π) (‚Üë(Subgraph.hom H) w‚úù)
    exact H'.adj_sub h
    -- üéâ no goals

lemma coeSubgraph_restrict_eq {H : G.Subgraph} (H' : G.Subgraph) :
    Subgraph.coeSubgraph (H.restrict H') = H ‚äì H' := by
  ext
  -- ‚ä¢ x‚úù ‚àà (Subgraph.coeSubgraph (Subgraph.restrict H')).verts ‚Üî x‚úù ‚àà (H ‚äì H').verts
  ¬∑ simp [and_comm]
    -- üéâ no goals
  ¬∑ simp_rw [coeSubgraph_Adj, restrict_Adj]
    -- ‚ä¢ (‚àÉ h h, Adj H x‚úù¬π x‚úù ‚àß Adj H' x‚úù¬π x‚úù) ‚Üî Adj (H ‚äì H') x‚úù¬π x‚úù
    simp only [exists_and_left, exists_prop, ge_iff_le, inf_adj, and_congr_right_iff]
    -- ‚ä¢ Adj H x‚úù¬π x‚úù ‚Üí (x‚úù ‚àà H.verts ‚àß x‚úù¬π ‚àà H.verts ‚àß Adj H' x‚úù¬π x‚úù ‚Üî Adj H' x‚úù¬π x‚úù)
    intro h
    -- ‚ä¢ x‚úù ‚àà H.verts ‚àß x‚úù¬π ‚àà H.verts ‚àß Adj H' x‚úù¬π x‚úù ‚Üî Adj H' x‚úù¬π x‚úù
    simp [H.edge_vert h, H.edge_vert h.symm]
    -- üéâ no goals

/-! ### Edge deletion -/


/-- Given a subgraph `G'` and a set of vertex pairs, remove all of the corresponding edges
from its edge set, if present.

See also: `SimpleGraph.deleteEdges`. -/
def deleteEdges (G' : G.Subgraph) (s : Set (Sym2 V)) : G.Subgraph where
  verts := G'.verts
  Adj := G'.Adj \ Sym2.ToRel s
  adj_sub h' := G'.adj_sub h'.1
  edge_vert h' := G'.edge_vert h'.1
  symm a b := by simp [G'.adj_comm, Sym2.eq_swap]
                 -- üéâ no goals
#align simple_graph.subgraph.delete_edges SimpleGraph.Subgraph.deleteEdges

section DeleteEdges

variable {G' : G.Subgraph} (s : Set (Sym2 V))

@[simp]
theorem deleteEdges_verts : (G'.deleteEdges s).verts = G'.verts :=
  rfl
#align simple_graph.subgraph.delete_edges_verts SimpleGraph.Subgraph.deleteEdges_verts

@[simp]
theorem deleteEdges_adj (v w : V) : (G'.deleteEdges s).Adj v w ‚Üî G'.Adj v w ‚àß ¬¨‚ü¶(v, w)‚üß ‚àà s :=
  Iff.rfl
#align simple_graph.subgraph.delete_edges_adj SimpleGraph.Subgraph.deleteEdges_adj

@[simp]
theorem deleteEdges_deleteEdges (s s' : Set (Sym2 V)) :
    (G'.deleteEdges s).deleteEdges s' = G'.deleteEdges (s ‚à™ s') := by
  ext <;> simp [and_assoc, not_or]
  -- ‚ä¢ x‚úù ‚àà (deleteEdges (deleteEdges G' s) s').verts ‚Üî x‚úù ‚àà (deleteEdges G' (s ‚à™ s ‚Ä¶
          -- üéâ no goals
          -- üéâ no goals
#align simple_graph.subgraph.delete_edges_delete_edges SimpleGraph.Subgraph.deleteEdges_deleteEdges

@[simp]
theorem deleteEdges_empty_eq : G'.deleteEdges ‚àÖ = G' := by
  ext <;> simp
  -- ‚ä¢ x‚úù ‚àà (deleteEdges G' ‚àÖ).verts ‚Üî x‚úù ‚àà G'.verts
          -- üéâ no goals
          -- üéâ no goals
#align simple_graph.subgraph.delete_edges_empty_eq SimpleGraph.Subgraph.deleteEdges_empty_eq

@[simp]
theorem deleteEdges_spanningCoe_eq :
    G'.spanningCoe.deleteEdges s = (G'.deleteEdges s).spanningCoe := by
  ext
  -- ‚ä¢ SimpleGraph.Adj (SimpleGraph.deleteEdges (Subgraph.spanningCoe G') s) x‚úù¬π x‚úù ‚Ä¶
  simp
  -- üéâ no goals
#align simple_graph.subgraph.delete_edges_spanning_coe_eq SimpleGraph.Subgraph.deleteEdges_spanningCoe_eq

theorem deleteEdges_coe_eq (s : Set (Sym2 G'.verts)) :
    G'.coe.deleteEdges s = (G'.deleteEdges (Sym2.map (‚Üë) '' s)).coe := by
  ext ‚ü®v, hv‚ü© ‚ü®w, hw‚ü©
  -- ‚ä¢ SimpleGraph.Adj (SimpleGraph.deleteEdges (Subgraph.coe G') s) { val := v, pr ‚Ä¶
  simp only [SimpleGraph.deleteEdges_adj, coe_Adj, deleteEdges_adj, Set.mem_image, not_exists,
    not_and, and_congr_right_iff]
  intro
  -- ‚ä¢ ¬¨Quotient.mk (Sym2.Rel.setoid ‚ÜëG'.verts) ({ val := v, property := hv }, { va ‚Ä¶
  constructor
  -- ‚ä¢ ¬¨Quotient.mk (Sym2.Rel.setoid ‚ÜëG'.verts) ({ val := v, property := hv }, { va ‚Ä¶
  ¬∑ intro hs
    -- ‚ä¢ ‚àÄ (x : Sym2 ‚ÜëG'.verts), x ‚àà s ‚Üí ¬¨Sym2.map Subtype.val x = Quotient.mk (Sym2. ‚Ä¶
    refine' Sym2.ind _
    -- ‚ä¢ ‚àÄ (x y : ‚ÜëG'.verts), Quotient.mk (Sym2.Rel.setoid ‚ÜëG'.verts) (x, y) ‚àà s ‚Üí ¬¨S ‚Ä¶
    rintro ‚ü®v', hv'‚ü© ‚ü®w', hw'‚ü©
    -- ‚ä¢ Quotient.mk (Sym2.Rel.setoid ‚ÜëG'.verts) ({ val := v', property := hv' }, { v ‚Ä¶
    simp only [Sym2.map_pair_eq, Quotient.eq]
    -- ‚ä¢ Quotient.mk (Sym2.Rel.setoid ‚ÜëG'.verts) ({ val := v', property := hv' }, { v ‚Ä¶
    contrapose!
    -- ‚ä¢ (v', w') ‚âà (v, w) ‚Üí ¬¨Quotient.mk (Sym2.Rel.setoid ‚ÜëG'.verts) ({ val := v', p ‚Ä¶
    rintro (_ | _) <;> simpa only [Sym2.eq_swap]
    -- ‚ä¢ ¬¨Quotient.mk (Sym2.Rel.setoid ‚ÜëG'.verts) ({ val := v, property := hv' }, { v ‚Ä¶
                       -- üéâ no goals
                       -- üéâ no goals
  ¬∑ intro h' hs
    -- ‚ä¢ False
    exact h' _ hs rfl
    -- üéâ no goals
#align simple_graph.subgraph.delete_edges_coe_eq SimpleGraph.Subgraph.deleteEdges_coe_eq

theorem coe_deleteEdges_eq (s : Set (Sym2 V)) :
    (G'.deleteEdges s).coe = G'.coe.deleteEdges (Sym2.map (‚Üë) ‚Åª¬π' s) := by
  ext ‚ü®v, hv‚ü© ‚ü®w, hw‚ü©
  -- ‚ä¢ SimpleGraph.Adj (Subgraph.coe (deleteEdges G' s)) { val := v, property := hv ‚Ä¶
  simp
  -- üéâ no goals
#align simple_graph.subgraph.coe_delete_edges_eq SimpleGraph.Subgraph.coe_deleteEdges_eq

theorem deleteEdges_le : G'.deleteEdges s ‚â§ G' := by
  constructor <;> simp (config := { contextual := true }) [subset_rfl]
  -- ‚ä¢ (deleteEdges G' s).verts ‚äÜ G'.verts
                  -- üéâ no goals
                  -- üéâ no goals
#align simple_graph.subgraph.delete_edges_le SimpleGraph.Subgraph.deleteEdges_le

theorem deleteEdges_le_of_le {s s' : Set (Sym2 V)} (h : s ‚äÜ s') :
    G'.deleteEdges s' ‚â§ G'.deleteEdges s := by
  constructor <;> simp (config := { contextual := true }) only [deleteEdges_verts, deleteEdges_adj,
  -- ‚ä¢ (deleteEdges G' s').verts ‚äÜ (deleteEdges G' s).verts
    true_and_iff, and_imp, subset_rfl]
  exact fun _ _ _ hs' hs ‚Ü¶ hs' (h hs)
  -- üéâ no goals
#align simple_graph.subgraph.delete_edges_le_of_le SimpleGraph.Subgraph.deleteEdges_le_of_le

@[simp]
theorem deleteEdges_inter_edgeSet_left_eq :
    G'.deleteEdges (G'.edgeSet ‚à© s) = G'.deleteEdges s := by
  ext <;> simp (config := { contextual := true }) [imp_false]
  -- ‚ä¢ x‚úù ‚àà (deleteEdges G' (edgeSet G' ‚à© s)).verts ‚Üî x‚úù ‚àà (deleteEdges G' s).verts
          -- üéâ no goals
          -- üéâ no goals
#align simple_graph.subgraph.delete_edges_inter_edge_set_left_eq SimpleGraph.Subgraph.deleteEdges_inter_edgeSet_left_eq

@[simp]
theorem deleteEdges_inter_edgeSet_right_eq :
    G'.deleteEdges (s ‚à© G'.edgeSet) = G'.deleteEdges s := by
  ext <;> simp (config := { contextual := true }) [imp_false]
  -- ‚ä¢ x‚úù ‚àà (deleteEdges G' (s ‚à© edgeSet G')).verts ‚Üî x‚úù ‚àà (deleteEdges G' s).verts
          -- üéâ no goals
          -- üéâ no goals
#align simple_graph.subgraph.delete_edges_inter_edge_set_right_eq SimpleGraph.Subgraph.deleteEdges_inter_edgeSet_right_eq

theorem coe_deleteEdges_le : (G'.deleteEdges s).coe ‚â§ (G'.coe : SimpleGraph G'.verts) := by
  intro v w
  -- ‚ä¢ SimpleGraph.Adj (Subgraph.coe (deleteEdges G' s)) v w ‚Üí SimpleGraph.Adj (Sub ‚Ä¶
  simp (config := { contextual := true })
  -- üéâ no goals
#align simple_graph.subgraph.coe_delete_edges_le SimpleGraph.Subgraph.coe_deleteEdges_le

theorem spanningCoe_deleteEdges_le (G' : G.Subgraph) (s : Set (Sym2 V)) :
    (G'.deleteEdges s).spanningCoe ‚â§ G'.spanningCoe :=
  spanningCoe_le_of_le (deleteEdges_le s)
#align simple_graph.subgraph.spanning_coe_delete_edges_le SimpleGraph.Subgraph.spanningCoe_deleteEdges_le

end DeleteEdges

/-! ### Induced subgraphs -/


/- Given a subgraph, we can change its vertex set while removing any invalid edges, which
gives induced subgraphs. See also `SimpleGraph.induce` for the `SimpleGraph` version, which,
unlike for subgraphs, results in a graph with a different vertex type. -/
/-- The induced subgraph of a subgraph. The expectation is that `s ‚äÜ G'.verts` for the usual
notion of an induced subgraph, but, in general, `s` is taken to be the new vertex set and edges
are induced from the subgraph `G'`. -/
@[simps]
def induce (G' : G.Subgraph) (s : Set V) : G.Subgraph where
  verts := s
  Adj u v := u ‚àà s ‚àß v ‚àà s ‚àß G'.Adj u v
  adj_sub h := G'.adj_sub h.2.2
  edge_vert h := h.1
  symm _ _ h := ‚ü®h.2.1, h.1, G'.symm h.2.2‚ü©
#align simple_graph.subgraph.induce SimpleGraph.Subgraph.induce

theorem _root_.SimpleGraph.induce_eq_coe_induce_top (s : Set V) :
    G.induce s = ((‚ä§ : G.Subgraph).induce s).coe := by
  ext
  -- ‚ä¢ SimpleGraph.Adj (SimpleGraph.induce s G) x‚úù¬π x‚úù ‚Üî SimpleGraph.Adj (Subgraph. ‚Ä¶
  simp
  -- üéâ no goals
#align simple_graph.induce_eq_coe_induce_top SimpleGraph.induce_eq_coe_induce_top

section Induce

variable {G' G'' : G.Subgraph} {s s' : Set V}

theorem induce_mono (hg : G' ‚â§ G'') (hs : s ‚äÜ s') : G'.induce s ‚â§ G''.induce s' := by
  constructor
  -- ‚ä¢ (induce G' s).verts ‚äÜ (induce G'' s').verts
  ¬∑ simp [hs]
    -- üéâ no goals
  ¬∑ simp (config := { contextual := true }) only [induce_Adj, true_and_iff, and_imp]
    -- ‚ä¢ ‚àÄ ‚¶Év w : V‚¶Ñ, v ‚àà s ‚Üí w ‚àà s ‚Üí Adj G' v w ‚Üí v ‚àà s' ‚àß w ‚àà s' ‚àß Adj G'' v w
    intro v w hv hw ha
    -- ‚ä¢ v ‚àà s' ‚àß w ‚àà s' ‚àß Adj G'' v w
    exact ‚ü®hs hv, hs hw, hg.2 ha‚ü©
    -- üéâ no goals
#align simple_graph.subgraph.induce_mono SimpleGraph.Subgraph.induce_mono

@[mono]
theorem induce_mono_left (hg : G' ‚â§ G'') : G'.induce s ‚â§ G''.induce s :=
  induce_mono hg subset_rfl
#align simple_graph.subgraph.induce_mono_left SimpleGraph.Subgraph.induce_mono_left

@[mono]
theorem induce_mono_right (hs : s ‚äÜ s') : G'.induce s ‚â§ G'.induce s' :=
  induce_mono le_rfl hs
#align simple_graph.subgraph.induce_mono_right SimpleGraph.Subgraph.induce_mono_right

@[simp]
theorem induce_empty : G'.induce ‚àÖ = ‚ä• := by
  ext <;> simp
  -- ‚ä¢ x‚úù ‚àà (induce G' ‚àÖ).verts ‚Üî x‚úù ‚àà ‚ä•.verts
          -- üéâ no goals
          -- üéâ no goals
#align simple_graph.subgraph.induce_empty SimpleGraph.Subgraph.induce_empty

@[simp]
theorem induce_self_verts : G'.induce G'.verts = G' := by
  ext
  -- ‚ä¢ x‚úù ‚àà (induce G' G'.verts).verts ‚Üî x‚úù ‚àà G'.verts
  ¬∑ simp
    -- üéâ no goals
  ¬∑ constructor <;>
    -- ‚ä¢ Adj (induce G' G'.verts) x‚úù¬π x‚úù ‚Üí Adj G' x‚úù¬π x‚úù
      simp (config := { contextual := true }) only [induce_Adj, imp_true_iff, and_true_iff]
      -- üéâ no goals
      -- ‚ä¢ Adj G' x‚úù¬π x‚úù ‚Üí x‚úù¬π ‚àà G'.verts ‚àß x‚úù ‚àà G'.verts
    exact fun ha ‚Ü¶ ‚ü®G'.edge_vert ha, G'.edge_vert ha.symm‚ü©
    -- üéâ no goals
#align simple_graph.subgraph.induce_self_verts SimpleGraph.Subgraph.induce_self_verts

lemma le_induce_top_verts : G' ‚â§ (‚ä§ : G.Subgraph).induce G'.verts :=
  calc G' = G'.induce G'.verts               := Subgraph.induce_self_verts.symm
       _  ‚â§ (‚ä§ : G.Subgraph).induce G'.verts := Subgraph.induce_mono_left le_top

lemma le_induce_union : G'.induce s ‚äî G'.induce s' ‚â§ G'.induce (s ‚à™ s') := by
  constructor
  -- ‚ä¢ (induce G' s ‚äî induce G' s').verts ‚äÜ (induce G' (s ‚à™ s')).verts
  ¬∑ simp only [verts_sup, induce_verts, Set.Subset.rfl]
    -- üéâ no goals
  ¬∑ simp only [sup_adj, induce_Adj, Set.mem_union]
    -- ‚ä¢ ‚àÄ ‚¶Év w : V‚¶Ñ, v ‚àà s ‚àß w ‚àà s ‚àß Adj G' v w ‚à® v ‚àà s' ‚àß w ‚àà s' ‚àß Adj G' v w ‚Üí (v  ‚Ä¶
    rintro v w (h | h) <;> simp [h]
    -- ‚ä¢ (v ‚àà s ‚à® v ‚àà s') ‚àß (w ‚àà s ‚à® w ‚àà s') ‚àß Adj G' v w
                           -- üéâ no goals
                           -- üéâ no goals

lemma le_induce_union_left : G'.induce s ‚â§ G'.induce (s ‚à™ s') := by
  exact (sup_le_iff.mp le_induce_union).1
  -- üéâ no goals

lemma le_induce_union_right : G'.induce s' ‚â§ G'.induce (s ‚à™ s') := by
  exact (sup_le_iff.mp le_induce_union).2
  -- üéâ no goals

theorem singletonSubgraph_eq_induce {v : V} : G.singletonSubgraph v = (‚ä§ : G.Subgraph).induce {v} :=
  by ext <;> simp (config := { contextual := true }) [-Set.bot_eq_empty, Prop.bot_eq_false]
     -- ‚ä¢ x‚úù ‚àà (SimpleGraph.singletonSubgraph G v).verts ‚Üî x‚úù ‚àà (induce ‚ä§ {v}).verts
             -- üéâ no goals
             -- üéâ no goals
#align simple_graph.subgraph.singleton_subgraph_eq_induce SimpleGraph.Subgraph.singletonSubgraph_eq_induce

theorem subgraphOfAdj_eq_induce {v w : V} (hvw : G.Adj v w) :
    G.subgraphOfAdj hvw = (‚ä§ : G.Subgraph).induce {v, w} := by
  ext
  -- ‚ä¢ x‚úù ‚àà (subgraphOfAdj G hvw).verts ‚Üî x‚úù ‚àà (induce ‚ä§ {v, w}).verts
  ¬∑ simp
    -- üéâ no goals
  ¬∑ constructor
    -- ‚ä¢ Adj (subgraphOfAdj G hvw) x‚úù¬π x‚úù ‚Üí Adj (induce ‚ä§ {v, w}) x‚úù¬π x‚úù
    ¬∑ intro h
      -- ‚ä¢ Adj (induce ‚ä§ {v, w}) x‚úù¬π x‚úù
      simp only [subgraphOfAdj_Adj, Quotient.eq, Sym2.rel_iff] at h
      -- ‚ä¢ Adj (induce ‚ä§ {v, w}) x‚úù¬π x‚úù
      obtain ‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü© := h <;> simp [hvw, hvw.symm]
      -- ‚ä¢ Adj (induce ‚ä§ {v, w}) v w
                                              -- üéâ no goals
                                              -- üéâ no goals
    ¬∑ intro h
      -- ‚ä¢ Adj (subgraphOfAdj G hvw) x‚úù¬π x‚úù
      simp only [induce_Adj, Set.mem_insert_iff, Set.mem_singleton_iff, top_adj] at h
      -- ‚ä¢ Adj (subgraphOfAdj G hvw) x‚úù¬π x‚úù
      obtain ‚ü®rfl | rfl, rfl | rfl, ha‚ü© := h <;> first |exact (ha.ne rfl).elim|simp
                                                 -- üéâ no goals
                                                 -- üéâ no goals
                                                 -- üéâ no goals
                                                 -- üéâ no goals
#align simple_graph.subgraph.subgraph_of_adj_eq_induce SimpleGraph.Subgraph.subgraphOfAdj_eq_induce

end Induce

/-- Given a subgraph and a set of vertices, delete all the vertices from the subgraph,
if present. Any edges incident to the deleted vertices are deleted as well. -/
@[reducible]
def deleteVerts (G' : G.Subgraph) (s : Set V) : G.Subgraph :=
  G'.induce (G'.verts \ s)
#align simple_graph.subgraph.delete_verts SimpleGraph.Subgraph.deleteVerts

section DeleteVerts

variable {G' : G.Subgraph} {s : Set V}

theorem deleteVerts_verts : (G'.deleteVerts s).verts = G'.verts \ s :=
  rfl
#align simple_graph.subgraph.delete_verts_verts SimpleGraph.Subgraph.deleteVerts_verts

theorem deleteVerts_adj {u v : V} :
    (G'.deleteVerts s).Adj u v ‚Üî u ‚àà G'.verts ‚àß ¬¨u ‚àà s ‚àß v ‚àà G'.verts ‚àß ¬¨v ‚àà s ‚àß G'.Adj u v := by
  simp [and_assoc]
  -- üéâ no goals
#align simple_graph.subgraph.delete_verts_adj SimpleGraph.Subgraph.deleteVerts_adj

@[simp]
theorem deleteVerts_deleteVerts (s s' : Set V) :
    (G'.deleteVerts s).deleteVerts s' = G'.deleteVerts (s ‚à™ s') := by
  ext <;> simp (config := { contextual := true }) [not_or, and_assoc]
  -- ‚ä¢ x‚úù ‚àà (deleteVerts (deleteVerts G' s) s').verts ‚Üî x‚úù ‚àà (deleteVerts G' (s ‚à™ s ‚Ä¶
          -- üéâ no goals
          -- üéâ no goals
#align simple_graph.subgraph.delete_verts_delete_verts SimpleGraph.Subgraph.deleteVerts_deleteVerts

@[simp]
theorem deleteVerts_empty : G'.deleteVerts ‚àÖ = G' := by
  simp [deleteVerts]
  -- üéâ no goals
#align simple_graph.subgraph.delete_verts_empty SimpleGraph.Subgraph.deleteVerts_empty

theorem deleteVerts_le : G'.deleteVerts s ‚â§ G' := by
  constructor <;> simp [Set.diff_subset]
  -- ‚ä¢ (deleteVerts G' s).verts ‚äÜ G'.verts
                  -- üéâ no goals
                  -- üéâ no goals
#align simple_graph.subgraph.delete_verts_le SimpleGraph.Subgraph.deleteVerts_le

@[mono]
theorem deleteVerts_mono {G' G'' : G.Subgraph} (h : G' ‚â§ G'') :
    G'.deleteVerts s ‚â§ G''.deleteVerts s :=
  induce_mono h (Set.diff_subset_diff_left h.1)
#align simple_graph.subgraph.delete_verts_mono SimpleGraph.Subgraph.deleteVerts_mono

@[mono]
theorem deleteVerts_anti {s s' : Set V} (h : s ‚äÜ s') : G'.deleteVerts s' ‚â§ G'.deleteVerts s :=
  induce_mono (le_refl _) (Set.diff_subset_diff_right h)
#align simple_graph.subgraph.delete_verts_anti SimpleGraph.Subgraph.deleteVerts_anti

@[simp]
theorem deleteVerts_inter_verts_left_eq : G'.deleteVerts (G'.verts ‚à© s) = G'.deleteVerts s := by
  ext <;> simp (config := { contextual := true }) [imp_false]
  -- ‚ä¢ x‚úù ‚àà (deleteVerts G' (G'.verts ‚à© s)).verts ‚Üî x‚úù ‚àà (deleteVerts G' s).verts
          -- üéâ no goals
          -- üéâ no goals
#align simple_graph.subgraph.delete_verts_inter_verts_left_eq SimpleGraph.Subgraph.deleteVerts_inter_verts_left_eq

@[simp]
theorem deleteVerts_inter_verts_set_right_eq : G'.deleteVerts (s ‚à© G'.verts) = G'.deleteVerts s :=
  by ext <;> simp (config := { contextual := true }) [imp_false]
     -- ‚ä¢ x‚úù ‚àà (deleteVerts G' (s ‚à© G'.verts)).verts ‚Üî x‚úù ‚àà (deleteVerts G' s).verts
             -- üéâ no goals
             -- üéâ no goals
#align simple_graph.subgraph.delete_verts_inter_verts_set_right_eq SimpleGraph.Subgraph.deleteVerts_inter_verts_set_right_eq

end DeleteVerts

end Subgraph

end SimpleGraph
