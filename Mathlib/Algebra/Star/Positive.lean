/-
Copyright (c) 2023 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathlib.Algebra.Order.Nonneg.Ring
import Mathlib.Algebra.Star.Order
import Mathlib.Algebra.Star.SelfAdjoint
import Mathlib.GroupTheory.Submonoid.Operations

/-!
# Positive elements in a star ordered ring

This file defines the `AddSubmonoid` of positive elements `StarOrderedRing.positive R` in a
star ordered ring `R` as generated by the elements of the form `star s * s`. It's carrier is
propositionally equal to `{ x : R | 0 ≤ x }`. Even though this technically corresponds to the
nonnegative elements, the "positive" terminology is standard throughout the literature (at least
in C⋆-algebra theory and operator theory), so we choose to prefer that.

The advantage of using this over other definitions of positivity is that it allows us to unify
several different concepts under a single umbrella. For example, one might be tempted to consider
the collection of bounded linear operators on an Hilbert space and define positivity as
`∀ x, 0 ≤ ⟪T x, x⟫`, but this doesn't generalize nicely to C⋆-algebras. Alternatively, one could
define positivity as those self-adjoint elements with nonnegative spectrum, but this requires the
algebra to be unital. Our definition herein conveniently sidesteps these issues.

We place everything in the `StarOrderedRing` namespace in order to avoid collisions or confusion
with other parts of the library.

## Main definitions

* `StarOrderedRing.positive R`: The additive submonoid of a star ordered ring `R` generated by
  elements of the form `star s * s` for `s : R`.
* `StarOrderedRing.positive.selfAdjoint : positive R →+ selfAdjoint R`: the identity map as an
  `AddMonoidHom`.
* `StarOrderedRing.positive.instAddMonoidWithOne`: Makes `positive R` into an `AddMonoidWithOne`
* `StarOrderedRing.positive.instCanonicallyOrderedAddMonoid`: Makes `positive R` into a
  `CanonicallyOrderedAddMonoid` which avoids duplication of some lemmas (e.g., `zero_le`)

-/

universe u

variable {R : Type u}

namespace StarOrderedRing

/-- The type of positive elements in a `StarOrderedRing`. We opt for the terminology `Positive`
as opposed to `Nonnegative` for consistency with the literature.

Note that the type class assumptions for `Positive` are actually significantly weaker (just
`OrderedAddCommMonoid`) so that it can be used in as many contexts as possible, but the primary
intended use case is when `R` is a `StarOrderedRing`.

In addition, note that we make a new type instead of simply using the subtype itself so that we can
add instances which would otherwise conflict if `R` had enough structure. -/
def positive (R : Type u) [OrderedAddCommMonoid R] : AddSubmonoid R where
  carrier := {x : R | 0 ≤ x}
  add_mem' := add_nonneg
  zero_mem' := le_rfl

theorem positive_def [OrderedAddCommMonoid R] {x : R} :
    x ∈ positive R ↔ 0 ≤ x :=
  Iff.rfl

section NonUnitalSemiring

variable [NonUnitalSemiring R] [PartialOrder R] [StarOrderedRing R]

theorem positive_iff {x : R} :
    x ∈ positive R ↔ x ∈ AddSubmonoid.closure (Set.range fun s : R => star s * s) := by
  rw [positive_def, nonneg_iff]

theorem positive_coe_set : (positive R : Set R) = {x | 0 ≤ x} := rfl

theorem isSelfAdjoint_of_nonneg [NonUnitalSemiring R] [PartialOrder R] [StarOrderedRing R]
    {x : R} (hx : 0 ≤ x) : IsSelfAdjoint x := by
  rw [nonneg_iff] at hx
  refine AddSubmonoid.closure_induction hx ?_ (isSelfAdjoint_zero R) fun _ _ => IsSelfAdjoint.add
  rintro - ⟨s, rfl⟩
  exact IsSelfAdjoint.star_mul_self s

theorem le_iff_exists_positive {x y : R} : x ≤ y ↔ ∃ p : positive R, y = x + p := by
  rw [le_iff']
  constructor
  · rintro ⟨p, hp, rfl⟩
    exact ⟨⟨p, hp⟩, rfl⟩
  · rintro ⟨p, rfl⟩
    exact ⟨p, p.prop, rfl⟩

theorem positive.coe_le_coe {x y : positive R} : (x : R) ≤ y ↔ x ≤ y :=
  Iff.rfl

instance positive.instCanonicallyOrderedAddMonoid : CanonicallyOrderedAddMonoid (positive R) :=
  { inferInstanceAs (OrderedAddCommMonoid (positive R)) with
    bot := 0
    bot_le := Subtype.prop
    exists_add_of_le := @fun x y (h : (x : R) ≤ y) => by
      convert le_iff_exists_positive.mp h using 1
      funext p
      exact_mod_cast rfl
    le_self_add := fun x y => show (x : R) ≤ x + y from le_iff_exists_positive.mpr ⟨y, rfl⟩ }

theorem positive.isSelfAdjoint (x : positive R) : IsSelfAdjoint (x : R) :=
  isSelfAdjoint_of_nonneg x.prop

end NonUnitalSemiring

namespace positive

section NonUnitalRing

variable [NonUnitalRing R] [PartialOrder R] [StarOrderedRing R]

-- annoyingly, this requires an `AddCommGroup` because `selfAdjoint` does
protected def selfAdjoint : positive R →+ selfAdjoint R where
  toFun x := ⟨x, positive.isSelfAdjoint x⟩
  map_zero' := rfl
  map_add' _ _ := rfl

@[simp]
theorem coe_selfAdjoint (x : positive R) : (positive.selfAdjoint x : R) = x :=
  rfl

lemma selfAdjoint_le (x y : positive R) :
    positive.selfAdjoint x ≤ positive.selfAdjoint y ↔ x ≤ y :=
  Iff.rfl

end NonUnitalRing

section Semiring

variable [Semiring R] [PartialOrder R] [StarOrderedRing R]

variable (R)

protected theorem one_mem : (1 : R) ∈ positive R := by
  simpa only [positive_def, star_one, mul_one] using star_mul_self_nonneg (1 : R)

theorem natCast_mem (n : ℕ) : (n : R) ∈ positive R :=
  @Nat.recOn (fun n => (n : R) ∈ positive R) n
    (by simpa only [Nat.zero_eq, Nat.cast_zero] using zero_mem (positive R))
    fun _ h => by
      simpa only [Nat.cast_succ] using add_mem h (positive.one_mem R)

instance instOne : One (positive R) :=
  ⟨⟨1, positive.one_mem R⟩⟩

@[simp, norm_cast]
lemma val_one : (1 : positive R) = (1 : R) :=
  rfl

variable {R}

instance [Nontrivial R] : NeZero (1 : positive R) where
  out := by rw [Ne.def, Subtype.ext_iff]; exact one_ne_zero' R

instance [Nontrivial R] : Nontrivial (positive R) where
  exists_pair_ne := ⟨1, 0, NeZero.ne 1⟩

instance instNatCast : NatCast (positive R) where
  natCast := let rec aux
      | 0 => 0
      | 1 => 1
      | n => ⟨n, natCast_mem R n⟩
    aux

@[simp, norm_cast]
theorem coe_natCast : ∀ n : ℕ, ((n : positive R) : R) = n
  | 0 => show (0 : R) = _ from Nat.cast_zero.symm
  | 1 => show (1 : R) = _ from Nat.cast_one.symm
  | _ + 2 => rfl

instance instAddCommMonoidWithOne : AddCommMonoidWithOne (positive R) :=
  { inferInstanceAs (AddCommMonoid (positive R)) with
    toNatCast := instNatCast
    one := 1
    natCast_zero := rfl
    natCast_succ := fun n ↦ by ext; simp }

end Semiring

section Ring

variable [Ring R] [PartialOrder R] [StarOrderedRing R]

@[simp]
theorem selfAdjoint_natCast (n : ℕ) :
    positive.selfAdjoint (n : positive R) = (n : selfAdjoint R) := by
  ext
  simp only [coe_selfAdjoint, coe_natCast]
  rfl

end Ring

end positive

end StarOrderedRing
