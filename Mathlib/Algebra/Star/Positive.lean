/-
Copyright (c) 2023 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathlib.Algebra.Order.Nonneg.Ring
import Mathlib.Algebra.Star.Order
import Mathlib.Algebra.Star.SelfAdjoint
import Mathlib.GroupTheory.Submonoid.Operations

/-!
# Positive elements in a star ordered ring

This file defines the `AddSubmonoid` of nonegative elements `StarOrderedRing.positive R` in a
star ordered ring `R` with carrier `{ x : R | 0 ≤ x }` (in fact, the definition only requires
`OrderedAddCommMonoid R` to allow for other use caess, but it is primarily intended for
`StarOrderedRing R`). Equivalently, this is the `AddSubmonoid` generated by the elements of the
form `star s * s`. Even though this technically corresponds to the nonnegative elements, the
"positive" terminology is standard throughout the literature (at least in C⋆-algebra theory and
operator theory), so we choose to prefer that.

The advantage of using this over other definitions of positivity is that it allows us to unify
several different concepts under a single umbrella. For example, one might be tempted to consider
the collection of bounded linear operators on an Hilbert space and define positivity as
`∀ x, 0 ≤ ⟪T x, x⟫`, but this doesn't generalize nicely to C⋆-algebras. Alternatively, one could
define positivity as those self-adjoint elements with nonnegative spectrum, but this requires the
algebra to be unital. Our definition herein conveniently sidesteps these issues.

We place everything in the `StarOrderedRing` namespace in order to avoid collisions or confusion
with other parts of the library.

## Main definitions

* `StarOrderedRing.positive R`: The additive submonoid of a star ordered ring `R` generated by
  elements of the form `star s * s` for `s : R`.
* `StarOrderedRing.positive.selfAdjoint : positive R →+ selfAdjoint R`: the identity map as an
  `AddMonoidHom`.
* `StarOrderedRing.positive.instAddMonoidWithOne`: Makes `positive R` into an `AddMonoidWithOne`
* `StarOrderedRing.positive.instCanonicallyOrderedAddMonoid`: Makes `positive R` into a
  `CanonicallyOrderedAddMonoid` which avoids duplication of some lemmas (e.g., `zero_le`)

-/

universe u

variable {R : Type u}

namespace StarOrderedRing

/-- The positive elements of a star ordered ring, as an additive submonoid.

Note that the type class assumptions for `StarOrderedRing.positive` are actually significantly
weaker (just `OrderedAddCommMonoid`) so that it can be used in as many contexts as possible, but
the primary intended use case is when `R` is a `StarOrderedRing`.  -/
def positive (R : Type u) [OrderedAddCommMonoid R] : AddSubmonoid R where
  carrier := {x : R | 0 ≤ x}
  add_mem' := add_nonneg
  zero_mem' := le_rfl

theorem positive_def [OrderedAddCommMonoid R] {x : R} :
    x ∈ positive R ↔ 0 ≤ x :=
  Iff.rfl

section NonUnitalSemiring

variable [NonUnitalSemiring R] [PartialOrder R] [StarOrderedRing R]

theorem positive_iff {x : R} :
    x ∈ positive R ↔ x ∈ AddSubmonoid.closure (Set.range fun s : R => star s * s) := by
  rw [positive_def, nonneg_iff]

theorem positive_coe_set : (positive R : Set R) = {x | 0 ≤ x} := rfl

theorem isSelfAdjoint_of_nonneg [NonUnitalSemiring R] [PartialOrder R] [StarOrderedRing R]
    {x : R} (hx : 0 ≤ x) : IsSelfAdjoint x := by
  rw [nonneg_iff] at hx
  refine AddSubmonoid.closure_induction hx ?_ (isSelfAdjoint_zero R) fun _ _ => IsSelfAdjoint.add
  rintro - ⟨s, rfl⟩
  exact IsSelfAdjoint.star_mul_self s

theorem le_iff_exists_positive {x y : R} : x ≤ y ↔ ∃ p : positive R, y = x + p := by
  rw [le_iff']
  constructor
  · rintro ⟨p, hp, rfl⟩
    exact ⟨⟨p, hp⟩, rfl⟩
  · rintro ⟨p, rfl⟩
    exact ⟨p, p.prop, rfl⟩

theorem positive.val_le_val {x y : positive R} : (x : R) ≤ y ↔ x ≤ y :=
  Iff.rfl

instance positive.instCanonicallyOrderedAddMonoid : CanonicallyOrderedAddMonoid (positive R) :=
  { inferInstanceAs (OrderedAddCommMonoid (positive R)) with
    bot := 0
    bot_le := Subtype.prop
    exists_add_of_le := @fun x y (h : (x : R) ≤ y) => by
      convert le_iff_exists_positive.mp h using 1
      funext p
      exact_mod_cast rfl
    le_self_add := fun x y => show (x : R) ≤ x + y from le_iff_exists_positive.mpr ⟨y, rfl⟩ }

theorem positive.isSelfAdjoint (x : positive R) : IsSelfAdjoint (x : R) :=
  isSelfAdjoint_of_nonneg x.prop

end NonUnitalSemiring

namespace positive

section NonUnitalRing

variable [NonUnitalRing R] [PartialOrder R] [StarOrderedRing R]

/-- The identity map from `positive R` to `selfAdjoint R`, as an `AddMonoidHom`. -/
protected def selfAdjoint : positive R →+ selfAdjoint R where
  toFun := Subtype.map id (fun _ => isSelfAdjoint_of_nonneg)
  map_zero' := rfl
  map_add' _ _ := rfl

@[simp]
theorem val_selfAdjoint (x : positive R) : (positive.selfAdjoint x : R) = x :=
  rfl

lemma selfAdjoint_le (x y : positive R) :
    positive.selfAdjoint x ≤ positive.selfAdjoint y ↔ x ≤ y :=
  Iff.rfl

end NonUnitalRing

section Semiring

variable [Semiring R] [PartialOrder R] [StarOrderedRing R]

variable (R)

instance instOne : One (positive R) := ⟨⟨1, zero_le_one⟩⟩

@[simp, norm_cast]
lemma val_one : (1 : positive R) = (1 : R) :=
  rfl

variable {R}

instance instNeZeroOne [Nontrivial R] : NeZero (1 : positive R) where
  out := by rw [Ne.def, Subtype.ext_iff]; exact one_ne_zero

instance instNontrivial [Nontrivial R] : Nontrivial (positive R) where
  exists_pair_ne := ⟨1, 0, NeZero.ne 1⟩

instance instNatCast : NatCast (positive R) where
  natCast := let rec aux
      | 0 => 0
      | 1 => 1
      | n => ⟨n, n.cast_nonneg'⟩
    aux

@[simp, norm_cast]
theorem val_natCast : ∀ n : ℕ, ((n : positive R) : R) = n
  | 0 => show (0 : R) = _ from Nat.cast_zero.symm
  | 1 => show (1 : R) = _ from Nat.cast_one.symm
  | _ + 2 => rfl

instance instAddCommMonoidWithOne : AddCommMonoidWithOne (positive R) :=
  { inferInstanceAs (AddCommMonoid (positive R)) with
    natCast_succ := fun n ↦ by ext; simp }

end Semiring

section Ring

variable [Ring R] [PartialOrder R] [StarOrderedRing R]

@[simp]
theorem selfAdjoint_natCast (n : ℕ) :
    positive.selfAdjoint (n : positive R) = (n : selfAdjoint R) := by
  ext
  simp only [val_selfAdjoint, val_natCast]
  rfl

end Ring

end positive

end StarOrderedRing
