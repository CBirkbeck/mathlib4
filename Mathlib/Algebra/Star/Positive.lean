/-
Copyright (c) 2023 Jireh Loreaux. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jireh Loreaux
-/
import Mathlib.Algebra.Star.Order
import Mathlib.Algebra.Star.SelfAdjoint
import Mathlib.GroupTheory.Submonoid.Operations

/-!
# Positive elements in a star ordered ring

This file defines the `AddSubmonoid` of positive elements `StarOrderedRing.positive R` in a
star ordered ring `R` as generated by the elements of the form `star s * s`. It's carrier is
propositionally equal to `{ x : R | 0 ≤ x }`. Even though this technically corresponds to the
nonnegative elements, the "positive" terminology is standard throughout the literature (at least
in C⋆-algebra theory and operator theory), so we choose to prefer that.

The advantage of using this over other definitions of positivity is that it allows us to unify
several different concepts under a single umbrella. For example, one might be tempted to consider
the collection of bounded linear operators on an Hilbert space and define positivity as
`∀ x, 0 ≤ ⟪T x, x⟫`, but this doesn't generalize nicely to C⋆-algebras. Alternatively, one could
define positivity as those self-adjoint elements with nonnegative spectrum, but this requires the
algebra to be unital. Our definition herein conveniently sidesteps these issues.

We place everything in the `StarOrderedRing` namespace in order to avoid collisions or confusion
with other parts of the library.

## Main definitions

* `StarOrderedRing.positive R`: The additive submonoid of a star ordered ring `R` generated by
  elements of the form `star s * s` for `s : R`.
* `StarOrderedRing.positive.selfAdjoint : positive R →+ selfAdjoint R`: the identity map as an
  `AddMonoidHom`.
* `StarOrderedRing.positive.instAddMonoidWithOne`: Makes `positive R` into an `AddMonoidWithOne`
* `StarOrderedRing.positive.instCanonicallyOrderedAddMonoid`: Makes `positive R` into a
  `CanonicallyOrderedAddMonoid` which avoids duplication of some lemmas (e.g., `zero_le`)

-/

universe u

variable {R : Type u}

namespace StarOrderedRing

def positive (R : Type u) [NonUnitalSemiring R] [PartialOrder R] [StarOrderedRing R] :
    AddSubmonoid R :=
  AddSubmonoid.closure (Set.range fun s : R => star s * s)

section NonUnitalSemiring

variable [NonUnitalSemiring R] [PartialOrder R] [StarOrderedRing R]

theorem positive_def {x : R} :
    x ∈ positive R ↔ x ∈ AddSubmonoid.closure (Set.range fun s : R => star s * s) :=
  Iff.rfl

theorem positive_iff {x : R} : x ∈ positive R ↔ 0 ≤ x := by rw [positive_def, nonneg_iff]

theorem positive_coe_set : (positive R : Set R) = {x | 0 ≤ x} :=
  Set.ext fun _x => positive_iff

theorem le_iff_exists_positive {x y : R} : x ≤ y ↔ ∃ p : positive R, x + p = y := by
  rw [le_iff]
  constructor
  · rintro ⟨p, hp, rfl⟩
    exact ⟨⟨p, hp⟩, rfl⟩
  · rintro ⟨p, rfl⟩
    exact ⟨p, p.prop, rfl⟩

theorem positive.coe_le_coe {x y : positive R} : (x : R) ≤ y ↔ x ≤ y :=
  Iff.rfl

instance positive.instCanonicallyOrderedAddMonoid : CanonicallyOrderedAddMonoid (positive R) :=
  { inferInstanceAs (OrderedAddCommMonoid (positive R)) with
    bot := 0
    bot_le := fun x => positive_iff.mp x.prop
    exists_add_of_le := @fun x y (h : (x : R) ≤ y) => by
      convert le_iff_exists_positive.mp h using 1
      funext p
      rw [@eq_comm _ y]
      exact_mod_cast rfl
    le_self_add := fun x y => show (x : R) ≤ x + y from le_iff_exists_positive.mpr ⟨y, rfl⟩ }

theorem positive.isSelfAdjoint (x : positive R) : IsSelfAdjoint (x : R) := by
  refine' AddSubmonoid.closure_induction x.prop _ (isSelfAdjoint_zero R)
    fun _ _ => IsSelfAdjoint.add
  rintro _ ⟨s, rfl⟩
  exact IsSelfAdjoint.star_mul_self s

end NonUnitalSemiring

namespace positive

section NonUnitalRing

variable [NonUnitalRing R] [PartialOrder R] [StarOrderedRing R]

-- annoyingly, this requires an `AddCommGroup` because `selfAdjoint` does
protected def selfAdjoint : positive R →+ selfAdjoint R where
  toFun x := ⟨x, positive.isSelfAdjoint x⟩
  map_zero' := rfl
  map_add' _ _ := rfl

@[simp]
theorem coe_selfAdjoint (x : positive R) : (positive.selfAdjoint x : R) = x :=
  rfl

lemma selfAdjoint_le (x y : positive R) :
    positive.selfAdjoint x ≤ positive.selfAdjoint y ↔ x ≤ y :=
  Iff.rfl

end NonUnitalRing

section Semiring

variable [Semiring R] [PartialOrder R] [StarOrderedRing R]

variable (R)

protected theorem one_mem : (1 : R) ∈ positive R := by
  simpa only [positive_iff, star_one, mul_one] using star_mul_self_nonneg (1 : R)

theorem natCast_mem (n : ℕ) : (n : R) ∈ positive R :=
  @Nat.recOn (fun n => (n : R) ∈ positive R) n
    (by simpa only [Nat.zero_eq, Nat.cast_zero] using zero_mem (positive R))
    fun _ h => by
      simpa only [Nat.cast_succ] using add_mem h (positive.one_mem R)

instance instOne : One (positive R) :=
  ⟨⟨1, positive.one_mem R⟩⟩

@[simp, norm_cast]
lemma val_one : (1 : positive R) = (1 : R) :=
  rfl

variable {R}

instance instNatCast : NatCast (positive R) where
  natCast := let rec aux
      | 0 => 0
      | 1 => 1
      | n => ⟨n, natCast_mem R n⟩
    aux

@[simp, norm_cast]
theorem coe_natCast : ∀ n : ℕ, ((n : positive R) : R) = n
  | 0 => show (0 : R) = _ from Nat.cast_zero.symm
  | 1 => show (1 : R) = _ from Nat.cast_one.symm
  | _ + 2 => rfl

instance instAddMonoidWithOne : AddMonoidWithOne (positive R) :=
  { inferInstanceAs (AddMonoid (positive R)),
    inferInstanceAs (NatCast (positive R)) with
    one := 1
    natCast := fun n ↦ n
    natCast_zero := rfl
    natCast_succ := fun n ↦ by ext; simp }

end Semiring

section Ring

variable [Ring R] [PartialOrder R] [StarOrderedRing R]

@[simp]
theorem selfAdjoint_natCast (n : ℕ) :
    positive.selfAdjoint (n : positive R) = (n : selfAdjoint R) := by
  ext
  simp only [coe_selfAdjoint, coe_natCast]
  rfl

end Ring

end positive

end StarOrderedRing
