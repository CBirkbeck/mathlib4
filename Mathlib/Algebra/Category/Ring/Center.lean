/-
Copyright (c) 2025 Jujian Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jujian Zhang
-/
import Mathlib.CategoryTheory.Adjunction.Limits
import Mathlib.Algebra.Category.ModuleCat.Limits

/-!
# A categorical description of the center of a ring

In this file we prove that the center of a ring `R` is isomorphic to `End (ùü≠ R-Mod)` the
endomorphism ring of the identity functor on the category of `R`-modules. Consequently, the ring
structure of a commutative ring is complete determined by its module category.

## Main results

- `Subring.centerEquivEndIdFunctor`: the center of a ring `R` is isomorphic to `End (ùü≠ R-Mod)`.
- `RingEquiv.ofModuleCatEquiv`: if two commutative rings have equivalent module categories, they are
  isomorphic as rings.

-/

universe u u' v v'

variable (R : Type u) [Ring R]

open CategoryTheory

/--
For any ring `R`, the center of `R` is isomorphic to `End (ùü≠ (ModuleCat R))`, the endomorphism ring
of the identity functor on the category of `R`-modules.
-/
@[simps]
noncomputable def Subring.centerEquivEndIdFunctor [Small.{v} R] :
    Subring.center R ‚âÉ+* End (ùü≠ (ModuleCat.{v} R)) where
  toFun x :=
  { app M := ModuleCat.ofHom
      { toFun := (x.1 ‚Ä¢ ¬∑)
        map_add' := by aesop
        map_smul' r := by simp [‚Üê mul_smul, Subring.mem_center_iff.1 x.2 r] } }
  invFun f :=
  ‚ü®(equivShrink R).symm <| f.app (.of R <| Shrink.{v} R) |>.hom (1 : Shrink.{v} R), by
    rw [Subring.mem_center_iff]
    intro r
    have := congr((equivShrink R).symm ($(f.naturality
      (X := .of R <| Shrink.{v} R) (Y := .of R <| Shrink.{v} R)
      (ModuleCat.ofHom
        { toFun x := x * equivShrink R r
          map_add' := by simp [add_mul]
          map_smul' := by intros; ext; simp [mul_assoc] })).hom (1 : Shrink R)))
    simp only [Functor.id_obj, Functor.id_map, ModuleCat.hom_comp, LinearMap.coe_comp,
      LinearMap.coe_mk, AddHom.coe_mk, Function.comp_apply, one_mul, equivShrink_symm_mul,
      Equiv.symm_apply_apply] at this
    erw [‚Üê this]
    have := congr((equivShrink R).symm
      $((f.app (ModuleCat.of R <| Shrink.{v} R)).hom.map_smul r (1 : Shrink.{v} R)))
    rw [show r ‚Ä¢ (1 : Shrink.{v} R) = equivShrink R r by ext; simp] at this
    simp only [Functor.id_obj, equivShrink_symm_smul, smul_eq_mul] at this
    exact this.symm‚ü©
  left_inv _ := by simp
  right_inv f := by
    apply NatTrans.ext
    ext M (m : M)
    simp only [Functor.id_obj, LinearMap.coe_mk, AddHom.coe_mk]
    have := congr($(f.naturality (X := .of R <| Shrink.{v} R) (Y := .of R M)
      (ModuleCat.ofHom
        { toFun x := (equivShrink R).symm x ‚Ä¢ m
          map_add' := by simp [add_smul]
          map_smul' x y := by simp [mul_smul] })).hom (1 : Shrink R))
    simp only [ModuleCat.of_coe, Functor.id_obj, Functor.id_map, ModuleCat.hom_comp,
      LinearMap.coe_comp, LinearMap.coe_mk, AddHom.coe_mk, Function.comp_apply,
      equivShrink_symm_one, one_smul] at this
    exact this.symm
  map_mul' x y := by
    apply NatTrans.ext
    ext M (m : M)
    exact mul_smul x.1 y.1 m
  map_add' x y := by
    apply NatTrans.ext
    ext M (m : M)
    exact add_smul x.1 y.1 m

/--
For any two commutative rings `R` and `S`, if the categories of `R`-modules and `S`-modules are
equivalent, then `R` and `S` are isomorphic as rings.
-/
noncomputable def RingEquiv.ofModuleCatEquiv {R : Type u} {S : Type u'} [CommRing R] [CommRing S]
    [Small.{v} R] [Small.{v'} S]
    (e : ModuleCat.{v} R ‚âå ModuleCat.{v'} S) : R ‚âÉ+* S :=
  letI : e.functor.Additive := Functor.additive_of_preserves_binary_products e.functor
  let i‚ÇÅ : R ‚âÉ+* (‚ä§ : Subring R) := Subring.topEquiv.symm
  let i‚ÇÇ : (‚ä§ : Subring R) ‚âÉ+* Subring.center R := Subring.center_eq_top R ‚ñ∏ .refl _
  let i‚ÇÉ : End (ùü≠ (ModuleCat.{v} R)) ‚âÉ+* End (ùü≠ (ModuleCat.{v'} S)) :=
    Equivalence.endRingEquiv (e := e) (e' := e) (by rfl)
  let i‚ÇÑ : Subring.center S ‚âÉ+* (‚ä§ : Subring S) := Subring.center_eq_top S ‚ñ∏ .refl _
  let i‚ÇÖ : (‚ä§ : Subring S) ‚âÉ+* S := Subring.topEquiv
  i‚ÇÅ.trans <| i‚ÇÇ.trans <| (Subring.centerEquivEndIdFunctor R).trans <|
    i‚ÇÉ.trans <| (Subring.centerEquivEndIdFunctor S).symm.trans <| i‚ÇÑ.trans i‚ÇÖ
