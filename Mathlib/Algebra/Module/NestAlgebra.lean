/-
Copyright (c) 2024 Christopher Hoskin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christopher Hoskin
-/

import Mathlib.Algebra.Module.Submodule.Lattice
import Mathlib.Order.CompleteSublattice
import Mathlib.Algebra.Algebra.Subalgebra.Basic
import Mathlib.LinearAlgebra.Basis.Defs

/-!
# Nest algebras
-/

variable (R M N : Type*)

variable [CommSemiring R] [AddCommMonoid M] [Module R M]

/--
A nest is a totally ordered set which contains the top and bottom.
-/
structure Nest (α : Type*) [LE α] [OrderTop α] [OrderBot α] where
  /-- The `carrier` of a flag is the underlying set. -/
  carrier : Set α
  /-- By definition, a flag is a chain -/
  chain : IsChain (· ≤ ·) carrier
  mem_bot : ⊥ ∈ carrier
  mem_top : ⊤ ∈ carrier

variable (α : Type*)

/- A Flag is a Nest -/
instance [LE α] [OrderTop α] [OrderBot α] (s : Flag α) : Nest α where
  carrier := s.carrier
  chain := s.Chain'
  mem_bot := Flag.bot_mem _
  mem_top := Flag.top_mem _

/- A Nest is a sublattice -/
instance [Lattice α] [OrderTop α] [OrderBot α] (s : Nest α) : Sublattice α where
  carrier := s.carrier
  supClosed' := by
    intro _ ha _ hb
    cases s.chain.total ha hb with
      | inl h => rw [sup_of_le_right h]; exact hb
      | inr h => rw [sup_of_le_left h]; exact ha
  infClosed' := by
    intro _ ha _ hb
    cases s.chain.total ha hb with
      | inl h => rw [inf_of_le_left h]; exact ha
      | inr h => rw [inf_of_le_right h]; exact hb



/-
structure IsNest (N : Sublattice (Submodule R M)) where
  mem_bot: ⊥ ∈ N
  mem_top: ⊤ ∈ N
  chain: IsChain (· ≤ ·) (N : Set (Submodule R M))
-/

variable {ι : Type*} [LinearOrder ι] (bm : Basis ι R M)


def basis_nest_map : ι →o Submodule R M :=
  ⟨fun i => Submodule.span R (bm '' Set.Iio i), fun _ _ hab =>
  sInf_le_sInf (fun _ hn => subset_trans (Set.image_subset _ (Set.Iio_subset_Iio hab)) hn)⟩

/-
def basis_nest_map2 : WithTop ι → Submodule R M
  | none => ⊤
  | some i => (basis_nest_map R M bm) i

def basis_nest_map2a : WithBot (WithTop ι) → Submodule R M
  | none => ⊥
  | some i => (basis_nest_map2 R M bm) i
-/

def basis_nest_map3 : LatticeHom (WithBot (WithTop ι)) (Submodule R M) :=
  LatticeHom.withBot' (LatticeHom.withTop' (basis_nest_map R M bm))

/-
lemma test6 {α : Type*} [CompleteLattice α] (a : α) (t : Set α) :
    sSup (insert a t) = a ⊔ sSup t := by
  simp_all only [sSup_insert]
-/

/--
The nest generated by a linearly ordered basis
-/
def Basis.toNest : Nest (Submodule R M) where
  carrier := Set.range (basis_nest_map3 R M bm)
  chain := Monotone.isChain_range (OrderHomClass.mono (basis_nest_map3 R M bm))
  mem_bot := by
    use ⊥
    rfl
  mem_top := by
    use ⊤
    rfl





/-
instance : LinearOrder (bm.toNest R M) where
  le_total := by
    intro ⟨n, hn⟩ ⟨m, hm⟩
    simp[Basis.toNest] at hn
    simp[Basis.toNest] at hm
    cases' hn with hn' hn''
    · apply Or.inr
      simp_all only [Subtype.mk_le_mk, le_top]
    · cases' hm with hm' hm''
      · apply Or.inl
        aesop
      · obtain ⟨i,hi⟩ := hn''
        obtain ⟨j,hj⟩ := hm''

  decidableLE := sorry
-/


/-
structure nest extends  CompleteSublattice (Submodule R M) where
  mem_bot: ⊥ ∈ carrier
  mem_top: ⊤ ∈ carrier
  lo: LinearOrder carrier
-/

/--
The nest algebra of a nest
-/
def NestAlg (N : Sublattice (Submodule R M)) : Subalgebra R (M →ₗ[R] M) where
  carrier := { T | ∀ (n : N), T '' n ⊆ n}
  add_mem' S T := by
    intro n x hx
    obtain ⟨y, ⟨hy₁, hy₂⟩⟩ := hx
    rw [← hy₂, LinearMap.add_apply]
    exact AddMemClass.add_mem (S _ (Set.mem_image_of_mem _ hy₁))  (T _ (Set.mem_image_of_mem _ hy₁))
  mul_mem' S T := by
    intro n h hx
    obtain ⟨y, hy₁, hy₂⟩ := hx
    rw [← hy₂, LinearMap.mul_apply]
    exact S _ (Set.mem_image_of_mem _ (T _ (Set.mem_image_of_mem _ hy₁)))
  one_mem' := by
    intro n
    simp only [LinearMap.one_apply, Set.image_id', subset_refl]
  zero_mem' := by
    intro n
    simp only [LinearMap.zero_apply, Set.image_subset_iff, SetLike.mem_coe, Submodule.zero_mem,
      Set.preimage_const_of_mem, Set.subset_univ]
  algebraMap_mem' := by
    intro r n x hx
    obtain ⟨y, hy₁, hy₂⟩ := hx
    rw [← hy₂, Module.algebraMap_end_apply]
    exact SMulMemClass.smul_mem _ hy₁
