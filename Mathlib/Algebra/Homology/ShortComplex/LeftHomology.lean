import Mathlib.Algebra.Homology.ShortComplex.Basic

open ZeroObject

namespace CategoryTheory

open Category

namespace Limits

variable {C : Type _} [Category C] [HasZeroMorphisms C]

def KernelFork.IsLimit.of_id {X Y : C} (f : X โถ Y) (hf : f = 0) :
    IsLimit (KernelFork.ofฮน (๐ X) (show ๐ X โซ f = 0 by rw [hf, comp_zero])) :=
  KernelFork.IsLimit.ofฮน _ _ (fun x _ => x) (fun _ _ => comp_id _)
    (fun _ _ _ hb => by simp only [โ hb, comp_id])

def KernelFork.IsLimit.of_isZero_of_mono {X Y : C} {f : X โถ Y} (c : KernelFork f)
    (hf : Mono f) (h : IsZero c.pt) : IsLimit c :=
  isLimitAux _ (fun s => 0) (fun s => by rw [zero_comp, โ cancel_mono f, zero_comp, s.condition])
    (fun _ _ _ => h.eq_of_tgt _ _)

lemma KernelFork.IsLimit.isIso_ฮน_of_zero {X Y : C} {f : X โถ Y} (c : KernelFork f)
    (hc : IsLimit c) (hf : f = 0) : IsIso c.ฮน := by
  let e : c.pt โ X := IsLimit.conePointUniqueUpToIso hc
    (KernelFork.IsLimit.of_id (f : X โถ Y) hf)
  have eq : e.inv โซ c.ฮน = ๐ X := Fork.IsLimit.lift_ฮน hc
  haveI : IsIso (e.inv โซ c.ฮน) := by
    rw [eq]
    infer_instance
  exact IsIso.of_isIso_comp_left e.inv c.ฮน

def CokernelCofork.IsColimit.of_id {X Y : C} (f : X โถ Y) (hf : f = 0) :
    IsColimit (CokernelCofork.ofฯ (๐ Y) (show f โซ ๐ Y = 0 by rw [hf, zero_comp])) :=
  CokernelCofork.IsColimit.ofฯ  _ _ (fun x _ => x) (fun _ _ => id_comp _)
    (fun _ _ _ hb => by simp only [โ hb, id_comp])

def CokernelCofork.IsColimit.of_isZero_of_epi {X Y : C} {f : X โถ Y} (c : CokernelCofork f)
    (hf : Epi f) (h : IsZero c.pt) : IsColimit c :=
  isColimitAux _ (fun s => 0) (fun s => by rw [comp_zero, โ cancel_epi f, comp_zero, s.condition])
    (fun _ _ _ => h.eq_of_src _ _)

lemma CokernelCofork.IsColimit.isIso_ฯ_of_zero {X Y : C} {f : X โถ Y} (c : CokernelCofork f)
    (hc : IsColimit c) (hf : f = 0) : IsIso c.ฯ := by
  let e : c.pt โ Y := IsColimit.coconePointUniqueUpToIso hc
    (CokernelCofork.IsColimit.of_id (f : X โถ Y) hf)
  have eq : c.ฯ โซ e.hom = ๐ Y := Cofork.IsColimit.ฯ_desc hc
  haveI : IsIso (c.ฯ โซ e.hom) := by
    rw [eq]
    dsimp
    infer_instance
  exact IsIso.of_isIso_comp_right c.ฯ e.hom

def CokernelCofork.IsColimit.ofฯ_op {X Y Q : C} (p : Y โถ Q) {f : X โถ Y}
    (w : f โซ p = 0) (h : IsColimit (CokernelCofork.ofฯ p w)) :
    IsLimit (KernelFork.ofฮน p.op (show p.op โซ f.op = 0 by rw [โ op_comp, w, op_zero])) :=
  KernelFork.IsLimit.ofฮน _ _
    (fun x hx => (h.desc (CokernelCofork.ofฯ x.unop (Quiver.Hom.op_inj hx))).op)
    (fun x hx => Quiver.Hom.unop_inj (Cofork.IsColimit.ฯ_desc h))
    (fun x hx b hb => Quiver.Hom.unop_inj (Cofork.IsColimit.hom_ext h
      (by simpa only [Quiver.Hom.unop_op, Cofork.IsColimit.ฯ_desc] using Quiver.Hom.op_inj hb)))

def CokernelCofork.IsColimit.ofฯ_unop {X Y Q : Cแตแต} (p : Y โถ Q) {f : X โถ Y}
    (w : f โซ p = 0) (h : IsColimit (CokernelCofork.ofฯ p w)) :
    IsLimit (KernelFork.ofฮน p.unop (show p.unop โซ f.unop = 0 by rw [โ unop_comp, w, unop_zero])) :=
  KernelFork.IsLimit.ofฮน _ _
    (fun x hx => (h.desc (CokernelCofork.ofฯ x.op (Quiver.Hom.op_inj hx))).unop)
    (fun x hx => Quiver.Hom.op_inj (Cofork.IsColimit.ฯ_desc h))
    (fun x hx b hb => Quiver.Hom.op_inj (Cofork.IsColimit.hom_ext h
      (by simpa only [Quiver.Hom.op_unop, Cofork.IsColimit.ฯ_desc] using Quiver.Hom.unop_inj hb)))

def KernelFork.IsLimit.ofฮน_op {K X Y : C} (i : K โถ X) {f : X โถ Y}
    (w : i โซ f = 0) (h : IsLimit (KernelFork.ofฮน i w)) :
    IsColimit (CokernelCofork.ofฯ i.op
      (show f.op โซ i.op = 0 by rw [โ op_comp, w, op_zero])) :=
  CokernelCofork.IsColimit.ofฯ _ _
    (fun x hx => (h.lift (KernelFork.ofฮน x.unop (Quiver.Hom.op_inj hx))).op)
    (fun x hx => Quiver.Hom.unop_inj (Fork.IsLimit.lift_ฮน h))
    (fun x hx b hb => Quiver.Hom.unop_inj (Fork.IsLimit.hom_ext h (by
      simpa only [Quiver.Hom.unop_op, Fork.IsLimit.lift_ฮน] using Quiver.Hom.op_inj hb)))

def KernelFork.IsLimit.ofฮน_unop {K X Y : Cแตแต} (i : K โถ X) {f : X โถ Y}
    (w : i โซ f = 0) (h : IsLimit (KernelFork.ofฮน i w)) :
    IsColimit (CokernelCofork.ofฯ i.unop
      (show f.unop โซ i.unop = 0 by rw [โ unop_comp, w, unop_zero])) :=
  CokernelCofork.IsColimit.ofฯ _ _
    (fun x hx => (h.lift (KernelFork.ofฮน x.op (Quiver.Hom.unop_inj hx))).unop)
    (fun x hx => Quiver.Hom.op_inj (Fork.IsLimit.lift_ฮน h))
    (fun x hx b hb => Quiver.Hom.op_inj (Fork.IsLimit.hom_ext h (by
      simpa only [Quiver.Hom.op_unop, Fork.IsLimit.lift_ฮน] using Quiver.Hom.unop_inj hb)))

end Limits

end CategoryTheory

/-
open category_theory category_theory.category category_theory.limits
open_locale zero_object

namespace category_theory.limits

variables {C : Type*} [category C] [has_zero_morphisms C]


/-- fork.is_limit.lift_ฮน has to be fixed -/
@[simp, reassoc]
lemma fork.is_limit.lift_ฮน' {X Y : C} {f g : X โถ Y} {c : fork f g} (hc : is_limit c)
  (c' : fork f g ) : hc.lift c' โซ c.ฮน = c'.ฮน :=
by apply fork.is_limit.lift_ฮน

namespace kernel_fork

def is_limit.of_ฮน_op {K X Y : C} (i : K โถ X) {f : X โถ Y}
  (w : i โซ f = 0) (h : is_limit (kernel_fork.of_ฮน i w)) :
  is_colimit (cokernel_cofork.of_ฯ i.op
    (show f.op โซ i.op = 0, by simpa only [โ op_comp, w])) :=
cokernel_cofork.is_colimit.of_ฯ _ _
  (ฮป A x hx, (h.lift (kernel_fork.of_ฮน x.unop (quiver.hom.op_inj hx))).op)
  (ฮป A x hx, quiver.hom.unop_inj (fork.is_limit.lift_ฮน h))
  (ฮป A x hx b hb, quiver.hom.unop_inj (fork.is_limit.hom_ext h begin
    simp only [quiver.hom.unop_op, fork.is_limit.lift_ฮน],
    exact quiver.hom.op_inj hb,
  end))

def is_limit.of_ฮน_unop {K X Y : Cแตแต} (i : K โถ X) {f : X โถ Y}
  (w : i โซ f = 0) (h : is_limit (kernel_fork.of_ฮน i w)) :
  is_colimit (cokernel_cofork.of_ฯ i.unop
    (show f.unop โซ i.unop = 0, by simpa only [โ unop_comp, w])) :=
cokernel_cofork.is_colimit.of_ฯ _ _
  (ฮป A x hx, (h.lift (kernel_fork.of_ฮน x.op (quiver.hom.unop_inj hx))).unop)
  (ฮป A x hx, quiver.hom.op_inj (fork.is_limit.lift_ฮน h))
  (ฮป A x hx b hb, quiver.hom.op_inj (fork.is_limit.hom_ext h begin
    simp only [quiver.hom.op_unop, fork.is_limit.lift_ฮน],
    exact quiver.hom.unop_inj hb,
  end))

lemma is_limit.is_iso_ฮน_of_zero {X Y : C} {f : X โถ Y} (c : kernel_fork f)
  (hc : is_limit c) (hf : f = 0) : is_iso c.ฮน :=
begin
  subst hf,
  let e : c.X โ X := is_limit.cone_point_unique_up_to_iso hc (kernel_zero (0 : X โถ Y) rfl),
  have eq : e.inv โซ fork.ฮน c  = ๐ X := fork.is_limit.lift_ฮน hc,
  haveI : is_iso (e.inv โซ fork.ฮน c),
  { rw eq, dsimp, apply_instance, },
  exact is_iso.of_is_iso_comp_left e.inv (fork.ฮน c),
end

end kernel_fork

namespace cokernel_cofork

def is_colimit.of_ฯ_op {X Y Q : C} (p : Y โถ Q) {f : X โถ Y}
  (w : f โซ p = 0) (h : is_colimit (cokernel_cofork.of_ฯ p w)) :
  is_limit (kernel_fork.of_ฮน p.op
    (show p.op โซ f.op = 0, by simpa only [โ op_comp, w])) :=
kernel_fork.is_limit.of_ฮน _ _
  (ฮป A x hx, (h.desc (cokernel_cofork.of_ฯ x.unop (quiver.hom.op_inj hx))).op)
  (ฮป A x hx, quiver.hom.unop_inj (cofork.is_colimit.ฯ_desc h))
  (ฮป A x hx b hb, quiver.hom.unop_inj (cofork.is_colimit.hom_ext h begin
    simp only [quiver.hom.unop_op, cofork.is_colimit.ฯ_desc],
    exact quiver.hom.op_inj hb,
  end))

def is_colimit.of_ฯ_unop {X Y Q : Cแตแต} (p : Y โถ Q) {f : X โถ Y}
  (w : f โซ p = 0) (h : is_colimit (cokernel_cofork.of_ฯ p w)) :
  is_limit (kernel_fork.of_ฮน p.unop
    (show p.unop โซ f.unop = 0, by simpa only [โ unop_comp, w])) :=
kernel_fork.is_limit.of_ฮน _ _
  (ฮป A x hx, (h.desc (cokernel_cofork.of_ฯ x.op (quiver.hom.unop_inj hx))).unop)
  (ฮป A x hx, quiver.hom.op_inj (cofork.is_colimit.ฯ_desc h))
  (ฮป A x hx b hb, quiver.hom.op_inj (cofork.is_colimit.hom_ext h begin
    simp only [quiver.hom.op_unop, cofork.is_colimit.ฯ_desc],
    exact quiver.hom.unop_inj hb,
  end))

lemma is_colimit.is_iso_ฯ_of_zero {X Y : C} {f : X โถ Y} (c : cokernel_cofork f)
  (hc : is_colimit c) (hf : f = 0) : is_iso c.ฯ :=
begin
  subst hf,
  let e : c.X โ Y := is_colimit.cocone_point_unique_up_to_iso hc (cokernel_zero (0 : X โถ Y) rfl),
  have eq : cofork.ฯ c โซ e.hom = ๐ Y := cofork.is_colimit.ฯ_desc hc,
  haveI : is_iso (cofork.ฯ c โซ e.hom),
  { rw eq, dsimp, apply_instance, },
  exact is_iso.of_is_iso_comp_right (cofork.ฯ c) e.hom,
end

end cokernel_cofork

end category_theory.limits

open category_theory.limits
-/

namespace CategoryTheory

open Category Limits

namespace ShortComplex

variable {C D : Type _} [Category C] [Category D]
  [HasZeroMorphisms C]
  (S : ShortComplex C) {Sโ Sโ Sโ : ShortComplex C}

structure LeftHomologyData :=
(K H : C)
(i : K โถ S.Xโ)
(ฯ : K โถ H)
(wi : i โซ S.g = 0)
(hi : IsLimit (KernelFork.ofฮน i wi))
(wฯ : hi.lift (KernelFork.ofฮน _ S.zero) โซ ฯ = 0)
(hฯ : IsColimit (CokernelCofork.ofฯ ฯ wฯ))

initialize_simps_projections LeftHomologyData (-hi, -hฯ)

namespace LeftHomologyData

@[simps]
noncomputable def of_ker_of_coker [HasKernel S.g] [HasCokernel (kernel.lift S.g S.f S.zero)] :
  S.LeftHomologyData :=
{ K := kernel S.g,
  H := cokernel (kernel.lift S.g S.f S.zero),
  i := kernel.ฮน _,
  ฯ := cokernel.ฯ _,
  wi := kernel.condition _,
  hi := kernelIsKernel _,
  wฯ := cokernel.condition _,
  hฯ := cokernelIsCokernel _, }

attribute [reassoc (attr := simp)] wi wฯ

variable {S}
variable (h : S.LeftHomologyData) {A : C}

instance : Mono h.i :=
  โจfun _ _ => Fork.IsLimit.hom_ext h.hiโฉ

instance : Epi h.ฯ :=
  โจfun _ _ => Cofork.IsColimit.hom_ext h.hฯโฉ

def lift_K (k : A โถ S.Xโ) (hk : k โซ S.g = 0) : A โถ h.K :=
h.hi.lift (KernelFork.ofฮน k hk)

@[reassoc (attr := simp)]
lemma lift_K_i (k : A โถ S.Xโ) (hk : k โซ S.g = 0) :
  h.lift_K k hk โซ h.i = k :=
h.hi.fac _ WalkingParallelPair.zero

@[simp]
def lift_H (k : A โถ S.Xโ) (hk : k โซ S.g = 0) : A โถ h.H :=
  h.lift_K k hk โซ h.ฯ

/-- The morphism `S.Xโ โถ h.K` induced by `S.f : S.Xโ โถ S.Xโ` and the fact that
`h.K` is a kernel of `S.g : S.Xโ โถ S.Xโ`. -/
def f' : S.Xโ โถ h.K := h.lift_K S.f S.zero

@[reassoc (attr := simp)]
lemma f'_i : h.f' โซ h.i = S.f :=
lift_K_i _ _ _

@[reassoc (attr := simp)]
lemma f'_ฯ : h.f' โซ h.ฯ = 0 := h.wฯ

@[reassoc]
lemma lift_K_ฯ_eq_zero_of_boundary (k : A โถ S.Xโ) (x : A โถ S.Xโ) (hx : k = x โซ S.f) :
    h.lift_K k (by rw [hx, assoc, S.zero, comp_zero]) โซ h.ฯ = 0 := by
  rw [show 0 = (x โซ h.f') โซ h.ฯ by simp]
  congr 1
  simp only [โ cancel_mono h.i, hx, lift_K_i, assoc, f'_i]

/-- For `h : S.LeftHomologyData`, this is a restatement of `h.hฯ`, saying that
`ฯ : h.K โถ h.H` is a cokernel of `h.f' : S.Xโ โถ h.K`. -/
def hฯ' : IsColimit (CokernelCofork.ofฯ h.ฯ h.f'_ฯ) := h.hฯ

def desc_H (k : h.K โถ A) (hk : h.f' โซ k = 0) :
  h.H โถ A :=
h.hฯ.desc (CokernelCofork.ofฯ k hk)

@[reassoc (attr := simp)]
lemma ฯ_desc_H (k : h.K โถ A) (hk : h.f' โซ k = 0) :
  h.ฯ โซ h.desc_H k hk = k :=
h.hฯ.fac (CokernelCofork.ofฯ k hk) WalkingParallelPair.one

variable (S)

@[simps]
def of_isColimit_cokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :
  S.LeftHomologyData where
  K := S.Xโ
  H := c.pt
  i := ๐ _
  ฯ := c.ฯ
  wi := by rw [id_comp, hg]
  hi := KernelFork.IsLimit.of_id _ hg
  wฯ := CokernelCofork.condition _
  hฯ := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _) (by aesop_cat))

@[simp] lemma of_isColimit_cokernelCofork_f' (hg : S.g = 0) (c : CokernelCofork S.f)
    (hc : IsColimit c) : (of_isColimit_cokernelCofork S hg c hc).f' = S.f := by
  rw [โ cancel_mono (of_isColimit_cokernelCofork S hg c hc).i, f'_i,
    of_isColimit_cokernelCofork_i]
  dsimp
  rw [comp_id]

@[simps!]
noncomputable def of_hasCokernel [HasCokernel S.f] (hg : S.g = 0) : S.LeftHomologyData :=
of_isColimit_cokernelCofork S hg _ (cokernelIsCokernel _)

@[simps]
def of_isLimit_kernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :
  S.LeftHomologyData where
  K := c.pt
  H := c.pt
  i := c.ฮน
  ฯ := ๐ _
  wi := KernelFork.condition _
  hi := IsLimit.ofIsoLimit hc (Fork.ext (Iso.refl _) (by aesop_cat))
  wฯ := Fork.IsLimit.hom_ext hc (by
    dsimp
    simp only [comp_id, zero_comp, Fork.IsLimit.lift_ฮน, Fork.ฮน_ofฮน, hf])
  hฯ := CokernelCofork.IsColimit.of_id _ (Fork.IsLimit.hom_ext hc (by
    dsimp
    simp only [comp_id, zero_comp, Fork.IsLimit.lift_ฮน, Fork.ฮน_ofฮน, hf]))

@[simp] lemma of_isLimit_kernelFork_f' (hf : S.f = 0) (c : KernelFork S.g)
  (hc : IsLimit c) : (of_isLimit_kernelFork S hf c hc).f' = 0 :=
by rw [โ cancel_mono (of_isLimit_kernelFork S hf c hc).i, f'_i, hf, zero_comp]

@[simp]
noncomputable def of_hasKernel [HasKernel S.g] (hf : S.f = 0) : S.LeftHomologyData :=
of_isLimit_kernelFork S hf _ (kernelIsKernel _)

@[simps]
def of_zeros (hf : S.f = 0) (hg : S.g = 0) : S.LeftHomologyData where
  K := S.Xโ
  H := S.Xโ
  i := ๐ _
  ฯ := ๐ _
  wi := by rw [id_comp, hg]
  hi := KernelFork.IsLimit.of_id _ hg
  wฯ := by
    change S.f โซ ๐ _ = 0
    simp only [hf, zero_comp]
  hฯ := CokernelCofork.IsColimit.of_id _ hf

@[simp]
lemma of_zeros_f' (hf : S.f = 0) (hg : S.g = 0) :
    (of_zeros S hf hg).f' = 0 := by
  rw [โ cancel_mono ((of_zeros S hf hg).i), zero_comp, f'_i, hf]

@[simps]
noncomputable def kernel_sequence' {X Y : C} (f : X โถ Y) (c : KernelFork f) (hc : IsLimit c)
  [HasZeroObject C] :
  LeftHomologyData (ShortComplex.mk c.ฮน f (KernelFork.condition c)) where
  K := c.pt
  H := 0
  i := c.ฮน
  ฯ := 0
  wi := KernelFork.condition _
  hi := IsLimit.ofIsoLimit hc (Fork.ext (Iso.refl _) (by simp))
  wฯ := Subsingleton.elim _ _
  hฯ := by
    refine' CokernelCofork.IsColimit.of_isZero_of_epi _ _ _
    . dsimp
      convert (inferInstance : Epi (๐ c.pt))
      haveI := mono_of_isLimit_fork hc
      rw [โ cancel_mono c.ฮน]
      simp only [Fork.ofฮน_pt, parallelPair_obj_zero, Functor.const_obj_obj,
        Fork.IsLimit.lift_ฮน, Fork.ฮน_ofฮน, id_comp, comp_id]
    . apply isZero_zero

@[simps!]
noncomputable def kernel_sequence {X Y : C} (f : X โถ Y) [HasKernel f] [HasZeroObject C] :
    LeftHomologyData (ShortComplex.mk (kernel.ฮน f) f (kernel.condition f)) := by
  let h := kernel_sequence' f _ (kernelIsKernel f)
  exact h

/-
section change

variables {S} {K H : C} {f' : S.Xโ โถ K} {i : K โถ S.Xโ}
  (commf' : f' โซ i = S.f) (e : K โ h.K) (commi : e.hom โซ h.i = i)
  (ฯ : K โถ H) (hฯโ : f' โซ ฯ = 0) (hฯ : is_colimit (cokernel_cofork.of_ฯ ฯ hฯโ))

include commf' commi hฯ

@[simps]
def change :
  LeftHomologyData S :=
begin
  have wi : i โซ S.g = 0 := by rw [โ commi, assoc, h.wi, comp_zero],
  have hi : is_limit (kernel_fork.of_ฮน i wi) :=
    is_limit.of_iso_limit h.hi (fork.ext e.symm (by simp [โ commi])),
  let f'' := hi.lift (kernel_fork.of_ฮน S.f S.zero),
  have eq : f'' = f',
  { rw [โ cancel_mono e.hom, โ cancel_mono h.i, assoc, commi],
    dsimp,
    erw fork.is_limit.lift_ฮน,
    simp only [kernel_fork.ฮน_of_ฮน, assoc, commi, commf'], },
  have wฯ' : f'' โซ ฯ = 0 := by rw [eq, hฯโ],
  have hฯ' : is_colimit (cokernel_cofork.of_ฯ ฯ wฯ'),
  { let e : parallel_pair f'' 0 โ parallel_pair f' 0 :=
      parallel_pair.ext (iso.refl _) (iso.refl _) (by simp [eq]) (by simp),
    equiv_rw (is_colimit.precompose_inv_equiv e _).symm,
    exact is_colimit.of_iso_colimit hฯ (cofork.ext (iso.refl _) (by tidy)), },
  exact โจK, H, i, ฯ, wi, hi, wฯ', hฯ'โฉ,
end

@[simp] lemma change_f' : (h.change commf' e commi ฯ hฯโ hฯ).f' = f' :=
by rw [โ cancel_mono (h.change commf' e commi ฯ hฯโ hฯ).i, f'_i, change_i, commf']

end change-/

end LeftHomologyData

class HasLeftHomology : Prop :=
(condition : Nonempty S.LeftHomologyData)

noncomputable def leftHomologyData [HasLeftHomology S] :
  S.LeftHomologyData := HasLeftHomology.condition.some

variable {S}

namespace HasLeftHomology

lemma mk' (h : S.LeftHomologyData) : HasLeftHomology S :=
โจNonempty.intro hโฉ

instance of_ker_of_coker
    [HasKernel S.g] [HasCokernel (kernel.lift S.g S.f S.zero)] :
  S.HasLeftHomology := HasLeftHomology.mk' (LeftHomologyData.of_ker_of_coker S)

instance of_hasCokernel {X Y : C} (f : X โถ Y) (Z : C) [HasCokernel f] :
    (ShortComplex.mk f (0 : Y โถ Z) comp_zero).HasLeftHomology :=
  HasLeftHomology.mk' (LeftHomologyData.of_hasCokernel _ rfl)

instance of_hasKernel {Y Z : C} (g : Y โถ Z) (X : C) [HasKernel g] :
    (ShortComplex.mk (0 : X โถ Y) g zero_comp).HasLeftHomology :=
  HasLeftHomology.mk' (LeftHomologyData.of_hasKernel _ rfl)

instance of_zeros (X Y Z : C) :
    (ShortComplex.mk (0 : X โถ Y) (0 : Y โถ Z) zero_comp).HasLeftHomology :=
  HasLeftHomology.mk' (LeftHomologyData.of_zeros _ rfl rfl)

end HasLeftHomology

section

variable (ฯ : Sโ โถ Sโ) (hโ : Sโ.LeftHomologyData) (hโ : Sโ.LeftHomologyData)

structure LeftHomologyMapData where
  ฯK : hโ.K โถ hโ.K
  ฯH : hโ.H โถ hโ.H
  commi : ฯK โซ hโ.i = hโ.i โซ ฯ.ฯโ := by aesop_cat
  commf' : hโ.f' โซ ฯK = ฯ.ฯโ โซ hโ.f' := by aesop_cat
  commฯ : hโ.ฯ โซ ฯH = ฯK โซ hโ.ฯ := by aesop_cat

namespace LeftHomologyMapData

attribute [reassoc (attr := simp)] commi commf' commฯ

@[simps]
def zero (hโ : Sโ.LeftHomologyData) (hโ : Sโ.LeftHomologyData) :
  LeftHomologyMapData 0 hโ hโ where
  ฯK := 0
  ฯH := 0

@[simps]
def id (h : S.LeftHomologyData) : LeftHomologyMapData (๐ S) h h where
  ฯK := ๐ _
  ฯH := ๐ _

@[simps]
def comp {ฯ : Sโ โถ Sโ} {ฯ' : Sโ โถ Sโ} {hโ : Sโ.LeftHomologyData}
  {hโ : Sโ.LeftHomologyData} {hโ : Sโ.LeftHomologyData}
  (ฯ : LeftHomologyMapData ฯ hโ hโ) (ฯ' : LeftHomologyMapData ฯ' hโ hโ) :
  LeftHomologyMapData (ฯ โซ ฯ') hโ hโ :=
{ ฯK := ฯ.ฯK โซ ฯ'.ฯK,
  ฯH := ฯ.ฯH โซ ฯ'.ฯH, }

instance : Subsingleton (LeftHomologyMapData ฯ hโ hโ) :=
  โจfun ฯโ ฯโ => by
    have hK : ฯโ.ฯK = ฯโ.ฯK := by rw [โ cancel_mono hโ.i, commi, commi]
    have hH : ฯโ.ฯH = ฯโ.ฯH := by rw [โ cancel_epi hโ.ฯ, commฯ, commฯ, hK]
    cases ฯโ
    cases ฯโ
    congrโฉ

attribute [-simp] mk.injEq

instance : Inhabited (LeftHomologyMapData ฯ hโ hโ) := โจby
  let ฯK : hโ.K โถ hโ.K := hโ.lift_K (hโ.i โซ ฯ.ฯโ)
    (by rw [assoc, ฯ.commโโ, hโ.wi_assoc, zero_comp])
  have commf' : hโ.f' โซ ฯK = ฯ.ฯโ โซ hโ.f' := by
    rw [โ cancel_mono hโ.i, assoc, assoc, LeftHomologyData.lift_K_i,
      LeftHomologyData.f'_i_assoc, LeftHomologyData.f'_i, ฯ.commโโ]
  let ฯH : hโ.H โถ hโ.H := hโ.desc_H (ฯK โซ hโ.ฯ)
    (by rw [reassoc_of% commf', hโ.f'_ฯ, comp_zero])
  exact โจฯK, ฯH, by simp, commf', by simpโฉโฉ

instance : Unique (LeftHomologyMapData ฯ hโ hโ) := Unique.mk' _

def _root_.CategoryTheory.ShortComplex.leftHomologyMapData :
  LeftHomologyMapData ฯ hโ hโ := default

variable {ฯ hโ hโ}

lemma congr_ฯH {ฮณโ ฮณโ : LeftHomologyMapData ฯ hโ hโ} (eq : ฮณโ = ฮณโ) : ฮณโ.ฯH = ฮณโ.ฯH := by rw [eq]
lemma congr_ฯK {ฮณโ ฮณโ : LeftHomologyMapData ฯ hโ hโ} (eq : ฮณโ = ฮณโ) : ฮณโ.ฯK = ฮณโ.ฯK := by rw [eq]

@[simps]
def of_zeros (ฯ : Sโ โถ Sโ) (hfโ : Sโ.f = 0) (hgโ : Sโ.g = 0) (hfโ : Sโ.f = 0) (hgโ : Sโ.g = 0) :
  LeftHomologyMapData ฯ (LeftHomologyData.of_zeros Sโ hfโ hgโ)
    (LeftHomologyData.of_zeros Sโ hfโ hgโ) where
  ฯK := ฯ.ฯโ
  ฯH := ฯ.ฯโ
  commf' := by simp only [LeftHomologyData.of_zeros_f', ฯ.commโโ, zero_comp, comp_zero]

@[simps]
def of_isColimit_cokernelCofork (ฯ : Sโ โถ Sโ)
  (hgโ : Sโ.g = 0) (cโ : CokernelCofork Sโ.f) (hcโ : IsColimit cโ)
  (hgโ : Sโ.g = 0) (cโ : CokernelCofork Sโ.f) (hcโ : IsColimit cโ) (f : cโ.pt โถ cโ.pt)
  (comm : ฯ.ฯโ โซ cโ.ฯ = cโ.ฯ โซ f) :
  LeftHomologyMapData ฯ (LeftHomologyData.of_isColimit_cokernelCofork Sโ hgโ cโ hcโ)
    (LeftHomologyData.of_isColimit_cokernelCofork Sโ hgโ cโ hcโ) where
  ฯK := ฯ.ฯโ
  ฯH := f
  commi := by simp
  commf' := by simp only [LeftHomologyData.of_isColimit_cokernelCofork_f', ฯ.commโโ]
  commฯ := comm.symm

@[simps]
def of_isLimit_kernelFork (ฯ : Sโ โถ Sโ)
  (hfโ : Sโ.f = 0) (cโ : KernelFork Sโ.g) (hcโ : IsLimit cโ)
  (hfโ : Sโ.f = 0) (cโ : KernelFork Sโ.g) (hcโ : IsLimit cโ) (f : cโ.pt โถ cโ.pt)
  (comm : cโ.ฮน โซ ฯ.ฯโ = f โซ cโ.ฮน) :
  LeftHomologyMapData ฯ (LeftHomologyData.of_isLimit_kernelFork Sโ hfโ cโ hcโ)
    (LeftHomologyData.of_isLimit_kernelFork Sโ hfโ cโ hcโ) where
  ฯK := f
  ฯH := f
  commi := comm.symm
  commf' := by simp only [LeftHomologyData.of_isLimit_kernelFork_f', zero_comp, comp_zero]

variable (S)

@[simps]
def compatibility_of_zeros_of_isColimit_cokernelCofork (hf : S.f = 0) (hg : S.g = 0)
  (c : CokernelCofork S.f) (hc : IsColimit c) :
  LeftHomologyMapData (๐ S) (LeftHomologyData.of_zeros S hf hg)
    (LeftHomologyData.of_isColimit_cokernelCofork S hg c hc) where
  ฯK := ๐ _
  ฯH := c.ฯ

@[simps]
def compatibility_of_zeros_of_isLimit_kernelFork (hf : S.f = 0) (hg : S.g = 0)
  (c : KernelFork S.g) (hc : IsLimit c) :
  LeftHomologyMapData (๐ S)
    (LeftHomologyData.of_isLimit_kernelFork S hf c hc)
    (LeftHomologyData.of_zeros S hf hg) where
  ฯK := c.ฮน
  ฯH := c.ฮน

end LeftHomologyMapData

end

variable (S)

noncomputable def leftHomology [HasLeftHomology S] : C := S.leftHomologyData.H
noncomputable def cycles [HasLeftHomology S] : C := S.leftHomologyData.K
noncomputable def leftHomology_ฯ [HasLeftHomology S] : S.cycles โถ S.leftHomology :=
  S.leftHomologyData.ฯ
noncomputable def cycles_i [HasLeftHomology S] : S.cycles โถ S.Xโ := S.leftHomologyData.i
noncomputable def toCycles [HasLeftHomology S] : S.Xโ โถ S.cycles := S.leftHomologyData.f'

@[reassoc (attr := simp)]
lemma cycles_i_g [HasLeftHomology S] : S.cycles_i โซ S.g = 0 :=
  S.leftHomologyData.wi

@[reassoc (attr := simp)]
lemma toCycles_i [HasLeftHomology S] : S.toCycles โซ S.cycles_i = S.f :=
  S.leftHomologyData.f'_i

instance [HasLeftHomology S] : Mono S.cycles_i := by
  dsimp only [cycles_i]
  infer_instance

instance [HasLeftHomology S] : Epi S.leftHomology_ฯ := by
  dsimp only [leftHomology_ฯ]
  infer_instance

variable {S}

def leftHomology_map' (ฯ : Sโ โถ Sโ) (hโ : Sโ.LeftHomologyData) (hโ : Sโ.LeftHomologyData) :
  hโ.H โถ hโ.H := (leftHomologyMapData ฯ _ _).ฯH

def cycles_map' (ฯ : Sโ โถ Sโ) (hโ : Sโ.LeftHomologyData) (hโ : Sโ.LeftHomologyData) :
  hโ.K โถ hโ.K := (leftHomologyMapData ฯ _ _).ฯK

@[reassoc (attr := simp)]
lemma cycles_map'_i (ฯ : Sโ โถ Sโ) (hโ : Sโ.LeftHomologyData) (hโ : Sโ.LeftHomologyData) :
    cycles_map' ฯ hโ hโ โซ hโ.i = hโ.i โซ ฯ.ฯโ :=
  LeftHomologyMapData.commi _

@[reassoc (attr := simp)]
lemma leftHomology_ฯ_naturality' (ฯ : Sโ โถ Sโ)
    (hโ : Sโ.LeftHomologyData) (hโ : Sโ.LeftHomologyData) :
    hโ.ฯ โซ leftHomology_map' ฯ hโ hโ = cycles_map' ฯ hโ hโ โซ hโ.ฯ :=
  LeftHomologyMapData.commฯ _

noncomputable def leftHomology_map [HasLeftHomology Sโ] [HasLeftHomology Sโ]
    (ฯ : Sโ โถ Sโ) : Sโ.leftHomology โถ Sโ.leftHomology :=
  leftHomology_map' ฯ _ _

noncomputable def cycles_map [HasLeftHomology Sโ] [HasLeftHomology Sโ]
    (ฯ : Sโ โถ Sโ) : Sโ.cycles โถ Sโ.cycles :=
  cycles_map' ฯ _ _

@[reassoc (attr := simp)]
lemma cycles_map_i (ฯ : Sโ โถ Sโ) [Sโ.HasLeftHomology] [Sโ.HasLeftHomology] :
    cycles_map ฯ โซ Sโ.cycles_i = Sโ.cycles_i โซ ฯ.ฯโ :=
  cycles_map'_i _ _ _

@[reassoc (attr := simp)]
lemma toCycles_naturality (ฯ : Sโ โถ Sโ) [Sโ.HasLeftHomology] [Sโ.HasLeftHomology] :
    Sโ.toCycles โซ cycles_map ฯ = ฯ.ฯโ โซ Sโ.toCycles := by
  simp only [โ cancel_mono Sโ.cycles_i, ฯ.commโโ, assoc, toCycles_i,
    cycles_map_i, toCycles_i_assoc]

@[reassoc (attr := simp)]
lemma leftHomology_ฯ_naturality [HasLeftHomology Sโ] [HasLeftHomology Sโ]
    (ฯ : Sโ โถ Sโ) :
    Sโ.leftHomology_ฯ โซ leftHomology_map ฯ = cycles_map ฯ โซ Sโ.leftHomology_ฯ :=
  leftHomology_ฯ_naturality' _ _ _

namespace LeftHomologyMapData

variable {ฯ : Sโ โถ Sโ} {hโ : Sโ.LeftHomologyData} {hโ : Sโ.LeftHomologyData}
  (ฮณ : LeftHomologyMapData ฯ hโ hโ)

lemma leftHomology_map'_eq : leftHomology_map' ฯ hโ hโ = ฮณ.ฯH :=
  LeftHomologyMapData.congr_ฯH (Subsingleton.elim _ _)

lemma cycles_map'_eq : cycles_map' ฯ hโ hโ = ฮณ.ฯK :=
  LeftHomologyMapData.congr_ฯK (Subsingleton.elim _ _)

end LeftHomologyMapData

@[simp]
lemma leftHomology_map'_id (h : S.LeftHomologyData) :
    leftHomology_map' (๐ S) h h = ๐ _ :=
  (LeftHomologyMapData.id h).leftHomology_map'_eq

@[simp]
lemma cycles_map'_id (h : S.LeftHomologyData) :
    cycles_map' (๐ S) h h = ๐ _ :=
  (LeftHomologyMapData.id h).cycles_map'_eq

variable (S)

@[simp]
lemma leftHomology_map_id [HasLeftHomology S] :
    leftHomology_map (๐ S) = ๐ _ :=
  leftHomology_map'_id _

@[simp]
lemma cycles_map_id [HasLeftHomology S] :
    cycles_map (๐ S) = ๐ _ :=
  cycles_map'_id _

@[simp]
lemma leftHomology_map'_zero (hโ : Sโ.LeftHomologyData) (hโ : Sโ.LeftHomologyData) :
    leftHomology_map' 0 hโ hโ = 0 :=
  (LeftHomologyMapData.zero hโ hโ).leftHomology_map'_eq

@[simp]
lemma cycles_map'_zero (hโ : Sโ.LeftHomologyData) (hโ : Sโ.LeftHomologyData) :
    cycles_map' 0 hโ hโ = 0 :=
  (LeftHomologyMapData.zero hโ hโ).cycles_map'_eq

variable (Sโ Sโ)

@[simp]
lemma left_homology_map_zero [HasLeftHomology Sโ] [HasLeftHomology Sโ] :
    leftHomology_map (0 : Sโ โถ Sโ) = 0 :=
  leftHomology_map'_zero _ _

@[simp]
lemma cycles_map_zero [HasLeftHomology Sโ] [HasLeftHomology Sโ] :
  cycles_map (0 : Sโ โถ Sโ) = 0 :=
cycles_map'_zero _ _

variable {Sโ Sโ}

lemma leftHomology_map'_comp (ฯโ : Sโ โถ Sโ) (ฯโ : Sโ โถ Sโ)
    (hโ : Sโ.LeftHomologyData) (hโ : Sโ.LeftHomologyData) (hโ : Sโ.LeftHomologyData) :
    leftHomology_map' (ฯโ โซ ฯโ) hโ hโ = leftHomology_map' ฯโ hโ hโ โซ
      leftHomology_map' ฯโ hโ hโ := by
  let ฮณโ := leftHomologyMapData ฯโ hโ hโ
  let ฮณโ := leftHomologyMapData ฯโ hโ hโ
  rw [ฮณโ.leftHomology_map'_eq, ฮณโ.leftHomology_map'_eq, (ฮณโ.comp ฮณโ).leftHomology_map'_eq,
    LeftHomologyMapData.comp_ฯH]

lemma cycles_map'_comp (ฯโ : Sโ โถ Sโ) (ฯโ : Sโ โถ Sโ)
    (hโ : Sโ.LeftHomologyData) (hโ : Sโ.LeftHomologyData) (hโ : Sโ.LeftHomologyData) :
    cycles_map' (ฯโ โซ ฯโ) hโ hโ = cycles_map' ฯโ hโ hโ โซ cycles_map' ฯโ hโ hโ := by
  let ฮณโ := leftHomologyMapData ฯโ hโ hโ
  let ฮณโ := leftHomologyMapData ฯโ hโ hโ
  rw [ฮณโ.cycles_map'_eq, ฮณโ.cycles_map'_eq, (ฮณโ.comp ฮณโ).cycles_map'_eq,
    LeftHomologyMapData.comp_ฯK]

@[simp]
lemma leftHomology_map_comp [HasLeftHomology Sโ] [HasLeftHomology Sโ] [HasLeftHomology Sโ]
    (ฯโ : Sโ โถ Sโ) (ฯโ : Sโ โถ Sโ) :
    leftHomology_map (ฯโ โซ ฯโ) = leftHomology_map ฯโ โซ leftHomology_map ฯโ :=
leftHomology_map'_comp _ _ _ _ _

@[simp]
lemma cycles_map_comp [HasLeftHomology Sโ] [HasLeftHomology Sโ] [HasLeftHomology Sโ]
    (ฯโ : Sโ โถ Sโ) (ฯโ : Sโ โถ Sโ) :
    cycles_map (ฯโ โซ ฯโ) = cycles_map ฯโ โซ cycles_map ฯโ :=
  cycles_map'_comp _ _ _ _ _

@[simps]
def leftHomology_map_iso' (e : Sโ โ Sโ) (hโ : Sโ.LeftHomologyData)
    (hโ : Sโ.LeftHomologyData) : hโ.H โ hโ.H where
  hom := leftHomology_map' e.hom hโ hโ
  inv := leftHomology_map' e.inv hโ hโ
  hom_inv_id := by rw [โ leftHomology_map'_comp, e.hom_inv_id, leftHomology_map'_id]
  inv_hom_id := by rw [โ leftHomology_map'_comp, e.inv_hom_id, leftHomology_map'_id]

instance isIso_leftHomology_map'_of_isIso (ฯ : Sโ โถ Sโ) [IsIso ฯ]
    (hโ : Sโ.LeftHomologyData) (hโ : Sโ.LeftHomologyData) :
    IsIso (leftHomology_map' ฯ hโ hโ) :=
  (inferInstance : IsIso (leftHomology_map_iso' (asIso ฯ) hโ hโ).hom)

@[simps]
def cycles_map_iso' (e : Sโ โ Sโ) (hโ : Sโ.LeftHomologyData)
  (hโ : Sโ.LeftHomologyData) : hโ.K โ hโ.K where
  hom := cycles_map' e.hom hโ hโ
  inv := cycles_map' e.inv hโ hโ
  hom_inv_id := by rw [โ cycles_map'_comp, e.hom_inv_id, cycles_map'_id]
  inv_hom_id := by rw [โ cycles_map'_comp, e.inv_hom_id, cycles_map'_id]

instance isIso_cycles_map'_of_isIso (ฯ : Sโ โถ Sโ) [IsIso ฯ]
    (hโ : Sโ.LeftHomologyData) (hโ : Sโ.LeftHomologyData) :
    IsIso (cycles_map' ฯ hโ hโ) :=
  (inferInstance : IsIso (cycles_map_iso' (asIso ฯ) hโ hโ).hom)

@[simps]
noncomputable def leftHomology_map_iso (e : Sโ โ Sโ) [Sโ.HasLeftHomology]
  [Sโ.HasLeftHomology] : Sโ.leftHomology โ Sโ.leftHomology where
  hom := leftHomology_map e.hom
  inv := leftHomology_map e.inv
  hom_inv_id := by rw [โ leftHomology_map_comp, e.hom_inv_id, leftHomology_map_id]
  inv_hom_id := by rw [โ leftHomology_map_comp, e.inv_hom_id, leftHomology_map_id]

instance isIso_leftHomologyMap_of_iso (ฯ : Sโ โถ Sโ) [IsIso ฯ] [Sโ.HasLeftHomology]
    [Sโ.HasLeftHomology] :
    IsIso (leftHomology_map ฯ) :=
  (inferInstance : IsIso (leftHomology_map_iso (asIso ฯ)).hom)

@[simps]
noncomputable def cycles_map_iso (e : Sโ โ Sโ) [Sโ.HasLeftHomology]
    [Sโ.HasLeftHomology] : Sโ.cycles โ Sโ.cycles where
  hom := cycles_map e.hom
  inv := cycles_map e.inv
  hom_inv_id := by rw [โ cycles_map_comp, e.hom_inv_id, cycles_map_id]
  inv_hom_id := by rw [โ cycles_map_comp, e.inv_hom_id, cycles_map_id]

instance isIso_cycles_map_of_iso (ฯ : Sโ โถ Sโ) [IsIso ฯ] [Sโ.HasLeftHomology]
    [Sโ.HasLeftHomology] : IsIso (cycles_map ฯ) :=
  (inferInstance : IsIso (cycles_map_iso (asIso ฯ)).hom)

variable {S}

noncomputable def LeftHomologyData.leftHomology_iso (h : S.LeftHomologyData) [S.HasLeftHomology] :
  S.leftHomology โ h.H := leftHomology_map_iso' (Iso.refl _) _ _

noncomputable def LeftHomologyData.cycles_iso (h : S.LeftHomologyData) [S.HasLeftHomology] :
  S.cycles โ h.K := cycles_map_iso' (Iso.refl _) _ _

@[reassoc (attr := simp)]
lemma LeftHomologyData.cycles_iso_hom_comp_i (h : S.LeftHomologyData) [S.HasLeftHomology] :
    h.cycles_iso.hom โซ h.i = S.cycles_i := by
  dsimp [cycles_i, LeftHomologyData.cycles_iso]
  simp only [cycles_map'_i, id_ฯโ, comp_id]

@[reassoc (attr := simp)]
lemma LeftHomologyData.cycles_iso_inv_comp_cycles_i (h : S.LeftHomologyData)
    [S.HasLeftHomology] : h.cycles_iso.inv โซ S.cycles_i = h.i := by
  simp only [โ h.cycles_iso_hom_comp_i, Iso.inv_hom_id_assoc]

namespace LeftHomologyMapData

variable {ฯ : Sโ โถ Sโ} {hโ : Sโ.LeftHomologyData} {hโ : Sโ.LeftHomologyData}
  (ฮณ : LeftHomologyMapData ฯ hโ hโ)

lemma leftHomology_map_eq [Sโ.HasLeftHomology] [Sโ.HasLeftHomology] :
    leftHomology_map ฯ = hโ.leftHomology_iso.hom โซ ฮณ.ฯH โซ hโ.leftHomology_iso.inv := by
  dsimp [LeftHomologyData.leftHomology_iso, leftHomology_map_iso']
  rw [โ ฮณ.leftHomology_map'_eq, โ leftHomology_map'_comp,
    โ leftHomology_map'_comp, id_comp, comp_id]
  rfl

lemma cycles_map_eq [Sโ.HasLeftHomology] [Sโ.HasLeftHomology] :
    cycles_map ฯ = hโ.cycles_iso.hom โซ ฮณ.ฯK โซ hโ.cycles_iso.inv := by
  dsimp [LeftHomologyData.cycles_iso, cycles_map_iso']
  rw [โ ฮณ.cycles_map'_eq, โ cycles_map'_comp, โ cycles_map'_comp, id_comp, comp_id]
  rfl

lemma leftHomology_map_comm [Sโ.HasLeftHomology] [Sโ.HasLeftHomology] :
    leftHomology_map ฯ โซ hโ.leftHomology_iso.hom = hโ.leftHomology_iso.hom โซ ฮณ.ฯH := by
  simp only [ฮณ.leftHomology_map_eq, assoc, Iso.inv_hom_id, comp_id]

lemma cycles_map_comm [Sโ.HasLeftHomology] [Sโ.HasLeftHomology] :
    cycles_map ฯ โซ hโ.cycles_iso.hom = hโ.cycles_iso.hom โซ ฮณ.ฯK := by
  simp only [ฮณ.cycles_map_eq, assoc, Iso.inv_hom_id, comp_id]

end LeftHomologyMapData

variable (C)

/-- We shall say that a category with left homology is a category for which
all short complexes have left homology. -/
abbrev _root_.CategoryTheory.CategoryWithLeftHomology : Prop :=
  โ (S : ShortComplex C), S.HasLeftHomology

@[simps]
noncomputable def leftHomology_functor [CategoryWithLeftHomology C] :
    ShortComplex C โฅค C where
  obj S := S.leftHomology
  map := leftHomology_map

@[simps]
noncomputable def cycles_functor [CategoryWithLeftHomology C] :
    ShortComplex C โฅค C where
  obj S := S.cycles
  map := cycles_map

@[simps]
noncomputable def leftHomology_ฯ_natTrans [CategoryWithLeftHomology C] :
    cycles_functor C โถ leftHomology_functor C where
  app S := leftHomology_ฯ S
  naturality := fun _ _ ฯ => (leftHomology_ฯ_naturality ฯ).symm

@[simps]
noncomputable def cycles_i_natTrans [CategoryWithLeftHomology C] :
    cycles_functor C โถ ShortComplex.ฯโ where
  app S := S.cycles_i

@[simps]
noncomputable def toCycles_natTrans [CategoryWithLeftHomology C] :
    ฯโ โถ cycles_functor C where
  app S := S.toCycles
  naturality := fun _ _  ฯ => (toCycles_naturality ฯ).symm

namespace LeftHomologyData

variable {C}

@[simps]
noncomputable def of_epi_of_isIso_of_mono (ฯ : Sโ โถ Sโ) (h : LeftHomologyData Sโ)
  [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ] : LeftHomologyData Sโ := by
  let i : h.K โถ Sโ.Xโ := h.i โซ ฯ.ฯโ
  have wi : i โซ Sโ.g = 0 := by simp only [assoc, ฯ.commโโ, h.wi_assoc, zero_comp]
  have hi : IsLimit (KernelFork.ofฮน i wi) := KernelFork.IsLimit.ofฮน _ _
    (fun x hx => h.lift_K (x โซ inv ฯ.ฯโ) (by rw [assoc, โ cancel_mono ฯ.ฯโ, assoc,
      assoc, โ ฯ.commโโ, IsIso.inv_hom_id_assoc, hx, zero_comp]))
    (fun x hx => by simp) (fun x hx b hb => by
      dsimp
      rw [โ cancel_mono h.i, โ cancel_mono ฯ.ฯโ, assoc, assoc, lift_K_i_assoc,
        assoc, IsIso.inv_hom_id, comp_id, hb])
  let f' := hi.lift (KernelFork.ofฮน Sโ.f Sโ.zero)
  have hf' : ฯ.ฯโ โซ f' = h.f' := by
    have eq := @Fork.IsLimit.lift_ฮน _ _ _ _ _ _ _ ((KernelFork.ofฮน Sโ.f Sโ.zero)) hi
    simp only [Fork.ฮน_ofฮน] at eq
    rw [โ cancel_mono h.i, โ cancel_mono ฯ.ฯโ, assoc, assoc, eq, f'_i, ฯ.commโโ]
  have wฯ : f' โซ h.ฯ = 0 := by
    rw [โ cancel_epi ฯ.ฯโ, comp_zero, reassoc_of% hf', h.f'_ฯ]
  have hฯ : IsColimit (CokernelCofork.ofฯ h.ฯ wฯ) := CokernelCofork.IsColimit.ofฯ _ _
    (fun x hx => h.desc_H x (by rw [โ hf', assoc, hx, comp_zero]))
    (fun x hx => by simp) (fun x hx b hb => by rw [โ cancel_epi h.ฯ, ฯ_desc_H, hb])
  exact โจh.K, h.H, i, h.ฯ, wi, hi, wฯ, hฯโฉ

@[simp]
lemma of_epi_of_isIso_of_mono_ฯโ_f' (ฯ : Sโ โถ Sโ) (h : LeftHomologyData Sโ)
    [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ] : ฯ.ฯโ โซ (of_epi_of_isIso_of_mono ฯ h).f' = h.f' := by
  rw [โ cancel_mono (of_epi_of_isIso_of_mono ฯ h).i, assoc, f'_i,
    of_epi_of_isIso_of_mono_i, f'_i_assoc, ฯ.commโโ]

@[simps]
noncomputable def of_epi_of_isIso_of_mono' (ฯ : Sโ โถ Sโ) (h : LeftHomologyData Sโ)
    [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ] : LeftHomologyData Sโ := by
  let i : h.K โถ Sโ.Xโ := h.i โซ inv ฯ.ฯโ
  have wi : i โซ Sโ.g = 0 := by
    rw [assoc, โ cancel_mono ฯ.ฯโ, zero_comp, assoc, assoc, โ ฯ.commโโ,
      IsIso.inv_hom_id_assoc, h.wi]
  have hi : IsLimit (KernelFork.ofฮน i wi) := KernelFork.IsLimit.ofฮน _ _
    (fun x hx => h.lift_K (x โซ ฯ.ฯโ)
      (by rw [assoc, ฯ.commโโ, reassoc_of% hx, zero_comp]))
    (fun x hx => by simp )
    (fun x hx b hb => by rw [โ cancel_mono h.i, โ cancel_mono (inv ฯ.ฯโ), assoc, assoc,
      hb, lift_K_i_assoc, assoc, IsIso.hom_inv_id, comp_id])
  let f' := hi.lift (KernelFork.ofฮน Sโ.f Sโ.zero)
  have hf' : f' โซ i = Sโ.f := Fork.IsLimit.lift_ฮน _
  have hf'' : f' = ฯ.ฯโ โซ h.f' := by
    rw [โ cancel_mono h.i, โ cancel_mono (inv ฯ.ฯโ), assoc, assoc, assoc, hf', f'_i_assoc,
      ฯ.commโโ_assoc, IsIso.hom_inv_id, comp_id]
  have wฯ : f' โซ h.ฯ = 0 := by simp only [hf'', assoc, f'_ฯ, comp_zero]
  have hฯ : IsColimit (CokernelCofork.ofฯ h.ฯ wฯ) := CokernelCofork.IsColimit.ofฯ _ _
    (fun x hx => h.desc_H x (by rw [โ cancel_epi ฯ.ฯโ, โ reassoc_of% hf'', hx, comp_zero]))
    (fun x hx => ฯ_desc_H _ _ _)
    (fun x hx b hx => by rw [โ cancel_epi h.ฯ, ฯ_desc_H, hx])
  exact โจh.K, h.H, i, h.ฯ, wi, hi, wฯ, hฯโฉ

@[simp]
lemma of_epi_of_is_iso_of_mono'_f' (ฯ : Sโ โถ Sโ) (h : LeftHomologyData Sโ)
    [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ] :
  (of_epi_of_isIso_of_mono' ฯ h).f' = ฯ.ฯโ โซ h.f' :=
by rw [โ cancel_mono (of_epi_of_isIso_of_mono' ฯ h).i, f'_i, of_epi_of_isIso_of_mono'_i,
    assoc, f'_i_assoc, ฯ.commโโ_assoc, IsIso.hom_inv_id, comp_id]

noncomputable def of_iso (e : Sโ โ Sโ) (hโ : LeftHomologyData Sโ) : LeftHomologyData Sโ :=
  hโ.of_epi_of_isIso_of_mono e.hom

end LeftHomologyData

variable {C}

lemma HasLeftHomology_of_epi_of_is_iso_of_mono (ฯ : Sโ โถ Sโ) [HasLeftHomology Sโ]
    [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ] : HasLeftHomology Sโ :=
  HasLeftHomology.mk' (LeftHomologyData.of_epi_of_isIso_of_mono ฯ Sโ.leftHomologyData)

lemma HasLeftHomology_of_epi_of_is_iso_of_mono' (ฯ : Sโ โถ Sโ) [HasLeftHomology Sโ]
    [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ] : HasLeftHomology Sโ :=
HasLeftHomology.mk' (LeftHomologyData.of_epi_of_isIso_of_mono' ฯ Sโ.leftHomologyData)

lemma HasLeftHomology_of_iso {Sโ Sโ : ShortComplex C}
    (e : Sโ โ Sโ) [HasLeftHomology Sโ] : HasLeftHomology Sโ :=
  HasLeftHomology_of_epi_of_is_iso_of_mono e.hom

namespace LeftHomologyMapData

@[simps]
def of_epi_of_isIso_of_mono (ฯ : Sโ โถ Sโ) (h : LeftHomologyData Sโ)
    [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ] :
    LeftHomologyMapData ฯ h (LeftHomologyData.of_epi_of_isIso_of_mono ฯ h) where
  ฯK := ๐ _
  ฯH := ๐ _
  commf' := by simp only [LeftHomologyData.of_epi_of_isIso_of_mono_ฯโ_f' ฯ h, comp_id]

@[simps]
noncomputable def of_epi_of_isIso_of_mono' (ฯ : Sโ โถ Sโ) (h : LeftHomologyData Sโ)
  [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ] :
    LeftHomologyMapData ฯ (LeftHomologyData.of_epi_of_isIso_of_mono' ฯ h) h :=
{ ฯK := ๐ _,
  ฯH := ๐ _, }

end LeftHomologyMapData

instance (ฯ : Sโ โถ Sโ) (hโ : Sโ.LeftHomologyData) (hโ : Sโ.LeftHomologyData)
    [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ] :
    IsIso (leftHomology_map' ฯ hโ hโ) := by
  let hโ' := LeftHomologyData.of_epi_of_isIso_of_mono ฯ hโ
  haveI : IsIso (leftHomology_map' ฯ hโ hโ') := by
    rw [(LeftHomologyMapData.of_epi_of_isIso_of_mono ฯ hโ).leftHomology_map'_eq]
    dsimp
    infer_instance
  have eq := leftHomology_map'_comp ฯ (๐ Sโ) hโ hโ' hโ
  rw [comp_id] at eq
  rw [eq]
  infer_instance

instance (ฯ : Sโ โถ Sโ) [Sโ.HasLeftHomology] [Sโ.HasLeftHomology]
    [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ] :
    IsIso (leftHomology_map ฯ) := by
  dsimp only [leftHomology_map]
  infer_instance

section

variable (S) (h : LeftHomologyData S)
  {A : C} (k : A โถ S.Xโ) (hk : k โซ S.g = 0) [HasLeftHomology S]

noncomputable def lift_cycles : A โถ S.cycles :=
  S.leftHomologyData.lift_K k hk

@[reassoc (attr := simp)]
lemma lift_cycles_i : S.lift_cycles k hk โซ S.cycles_i = k :=
  LeftHomologyData.lift_K_i _ k hk

@[reassoc]
lemma comp_lift_cycles {A' : C} (ฮฑ : A' โถ A) :
    ฮฑ โซ S.lift_cycles k hk = S.lift_cycles (ฮฑ โซ k) (by rw [assoc, hk, comp_zero]) := by
  simp only [โ cancel_mono S.cycles_i, assoc, lift_cycles_i]

noncomputable def cycles_is_kernel : IsLimit (KernelFork.ofฮน S.cycles_i S.cycles_i_g) :=
  S.leftHomologyData.hi

lemma isIso_cycles_i_of (hg : S.g = 0) : IsIso (S.cycles_i) :=
  KernelFork.IsLimit.isIso_ฮน_of_zero _ S.cycles_is_kernel hg

@[simps]
noncomputable def cycles_iso_kernel [HasKernel S.g] : S.cycles โ kernel S.g where
  hom := kernel.lift S.g S.cycles_i (by simp)
  inv := S.lift_cycles (kernel.ฮน S.g) (by simp)
  hom_inv_id := by simp only [โ  cancel_mono S.cycles_i, assoc, lift_cycles_i,
    kernel.lift_ฮน, id_comp]
  inv_hom_id := by simp only [โ cancel_mono (kernel.ฮน S.g), assoc, kernel.lift_ฮน,
    lift_cycles_i, id_comp]

@[simp]
noncomputable def lift_leftHomology : A โถ S.leftHomology :=
  S.lift_cycles k hk โซ S.leftHomology_ฯ

lemma lift_cycles_ฯ_eq_zero_of_boundary (x : A โถ S.Xโ) (hx : k = x โซ S.f) :
    S.lift_cycles k (by rw [hx, assoc, S.zero, comp_zero])โซ S.leftHomology_ฯ = 0 :=
  LeftHomologyData.lift_K_ฯ_eq_zero_of_boundary _ k x hx

@[reassoc (attr := simp)]
lemma toCycles_comp_leftHomology_ฯ :
  S.toCycles โซ S.leftHomology_ฯ = 0 :=
S.lift_cycles_ฯ_eq_zero_of_boundary S.f (๐ _) (by rw [id_comp])

noncomputable def leftHomology_is_cokernel :
    IsColimit (CokernelCofork.ofฯ S.leftHomology_ฯ S.toCycles_comp_leftHomology_ฯ) :=
  S.leftHomologyData.hฯ

@[reassoc (attr := simp)]
lemma lift_cycles_comp_cycles_map (ฯ : S โถ Sโ) [Sโ.HasLeftHomology] :
  S.lift_cycles k hk โซ cycles_map ฯ =
    Sโ.lift_cycles (k โซ ฯ.ฯโ) (by rw [assoc, ฯ.commโโ, reassoc_of% hk, zero_comp]) :=
by simp only [โ cancel_mono (Sโ.cycles_i), assoc, cycles_map_i, lift_cycles_i_assoc, lift_cycles_i]

variable {S}

@[reassoc (attr := simp)]
lemma LeftHomologyData.leftHomology_ฯ_comp_leftHomology_iso_hom :
    S.leftHomology_ฯ โซ h.leftHomology_iso.hom = h.cycles_iso.hom โซ h.ฯ := by
  dsimp only [leftHomology_ฯ, leftHomology_iso, cycles_iso, leftHomology_map_iso',
    cycles_map_iso', Iso.refl]
  rw [โ leftHomology_ฯ_naturality']

@[reassoc (attr := simp)]
lemma LeftHomologyData.ฯ_comp_left_homology_iso_inv :
    h.ฯ โซ h.leftHomology_iso.inv = h.cycles_iso.inv โซ S.leftHomology_ฯ := by
  simp only [โ cancel_epi h.cycles_iso.hom, โ cancel_mono h.leftHomology_iso.hom, assoc,
    Iso.inv_hom_id, comp_id, Iso.hom_inv_id_assoc,
    LeftHomologyData.leftHomology_ฯ_comp_leftHomology_iso_hom]

@[reassoc (attr := simp)]
lemma LeftHomologyData.lift_cycles_comp_cycles_iso_hom :
  S.lift_cycles k hk โซ h.cycles_iso.hom = h.lift_K k hk :=
by simp only [โcancel_mono h.i, assoc, LeftHomologyData.cycles_iso_hom_comp_i,
  lift_cycles_i, LeftHomologyData.lift_K_i]

@[simp]
lemma LeftHomologyData.lift_K_comp_cycles_iso_inv :
    h.lift_K k hk โซ h.cycles_iso.inv = S.lift_cycles k hk := by
  rw [โ h.lift_cycles_comp_cycles_iso_hom, assoc, Iso.hom_inv_id, comp_id]

lemma LeftHomologyData.ext_iff' (fโ fโ : S.leftHomology โถ A) :
    fโ = fโ โ h.ฯ โซ h.leftHomology_iso.inv โซ fโ = h.ฯ โซ h.leftHomology_iso.inv โซ fโ := by
  rw [โ cancel_epi h.leftHomology_iso.inv, cancel_epi h.ฯ]

end

namespace HasLeftHomology

variable (S)

lemma hasKernel [S.HasLeftHomology] : HasKernel S.g :=
โจโจโจ_, S.leftHomologyData.hiโฉโฉโฉ

lemma hasCokernel [S.HasLeftHomology] [HasKernel S.g] :
    HasCokernel (kernel.lift S.g S.f S.zero) := by
  let h := S.leftHomologyData
  haveI : HasColimit (parallelPair h.f' 0) := โจโจโจ_, h.hฯ'โฉโฉโฉ
  let e : parallelPair (kernel.lift S.g S.f S.zero) 0 โ parallelPair h.f' 0 :=
    parallelPair.ext (Iso.refl _)
      (IsLimit.conePointUniqueUpToIso (kernelIsKernel S.g) h.hi)
      (by aesop_cat) (by aesop_cat)
  exact hasColimitOfIso e

end HasLeftHomology

noncomputable def leftHomology_iso_cokernel_lift [S.HasLeftHomology] [HasKernel S.g]
    [HasCokernel (kernel.lift S.g S.f S.zero)] :
    S.leftHomology โ cokernel (kernel.lift S.g S.f S.zero) :=
  (LeftHomologyData.of_ker_of_coker S).leftHomology_iso

namespace LeftHomologyData

lemma isIso_i_of_zero_g (h : LeftHomologyData S) (hg : S.g = 0) : IsIso h.i :=
  โจโจh.lift_K (๐ S.Xโ) (by rw [hg, id_comp]),
    by simp only [โ cancel_mono h.i, id_comp, assoc, lift_K_i, comp_id], lift_K_i _ _ _โฉโฉ

end LeftHomologyData

end ShortComplex

end CategoryTheory
