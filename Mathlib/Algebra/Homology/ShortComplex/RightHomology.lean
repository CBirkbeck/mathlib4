import Mathlib.Algebra.Homology.ShortComplex.LeftHomology

open ZeroObject

namespace CategoryTheory

open Category Limits

namespace ShortComplex

variable {C D : Type _} [Category C] [Category D]
  [HasZeroMorphisms C]
  (S : ShortComplex C) {Sโ Sโ Sโ : ShortComplex C}

structure RightHomologyData :=
(Q H : C)
(p : S.Xโ โถ Q)
(ฮน : H โถ Q)
(wp : S.f โซ p = 0)
(hp : IsColimit (CokernelCofork.ofฯ p wp))
(wฮน : ฮน โซ hp.desc (CokernelCofork.ofฯ _ S.zero) = 0)
(hฮน : IsLimit (KernelFork.ofฮน ฮน wฮน))

initialize_simps_projections RightHomologyData (-hp, -hฮน)

namespace RightHomologyData

@[simps]
noncomputable def of_ker_of_coker [HasCokernel S.f] [HasKernel (cokernel.desc S.f S.g S.zero)] :
  S.RightHomologyData :=
{ Q := cokernel S.f,
  H := kernel (cokernel.desc S.f S.g S.zero),
  p := cokernel.ฯ _,
  ฮน := kernel.ฮน _,
  wp := cokernel.condition _,
  hp := cokernelIsCokernel _,
  wฮน := kernel.condition _,
  hฮน := kernelIsKernel _, }

attribute [reassoc (attr := simp)] wp wฮน

variable {S}
variable (h : S.RightHomologyData) {A : C}

instance : Epi h.p :=
  โจfun _ _ => Cofork.IsColimit.hom_ext h.hpโฉ

instance : Mono h.ฮน :=
  โจfun _ _ => Fork.IsLimit.hom_ext h.hฮนโฉ

def desc_Q (k : S.Xโ โถ A) (hk : S.f โซ k = 0) : h.Q โถ A :=
h.hp.desc (CokernelCofork.ofฯ k hk)

@[reassoc (attr := simp)]
lemma p_desc_Q (k : S.Xโ โถ A) (hk : S.f โซ k = 0) :
  h.p โซ h.desc_Q k hk = k :=
h.hp.fac _ WalkingParallelPair.one

@[simp]
def desc_H (k : S.Xโ โถ A) (hk : S.f โซ k = 0) : h.H โถ A :=
  h.ฮน โซ h.desc_Q k hk

/-- The morphism `h.Q โถ S.Xโ` induced by `S.g : S.Xโ โถ S.Xโ` and the fact that
`h.Q` is a cokernel of `S.f : S.Xโ โถ S.Xโ`. -/
def g' : h.Q โถ S.Xโ := h.desc_Q S.g S.zero

@[reassoc (attr := simp)]
lemma p_g' : h.p โซ h.g' = S.g :=
p_desc_Q _ _ _

@[reassoc (attr := simp)]
lemma ฮน_g' : h.ฮน โซ h.g' = 0 := h.wฮน

@[reassoc]
lemma ฮน_desc_Q_eq_zero_of_boundary (k : S.Xโ โถ A) (x : S.Xโ โถ A) (hx : k = S.g โซ x) :
  h.ฮน โซ h.desc_Q k (by rw [hx, S.zero_assoc, zero_comp]) = 0 := by
  rw [show 0 = h.ฮน โซ h.g' โซ x by simp]
  congr 1
  simp only [โ cancel_epi h.p, hx, p_desc_Q, p_g'_assoc]

/-- For `h : S.RightHomologyData`, this is a restatement of `h.hฮน `, saying that
`ฮน : h.H โถ h.Q` is a kernel of `h.g' : h.Q โถ S.Xโ`. -/
def hฮน' : IsLimit (KernelFork.ofฮน h.ฮน h.ฮน_g') := h.hฮน

def lift_H (k : A โถ h.Q) (hk : k โซ h.g' = 0) :
  A โถ h.H :=
h.hฮน.lift (KernelFork.ofฮน k hk)

@[reassoc (attr := simp)]
lemma lift_H_ฮน (k : A โถ h.Q) (hk : k โซ h.g' = 0) :
  h.lift_H k hk โซ h.ฮน = k :=
h.hฮน.fac (KernelFork.ofฮน k hk) WalkingParallelPair.zero

variable (S)

@[simps]
def of_isLimit_kernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :
  S.RightHomologyData where
  Q := S.Xโ
  H := c.pt
  p := ๐ _
  ฮน := c.ฮน
  wp := by rw [comp_id, hf]
  hp := CokernelCofork.IsColimit.of_id _ hf
  wฮน := KernelFork.condition _
  hฮน := IsLimit.ofIsoLimit hc (Fork.ext (Iso.refl _) (by aesop_cat))

@[simp] lemma of_isLimit_kernelFork_g' (hf : S.f = 0) (c : KernelFork S.g)
    (hc : IsLimit c) : (of_isLimit_kernelFork S hf c hc).g' = S.g := by
  rw [โ cancel_epi (of_isLimit_kernelFork S hf c hc).p, p_g',
    of_isLimit_kernelFork_p, id_comp]

@[simps!]
noncomputable def of_hasKernel [HasKernel S.g] (hf : S.f = 0) : S.RightHomologyData :=
of_isLimit_kernelFork S hf _ (kernelIsKernel _)

@[simps]
def of_isColimit_cokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :
  S.RightHomologyData where
  Q := c.pt
  H := c.pt
  p := c.ฯ
  ฮน := ๐ _
  wp := CokernelCofork.condition _
  hp := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _) (by aesop_cat))
  wฮน := Cofork.IsColimit.hom_ext hc (by simp [hg])
  hฮน := KernelFork.IsLimit.of_id _ (Cofork.IsColimit.hom_ext hc (by simp [hg]))

@[simp] lemma of_isColimit_cokernelCofork_g' (hg : S.g = 0) (c : CokernelCofork S.f)
  (hc : IsColimit c) : (of_isColimit_cokernelCofork S hg c hc).g' = 0 :=
by rw [โ cancel_epi (of_isColimit_cokernelCofork S hg c hc).p, p_g', hg, comp_zero]

@[simp]
noncomputable def of_hasCokernel [HasCokernel S.f] (hg : S.g = 0) : S.RightHomologyData :=
of_isColimit_cokernelCofork S hg _ (cokernelIsCokernel _)

@[simps]
def of_zeros (hf : S.f = 0) (hg : S.g = 0) : S.RightHomologyData where
  Q := S.Xโ
  H := S.Xโ
  p := ๐ _
  ฮน := ๐ _
  wp := by rw [comp_id, hf]
  hp := CokernelCofork.IsColimit.of_id _ hf
  wฮน := by
    change ๐ _ โซ S.g = 0
    simp only [hg, comp_zero]
  hฮน := KernelFork.IsLimit.of_id _ hg

@[simp]
lemma of_zeros_g' (hf : S.f = 0) (hg : S.g = 0) :
    (of_zeros S hf hg).g' = 0 := by
  rw [โ cancel_epi ((of_zeros S hf hg).p), comp_zero, p_g', hg]

@[simps]
noncomputable def cokernel_sequence' {X Y : C} (f : X โถ Y) (c : CokernelCofork f)
    (hc : IsColimit c) [HasZeroObject C] :
    RightHomologyData (ShortComplex.mk f c.ฯ c.condition) where
  Q := c.pt
  H := 0
  p := c.ฯ
  ฮน := 0
  wp := c.condition
  hp := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _) (by simp))
  wฮน := Subsingleton.elim _ _
  hฮน := by
    refine' KernelFork.IsLimit.of_isZero_of_mono _ _ _
    . dsimp
      convert (inferInstance : Mono (๐ c.pt))
      haveI := epi_of_isColimit_cofork hc
      rw [โ cancel_epi c.ฯ]
      simp only [parallelPair_obj_one, Functor.const_obj_obj, id_comp,
        Cofork.IsColimit.ฯ_desc, Cofork.ฯ_ofฯ, comp_id]
    . apply isZero_zero

@[simps!]
noncomputable def cokernel_sequence {X Y : C} (f : X โถ Y) [HasCokernel f] [HasZeroObject C] :
    RightHomologyData (ShortComplex.mk f (cokernel.ฯ f) (cokernel.condition f)) := by
  let h := cokernel_sequence' f _ (cokernelIsCokernel f)
  exact h

end RightHomologyData

class HasRightHomology : Prop :=
(condition : Nonempty S.RightHomologyData)

noncomputable def rightHomologyData [HasRightHomology S] :
  S.RightHomologyData := HasRightHomology.condition.some

variable {S}

namespace HasRightHomology

lemma mk' (h : S.RightHomologyData) : HasRightHomology S :=
โจNonempty.intro hโฉ

instance of_ker_of_coker
    [HasCokernel S.f] [HasKernel (cokernel.desc S.f S.g S.zero)] :
  S.HasRightHomology := HasRightHomology.mk' (RightHomologyData.of_ker_of_coker S)

instance of_hasKernel {Y Z : C} (g : Y โถ Z) (X : C) [HasKernel g] :
    (ShortComplex.mk (0 : X โถ Y) g zero_comp).HasRightHomology :=
  HasRightHomology.mk' (RightHomologyData.of_hasKernel _ rfl)

instance of_hasCokernel {X Y : C} (f : X โถ Y) (Z : C) [HasCokernel f] :
    (ShortComplex.mk f (0 : Y โถ Z) comp_zero).HasRightHomology :=
  HasRightHomology.mk' (RightHomologyData.of_hasCokernel _ rfl)

instance of_zeros (X Y Z : C) :
    (ShortComplex.mk (0 : X โถ Y) (0 : Y โถ Z) zero_comp).HasRightHomology :=
  HasRightHomology.mk' (RightHomologyData.of_zeros _ rfl rfl)

end HasRightHomology

namespace RightHomologyData

@[simps]
def op (h : S.RightHomologyData) : S.op.LeftHomologyData where
  K := Opposite.op h.Q
  H := Opposite.op h.H
  i := h.p.op
  ฯ := h.ฮน.op
  wi := Quiver.Hom.unop_inj h.wp
  hi := CokernelCofork.IsColimit.ofฯ_op _ _ h.hp
  wฯ := Quiver.Hom.unop_inj h.wฮน
  hฯ := KernelFork.IsLimit.ofฮน_op _ _ h.hฮน

@[simp] lemma op_f' (h : S.RightHomologyData) :
    h.op.f' = h.g'.op := rfl

@[simps]
def unop {S : ShortComplex Cแตแต} (h : S.RightHomologyData) : S.unop.LeftHomologyData where
  K := Opposite.unop h.Q
  H := Opposite.unop h.H
  i := h.p.unop
  ฯ := h.ฮน.unop
  wi := Quiver.Hom.op_inj h.wp
  hi := CokernelCofork.IsColimit.ofฯ_unop _ _ h.hp
  wฯ := Quiver.Hom.op_inj h.wฮน
  hฯ := KernelFork.IsLimit.ofฮน_unop _ _ h.hฮน

@[simp] lemma unop_f' {S : ShortComplex Cแตแต} (h : S.RightHomologyData) :
    h.unop.f' = h.g'.unop := rfl

end RightHomologyData

namespace LeftHomologyData

@[simps]
def op (h : S.LeftHomologyData) : S.op.RightHomologyData where
  Q := Opposite.op h.K
  H := Opposite.op h.H
  p := h.i.op
  ฮน := h.ฯ.op
  wp := Quiver.Hom.unop_inj h.wi
  hp := KernelFork.IsLimit.ofฮน_op _ _ h.hi
  wฮน := Quiver.Hom.unop_inj h.wฯ
  hฮน := CokernelCofork.IsColimit.ofฯ_op _ _ h.hฯ

@[simp] lemma op_g' (h : S.LeftHomologyData) :
    h.op.g' = h.f'.op := rfl

@[simps]
def unop {S : ShortComplex Cแตแต} (h : S.LeftHomologyData) : S.unop.RightHomologyData where
  Q := Opposite.unop h.K
  H := Opposite.unop h.H
  p := h.i.op
  ฮน := h.ฯ.op
  wp := Quiver.Hom.op_inj h.wi
  hp := KernelFork.IsLimit.ofฮน_unop _ _ h.hi
  wฮน := Quiver.Hom.op_inj h.wฯ
  hฮน := CokernelCofork.IsColimit.ofฯ_unop _ _ h.hฯ

@[simp] lemma unop_g' {S : ShortComplex Cแตแต} (h : S.LeftHomologyData) :
    h.unop.g' = h.f'.unop := rfl

end LeftHomologyData

instance [S.HasLeftHomology] : HasRightHomology S.op :=
  HasRightHomology.mk' S.leftHomologyData.op

instance [S.HasRightHomology] : HasLeftHomology S.op :=
  HasLeftHomology.mk' S.rightHomologyData.op

lemma hasLeftHomology_iff_op (S : ShortComplex C) :
    S.HasLeftHomology โ S.op.HasRightHomology :=
  โจfun _ => inferInstance, fun _ => HasLeftHomology.mk' S.op.rightHomologyData.unopโฉ

lemma hasRightHomology_iff_op (S : ShortComplex C) :
    S.HasRightHomology โ S.op.HasLeftHomology :=
  โจfun _ => inferInstance, fun _ => HasRightHomology.mk' S.op.leftHomologyData.unopโฉ

lemma hasLeftHomology_iff_unop (S : ShortComplex Cแตแต) :
    S.HasLeftHomology โ S.unop.HasRightHomology :=
  S.unop.hasRightHomology_iff_op.symm

lemma hasRightHomology_iff_unop (S : ShortComplex Cแตแต) :
    S.HasRightHomology โ S.unop.HasLeftHomology :=
  S.unop.hasLeftHomology_iff_op.symm

section

variable (ฯ : Sโ โถ Sโ) (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData)

structure RightHomologyMapData where
  ฯQ : hโ.Q โถ hโ.Q
  ฯH : hโ.H โถ hโ.H
  commp : hโ.p โซ ฯQ = ฯ.ฯโ โซ hโ.p := by aesop_cat
  commg' : ฯQ โซ hโ.g' = hโ.g' โซ ฯ.ฯโ := by aesop_cat
  commฮน : ฯH โซ hโ.ฮน = hโ.ฮน โซ ฯQ := by aesop_cat

namespace RightHomologyMapData

attribute [reassoc (attr := simp)] commp commg' commฮน

@[simps]
def zero (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData) :
  RightHomologyMapData 0 hโ hโ where
  ฯQ := 0
  ฯH := 0

@[simps]
def id (h : S.RightHomologyData) : RightHomologyMapData (๐ S) h h where
  ฯQ := ๐ _
  ฯH := ๐ _

@[simps]
def comp {ฯ : Sโ โถ Sโ} {ฯ' : Sโ โถ Sโ} {hโ : Sโ.RightHomologyData}
  {hโ : Sโ.RightHomologyData} {hโ : Sโ.RightHomologyData}
  (ฯ : RightHomologyMapData ฯ hโ hโ) (ฯ' : RightHomologyMapData ฯ' hโ hโ) :
  RightHomologyMapData (ฯ โซ ฯ') hโ hโ where
  ฯQ := ฯ.ฯQ โซ ฯ'.ฯQ
  ฯH := ฯ.ฯH โซ ฯ'.ฯH

instance : Subsingleton (RightHomologyMapData ฯ hโ hโ) :=
  โจfun ฯโ ฯโ => by
    have hQ : ฯโ.ฯQ = ฯโ.ฯQ := by rw [โ cancel_epi hโ.p, commp, commp]
    have hH : ฯโ.ฯH = ฯโ.ฯH := by rw [โ cancel_mono hโ.ฮน, commฮน, commฮน, hQ]
    cases ฯโ
    cases ฯโ
    congrโฉ

instance : Inhabited (RightHomologyMapData ฯ hโ hโ) := โจby
  let ฯQ : hโ.Q โถ hโ.Q := hโ.desc_Q (ฯ.ฯโ โซ hโ.p) (by rw [โ ฯ.commโโ_assoc, hโ.wp, comp_zero])
  have commg' : ฯQ โซ hโ.g' = hโ.g' โซ ฯ.ฯโ :=
    by rw [โ cancel_epi hโ.p, RightHomologyData.p_desc_Q_assoc, assoc,
      RightHomologyData.p_g', ฯ.commโโ, RightHomologyData.p_g'_assoc]
  let ฯH : hโ.H โถ hโ.H := hโ.lift_H (hโ.ฮน โซ ฯQ)
    (by rw [assoc, commg', RightHomologyData.ฮน_g'_assoc, zero_comp])
  exact โจฯQ, ฯH, by simp, commg', by simpโฉโฉ

instance : Unique (RightHomologyMapData ฯ hโ hโ) := Unique.mk' _

def _root_.CategoryTheory.ShortComplex.rightHomologyMapData :
  RightHomologyMapData ฯ hโ hโ := default

variable {ฯ hโ hโ}

lemma congr_ฯH {ฮณโ ฮณโ : RightHomologyMapData ฯ hโ hโ} (eq : ฮณโ = ฮณโ) : ฮณโ.ฯH = ฮณโ.ฯH := by rw [eq]
lemma congr_ฯQ {ฮณโ ฮณโ : RightHomologyMapData ฯ hโ hโ} (eq : ฮณโ = ฮณโ) : ฮณโ.ฯQ = ฮณโ.ฯQ := by rw [eq]

@[simps]
def of_zeros (ฯ : Sโ โถ Sโ) (hfโ : Sโ.f = 0) (hgโ : Sโ.g = 0) (hfโ : Sโ.f = 0) (hgโ : Sโ.g = 0) :
  RightHomologyMapData ฯ (RightHomologyData.of_zeros Sโ hfโ hgโ)
    (RightHomologyData.of_zeros Sโ hfโ hgโ) where
  ฯQ := ฯ.ฯโ
  ฯH := ฯ.ฯโ

@[simps]
def of_isLimit_kernelFork (ฯ : Sโ โถ Sโ)
    (hfโ : Sโ.f = 0) (cโ : KernelFork Sโ.g) (hcโ : IsLimit cโ)
    (hfโ : Sโ.f = 0) (cโ : KernelFork Sโ.g) (hcโ : IsLimit cโ) (f : cโ.pt โถ cโ.pt)
    (comm : cโ.ฮน โซ ฯ.ฯโ = f โซ cโ.ฮน) :
    RightHomologyMapData ฯ (RightHomologyData.of_isLimit_kernelFork Sโ hfโ cโ hcโ)
      (RightHomologyData.of_isLimit_kernelFork Sโ hfโ cโ hcโ) where
  ฯQ := ฯ.ฯโ
  ฯH := f
  commg' := by simp only [RightHomologyData.of_isLimit_kernelFork_Q,
    RightHomologyData.of_isLimit_kernelFork_g', ฯ.commโโ]
  commฮน := comm.symm

@[simps]
def of_isColimit_cokernelCofork (ฯ : Sโ โถ Sโ)
  (hgโ : Sโ.g = 0) (cโ : CokernelCofork Sโ.f) (hcโ : IsColimit cโ)
  (hgโ : Sโ.g = 0) (cโ : CokernelCofork Sโ.f) (hcโ : IsColimit cโ) (f : cโ.pt โถ cโ.pt)
  (comm : ฯ.ฯโ โซ cโ.ฯ = cโ.ฯ โซ f) :
  RightHomologyMapData ฯ (RightHomologyData.of_isColimit_cokernelCofork Sโ hgโ cโ hcโ)
    (RightHomologyData.of_isColimit_cokernelCofork Sโ hgโ cโ hcโ) where
  ฯQ := f
  ฯH := f
  commp := comm.symm

variable (S)

@[simps]
def compatibility_of_zeros_of_isLimit_kernelFork (hf : S.f = 0) (hg : S.g = 0)
    (c : KernelFork S.g) (hc : IsLimit c) :
    RightHomologyMapData (๐ S)
      (RightHomologyData.of_isLimit_kernelFork S hf c hc)
      (RightHomologyData.of_zeros S hf hg) where
  ฯQ := ๐ _
  ฯH := c.ฮน

@[simps]
def compatibility_of_zeros_of_isColimit_cokernelCofork (hf : S.f = 0) (hg : S.g = 0)
  (c : CokernelCofork S.f) (hc : IsColimit c) :
  RightHomologyMapData (๐ S)
    (RightHomologyData.of_zeros S hf hg)
    (RightHomologyData.of_isColimit_cokernelCofork S hg c hc) where
  ฯQ := c.ฯ
  ฯH := c.ฯ

end RightHomologyMapData

end

variable (S)

noncomputable def rightHomology [HasRightHomology S] : C := S.rightHomologyData.H
noncomputable def cyclesCo [HasRightHomology S] : C := S.rightHomologyData.Q
noncomputable def rightHomology_ฮน [HasRightHomology S] : S.rightHomology โถ S.cyclesCo :=
  S.rightHomologyData.ฮน
noncomputable def p_cyclesCo [HasRightHomology S] : S.Xโ โถ S.cyclesCo := S.rightHomologyData.p
noncomputable def fromCyclesCo [HasRightHomology S] : S.cyclesCo โถ S.Xโ := S.rightHomologyData.g'

@[reassoc (attr := simp)]
lemma f_p_cyclesCo [HasRightHomology S] : S.f โซ S.p_cyclesCo = 0 :=
  S.rightHomologyData.wp

@[reassoc (attr := simp)]
lemma p_fromCyclesCo [HasRightHomology S] : S.p_cyclesCo โซ S.fromCyclesCo = S.g :=
  S.rightHomologyData.p_g'

instance [HasRightHomology S] : Epi S.p_cyclesCo := by
  dsimp only [p_cyclesCo]
  infer_instance

instance [HasRightHomology S] : Mono S.rightHomology_ฮน := by
  dsimp only [rightHomology_ฮน]
  infer_instance

variable {S}

end ShortComplex

end CategoryTheory

#exit
-----

end

variables {Sโ Sโ Sโ : short_complex C}

namespace right_homology_data

@[simp]
def of_epi_of_is_iso_of_mono (ฯ : Sโ โถ Sโ) (h : right_homology_data Sโ)
  [epi ฯ.ฯโ] [is_iso ฯ.ฯโ] [mono ฯ.ฯโ] : right_homology_data Sโ :=
begin
  haveI : epi (op_map ฯ).ฯโ := by { dsimp, apply_instance, },
  haveI : is_iso (op_map ฯ).ฯโ := by { dsimp, apply_instance, },
  haveI : mono (op_map ฯ).ฯโ := by { dsimp, apply_instance, },
  exact (left_homology_data.of_epi_of_is_iso_of_mono' (op_map ฯ) h.op).unop,
end

@[simp]
lemma of_epi_of_is_iso_of_mono_p (ฯ : Sโ โถ Sโ) (h : right_homology_data Sโ)
  [epi ฯ.ฯโ] [is_iso ฯ.ฯโ] [mono ฯ.ฯโ] :
    (right_homology_data.of_epi_of_is_iso_of_mono ฯ h).p = inv ฯ.ฯโ โซ h.p :=
begin
  change (h.p.op โซ inv ฯ.ฯโ.op).unop = _,
  simp only [quiver.hom.unop_op, unop_comp, unop_inv],
end

@[simp]
lemma of_epi_of_is_iso_of_mono_g' (ฯ : Sโ โถ Sโ) (h : right_homology_data Sโ)
  [epi ฯ.ฯโ] [is_iso ฯ.ฯโ] [mono ฯ.ฯโ] :
    (of_epi_of_is_iso_of_mono ฯ h).g' = h.g' โซ ฯ.ฯโ :=
begin
  rw [โ cancel_epi (of_epi_of_is_iso_of_mono ฯ h).p, p_g'],
  simp only [of_epi_of_is_iso_of_mono_p, assoc, p_g'_assoc, is_iso.eq_inv_comp, ฯ.commโโ],
end

@[simp]
lemma of_epi_of_is_iso_of_mono_ฮน (ฯ : Sโ โถ Sโ) (h : right_homology_data Sโ)
  [epi ฯ.ฯโ] [is_iso ฯ.ฯโ] [mono ฯ.ฯโ] :
    (of_epi_of_is_iso_of_mono ฯ h).ฮน = h.ฮน := rfl

@[simp]
def of_epi_of_is_iso_of_mono' (ฯ : Sโ โถ Sโ) (h : right_homology_data Sโ)
  [epi ฯ.ฯโ] [is_iso ฯ.ฯโ] [mono ฯ.ฯโ] : right_homology_data Sโ :=
begin
  haveI : epi (op_map ฯ).ฯโ := by { dsimp, apply_instance, },
  haveI : is_iso (op_map ฯ).ฯโ := by { dsimp, apply_instance, },
  haveI : mono (op_map ฯ).ฯโ := by { dsimp, apply_instance, },
  exact (left_homology_data.of_epi_of_is_iso_of_mono (op_map ฯ) h.op).unop,
end

@[simp]
lemma of_epi_of_is_iso_of_mono'_p (ฯ : Sโ โถ Sโ) (h : right_homology_data Sโ)
  [epi ฯ.ฯโ] [is_iso ฯ.ฯโ] [mono ฯ.ฯโ] :
    (of_epi_of_is_iso_of_mono' ฯ h).p = ฯ.ฯโ โซ h.p := rfl

@[simp]
lemma of_epi_of_is_iso_of_mono'_g'_ฯโ (ฯ : Sโ โถ Sโ) (h : right_homology_data Sโ)
  [epi ฯ.ฯโ] [is_iso ฯ.ฯโ] [mono ฯ.ฯโ] :
  (of_epi_of_is_iso_of_mono' ฯ h).g' โซ ฯ.ฯโ = h.g' :=
by rw [โ cancel_epi (of_epi_of_is_iso_of_mono' ฯ h).p, p_g'_assoc,
    of_epi_of_is_iso_of_mono'_p, assoc, p_g', ฯ.commโโ]

@[simp]
lemma of_epi_of_is_iso_of_mono'_ฮน (ฯ : Sโ โถ Sโ) (h : right_homology_data Sโ)
  [epi ฯ.ฯโ] [is_iso ฯ.ฯโ] [mono ฯ.ฯโ] :
    (of_epi_of_is_iso_of_mono' ฯ h).ฮน = h.ฮน := rfl

def of_iso (e : Sโ โ Sโ) (hโ : right_homology_data Sโ) : right_homology_data Sโ :=
hโ.of_epi_of_is_iso_of_mono e.hom

end right_homology_data

lemma has_right_homology_of_epi_of_is_iso_of_mono (ฯ : Sโ โถ Sโ) [has_right_homology Sโ]
  [epi ฯ.ฯโ] [is_iso ฯ.ฯโ] [mono ฯ.ฯโ] : has_right_homology Sโ :=
has_right_homology.mk' (right_homology_data.of_epi_of_is_iso_of_mono ฯ Sโ.some_right_homology_data)

lemma has_right_homology_of_epi_of_is_iso_of_mono' (ฯ : Sโ โถ Sโ) [has_right_homology Sโ]
  [epi ฯ.ฯโ] [is_iso ฯ.ฯโ] [mono ฯ.ฯโ] : has_right_homology Sโ :=
has_right_homology.mk' (right_homology_data.of_epi_of_is_iso_of_mono' ฯ Sโ.some_right_homology_data)

lemma has_right_homology_of_iso {Sโ Sโ : short_complex C}
  (e : Sโ โ Sโ) [has_right_homology Sโ] : has_right_homology Sโ :=
has_right_homology_of_epi_of_is_iso_of_mono e.hom

variables (ฯ : Sโ โถ Sโ)
  (hโ : Sโ.right_homology_data) (hโ : Sโ.right_homology_data)

---

variables {S Sโ Sโ Sโ}

def right_homology_map' (ฯ : Sโ โถ Sโ) (hโ : Sโ.right_homology_data) (hโ : Sโ.right_homology_data) :
  hโ.H โถ hโ.H := (right_homology_map_data.some ฯ _ _).ฯH

def cycles_co_map' (ฯ : Sโ โถ Sโ) (hโ : Sโ.right_homology_data) (hโ : Sโ.right_homology_data) :
  hโ.Q โถ hโ.Q := (right_homology_map_data.some ฯ _ _).ฯQ

@[simp, reassoc]
lemma p_cycles_co_map' (ฯ : Sโ โถ Sโ) (hโ : Sโ.right_homology_data) (hโ : Sโ.right_homology_data) :
  hโ.p โซ cycles_co_map' ฯ hโ hโ = ฯ.ฯโ โซ hโ.p :=
right_homology_map_data.commp _

@[simp, reassoc]
lemma right_homology_ฮน_naturality' (ฯ : Sโ โถ Sโ)
  (hโ : Sโ.right_homology_data) (hโ : Sโ.right_homology_data) :
  right_homology_map' ฯ hโ hโ โซ hโ.ฮน = hโ.ฮน โซ cycles_co_map' ฯ hโ hโ :=
right_homology_map_data.commฮน _

def right_homology_map [has_right_homology Sโ] [has_right_homology Sโ]
  (ฯ : Sโ โถ Sโ) : Sโ.right_homology โถ Sโ.right_homology :=
right_homology_map' ฯ _ _

def cycles_co_map [has_right_homology Sโ] [has_right_homology Sโ]
  (ฯ : Sโ โถ Sโ) : Sโ.cycles_co โถ Sโ.cycles_co :=
cycles_co_map' ฯ _ _

@[simp, reassoc]
lemma p_cycles_co_map (ฯ : Sโ โถ Sโ) [Sโ.has_right_homology] [Sโ.has_right_homology] :
  Sโ.p_cycles_co โซ cycles_co_map ฯ = ฯ.ฯโ โซ Sโ.p_cycles_co :=
p_cycles_co_map' _ _ _

@[reassoc]
lemma from_cycles_co_naturality (ฯ : Sโ โถ Sโ) [Sโ.has_right_homology] [Sโ.has_right_homology] :
  cycles_co_map ฯ โซ Sโ.from_cycles_co = Sโ.from_cycles_co โซ ฯ.ฯโ :=
by simp only [โcancel_epi Sโ.p_cycles_co, ฯ.commโโ, p_cycles_co_map_assoc,
  p_from_cycles_co, p_from_cycles_co_assoc]

@[simp, reassoc]
lemma right_homology_ฮน_naturality [has_right_homology Sโ] [has_right_homology Sโ]
  (ฯ : Sโ โถ Sโ) :
  right_homology_map ฯ โซ Sโ.right_homology_ฮน = Sโ.right_homology_ฮน โซ cycles_co_map ฯ :=
right_homology_ฮน_naturality' _ _ _

namespace right_homology_map_data

variables (ฮณ : right_homology_map_data ฯ hโ hโ) {ฯ hโ hโ}

lemma right_homology_map'_eq : right_homology_map' ฯ hโ hโ = ฮณ.ฯH :=
right_homology_map_data.congr_ฯH (subsingleton.elim _ _)

lemma cycles_co_map'_eq : cycles_co_map' ฯ hโ hโ = ฮณ.ฯQ :=
right_homology_map_data.congr_ฯQ (subsingleton.elim _ _)

end right_homology_map_data

@[simp]
lemma right_homology_map'_id (h : S.right_homology_data) :
  right_homology_map' (๐ S) h h = ๐ _ :=
(right_homology_map_data.id h).right_homology_map'_eq

@[simp]
lemma cycles_co_map'_id (h : S.right_homology_data) :
  cycles_co_map' (๐ S) h h = ๐ _ :=
(right_homology_map_data.id h).cycles_co_map'_eq

variable (S)

@[simp]
lemma right_homology_map_id [has_right_homology S] :
  right_homology_map (๐ S) = ๐ _ :=
right_homology_map'_id _

@[simp]
lemma cycles_co_map_id [has_right_homology S] :
  cycles_co_map (๐ S) = ๐ _ :=
cycles_co_map'_id _

@[simp]
lemma right_homology_map'_zero (hโ : Sโ.right_homology_data) (hโ : Sโ.right_homology_data):
  right_homology_map' 0 hโ hโ = 0 :=
(right_homology_map_data.zero hโ hโ).right_homology_map'_eq

@[simp]
lemma cycles_co_map'_zero (hโ : Sโ.right_homology_data) (hโ : Sโ.right_homology_data):
  cycles_co_map' 0 hโ hโ = 0 :=
(right_homology_map_data.zero hโ hโ).cycles_co_map'_eq

variables (Sโ Sโ)

@[simp]
lemma right_homology_map_zero [has_right_homology Sโ] [has_right_homology Sโ]:
  right_homology_map (0 : Sโ โถ Sโ) = 0 :=
right_homology_map'_zero _ _

@[simp]
lemma cycles_co_map_zero [has_right_homology Sโ] [has_right_homology Sโ] :
  cycles_co_map (0 : Sโ โถ Sโ) = 0 :=
cycles_co_map'_zero _ _

variables {Sโ Sโ}

lemma right_homology_map'_comp (ฯโ : Sโ โถ Sโ) (ฯโ : Sโ โถ Sโ)
  (hโ : Sโ.right_homology_data) (hโ : Sโ.right_homology_data) (hโ : Sโ.right_homology_data) :
  right_homology_map' (ฯโ โซ ฯโ) hโ hโ = right_homology_map' ฯโ hโ hโ โซ
    right_homology_map' ฯโ hโ hโ :=
begin
  let ฮณโ := right_homology_map_data.some ฯโ _ _,
  let ฮณโ := right_homology_map_data.some ฯโ _ _,
  rw [ฮณโ.right_homology_map'_eq, ฮณโ.right_homology_map'_eq, (ฮณโ.comp ฮณโ).right_homology_map'_eq,
    right_homology_map_data.comp_ฯH],
end

lemma cycles_co_map'_comp (ฯโ : Sโ โถ Sโ) (ฯโ : Sโ โถ Sโ)
  (hโ : Sโ.right_homology_data) (hโ : Sโ.right_homology_data) (hโ : Sโ.right_homology_data) :
  cycles_co_map' (ฯโ โซ ฯโ) hโ hโ = cycles_co_map' ฯโ hโ hโ โซ
    cycles_co_map' ฯโ hโ hโ :=
begin
  let ฮณโ := right_homology_map_data.some ฯโ _ _,
  let ฮณโ := right_homology_map_data.some ฯโ _ _,
  rw [ฮณโ.cycles_co_map'_eq, ฮณโ.cycles_co_map'_eq, (ฮณโ.comp ฮณโ).cycles_co_map'_eq,
    right_homology_map_data.comp_ฯQ],
end

@[simp]
lemma right_homology_map_comp [has_right_homology Sโ] [has_right_homology Sโ]
  [has_right_homology Sโ] (ฯโ : Sโ โถ Sโ) (ฯโ : Sโ โถ Sโ) :
  right_homology_map (ฯโ โซ ฯโ) = right_homology_map ฯโ โซ right_homology_map ฯโ :=
right_homology_map'_comp _ _ _ _ _

@[simp]
lemma cycles_co_map_comp [has_right_homology Sโ] [has_right_homology Sโ]
  [has_right_homology Sโ] (ฯโ : Sโ โถ Sโ) (ฯโ : Sโ โถ Sโ) :
  cycles_co_map (ฯโ โซ ฯโ) = cycles_co_map ฯโ โซ cycles_co_map ฯโ :=
cycles_co_map'_comp _ _ _ _ _

@[simps]
def right_homology_map_iso' (e : Sโ โ Sโ) (hโ : Sโ.right_homology_data)
  (hโ : Sโ.right_homology_data) : hโ.H โ hโ.H :=
{ hom := right_homology_map' e.hom hโ hโ,
  inv := right_homology_map' e.inv hโ hโ,
  hom_inv_id' := by rw [โ right_homology_map'_comp, e.hom_inv_id, right_homology_map'_id],
  inv_hom_id' := by rw [โ right_homology_map'_comp, e.inv_hom_id, right_homology_map'_id], }

instance is_iso_right_homology_map'_of_iso (ฯ : Sโ โถ Sโ) [is_iso ฯ]
  (hโ : Sโ.right_homology_data) (hโ : Sโ.right_homology_data) :
  is_iso (right_homology_map' ฯ hโ hโ) :=
by { change is_iso (right_homology_map_iso' (as_iso ฯ) hโ hโ).hom, apply_instance, }

@[simps]
def cycles_co_map_iso' (e : Sโ โ Sโ) (hโ : Sโ.right_homology_data)
  (hโ : Sโ.right_homology_data) : hโ.Q โ hโ.Q :=
{ hom := cycles_co_map' e.hom hโ hโ,
  inv := cycles_co_map' e.inv hโ hโ,
  hom_inv_id' := by rw [โ cycles_co_map'_comp, e.hom_inv_id, cycles_co_map'_id],
  inv_hom_id' := by rw [โ cycles_co_map'_comp, e.inv_hom_id, cycles_co_map'_id], }

instance is_iso_cycles_co_map'_of_iso (ฯ : Sโ โถ Sโ) [is_iso ฯ]
  (hโ : Sโ.right_homology_data) (hโ : Sโ.right_homology_data) :
  is_iso (cycles_co_map' ฯ hโ hโ) :=
by { change is_iso (cycles_co_map_iso' (as_iso ฯ) hโ hโ).hom, apply_instance, }

@[simps]
def right_homology_map_iso (e : Sโ โ Sโ) [Sโ.has_right_homology]
  [Sโ.has_right_homology] : Sโ.right_homology โ Sโ.right_homology :=
{ hom := right_homology_map e.hom,
  inv := right_homology_map e.inv,
  hom_inv_id' := by rw [โ right_homology_map_comp, e.hom_inv_id, right_homology_map_id],
  inv_hom_id' := by rw [โ right_homology_map_comp, e.inv_hom_id, right_homology_map_id], }

instance is_iso_right_homology_map_of_iso (ฯ : Sโ โถ Sโ) [is_iso ฯ] [Sโ.has_right_homology]
  [Sโ.has_right_homology] :
  is_iso (right_homology_map ฯ) :=
by { change is_iso (right_homology_map_iso (as_iso ฯ)).hom, apply_instance, }

@[simps]
def cycles_co_map_iso (e : Sโ โ Sโ) [Sโ.has_right_homology]
  [Sโ.has_right_homology] : Sโ.cycles_co โ Sโ.cycles_co :=
{ hom := cycles_co_map e.hom,
  inv := cycles_co_map e.inv,
  hom_inv_id' := by rw [โ cycles_co_map_comp, e.hom_inv_id, cycles_co_map_id],
  inv_hom_id' := by rw [โ cycles_co_map_comp, e.inv_hom_id, cycles_co_map_id], }

instance is_iso_cycles_co_map_of_iso (ฯ : Sโ โถ Sโ) [is_iso ฯ] [Sโ.has_right_homology]
  [Sโ.has_right_homology] :
  is_iso (cycles_co_map ฯ) :=
by { change is_iso (cycles_co_map_iso (as_iso ฯ)).hom, apply_instance, }

variable {S}

def right_homology_data.right_homology_iso (h : S.right_homology_data) [S.has_right_homology] :
  S.right_homology โ h.H := right_homology_map_iso' (iso.refl _) _ _

def right_homology_data.cycles_co_iso (h : S.right_homology_data) [S.has_right_homology] :
  S.cycles_co โ h.Q := cycles_co_map_iso' (iso.refl _) _ _

@[simp, reassoc]
lemma right_homology_data.p_comp_cycles_co_iso_inv (h : S.right_homology_data)
  [S.has_right_homology] :
  h.p โซ h.cycles_co_iso.inv = S.p_cycles_co :=
begin
  dsimp [p_cycles_co, right_homology_data.cycles_co_iso],
  simp only [p_cycles_co_map', id_ฯโ, id_comp],
end

@[simp, reassoc]
lemma right_homology_data.cycles_co_iso_hom_comp_p (h : S.right_homology_data)
  [S.has_right_homology] :
  S.p_cycles_co โซ h.cycles_co_iso.hom = h.p :=
by simp only [โ h.p_comp_cycles_co_iso_inv, assoc, iso.inv_hom_id, comp_id]

@[simps]
def left_homology_map_data.op {Sโ Sโ : short_complex C} {ฯ : Sโ โถ Sโ}
  {hโ : Sโ.left_homology_data} {hโ : Sโ.left_homology_data}
  (ฯ : left_homology_map_data ฯ hโ hโ) :
  right_homology_map_data (op_map ฯ) hโ.op hโ.op :=
{ ฯQ := ฯ.ฯK.op,
  ฯH := ฯ.ฯH.op,
  commp' := quiver.hom.unop_inj (by simp),
  commg'' := quiver.hom.unop_inj (by simp),
  commฮน' := quiver.hom.unop_inj (by simp), }

@[simps]
def left_homology_map_data.unop' {Sโ Sโ : short_complex Cแตแต} {ฯ : Sโ โถ Sโ}
  {hโ : Sโ.left_homology_data} {hโ : Sโ.left_homology_data}
  (ฯ : left_homology_map_data ฯ hโ hโ) :
  right_homology_map_data (unop'_map ฯ) hโ.unop' hโ.unop' :=
{ ฯQ := ฯ.ฯK.unop,
  ฯH := ฯ.ฯH.unop,
  commp' := quiver.hom.op_inj (by simp),
  commg'' := quiver.hom.op_inj (by simp),
  commฮน' := quiver.hom.op_inj (by simp), }

@[simps]
def left_homology_map_data.unop {Sโ Sโ : short_complex C} {ฯ : Sโ.op โถ Sโ.op}
  {hโ : Sโ.op.left_homology_data} {hโ : Sโ.op.left_homology_data}
  (ฯ : left_homology_map_data ฯ hโ hโ) :
  right_homology_map_data (unop_map ฯ) hโ.unop hโ.unop :=
{ ฯQ := ฯ.ฯK.unop,
  ฯH := ฯ.ฯH.unop,
  commp' := quiver.hom.op_inj (by simp),
  commg'' := quiver.hom.op_inj (by simp),
  commฮน' := quiver.hom.op_inj (by simp), }

@[simps]
def right_homology_map_data.op {Sโ Sโ : short_complex C} {ฯ : Sโ โถ Sโ}
  {hโ : Sโ.right_homology_data} {hโ : Sโ.right_homology_data}
  (ฯ : right_homology_map_data ฯ hโ hโ) :
  left_homology_map_data (op_map ฯ) hโ.op hโ.op :=
{ ฯK := ฯ.ฯQ.op,
  ฯH := ฯ.ฯH.op,
  commi' := quiver.hom.unop_inj (by simp),
  commf'' := quiver.hom.unop_inj (by simp),
  commฯ' := quiver.hom.unop_inj (by simp), }

@[simps]
def right_homology_map_data.unop' {Sโ Sโ : short_complex Cแตแต} {ฯ : Sโ โถ Sโ}
  {hโ : Sโ.right_homology_data} {hโ : Sโ.right_homology_data}
  (ฯ : right_homology_map_data ฯ hโ hโ) :
  left_homology_map_data (unop'_map ฯ) hโ.unop' hโ.unop' :=
{ ฯK := ฯ.ฯQ.unop,
  ฯH := ฯ.ฯH.unop,
  commi' := quiver.hom.op_inj (by simp),
  commf'' := quiver.hom.op_inj (by simp),
  commฯ' := quiver.hom.op_inj (by simp), }

@[simps]
def right_homology_map_data.unop {Sโ Sโ : short_complex C} {ฯ : Sโ.op โถ Sโ.op}
  {hโ : Sโ.op.right_homology_data} {hโ : Sโ.op.right_homology_data}
  (ฯ : right_homology_map_data ฯ hโ hโ) :
  left_homology_map_data (unop_map ฯ) hโ.unop hโ.unop :=
{ ฯK := ฯ.ฯQ.unop,
  ฯH := ฯ.ฯH.unop,
  commi' := quiver.hom.op_inj (by simp),
  commf'' := quiver.hom.op_inj (by simp),
  commฯ' := quiver.hom.op_inj (by simp), }

namespace right_homology_map_data

variables (ฮณ : right_homology_map_data ฯ hโ hโ) {ฯ hโ hโ}

lemma right_homology_map_eq [Sโ.has_right_homology] [Sโ.has_right_homology] :
  right_homology_map ฯ = hโ.right_homology_iso.hom โซ ฮณ.ฯH โซ hโ.right_homology_iso.inv :=
begin
  dsimp [right_homology_data.right_homology_iso, right_homology_map_iso'],
  rw [โ ฮณ.right_homology_map'_eq, โ right_homology_map'_comp, โ right_homology_map'_comp, id_comp, comp_id],
  refl,
end

lemma cycles_co_map_eq [Sโ.has_right_homology] [Sโ.has_right_homology] :
  cycles_co_map ฯ = hโ.cycles_co_iso.hom โซ ฮณ.ฯQ โซ hโ.cycles_co_iso.inv :=
begin
  dsimp [right_homology_data.cycles_co_iso, cycles_co_map_iso'],
  rw [โ ฮณ.cycles_co_map'_eq, โ cycles_co_map'_comp, โ cycles_co_map'_comp, id_comp, comp_id],
  refl,
end

lemma right_homology_map_comm [Sโ.has_right_homology] [Sโ.has_right_homology] :
  right_homology_map ฯ โซ hโ.right_homology_iso.hom = hโ.right_homology_iso.hom โซ ฮณ.ฯH :=
by simp only [ฮณ.right_homology_map_eq, assoc, iso.inv_hom_id, comp_id]

lemma cycles_co_map_comm [Sโ.has_right_homology] [Sโ.has_right_homology] :
  cycles_co_map ฯ โซ hโ.cycles_co_iso.hom = hโ.cycles_co_iso.hom โซ ฮณ.ฯQ :=
by simp only [ฮณ.cycles_co_map_eq, assoc, iso.inv_hom_id, comp_id]

end right_homology_map_data

variable (C)

abbreviation _root_.category_with_right_homology := โ (S : short_complex C), S.has_right_homology

@[simps]
def right_homology_functor [category_with_right_homology C] :
  short_complex C โฅค C :=
{ obj := ฮป S, S.right_homology,
  map := ฮป Sโ Sโ, right_homology_map, }

@[simps]
def cycles_co_functor [category_with_right_homology C] :
  short_complex C โฅค C :=
{ obj := ฮป S, S.cycles_co,
  map := ฮป Sโ Sโ, cycles_co_map, }

@[simps]
def right_homology_ฮน_nat_trans [category_with_right_homology C] :
  right_homology_functor C โถ cycles_co_functor C :=
{ app := ฮป S, right_homology_ฮน S,
  naturality' := ฮป Sโ Sโ, right_homology_ฮน_naturality, }

@[simps]
def p_cycles_co_nat_trans [category_with_right_homology C] :
  short_complex.ฯโ โถ cycles_co_functor C :=
{ app := ฮป S, p_cycles_co S, }

@[simps]
def from_cycles_co_nat_trans [category_with_right_homology C] :
  cycles_co_functor C โถ ฯโ :=
{ app := ฮป S, S.from_cycles_co,
  naturality' := ฮป Sโ Sโ ฯ, from_cycles_co_naturality ฯ, }

variables {C} (S)

def op_right_homology_iso [S.has_left_homology] :
  S.op.right_homology โ opposite.op S.left_homology :=
S.some_left_homology_data.op.right_homology_iso

def op_left_homology_iso [S.has_right_homology] :
  S.op.left_homology โ opposite.op S.right_homology :=
S.some_right_homology_data.op.left_homology_iso

def op_cycles_co_iso [S.has_left_homology] :
  S.op.cycles_co โ opposite.op S.cycles :=
S.some_left_homology_data.op.cycles_co_iso

def op_cycles_iso [S.has_right_homology] :
  S.op.cycles โ opposite.op S.cycles_co :=
S.some_right_homology_data.op.cycles_iso

variables {S}

@[simp]
lemma left_homology_map'_op
  (ฯ : Sโ โถ Sโ) (hโ : Sโ.left_homology_data) (hโ : Sโ.left_homology_data) :
  (left_homology_map' ฯ hโ hโ).op = right_homology_map' (op_map ฯ) hโ.op hโ.op :=
begin
  let ฮณ : left_homology_map_data ฯ hโ hโ := default,
  simp only [ฮณ.left_homology_map'_eq, ฮณ.op.right_homology_map'_eq,
    left_homology_map_data.op_ฯH],
end

@[simp]
lemma right_homology_map'_op
  (ฯ : Sโ โถ Sโ) (hโ : Sโ.right_homology_data) (hโ : Sโ.right_homology_data) :
  (right_homology_map' ฯ hโ hโ).op = left_homology_map' (op_map ฯ) hโ.op hโ.op :=
begin
  let ฮณ : right_homology_map_data ฯ hโ hโ := default,
  simp only [ฮณ.right_homology_map'_eq, ฮณ.op.left_homology_map'_eq,
    right_homology_map_data.op_ฯH],
end

@[simp]
lemma left_homology_map_op (ฯ : Sโ โถ Sโ) [has_left_homology Sโ] [has_left_homology Sโ] :
  (left_homology_map ฯ).op =
    Sโ.op_right_homology_iso.inv โซ right_homology_map (op_map ฯ) โซ Sโ.op_right_homology_iso.hom :=
begin
  dsimp only [left_homology_map, right_homology_map,
    op_right_homology_iso, right_homology_data.right_homology_iso,
    right_homology_map_iso', iso.refl],
  rw [left_homology_map'_op, โ right_homology_map'_comp, โ right_homology_map'_comp,
    comp_id, id_comp],
end

@[simp]
lemma right_homology_map_op (ฯ : Sโ โถ Sโ) [has_right_homology Sโ] [has_right_homology Sโ] :
  (right_homology_map ฯ).op =
    Sโ.op_left_homology_iso.inv โซ left_homology_map (op_map ฯ) โซ Sโ.op_left_homology_iso.hom :=
begin
  dsimp only [right_homology_map, left_homology_map,
    op_left_homology_iso, left_homology_data.left_homology_iso,
    left_homology_map_iso', iso.refl],
  rw [right_homology_map'_op, โ left_homology_map'_comp, โ left_homology_map'_comp,
    comp_id, id_comp],
end

instance category_with_left_homology_op_of_category_with_right_homology
  [category_with_right_homology C] : category_with_left_homology Cแตแต :=
ฮป S, has_left_homology_of_iso S.unop_op

instance category_with_right_homology_op_of_category_with_left_homology
  [category_with_left_homology C] : category_with_right_homology Cแตแต :=
ฮป S, has_right_homology_of_iso S.unop_op

instance category_with_right_homology_of_category_with_left_homology
  [category_with_right_homology C] : category_with_left_homology Cแตแต :=
ฮป S, has_left_homology_of_iso S.unop_op

@[simps]
def right_homology_functor_op_nat_iso [category_with_right_homology C] :
  (right_homology_functor C).op โ op_functor C โ left_homology_functor Cแตแต :=
nat_iso.of_components (ฮป S, (op_left_homology_iso S.unop).symm) (by simp)

@[simps]
def left_homology_functor_op_nat_iso [category_with_left_homology C] :
  (left_homology_functor C).op โ op_functor C โ right_homology_functor Cแตแต :=
nat_iso.of_components (ฮป S, (op_right_homology_iso S.unop).symm) (by simp)

namespace right_homology_map_data

@[simps]
def of_epi_of_is_iso_of_mono (ฯ : Sโ โถ Sโ) (h : right_homology_data Sโ)
  [epi ฯ.ฯโ] [is_iso ฯ.ฯโ] [mono ฯ.ฯโ] :
    right_homology_map_data ฯ h (right_homology_data.of_epi_of_is_iso_of_mono ฯ h) :=
{ ฯQ := ๐ _,
  ฯH := ๐ _,
  commp' := by simp only [comp_id, right_homology_data.of_epi_of_is_iso_of_mono_p, is_iso.hom_inv_id_assoc],
  commg'' := by simp only [right_homology_data.of_epi_of_is_iso_of_mono_g', id_comp],
  commฮน' := by simp only [comp_id, right_homology_data.of_epi_of_is_iso_of_mono_ฮน, id_comp], }

@[simps]
def of_epi_of_is_iso_of_mono' (ฯ : Sโ โถ Sโ) (h : right_homology_data Sโ)
  [epi ฯ.ฯโ] [is_iso ฯ.ฯโ] [mono ฯ.ฯโ] :
    right_homology_map_data ฯ (right_homology_data.of_epi_of_is_iso_of_mono' ฯ h) h :=
{ ฯQ := ๐ _,
  ฯH := ๐ _,
  commp' := by { dsimp, simp only [comp_id], },
  commg'' := by { simp only [right_homology_data.of_epi_of_is_iso_of_mono'_g'_ฯโ, id_comp], },
  commฮน' := by { dsimp, simp only [comp_id, id_comp], }, }

end right_homology_map_data

instance (ฯ : Sโ โถ Sโ) (hโ : Sโ.right_homology_data) (hโ : Sโ.right_homology_data)
  [epi ฯ.ฯโ] [is_iso ฯ.ฯโ] [mono ฯ.ฯโ] :
  is_iso (right_homology_map' ฯ hโ hโ) :=
begin
  let hโ' := right_homology_data.of_epi_of_is_iso_of_mono ฯ hโ,
  haveI : is_iso (right_homology_map' ฯ hโ hโ'),
  { let ฮณ := right_homology_map_data.of_epi_of_is_iso_of_mono ฯ hโ,
    rw ฮณ.right_homology_map'_eq,
    dsimp,
    apply_instance, },
  have eq := right_homology_map'_comp ฯ (๐ Sโ) hโ hโ' hโ,
  rw comp_id at eq,
  rw eq,
  apply_instance,
end

instance (ฯ : Sโ โถ Sโ) [Sโ.has_right_homology] [Sโ.has_right_homology]
  [epi ฯ.ฯโ] [is_iso ฯ.ฯโ] [mono ฯ.ฯโ] :
  is_iso (right_homology_map ฯ) :=
by { dsimp only [right_homology_map], apply_instance, }

section

variables (S) (h : S.right_homology_data) {A : C} (k : S.Xโ โถ A) (hk : S.f โซ k = 0)
  [has_right_homology S]

def desc_cycles_co : S.cycles_co โถ A :=
S.some_right_homology_data.desc_Q k hk

@[simp, reassoc]
lemma p_desc_cycles_co : S.p_cycles_co โซ S.desc_cycles_co k hk = k :=
right_homology_data.p_desc_Q _ k hk

def cycles_co_is_cokernel : is_colimit (cokernel_cofork.of_ฯ S.p_cycles_co S.f_cycles_co_p) :=
S.some_right_homology_data.hp

lemma is_iso_p_cycles_co_of (hf : S.f = 0) : is_iso (S.p_cycles_co) :=
cokernel_cofork.is_colimit.is_iso_ฯ_of_zero _ S.cycles_co_is_cokernel hf

@[simps]
def cycles_co_iso_cokernel [has_cokernel S.f] : S.cycles_co โ cokernel S.f :=
{ hom := S.desc_cycles_co (cokernel.ฯ S.f) (by simp),
  inv := cokernel.desc S.f S.p_cycles_co (by simp),
  hom_inv_id' := by simp only [โ cancel_epi S.p_cycles_co, p_desc_cycles_co_assoc,
    cokernel.ฯ_desc, comp_id],
  inv_hom_id' := by simp only [โ cancel_epi (cokernel.ฯ S.f), cokernel.ฯ_desc_assoc,
    p_desc_cycles_co, comp_id], }

@[simp]
def desc_right_homology : S.right_homology โถ A :=
S.right_homology_ฮน โซ S.desc_cycles_co k hk

lemma ฮน_desc_cycles_co_eq_zero_of_boundary (x : S.Xโ โถ A) (hx : k = S.g โซ x) :
S.right_homology_ฮน โซ S.desc_cycles_co k (by rw [hx, S.zero_assoc, zero_comp]) = 0 :=
right_homology_data.ฮน_desc_Q_eq_zero_of_boundary _ k x hx

@[simp, reassoc]
lemma right_homology_ฮน_comp_from_cycles_co :
  S.right_homology_ฮน โซ S.from_cycles_co = 0 :=
S.ฮน_desc_cycles_co_eq_zero_of_boundary S.g (๐ _) (by rw comp_id)

def right_homology_is_kernel :
  is_limit (kernel_fork.of_ฮน S.right_homology_ฮน S.right_homology_ฮน_comp_from_cycles_co) :=
S.some_right_homology_data.hฮน

variable {S}

@[simp, reassoc]
lemma right_homology_data.right_homology_iso_inv_comp_right_homology_ฮน :
  h.right_homology_iso.inv โซ S.right_homology_ฮน = h.ฮน โซ h.cycles_co_iso.inv :=
begin
  dsimp only [right_homology_ฮน, right_homology_data.right_homology_iso,
    right_homology_map_iso', iso.refl, right_homology_data.cycles_co_iso, cycles_co_map_iso'],
  rw โ right_homology_ฮน_naturality',
end

@[simp, reassoc]
lemma right_homology_data.right_homology_ฮน_comp_cycles_co_iso_hom :
   S.right_homology_ฮน โซ h.cycles_co_iso.hom = h.right_homology_iso.hom โซ h.ฮน :=
by simp only [โ cancel_mono h.cycles_co_iso.inv, โ cancel_epi h.right_homology_iso.inv,
  assoc, iso.hom_inv_id, comp_id, iso.inv_hom_id_assoc,
  h.right_homology_iso_inv_comp_right_homology_ฮน]

@[simp, reassoc]
lemma right_homology_data.cycles_co_iso_inv_comp_desc_cycles_co :
  h.cycles_co_iso.inv โซ S.desc_cycles_co k hk = h.desc_Q k hk :=
by simp only [โ cancel_epi h.p, h.p_comp_cycles_co_iso_inv_assoc, p_desc_cycles_co,
  h.p_desc_Q]

@[simp, reassoc]
lemma right_homology_data.cycles_co_iso_inv_comp_desc_cycles_co' :
  h.cycles_co_iso.hom โซ h.desc_Q k hk =  S.desc_cycles_co k hk :=
by rw [โ cancel_epi h.cycles_co_iso.inv, iso.inv_hom_id_assoc,
  h.cycles_co_iso_inv_comp_desc_cycles_co]

lemma right_homology_data.ext_iff' (fโ fโ : A โถ S.right_homology) :
  fโ = fโ โ fโ โซ h.right_homology_iso.hom โซ h.ฮน = fโ โซ h.right_homology_iso.hom โซ h.ฮน :=
by simp only [โ cancel_mono h.right_homology_iso.hom, โ cancel_mono h.ฮน, assoc]

end

namespace has_right_homology

variable (S)

@[protected]
lemma has_cokernel [S.has_right_homology] : has_cokernel S.f :=
โจโจโจ_, S.some_right_homology_data.hpโฉโฉโฉ

lemma has_kernel [S.has_right_homology] [has_cokernel S.f] :
  has_kernel (cokernel.desc S.f S.g S.zero) :=
begin
  let h := S.some_right_homology_data,
  haveI : has_limit (parallel_pair h.g' 0) := โจโจโจ_, h.hฮน'โฉโฉโฉ,
  let e : parallel_pair h.g' 0 โ parallel_pair (cokernel.desc S.f S.g S.zero) 0 :=
    parallel_pair.ext (is_colimit.cocone_point_unique_up_to_iso h.hp (cokernel_is_cokernel S.f))
      (iso.refl _) (by tidy) (by tidy),
  exact has_limit_of_iso e,
end

end has_right_homology

variable (S)

def right_homology_iso_kernel_desc [S.has_right_homology] [has_cokernel S.f]
  [has_kernel (cokernel.desc S.f S.g S.zero)] :
  S.right_homology โ kernel (cokernel.desc S.f S.g S.zero) :=
(right_homology_data.of_coker_of_ker S).right_homology_iso

namespace right_homology_data

variable {S}

lemma is_iso_p_of_zero_f (h : right_homology_data S) (hf : S.f = 0) : is_iso h.p :=
โจโจh.desc_Q (๐ S.Xโ) (by rw [hf, zero_comp]), p_desc_Q _ _ _,
  by simp only [โcancel_epi h.p, p_desc_Q_assoc, id_comp, comp_id]โฉโฉ

end right_homology_data

end short_complex

end category_theory
