import Mathlib.Algebra.Homology.ShortComplex.LeftHomology

open ZeroObject

namespace CategoryTheory

open Category Limits

namespace ShortComplex

variable {C D : Type _} [Category C] [Category D]
  [HasZeroMorphisms C]
  (S : ShortComplex C) {Sโ Sโ Sโ : ShortComplex C}

structure RightHomologyData :=
(Q H : C)
(p : S.Xโ โถ Q)
(ฮน : H โถ Q)
(wp : S.f โซ p = 0)
(hp : IsColimit (CokernelCofork.ofฯ p wp))
(wฮน : ฮน โซ hp.desc (CokernelCofork.ofฯ _ S.zero) = 0)
(hฮน : IsLimit (KernelFork.ofฮน ฮน wฮน))

initialize_simps_projections RightHomologyData (-hp, -hฮน)

namespace RightHomologyData

@[simps]
noncomputable def ofKerOfCoker [HasCokernel S.f] [HasKernel (cokernel.desc S.f S.g S.zero)] :
  S.RightHomologyData :=
{ Q := cokernel S.f,
  H := kernel (cokernel.desc S.f S.g S.zero),
  p := cokernel.ฯ _,
  ฮน := kernel.ฮน _,
  wp := cokernel.condition _,
  hp := cokernelIsCokernel _,
  wฮน := kernel.condition _,
  hฮน := kernelIsKernel _, }

attribute [reassoc (attr := simp)] wp wฮน

variable {S}
variable (h : S.RightHomologyData) {A : C}

instance : Epi h.p :=
  โจfun _ _ => Cofork.IsColimit.hom_ext h.hpโฉ

instance : Mono h.ฮน :=
  โจfun _ _ => Fork.IsLimit.hom_ext h.hฮนโฉ

def descQ (k : S.Xโ โถ A) (hk : S.f โซ k = 0) : h.Q โถ A :=
h.hp.desc (CokernelCofork.ofฯ k hk)

@[reassoc (attr := simp)]
lemma p_descQ (k : S.Xโ โถ A) (hk : S.f โซ k = 0) :
  h.p โซ h.descQ k hk = k :=
h.hp.fac _ WalkingParallelPair.one

@[simp]
def descH (k : S.Xโ โถ A) (hk : S.f โซ k = 0) : h.H โถ A :=
  h.ฮน โซ h.descQ k hk

/-- The morphism `h.Q โถ S.Xโ` induced by `S.g : S.Xโ โถ S.Xโ` and the fact that
`h.Q` is a cokernel of `S.f : S.Xโ โถ S.Xโ`. -/
def g' : h.Q โถ S.Xโ := h.descQ S.g S.zero

@[reassoc (attr := simp)]
lemma p_g' : h.p โซ h.g' = S.g :=
p_descQ _ _ _

@[reassoc (attr := simp)]
lemma ฮน_g' : h.ฮน โซ h.g' = 0 := h.wฮน

@[reassoc]
lemma ฮน_descQ_eq_zero_of_boundary (k : S.Xโ โถ A) (x : S.Xโ โถ A) (hx : k = S.g โซ x) :
  h.ฮน โซ h.descQ k (by rw [hx, S.zero_assoc, zero_comp]) = 0 := by
  rw [show 0 = h.ฮน โซ h.g' โซ x by simp]
  congr 1
  simp only [โ cancel_epi h.p, hx, p_descQ, p_g'_assoc]

/-- For `h : S.RightHomologyData`, this is a restatement of `h.hฮน `, saying that
`ฮน : h.H โถ h.Q` is a kernel of `h.g' : h.Q โถ S.Xโ`. -/
def hฮน' : IsLimit (KernelFork.ofฮน h.ฮน h.ฮน_g') := h.hฮน

def liftH (k : A โถ h.Q) (hk : k โซ h.g' = 0) :
  A โถ h.H :=
h.hฮน.lift (KernelFork.ofฮน k hk)

@[reassoc (attr := simp)]
lemma liftH_ฮน (k : A โถ h.Q) (hk : k โซ h.g' = 0) :
  h.liftH k hk โซ h.ฮน = k :=
h.hฮน.fac (KernelFork.ofฮน k hk) WalkingParallelPair.zero

variable (S)

@[simps]
def ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :
  S.RightHomologyData where
  Q := S.Xโ
  H := c.pt
  p := ๐ _
  ฮน := c.ฮน
  wp := by rw [comp_id, hf]
  hp := CokernelCofork.IsColimit.ofId _ hf
  wฮน := KernelFork.condition _
  hฮน := IsLimit.ofIsoLimit hc (Fork.ext (Iso.refl _) (by aesop_cat))

@[simp] lemma ofIsLimitKernelFork_g' (hf : S.f = 0) (c : KernelFork S.g)
    (hc : IsLimit c) : (ofIsLimitKernelFork S hf c hc).g' = S.g := by
  rw [โ cancel_epi (ofIsLimitKernelFork S hf c hc).p, p_g',
    ofIsLimitKernelFork_p, id_comp]

@[simps!]
noncomputable def ofHasKernel [HasKernel S.g] (hf : S.f = 0) : S.RightHomologyData :=
ofIsLimitKernelFork S hf _ (kernelIsKernel _)

@[simps]
def ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :
  S.RightHomologyData where
  Q := c.pt
  H := c.pt
  p := c.ฯ
  ฮน := ๐ _
  wp := CokernelCofork.condition _
  hp := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _) (by aesop_cat))
  wฮน := Cofork.IsColimit.hom_ext hc (by simp [hg])
  hฮน := KernelFork.IsLimit.ofId _ (Cofork.IsColimit.hom_ext hc (by simp [hg]))

@[simp] lemma ofIsColimitCokernelCofork_g' (hg : S.g = 0) (c : CokernelCofork S.f)
  (hc : IsColimit c) : (ofIsColimitCokernelCofork S hg c hc).g' = 0 :=
by rw [โ cancel_epi (ofIsColimitCokernelCofork S hg c hc).p, p_g', hg, comp_zero]

@[simp]
noncomputable def ofHasCokernel [HasCokernel S.f] (hg : S.g = 0) : S.RightHomologyData :=
ofIsColimitCokernelCofork S hg _ (cokernelIsCokernel _)

@[simps]
def ofZeros (hf : S.f = 0) (hg : S.g = 0) : S.RightHomologyData where
  Q := S.Xโ
  H := S.Xโ
  p := ๐ _
  ฮน := ๐ _
  wp := by rw [comp_id, hf]
  hp := CokernelCofork.IsColimit.ofId _ hf
  wฮน := by
    change ๐ _ โซ S.g = 0
    simp only [hg, comp_zero]
  hฮน := KernelFork.IsLimit.ofId _ hg

@[simp]
lemma ofZeros_g' (hf : S.f = 0) (hg : S.g = 0) :
    (ofZeros S hf hg).g' = 0 := by
  rw [โ cancel_epi ((ofZeros S hf hg).p), comp_zero, p_g', hg]

@[simps]
noncomputable def cokernelSequence' {X Y : C} (f : X โถ Y) (c : CokernelCofork f)
    (hc : IsColimit c) [HasZeroObject C] :
    RightHomologyData (ShortComplex.mk f c.ฯ c.condition) where
  Q := c.pt
  H := 0
  p := c.ฯ
  ฮน := 0
  wp := c.condition
  hp := IsColimit.ofIsoColimit hc (Cofork.ext (Iso.refl _) (by simp))
  wฮน := Subsingleton.elim _ _
  hฮน := by
    refine' KernelFork.IsLimit.ofIsZeroOfMono _ _ _
    . dsimp
      convert (inferInstance : Mono (๐ c.pt))
      haveI := epi_of_isColimit_cofork hc
      rw [โ cancel_epi c.ฯ]
      simp only [parallelPair_obj_one, Functor.const_obj_obj, id_comp,
        Cofork.IsColimit.ฯ_desc, Cofork.ฯ_ofฯ, comp_id]
    . apply isZero_zero

@[simps!]
noncomputable def cokernelSequence {X Y : C} (f : X โถ Y) [HasCokernel f] [HasZeroObject C] :
    RightHomologyData (ShortComplex.mk f (cokernel.ฯ f) (cokernel.condition f)) := by
  let h := cokernelSequence' f _ (cokernelIsCokernel f)
  exact h

end RightHomologyData

class HasRightHomology : Prop :=
(condition : Nonempty S.RightHomologyData)

noncomputable def rightHomologyData [HasRightHomology S] :
  S.RightHomologyData := HasRightHomology.condition.some

variable {S}

namespace HasRightHomology

lemma mk' (h : S.RightHomologyData) : HasRightHomology S :=
โจNonempty.intro hโฉ

instance of_ker_of_coker
    [HasCokernel S.f] [HasKernel (cokernel.desc S.f S.g S.zero)] :
  S.HasRightHomology := HasRightHomology.mk' (RightHomologyData.ofKerOfCoker S)

instance of_hasKernel {Y Z : C} (g : Y โถ Z) (X : C) [HasKernel g] :
    (ShortComplex.mk (0 : X โถ Y) g zero_comp).HasRightHomology :=
  HasRightHomology.mk' (RightHomologyData.ofHasKernel _ rfl)

instance of_hasCokernel {X Y : C} (f : X โถ Y) (Z : C) [HasCokernel f] :
    (ShortComplex.mk f (0 : Y โถ Z) comp_zero).HasRightHomology :=
  HasRightHomology.mk' (RightHomologyData.ofHasCokernel _ rfl)

instance of_zeros (X Y Z : C) :
    (ShortComplex.mk (0 : X โถ Y) (0 : Y โถ Z) zero_comp).HasRightHomology :=
  HasRightHomology.mk' (RightHomologyData.ofZeros _ rfl rfl)

end HasRightHomology

namespace RightHomologyData

@[simps]
def op (h : S.RightHomologyData) : S.op.LeftHomologyData where
  K := Opposite.op h.Q
  H := Opposite.op h.H
  i := h.p.op
  ฯ := h.ฮน.op
  wi := Quiver.Hom.unop_inj h.wp
  hi := CokernelCofork.IsColimit.ofฯOp _ _ h.hp
  wฯ := Quiver.Hom.unop_inj h.wฮน
  hฯ := KernelFork.IsLimit.ofฮนOp _ _ h.hฮน

@[simp] lemma op_f' (h : S.RightHomologyData) :
    h.op.f' = h.g'.op := rfl

@[simps]
def unop {S : ShortComplex Cแตแต} (h : S.RightHomologyData) : S.unop.LeftHomologyData where
  K := Opposite.unop h.Q
  H := Opposite.unop h.H
  i := h.p.unop
  ฯ := h.ฮน.unop
  wi := Quiver.Hom.op_inj h.wp
  hi := CokernelCofork.IsColimit.ofฯUnop _ _ h.hp
  wฯ := Quiver.Hom.op_inj h.wฮน
  hฯ := KernelFork.IsLimit.ofฮนUnop _ _ h.hฮน

@[simp] lemma unop_f' {S : ShortComplex Cแตแต} (h : S.RightHomologyData) :
    h.unop.f' = h.g'.unop := rfl

end RightHomologyData

namespace LeftHomologyData

@[simps]
def op (h : S.LeftHomologyData) : S.op.RightHomologyData where
  Q := Opposite.op h.K
  H := Opposite.op h.H
  p := h.i.op
  ฮน := h.ฯ.op
  wp := Quiver.Hom.unop_inj h.wi
  hp := KernelFork.IsLimit.ofฮนOp _ _ h.hi
  wฮน := Quiver.Hom.unop_inj h.wฯ
  hฮน := CokernelCofork.IsColimit.ofฯOp _ _ h.hฯ

@[simp] lemma op_g' (h : S.LeftHomologyData) :
    h.op.g' = h.f'.op := rfl

@[simps]
def unop {S : ShortComplex Cแตแต} (h : S.LeftHomologyData) : S.unop.RightHomologyData where
  Q := Opposite.unop h.K
  H := Opposite.unop h.H
  p := h.i.unop
  ฮน := h.ฯ.unop
  wp := Quiver.Hom.op_inj h.wi
  hp := KernelFork.IsLimit.ofฮนUnop _ _ h.hi
  wฮน := Quiver.Hom.op_inj h.wฯ
  hฮน := CokernelCofork.IsColimit.ofฯUnop _ _ h.hฯ

@[simp] lemma unop_g' {S : ShortComplex Cแตแต} (h : S.LeftHomologyData) :
    h.unop.g' = h.f'.unop := rfl

end LeftHomologyData

instance [S.HasLeftHomology] : HasRightHomology S.op :=
  HasRightHomology.mk' S.leftHomologyData.op

instance [S.HasRightHomology] : HasLeftHomology S.op :=
  HasLeftHomology.mk' S.rightHomologyData.op

lemma hasLeftHomology_iff_op (S : ShortComplex C) :
    S.HasLeftHomology โ S.op.HasRightHomology :=
  โจfun _ => inferInstance, fun _ => HasLeftHomology.mk' S.op.rightHomologyData.unopโฉ

lemma hasRightHomology_iff_op (S : ShortComplex C) :
    S.HasRightHomology โ S.op.HasLeftHomology :=
  โจfun _ => inferInstance, fun _ => HasRightHomology.mk' S.op.leftHomologyData.unopโฉ

lemma hasLeftHomology_iff_unop (S : ShortComplex Cแตแต) :
    S.HasLeftHomology โ S.unop.HasRightHomology :=
  S.unop.hasRightHomology_iff_op.symm

lemma hasRightHomology_iff_unop (S : ShortComplex Cแตแต) :
    S.HasRightHomology โ S.unop.HasLeftHomology :=
  S.unop.hasLeftHomology_iff_op.symm

section

variable (ฯ : Sโ โถ Sโ) (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData)

structure RightHomologyMapData where
  ฯQ : hโ.Q โถ hโ.Q
  ฯH : hโ.H โถ hโ.H
  commp : hโ.p โซ ฯQ = ฯ.ฯโ โซ hโ.p := by aesop_cat
  commg' : ฯQ โซ hโ.g' = hโ.g' โซ ฯ.ฯโ := by aesop_cat
  commฮน : ฯH โซ hโ.ฮน = hโ.ฮน โซ ฯQ := by aesop_cat

namespace RightHomologyMapData

attribute [reassoc (attr := simp)] commp commg' commฮน
attribute [nolint simpNF] mk.injEq

@[simps]
def zero (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData) :
  RightHomologyMapData 0 hโ hโ where
  ฯQ := 0
  ฯH := 0

@[simps]
def id (h : S.RightHomologyData) : RightHomologyMapData (๐ S) h h where
  ฯQ := ๐ _
  ฯH := ๐ _

@[simps]
def comp {ฯ : Sโ โถ Sโ} {ฯ' : Sโ โถ Sโ} {hโ : Sโ.RightHomologyData}
  {hโ : Sโ.RightHomologyData} {hโ : Sโ.RightHomologyData}
  (ฯ : RightHomologyMapData ฯ hโ hโ) (ฯ' : RightHomologyMapData ฯ' hโ hโ) :
  RightHomologyMapData (ฯ โซ ฯ') hโ hโ where
  ฯQ := ฯ.ฯQ โซ ฯ'.ฯQ
  ฯH := ฯ.ฯH โซ ฯ'.ฯH

instance : Subsingleton (RightHomologyMapData ฯ hโ hโ) :=
  โจfun ฯโ ฯโ => by
    have hQ : ฯโ.ฯQ = ฯโ.ฯQ := by rw [โ cancel_epi hโ.p, commp, commp]
    have hH : ฯโ.ฯH = ฯโ.ฯH := by rw [โ cancel_mono hโ.ฮน, commฮน, commฮน, hQ]
    cases ฯโ
    cases ฯโ
    congrโฉ

instance : Inhabited (RightHomologyMapData ฯ hโ hโ) := โจby
  let ฯQ : hโ.Q โถ hโ.Q := hโ.descQ (ฯ.ฯโ โซ hโ.p) (by rw [โ ฯ.commโโ_assoc, hโ.wp, comp_zero])
  have commg' : ฯQ โซ hโ.g' = hโ.g' โซ ฯ.ฯโ :=
    by rw [โ cancel_epi hโ.p, RightHomologyData.p_descQ_assoc, assoc,
      RightHomologyData.p_g', ฯ.commโโ, RightHomologyData.p_g'_assoc]
  let ฯH : hโ.H โถ hโ.H := hโ.liftH (hโ.ฮน โซ ฯQ)
    (by rw [assoc, commg', RightHomologyData.ฮน_g'_assoc, zero_comp])
  exact โจฯQ, ฯH, by simp, commg', by simpโฉโฉ

instance : Unique (RightHomologyMapData ฯ hโ hโ) := Unique.mk' _

def _root_.CategoryTheory.ShortComplex.rightHomologyMapData :
  RightHomologyMapData ฯ hโ hโ := default

variable {ฯ hโ hโ}

lemma congr_ฯH {ฮณโ ฮณโ : RightHomologyMapData ฯ hโ hโ} (eq : ฮณโ = ฮณโ) : ฮณโ.ฯH = ฮณโ.ฯH := by rw [eq]
lemma congr_ฯQ {ฮณโ ฮณโ : RightHomologyMapData ฯ hโ hโ} (eq : ฮณโ = ฮณโ) : ฮณโ.ฯQ = ฮณโ.ฯQ := by rw [eq]

@[simps]
def ofZeros (ฯ : Sโ โถ Sโ) (hfโ : Sโ.f = 0) (hgโ : Sโ.g = 0) (hfโ : Sโ.f = 0) (hgโ : Sโ.g = 0) :
  RightHomologyMapData ฯ (RightHomologyData.ofZeros Sโ hfโ hgโ)
    (RightHomologyData.ofZeros Sโ hfโ hgโ) where
  ฯQ := ฯ.ฯโ
  ฯH := ฯ.ฯโ

@[simps]
def ofIsLimitKernelFork (ฯ : Sโ โถ Sโ)
    (hfโ : Sโ.f = 0) (cโ : KernelFork Sโ.g) (hcโ : IsLimit cโ)
    (hfโ : Sโ.f = 0) (cโ : KernelFork Sโ.g) (hcโ : IsLimit cโ) (f : cโ.pt โถ cโ.pt)
    (comm : cโ.ฮน โซ ฯ.ฯโ = f โซ cโ.ฮน) :
    RightHomologyMapData ฯ (RightHomologyData.ofIsLimitKernelFork Sโ hfโ cโ hcโ)
      (RightHomologyData.ofIsLimitKernelFork Sโ hfโ cโ hcโ) where
  ฯQ := ฯ.ฯโ
  ฯH := f
  commg' := by simp only [RightHomologyData.ofIsLimitKernelFork_g', ฯ.commโโ]
  commฮน := comm.symm

@[simps]
def ofIsColimitCokernelCofork (ฯ : Sโ โถ Sโ)
  (hgโ : Sโ.g = 0) (cโ : CokernelCofork Sโ.f) (hcโ : IsColimit cโ)
  (hgโ : Sโ.g = 0) (cโ : CokernelCofork Sโ.f) (hcโ : IsColimit cโ) (f : cโ.pt โถ cโ.pt)
  (comm : ฯ.ฯโ โซ cโ.ฯ = cโ.ฯ โซ f) :
  RightHomologyMapData ฯ (RightHomologyData.ofIsColimitCokernelCofork Sโ hgโ cโ hcโ)
    (RightHomologyData.ofIsColimitCokernelCofork Sโ hgโ cโ hcโ) where
  ฯQ := f
  ฯH := f
  commp := comm.symm

variable (S)

@[simps]
def compatibilityOfZerosOfIsLimitKernelFork (hf : S.f = 0) (hg : S.g = 0)
    (c : KernelFork S.g) (hc : IsLimit c) :
    RightHomologyMapData (๐ S)
      (RightHomologyData.ofIsLimitKernelFork S hf c hc)
      (RightHomologyData.ofZeros S hf hg) where
  ฯQ := ๐ _
  ฯH := c.ฮน

@[simps]
def compatibilityOfZerosOfIsColimitCokernelCofork (hf : S.f = 0) (hg : S.g = 0)
  (c : CokernelCofork S.f) (hc : IsColimit c) :
  RightHomologyMapData (๐ S)
    (RightHomologyData.ofZeros S hf hg)
    (RightHomologyData.ofIsColimitCokernelCofork S hg c hc) where
  ฯQ := c.ฯ
  ฯH := c.ฯ

end RightHomologyMapData

end

variable (S)

noncomputable def rightHomology [HasRightHomology S] : C := S.rightHomologyData.H
noncomputable def cyclesCo [HasRightHomology S] : C := S.rightHomologyData.Q
noncomputable def rightHomologyฮน [HasRightHomology S] : S.rightHomology โถ S.cyclesCo :=
  S.rightHomologyData.ฮน
noncomputable def pCyclesCo [HasRightHomology S] : S.Xโ โถ S.cyclesCo := S.rightHomologyData.p
noncomputable def fromCyclesCo [HasRightHomology S] : S.cyclesCo โถ S.Xโ := S.rightHomologyData.g'

@[reassoc (attr := simp)]
lemma f_pCyclesCo [HasRightHomology S] : S.f โซ S.pCyclesCo = 0 :=
  S.rightHomologyData.wp

@[reassoc (attr := simp)]
lemma p_fromCyclesCo [HasRightHomology S] : S.pCyclesCo โซ S.fromCyclesCo = S.g :=
  S.rightHomologyData.p_g'

instance [HasRightHomology S] : Epi S.pCyclesCo := by
  dsimp only [pCyclesCo]
  infer_instance

instance [HasRightHomology S] : Mono S.rightHomologyฮน := by
  dsimp only [rightHomologyฮน]
  infer_instance

variable {S}

def rightHomologyMap' (ฯ : Sโ โถ Sโ) (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData) :
  hโ.H โถ hโ.H := (rightHomologyMapData ฯ _ _).ฯH

def cyclesCoMap' (ฯ : Sโ โถ Sโ) (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData) :
  hโ.Q โถ hโ.Q := (rightHomologyMapData ฯ _ _).ฯQ

@[reassoc (attr := simp)]
lemma p_cyclesCoMap' (ฯ : Sโ โถ Sโ) (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData) :
    hโ.p โซ cyclesCoMap' ฯ hโ hโ = ฯ.ฯโ โซ hโ.p :=
  RightHomologyMapData.commp _

@[reassoc (attr := simp)]
lemma rightHomologyฮน_naturality' (ฯ : Sโ โถ Sโ)
    (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData) :
    rightHomologyMap' ฯ hโ hโ โซ hโ.ฮน = hโ.ฮน โซ cyclesCoMap' ฯ hโ hโ :=
  RightHomologyMapData.commฮน _

noncomputable def rightHomologyMap [HasRightHomology Sโ] [HasRightHomology Sโ]
    (ฯ : Sโ โถ Sโ) : Sโ.rightHomology โถ Sโ.rightHomology :=
  rightHomologyMap' ฯ _ _

noncomputable def cyclesCoMap [HasRightHomology Sโ] [HasRightHomology Sโ]
    (ฯ : Sโ โถ Sโ) : Sโ.cyclesCo โถ Sโ.cyclesCo :=
  cyclesCoMap' ฯ _ _

@[reassoc (attr := simp)]
lemma p_cyclesCoMap (ฯ : Sโ โถ Sโ) [Sโ.HasRightHomology] [Sโ.HasRightHomology] :
    Sโ.pCyclesCo โซ cyclesCoMap ฯ = ฯ.ฯโ โซ Sโ.pCyclesCo :=
  p_cyclesCoMap' _ _ _

@[reassoc (attr := simp)]
lemma fromCyclesCo_naturality (ฯ : Sโ โถ Sโ) [Sโ.HasRightHomology] [Sโ.HasRightHomology] :
    cyclesCoMap ฯ โซ Sโ.fromCyclesCo = Sโ.fromCyclesCo โซ ฯ.ฯโ := by
  simp only [โ cancel_epi Sโ.pCyclesCo, p_cyclesCoMap_assoc, p_fromCyclesCo,
    p_fromCyclesCo_assoc, ฯ.commโโ]

@[reassoc (attr := simp)]
lemma rightHomologyฮน_naturality [HasRightHomology Sโ] [HasRightHomology Sโ]
    (ฯ : Sโ โถ Sโ) :
    rightHomologyMap ฯ โซ Sโ.rightHomologyฮน = Sโ.rightHomologyฮน โซ cyclesCoMap ฯ :=
  rightHomologyฮน_naturality' _ _ _

namespace RightHomologyMapData

variable {ฯ : Sโ โถ Sโ} {hโ : Sโ.RightHomologyData} {hโ : Sโ.RightHomologyData}
  (ฮณ : RightHomologyMapData ฯ hโ hโ)

lemma rightHomologyMap'_eq : rightHomologyMap' ฯ hโ hโ = ฮณ.ฯH :=
  RightHomologyMapData.congr_ฯH (Subsingleton.elim _ _)

lemma cyclesCoMap'_eq : cyclesCoMap' ฯ hโ hโ = ฮณ.ฯQ :=
  RightHomologyMapData.congr_ฯQ (Subsingleton.elim _ _)

end RightHomologyMapData

@[simp]
lemma rightHomologyMap'_id (h : S.RightHomologyData) :
    rightHomologyMap' (๐ S) h h = ๐ _ :=
  (RightHomologyMapData.id h).rightHomologyMap'_eq

@[simp]
lemma cyclesCoMap'_id (h : S.RightHomologyData) :
    cyclesCoMap' (๐ S) h h = ๐ _ :=
  (RightHomologyMapData.id h).cyclesCoMap'_eq

variable (S)

@[simp]
lemma rightHomologyMap_id [HasRightHomology S] :
    rightHomologyMap (๐ S) = ๐ _ :=
  rightHomologyMap'_id _

@[simp]
lemma cyclesCoMap_id [HasRightHomology S] :
    cyclesCoMap (๐ S) = ๐ _ :=
  cyclesCoMap'_id _

@[simp]
lemma rightHomologyMap'_zero (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData) :
    rightHomologyMap' 0 hโ hโ = 0 :=
  (RightHomologyMapData.zero hโ hโ).rightHomologyMap'_eq

@[simp]
lemma cyclesCoMap'_zero (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData) :
    cyclesCoMap' 0 hโ hโ = 0 :=
  (RightHomologyMapData.zero hโ hโ).cyclesCoMap'_eq

variable (Sโ Sโ)

@[simp]
lemma rightHomologyMap_zero [HasRightHomology Sโ] [HasRightHomology Sโ] :
    rightHomologyMap (0 : Sโ โถ Sโ) = 0 :=
  rightHomologyMap'_zero _ _

@[simp]
lemma cyclesCoMap_zero [HasRightHomology Sโ] [HasRightHomology Sโ] :
  cyclesCoMap (0 : Sโ โถ Sโ) = 0 :=
cyclesCoMap'_zero _ _

variable {Sโ Sโ}

@[reassoc]
lemma rightHomologyMap'_comp (ฯโ : Sโ โถ Sโ) (ฯโ : Sโ โถ Sโ)
    (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData) :
    rightHomologyMap' (ฯโ โซ ฯโ) hโ hโ = rightHomologyMap' ฯโ hโ hโ โซ
      rightHomologyMap' ฯโ hโ hโ := by
  let ฮณโ := rightHomologyMapData ฯโ hโ hโ
  let ฮณโ := rightHomologyMapData ฯโ hโ hโ
  rw [ฮณโ.rightHomologyMap'_eq, ฮณโ.rightHomologyMap'_eq, (ฮณโ.comp ฮณโ).rightHomologyMap'_eq,
    RightHomologyMapData.comp_ฯH]

@[reassoc]
lemma cyclesCoMap'_comp (ฯโ : Sโ โถ Sโ) (ฯโ : Sโ โถ Sโ)
    (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData) :
    cyclesCoMap' (ฯโ โซ ฯโ) hโ hโ = cyclesCoMap' ฯโ hโ hโ โซ cyclesCoMap' ฯโ hโ hโ := by
  let ฮณโ := rightHomologyMapData ฯโ hโ hโ
  let ฮณโ := rightHomologyMapData ฯโ hโ hโ
  rw [ฮณโ.cyclesCoMap'_eq, ฮณโ.cyclesCoMap'_eq, (ฮณโ.comp ฮณโ).cyclesCoMap'_eq,
    RightHomologyMapData.comp_ฯQ]

@[simp]
lemma rightHomologyMap_comp [HasRightHomology Sโ] [HasRightHomology Sโ] [HasRightHomology Sโ]
    (ฯโ : Sโ โถ Sโ) (ฯโ : Sโ โถ Sโ) :
    rightHomologyMap (ฯโ โซ ฯโ) = rightHomologyMap ฯโ โซ rightHomologyMap ฯโ :=
rightHomologyMap'_comp _ _ _ _ _

@[simp]
lemma cyclesCoMap_comp [HasRightHomology Sโ] [HasRightHomology Sโ] [HasRightHomology Sโ]
    (ฯโ : Sโ โถ Sโ) (ฯโ : Sโ โถ Sโ) :
    cyclesCoMap (ฯโ โซ ฯโ) = cyclesCoMap ฯโ โซ cyclesCoMap ฯโ :=
  cyclesCoMap'_comp _ _ _ _ _

attribute [simp] rightHomologyMap_comp cyclesCoMap_comp

@[simps]
def rightHomologyMapIso' (e : Sโ โ Sโ) (hโ : Sโ.RightHomologyData)
    (hโ : Sโ.RightHomologyData) : hโ.H โ hโ.H where
  hom := rightHomologyMap' e.hom hโ hโ
  inv := rightHomologyMap' e.inv hโ hโ
  hom_inv_id := by rw [โ rightHomologyMap'_comp, e.hom_inv_id, rightHomologyMap'_id]
  inv_hom_id := by rw [โ rightHomologyMap'_comp, e.inv_hom_id, rightHomologyMap'_id]

instance isIso_rightHomologyMap'_of_isIso (ฯ : Sโ โถ Sโ) [IsIso ฯ]
    (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData) :
    IsIso (rightHomologyMap' ฯ hโ hโ) :=
  (inferInstance : IsIso (rightHomologyMapIso' (asIso ฯ) hโ hโ).hom)

@[simps]
def cyclesCoMapIso' (e : Sโ โ Sโ) (hโ : Sโ.RightHomologyData)
  (hโ : Sโ.RightHomologyData) : hโ.Q โ hโ.Q where
  hom := cyclesCoMap' e.hom hโ hโ
  inv := cyclesCoMap' e.inv hโ hโ
  hom_inv_id := by rw [โ cyclesCoMap'_comp, e.hom_inv_id, cyclesCoMap'_id]
  inv_hom_id := by rw [โ cyclesCoMap'_comp, e.inv_hom_id, cyclesCoMap'_id]

instance isIso_cyclesCoMap'_of_isIso (ฯ : Sโ โถ Sโ) [IsIso ฯ]
    (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData) :
    IsIso (cyclesCoMap' ฯ hโ hโ) :=
  (inferInstance : IsIso (cyclesCoMapIso' (asIso ฯ) hโ hโ).hom)

@[simps]
noncomputable def rightHomologyMapIso (e : Sโ โ Sโ) [Sโ.HasRightHomology]
  [Sโ.HasRightHomology] : Sโ.rightHomology โ Sโ.rightHomology where
  hom := rightHomologyMap e.hom
  inv := rightHomologyMap e.inv
  hom_inv_id := by rw [โ rightHomologyMap_comp, e.hom_inv_id, rightHomologyMap_id]
  inv_hom_id := by rw [โ rightHomologyMap_comp, e.inv_hom_id, rightHomologyMap_id]

instance isIso_rightHomologyMap_of_iso (ฯ : Sโ โถ Sโ) [IsIso ฯ] [Sโ.HasRightHomology]
    [Sโ.HasRightHomology] :
    IsIso (rightHomologyMap ฯ) :=
  (inferInstance : IsIso (rightHomologyMapIso (asIso ฯ)).hom)

@[simps]
noncomputable def cyclesCoMapIso (e : Sโ โ Sโ) [Sโ.HasRightHomology]
    [Sโ.HasRightHomology] : Sโ.cyclesCo โ Sโ.cyclesCo where
  hom := cyclesCoMap e.hom
  inv := cyclesCoMap e.inv
  hom_inv_id := by rw [โ cyclesCoMap_comp, e.hom_inv_id, cyclesCoMap_id]
  inv_hom_id := by rw [โ cyclesCoMap_comp, e.inv_hom_id, cyclesCoMap_id]

instance isIso_cyclesCoMap_of_iso (ฯ : Sโ โถ Sโ) [IsIso ฯ] [Sโ.HasRightHomology]
    [Sโ.HasRightHomology] : IsIso (cyclesCoMap ฯ) :=
  (inferInstance : IsIso (cyclesCoMapIso (asIso ฯ)).hom)

variable {S}

noncomputable def RightHomologyData.rightHomologyIso (h : S.RightHomologyData) [S.HasRightHomology] :
  S.rightHomology โ h.H := rightHomologyMapIso' (Iso.refl _) _ _

noncomputable def RightHomologyData.cyclesCoIso (h : S.RightHomologyData) [S.HasRightHomology] :
  S.cyclesCo โ h.Q := cyclesCoMapIso' (Iso.refl _) _ _

@[reassoc (attr := simp)]
lemma RightHomologyData.p_compCyclesCoIso_inv (h : S.RightHomologyData) [S.HasRightHomology] :
    h.p โซ h.cyclesCoIso.inv = S.pCyclesCo := by
  dsimp [pCyclesCo, RightHomologyData.cyclesCoIso]
  simp only [p_cyclesCoMap', id_ฯโ, id_comp]

@[reassoc (attr := simp)]
lemma RightHomologyData.pCyclesCo_compCyclesCoIso_hom (h : S.RightHomologyData)
    [S.HasRightHomology] : S.pCyclesCo โซ h.cyclesCoIso.hom = h.p := by
  simp only [โ h.p_compCyclesCoIso_inv, assoc, Iso.inv_hom_id, comp_id]

namespace RightHomologyMapData

variable {ฯ : Sโ โถ Sโ} {hโ : Sโ.RightHomologyData} {hโ : Sโ.RightHomologyData}
  (ฮณ : RightHomologyMapData ฯ hโ hโ)

lemma rightHomologyMap_eq [Sโ.HasRightHomology] [Sโ.HasRightHomology] :
    rightHomologyMap ฯ = hโ.rightHomologyIso.hom โซ ฮณ.ฯH โซ hโ.rightHomologyIso.inv := by
  dsimp [RightHomologyData.rightHomologyIso, rightHomologyMapIso']
  rw [โ ฮณ.rightHomologyMap'_eq, โ rightHomologyMap'_comp,
    โ rightHomologyMap'_comp, id_comp, comp_id]
  rfl

lemma cyclesCoMap_eq [Sโ.HasRightHomology] [Sโ.HasRightHomology] :
    cyclesCoMap ฯ = hโ.cyclesCoIso.hom โซ ฮณ.ฯQ โซ hโ.cyclesCoIso.inv := by
  dsimp [RightHomologyData.cyclesCoIso, cyclesMapIso']
  rw [โ ฮณ.cyclesCoMap'_eq, โ cyclesCoMap'_comp, โ cyclesCoMap'_comp, id_comp, comp_id]
  rfl

lemma rightHomologyMap_comm [Sโ.HasRightHomology] [Sโ.HasRightHomology] :
    rightHomologyMap ฯ โซ hโ.rightHomologyIso.hom = hโ.rightHomologyIso.hom โซ ฮณ.ฯH := by
  simp only [ฮณ.rightHomologyMap_eq, assoc, Iso.inv_hom_id, comp_id]

lemma cyclesCoMap_comm [Sโ.HasRightHomology] [Sโ.HasRightHomology] :
    cyclesCoMap ฯ โซ hโ.cyclesCoIso.hom = hโ.cyclesCoIso.hom โซ ฮณ.ฯQ := by
  simp only [ฮณ.cyclesCoMap_eq, assoc, Iso.inv_hom_id, comp_id]

end RightHomologyMapData

variable (C)

/-- We shall say that a category with right homology is a category for which
all short complexes have right homology. -/
abbrev _root_.CategoryTheory.CategoryWithRightHomology : Prop :=
  โ (S : ShortComplex C), S.HasRightHomology

@[simps]
noncomputable def rightHomologyFunctor [CategoryWithRightHomology C] :
    ShortComplex C โฅค C where
  obj S := S.rightHomology
  map := rightHomologyMap

@[simps]
noncomputable def cyclesCoFunctor [CategoryWithRightHomology C] :
    ShortComplex C โฅค C where
  obj S := S.cyclesCo
  map := cyclesCoMap

@[simps]
noncomputable def rightHomologyฮนNatTrans [CategoryWithRightHomology C] :
    rightHomologyFunctor C โถ cyclesCoFunctor C where
  app S := rightHomologyฮน S
  naturality := fun _ _ ฯ => rightHomologyฮน_naturality ฯ

@[simps]
noncomputable def pCyclesCoNatTrans [CategoryWithRightHomology C] :
    ShortComplex.ฯโ โถ cyclesCoFunctor C where
  app S := S.pCyclesCo

@[simps]
noncomputable def fromCyclesCoNatTrans [CategoryWithRightHomology C] :
    cyclesCoFunctor C โถ ฯโ where
  app S := S.fromCyclesCo
  naturality := fun _ _  ฯ => fromCyclesCo_naturality ฯ

variable {C}

@[simps]
def LeftHomologyMapData.op {Sโ Sโ : ShortComplex C} {ฯ : Sโ โถ Sโ}
    {hโ : Sโ.LeftHomologyData} {hโ : Sโ.LeftHomologyData}
    (ฯ : LeftHomologyMapData ฯ hโ hโ) : RightHomologyMapData (opMap ฯ) hโ.op hโ.op where
  ฯQ := ฯ.ฯK.op
  ฯH := ฯ.ฯH.op
  commp := Quiver.Hom.unop_inj (by simp)
  commg' := Quiver.Hom.unop_inj (by simp)
  commฮน := Quiver.Hom.unop_inj (by simp)

@[simps]
def LeftHomologyMapData.unop {Sโ Sโ : ShortComplex Cแตแต} {ฯ : Sโ โถ Sโ}
    {hโ : Sโ.LeftHomologyData} {hโ : Sโ.LeftHomologyData}
    (ฯ : LeftHomologyMapData ฯ hโ hโ) : RightHomologyMapData (unopMap ฯ) hโ.unop hโ.unop where
  ฯQ := ฯ.ฯK.unop
  ฯH := ฯ.ฯH.unop
  commp := Quiver.Hom.op_inj (by simp)
  commg' := Quiver.Hom.op_inj (by simp)
  commฮน := Quiver.Hom.op_inj (by simp)

@[simps]
def RightHomologyMapData.op {Sโ Sโ : ShortComplex C} {ฯ : Sโ โถ Sโ}
    {hโ : Sโ.RightHomologyData} {hโ : Sโ.RightHomologyData}
    (ฯ : RightHomologyMapData ฯ hโ hโ) : LeftHomologyMapData (opMap ฯ) hโ.op hโ.op where
  ฯK := ฯ.ฯQ.op
  ฯH := ฯ.ฯH.op
  commi := Quiver.Hom.unop_inj (by simp)
  commf' := Quiver.Hom.unop_inj (by simp)
  commฯ := Quiver.Hom.unop_inj (by simp)

@[simps]
def RightHomologyMapData.unop {Sโ Sโ : ShortComplex Cแตแต} {ฯ : Sโ โถ Sโ}
    {hโ : Sโ.RightHomologyData} {hโ : Sโ.RightHomologyData}
    (ฯ : RightHomologyMapData ฯ hโ hโ) : LeftHomologyMapData (unopMap ฯ) hโ.unop hโ.unop where
  ฯK := ฯ.ฯQ.unop
  ฯH := ฯ.ฯH.unop
  commi := Quiver.Hom.op_inj (by simp)
  commf' := Quiver.Hom.op_inj (by simp)
  commฯ := Quiver.Hom.op_inj (by simp)

variable (S)

noncomputable def rightHomologyOpIso [S.HasLeftHomology] :
    S.op.rightHomology โ Opposite.op S.leftHomology :=
  S.leftHomologyData.op.rightHomologyIso

noncomputable def leftHomologyOpIso [S.HasRightHomology] :
    S.op.leftHomology โ Opposite.op S.rightHomology :=
  S.rightHomologyData.op.leftHomologyIso

noncomputable def cyclesCoOpIso [S.HasLeftHomology] :
    S.op.cyclesCo โ Opposite.op S.cycles :=
  S.leftHomologyData.op.cyclesCoIso

noncomputable def cyclesOpIso [S.HasRightHomology] :
    S.op.cycles โ Opposite.op S.cyclesCo :=
  S.rightHomologyData.op.cyclesIso

@[simp]
lemma leftHomologyMap'_op
    (ฯ : Sโ โถ Sโ) (hโ : Sโ.LeftHomologyData) (hโ : Sโ.LeftHomologyData) :
    (leftHomologyMap' ฯ hโ hโ).op = rightHomologyMap' (opMap ฯ) hโ.op hโ.op := by
  let ฮณ : LeftHomologyMapData ฯ hโ hโ := default
  simp only [ฮณ.leftHomologyMap'_eq, (ฮณ.op).rightHomologyMap'_eq,
    LeftHomologyMapData.op_ฯH]

@[simp]
lemma leftHomologyMap_op (ฯ : Sโ โถ Sโ) [Sโ.HasLeftHomology] [Sโ.HasLeftHomology] :
    (leftHomologyMap ฯ).op = (Sโ.rightHomologyOpIso).inv โซ rightHomologyMap (opMap ฯ) โซ
      (Sโ.rightHomologyOpIso).hom := by
  dsimp [rightHomologyOpIso, RightHomologyData.rightHomologyIso, rightHomologyMap,
    leftHomologyMap]
  simp only [โ rightHomologyMap'_comp, comp_id, id_comp, leftHomologyMap'_op]

@[simp]
lemma rightHomologyMap'_op
    (ฯ : Sโ โถ Sโ) (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData) :
    (rightHomologyMap' ฯ hโ hโ).op = leftHomologyMap' (opMap ฯ) hโ.op hโ.op := by
  let ฮณ : RightHomologyMapData ฯ hโ hโ := default
  simp only [ฮณ.rightHomologyMap'_eq, (ฮณ.op).leftHomologyMap'_eq,
    RightHomologyMapData.op_ฯH]

@[simp]
lemma rightHomologyMap_op (ฯ : Sโ โถ Sโ) [Sโ.HasRightHomology] [Sโ.HasRightHomology] :
    (rightHomologyMap ฯ).op = (Sโ.leftHomologyOpIso).inv โซ leftHomologyMap
      (opMap ฯ) โซ (Sโ.leftHomologyOpIso).hom := by
  dsimp [leftHomologyOpIso, LeftHomologyData.leftHomologyIso, leftHomologyMap,
    rightHomologyMap]
  simp only [โ leftHomologyMap'_comp, comp_id, id_comp, rightHomologyMap'_op]

namespace RightHomologyData

section

variable (ฯ : Sโ โถ Sโ) (h : RightHomologyData Sโ) [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ]

noncomputable def ofEpiOfIsIsoOfMono : RightHomologyData Sโ := by
  haveI : Epi (opMap ฯ).ฯโ := by dsimp ; infer_instance
  haveI : IsIso (opMap ฯ).ฯโ := by dsimp ; infer_instance
  haveI : Mono (opMap ฯ).ฯโ := by dsimp ; infer_instance
  exact (LeftHomologyData.ofEpiOfIsIsoOfMono' (opMap ฯ) h.op).unop

@[simp] lemma ofEpiOfIsIsoOfMono_Q : (ofEpiOfIsIsoOfMono ฯ h).Q = h.Q := rfl

@[simp] lemma ofEpiOfIsIsoOfMono_H : (ofEpiOfIsIsoOfMono ฯ h).H = h.H := rfl

@[simp] lemma ofEpiOfIsIsoOfMono_p : (ofEpiOfIsIsoOfMono ฯ h).p = (inv ฯ.ฯโ) โซ h.p := by
  simp [ofEpiOfIsIsoOfMono, opMap]

@[simp] lemma ofEpiOfIsIsoOfMono_ฮน : (ofEpiOfIsIsoOfMono ฯ h).ฮน = h.ฮน := rfl

@[simp] lemma ofEpiOfIsIsoOfMono_g' : (ofEpiOfIsIsoOfMono ฯ h).g' = h.g' โซ ฯ.ฯโ := by
  simp [ofEpiOfIsIsoOfMono, opMap]

end

section

variable (ฯ : Sโ โถ Sโ) (h : RightHomologyData Sโ) [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ]

noncomputable def ofEpiOfIsIsoOfMono' : RightHomologyData Sโ := by
  haveI : Epi (opMap ฯ).ฯโ := by dsimp ; infer_instance
  haveI : IsIso (opMap ฯ).ฯโ := by dsimp ; infer_instance
  haveI : Mono (opMap ฯ).ฯโ := by dsimp ; infer_instance
  exact (LeftHomologyData.ofEpiOfIsIsoOfMono (opMap ฯ) h.op).unop

@[simp] lemma ofEpiOfIsIsoOfMono'_Q : (ofEpiOfIsIsoOfMono' ฯ h).Q = h.Q := rfl

@[simp] lemma ofEpiOfIsIsoOfMono'_H : (ofEpiOfIsIsoOfMono' ฯ h).H = h.H := rfl

@[simp] lemma ofEpiOfIsIsoOfMono'_p : (ofEpiOfIsIsoOfMono' ฯ h).p = ฯ.ฯโ โซ h.p := by
  simp [ofEpiOfIsIsoOfMono', opMap]

@[simp] lemma ofEpiOfIsIsoOfMono'_ฮน : (ofEpiOfIsIsoOfMono' ฯ h).ฮน = h.ฮน := rfl

@[simp] lemma ofEpiOfIsIsoOfMono'_g'_ฯโ : (ofEpiOfIsIsoOfMono' ฯ h).g' โซ ฯ.ฯโ = h.g' := by
  rw [โ cancel_epi (ofEpiOfIsIsoOfMono' ฯ h).p, p_g'_assoc, ofEpiOfIsIsoOfMono'_p,
    assoc, p_g', ฯ.commโโ]

end

noncomputable def ofIso (e : Sโ โ Sโ) (hโ : RightHomologyData Sโ) : RightHomologyData Sโ :=
  hโ.ofEpiOfIsIsoOfMono e.hom

end RightHomologyData

lemma hasRightHomology_of_epi_of_isIso_of_mono (ฯ : Sโ โถ Sโ) [HasRightHomology Sโ]
    [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ] : HasRightHomology Sโ :=
  HasRightHomology.mk' (RightHomologyData.ofEpiOfIsIsoOfMono ฯ Sโ.rightHomologyData)

lemma hasRightHomology_of_epi_of_isIso_of_mono' (ฯ : Sโ โถ Sโ) [HasRightHomology Sโ]
    [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ] : HasRightHomology Sโ :=
HasRightHomology.mk' (RightHomologyData.ofEpiOfIsIsoOfMono' ฯ Sโ.rightHomologyData)

lemma hasRightHomology_of_iso {Sโ Sโ : ShortComplex C}
    (e : Sโ โ Sโ) [HasRightHomology Sโ] : HasRightHomology Sโ :=
  hasRightHomology_of_epi_of_isIso_of_mono e.hom

instance _root_.CategoryTheory.CategoryWithRightHomology.op
    [CategoryWithRightHomology C] : CategoryWithLeftHomology Cแตแต :=
  fun S => ShortComplex.hasLeftHomology_of_iso S.unopOp

instance _root_.CategoryTheory.CategoryWithLeftHomology.op
    [CategoryWithLeftHomology C] : CategoryWithRightHomology Cแตแต :=
  fun S => ShortComplex.hasRightHomology_of_iso S.unopOp

namespace RightHomologyMapData

@[simps]
def ofEpiOfIsIsoOfMono (ฯ : Sโ โถ Sโ) (h : RightHomologyData Sโ)
    [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ] :
    RightHomologyMapData ฯ h (RightHomologyData.ofEpiOfIsIsoOfMono ฯ h) where
  ฯQ := ๐ _
  ฯH := ๐ _

@[simps]
noncomputable def ofEpiOfIsIsoOfMono' (ฯ : Sโ โถ Sโ) (h : RightHomologyData Sโ)
  [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ] :
    RightHomologyMapData ฯ (RightHomologyData.ofEpiOfIsIsoOfMono' ฯ h) h :=
{ ฯQ := ๐ _,
  ฯH := ๐ _, }

end RightHomologyMapData

instance (ฯ : Sโ โถ Sโ) (hโ : Sโ.RightHomologyData) (hโ : Sโ.RightHomologyData)
    [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ] :
    IsIso (rightHomologyMap' ฯ hโ hโ) := by
  let hโ' := RightHomologyData.ofEpiOfIsIsoOfMono ฯ hโ
  haveI : IsIso (rightHomologyMap' ฯ hโ hโ') := by
    rw [(RightHomologyMapData.ofEpiOfIsIsoOfMono ฯ hโ).rightHomologyMap'_eq]
    dsimp
    infer_instance
  have eq := rightHomologyMap'_comp ฯ (๐ Sโ) hโ hโ' hโ
  rw [comp_id] at eq
  rw [eq]
  infer_instance

instance (ฯ : Sโ โถ Sโ) [Sโ.HasRightHomology] [Sโ.HasRightHomology]
    [Epi ฯ.ฯโ] [IsIso ฯ.ฯโ] [Mono ฯ.ฯโ] :
    IsIso (rightHomologyMap ฯ) := by
  dsimp only [rightHomologyMap]
  infer_instance

variable (C)

@[simps!]
noncomputable def rightHomologyFunctorOpNatIso [CategoryWithRightHomology C] :
  (rightHomologyFunctor C).op โ opFunctor C โ leftHomologyFunctor Cแตแต :=
    NatIso.ofComponents (fun S => (leftHomologyOpIso S.unop).symm) (by simp)

@[simps!]
noncomputable def leftHomologyFunctorOpNatIso [CategoryWithLeftHomology C] :
  (leftHomologyFunctor C).op โ opFunctor C โ rightHomologyFunctor Cแตแต :=
    NatIso.ofComponents (fun S => (rightHomologyOpIso S.unop).symm) (by simp)

section

variable {S C}
variable (h : RightHomologyData S)
  {A : C} (k : S.Xโ โถ A) (hk : S.f โซ k = 0) [HasRightHomology S]

noncomputable def descCyclesCo : S.cyclesCo โถ A :=
  S.rightHomologyData.descQ k hk

@[reassoc (attr := simp)]
lemma p_descCyclesCo : S.pCyclesCo โซ S.descCyclesCo k hk = k :=
  RightHomologyData.p_descQ _ k hk

@[reassoc]
lemma descCyclesCo_comp {A' : C} (ฮฑ : A โถ A') :
    S.descCyclesCo k hk โซ ฮฑ = S.descCyclesCo (k โซ ฮฑ) (by rw [reassoc_of% hk, zero_comp]) := by
  simp only [โ cancel_epi S.pCyclesCo, p_descCyclesCo_assoc, p_descCyclesCo]

variable (S)

noncomputable def cyclesCoIsCokernel :
    IsColimit (CokernelCofork.ofฯ S.pCyclesCo S.f_pCyclesCo) :=
  S.rightHomologyData.hp

lemma isIso_pCyclesCo_of_zero (hf : S.f = 0) : IsIso (S.pCyclesCo) :=
  CokernelCofork.IsColimit.isIso_ฯ_of_zero _ S.cyclesCoIsCokernel hf

@[simps]
noncomputable def cyclesCoIsoCokernel [HasCokernel S.f] : S.cyclesCo โ cokernel S.f where
  hom := S.descCyclesCo (cokernel.ฯ S.f) (by simp)
  inv := cokernel.desc S.f S.pCyclesCo (by simp)
  hom_inv_id := by simp only [โ cancel_epi S.pCyclesCo, p_descCyclesCo_assoc,
    cokernel.ฯ_desc, comp_id]
  inv_hom_id := by simp only [โ cancel_epi (cokernel.ฯ S.f), cokernel.ฯ_desc_assoc,
    p_descCyclesCo, comp_id]

variable {S}

@[simp]
noncomputable def descRightHomology : S.rightHomology โถ A :=
  S.rightHomologyฮน โซ S.descCyclesCo k hk

lemma ฮน_descCyclesCo_ฯ_eq_zero_of_boundary (x : S.Xโ โถ A) (hx : k = S.g โซ x) :
    S.rightHomologyฮน โซ S.descCyclesCo k (by rw [hx, S.zero_assoc, zero_comp]) = 0 :=
  RightHomologyData.ฮน_descQ_eq_zero_of_boundary _ k x hx

variable (S)

@[reassoc (attr := simp)]
lemma rightHomologyฮน_comp_fromCyclesCo :
    S.rightHomologyฮน โซ S.fromCyclesCo = 0 :=
  S.ฮน_descCyclesCo_ฯ_eq_zero_of_boundary S.g (๐ _) (by rw [comp_id])

noncomputable def rightHomologyIsKernel :
    IsLimit (KernelFork.ofฮน S.rightHomologyฮน S.rightHomologyฮน_comp_fromCyclesCo) :=
  S.rightHomologyData.hฮน

variable {S}

@[reassoc (attr := simp)]
lemma cyclesCoMap_comp_descCyclesCo (ฯ : Sโ โถ S) [Sโ.HasRightHomology] :
    cyclesCoMap ฯ โซ S.descCyclesCo k hk =
      Sโ.descCyclesCo (ฯ.ฯโ โซ k) (by rw [โ ฯ.commโโ_assoc, hk, comp_zero]) := by
  simp only [โ cancel_epi (Sโ.pCyclesCo), p_cyclesCoMap_assoc, p_descCyclesCo]

@[reassoc (attr := simp)]
lemma RightHomologyData.rightHomologyIso_inv_comp_rightHomologyฮน :
    h.rightHomologyIso.inv โซ S.rightHomologyฮน = h.ฮน โซ h.cyclesCoIso.inv := by
  dsimp only [rightHomologyฮน, rightHomologyIso, cyclesCoIso, rightHomologyMapIso']
  simp only [Iso.refl_inv, rightHomologyฮน_naturality', cyclesCoMapIso'_inv]

@[reassoc (attr := simp)]
lemma RightHomologyData.rightHomologyIso_hom_comp_ฮน :
    h.rightHomologyIso.hom โซ h.ฮน = S.rightHomologyฮน โซ h.cyclesCoIso.hom := by
  simp only [โ cancel_epi h.rightHomologyIso.inv, โ cancel_mono h.cyclesCoIso.inv, assoc,
    Iso.inv_hom_id_assoc, Iso.hom_inv_id, comp_id, rightHomologyIso_inv_comp_rightHomologyฮน]

@[reassoc (attr := simp)]
lemma RightHomologyData.cyclesCoIso_inv_comp_descCyclesCo :
    h.cyclesCoIso.inv โซ S.descCyclesCo k hk = h.descQ k hk := by
  simp only [โ cancel_epi h.p, p_compCyclesCoIso_inv_assoc, p_descCyclesCo, p_descQ]

@[simp]
lemma RightHomologyData.cyclesCoIso_hom_comp_descQ :
    h.cyclesCoIso.hom โซ h.descQ k hk = S.descCyclesCo k hk := by
  rw [โ h.cyclesCoIso_inv_comp_descCyclesCo, Iso.hom_inv_id_assoc]

lemma RightHomologyData.ext_iff' (fโ fโ : A โถ S.rightHomology) :
    fโ = fโ โ fโ โซ h.rightHomologyIso.hom โซ h.ฮน = fโ โซ h.rightHomologyIso.hom โซ h.ฮน := by
  rw [โ cancel_mono h.rightHomologyIso.hom, โ cancel_mono h.ฮน, assoc, assoc]

end

variable {C}

namespace HasRightHomology

lemma hasCokernel [S.HasRightHomology] : HasCokernel S.f :=
โจโจโจ_, S.rightHomologyData.hpโฉโฉโฉ

lemma hasKernel [S.HasRightHomology] [HasCokernel S.f] :
    HasKernel (cokernel.desc S.f S.g S.zero) := by
  let h := S.rightHomologyData
  haveI : HasLimit (parallelPair h.g' 0) := โจโจโจ_, h.hฮน'โฉโฉโฉ
  let e : parallelPair (cokernel.desc S.f S.g S.zero) 0 โ parallelPair h.g' 0 :=
    parallelPair.ext (IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) h.hp)
      (Iso.refl _) (coequalizer.hom_ext (by simp)) (by aesop_cat)
  exact hasLimitOfIso e.symm

end HasRightHomology

noncomputable def rightHomologyIsoKernelDesc [S.HasRightHomology] [HasCokernel S.f]
    [HasKernel (cokernel.desc S.f S.g S.zero)] :
    S.rightHomology โ kernel (cokernel.desc S.f S.g S.zero) :=
  (RightHomologyData.ofKerOfCoker S).rightHomologyIso

namespace RightHomologyData

lemma isIso_p_of_zero_f (h : RightHomologyData S) (hf : S.f = 0) : IsIso h.p :=
  โจโจh.descQ (๐ S.Xโ) (by rw [hf, comp_id]), p_descQ _ _ _, by
    rw [โ cancel_epi h.p, p_descQ_assoc, id_comp, comp_id]โฉโฉ

end RightHomologyData

end ShortComplex

end CategoryTheory
