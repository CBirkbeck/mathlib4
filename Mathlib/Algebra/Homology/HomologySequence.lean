<<<<<<< HEAD
import Mathlib.Algebra.Homology.ShortComplex.SnakeLemma
import Mathlib.Algebra.Homology.ShortComplex.ShortComplexFour
import Mathlib.Algebra.Homology.ShortComplex.HomologicalComplex
import Mathlib.Algebra.Homology.HomologicalComplexLimits

open CategoryTheory Category Limits

def CategoryTheory.Limits.KernelFork.IsLimit.ofŒπ'
    {C : Type*} [Category C] [HasZeroMorphisms C] {X Y K : C} {f : X ‚ü∂ Y} (i : K ‚ü∂ X) (w : i ‚â´ f = 0)
    (h : ‚àÄ {A : C} (k : A ‚ü∂ X) (_ : k ‚â´ f = 0), { l : A ‚ü∂ K // l ‚â´ i = k}) [hi : Mono i] :
    IsLimit (KernelFork.ofŒπ _ w) :=
  ofŒπ _ _ (fun {A} k hk => (h k hk).1) (fun {A} k hk => (h k hk).2) (fun {A} k hk m hm => by
    rw [‚Üê cancel_mono i, (h k hk).2, hm])

def CategoryTheory.Limits.CokernelCofork.IsColimit.ofœÄ'
    {C : Type*} [Category C] [HasZeroMorphisms C] {X Y Q : C} {f : X ‚ü∂ Y} (p : Y ‚ü∂ Q) (w : f ‚â´ p = 0)
    (h : ‚àÄ {A : C} (k : Y ‚ü∂ A) (_ : f ‚â´ k = 0), { l : Q ‚ü∂ A // p ‚â´ l = k}) [hp : Epi p] :
    IsColimit (CokernelCofork.ofœÄ _ w) :=
  ofœÄ _ _ (fun {A} k hk => (h k hk).1) (fun {A} k hk => (h k hk).2) (fun {A} k hk m hm => by
    rw [‚Üê cancel_epi p, (h k hk).2, hm])

variable {C Œπ : Type*} [Category C] [Abelian C] {c : ComplexShape Œπ}

variable {S S' : ShortComplex (HomologicalComplex C c)} (hS : S.ShortExact) (hS' : S'.ShortExact)
  (œÑ : S ‚ü∂ S') (K L : HomologicalComplex C c) (œÜ : K ‚ü∂ L)
  {i j : Œπ} (hij : c.Rel i j)

namespace HomologicalComplex

variable (i j)

noncomputable def opcyclesToCycles : K.opcycles i ‚ü∂ K.cycles j :=
=======
/-
Copyright (c) 2023 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.Algebra.Homology.ShortComplex.HomologicalComplex
import Mathlib.Algebra.Homology.ShortComplex.SnakeLemma
import Mathlib.Algebra.Homology.ShortComplex.ShortExact
import Mathlib.Algebra.Homology.HomologicalComplexLimits

/-!
# The homology sequence

If `0 ‚ü∂ X‚ÇÅ ‚ü∂ X‚ÇÇ ‚ü∂ X‚ÇÉ ‚ü∂ 0` is a short exact sequence in a category of complexes
`HomologicalComplex C c` in an abelian category (i.e. `S` is a short complex in
that category and satisfies `hS : S.ShortExact`), then whenever `i` and `j` are degrees
such that `hij : c.Rel i j`, then there is a long exact sequence :
`... ‚ü∂ S.X‚ÇÅ.homology i ‚ü∂ S.X‚ÇÇ.homology i ‚ü∂ S.X‚ÇÉ.homology i ‚ü∂ S.X‚ÇÅ.homology j ‚ü∂ ...`.
The connecting homomorphism `S.X‚ÇÉ.homology i ‚ü∂ S.X‚ÇÅ.homology j` is `hS.Œ¥ i j hij`, and
the exactness is asserted as lemmas `hS.homology_exact‚ÇÅ`, `hS.homology_exact‚ÇÇ` and
`hS.homology_exact‚ÇÉ`.

The proof is based on the snake lemma, similarly as it was originally done in
the Liquid Tensor Experiment.

## References

* https://stacks.math.columbia.edu/tag/0111

-/

open CategoryTheory Category Limits

namespace HomologicalComplex

section HasZeroMorphisms

variable {C Œπ : Type*} [Category C] [HasZeroMorphisms C] {c : ComplexShape Œπ}
  (K L : HomologicalComplex C c) (œÜ : K ‚ü∂ L) (i j : Œπ)
  [K.HasHomology i] [K.HasHomology j] [L.HasHomology i] [L.HasHomology j]

/-- The morphism `K.opcycles i ‚ü∂ K.cycles j` that is induced by `K.d i j`. -/
noncomputable def opcyclesToCycles [K.HasHomology i] [K.HasHomology j] :
    K.opcycles i ‚ü∂ K.cycles j :=
>>>>>>> origin/homology-sequence-computation
  K.liftCycles (K.fromOpcycles i j) _ rfl (by simp)

@[reassoc (attr := simp)]
lemma opcyclesToCycles_iCycles : K.opcyclesToCycles i j ‚â´ K.iCycles j = K.fromOpcycles i j := by
  dsimp only [opcyclesToCycles]
  simp

<<<<<<< HEAD
@[reassoc (attr := simp)]
=======
@[reassoc]
>>>>>>> origin/homology-sequence-computation
lemma pOpcycles_opcyclesToCycles_iCycles :
    K.pOpcycles i ‚â´ K.opcyclesToCycles i j ‚â´ K.iCycles j = K.d i j := by
  simp [opcyclesToCycles]

@[reassoc (attr := simp)]
lemma pOpcycles_opcyclesToCycles :
    K.pOpcycles i ‚â´ K.opcyclesToCycles i j = K.toCycles i j := by
  simp only [‚Üê cancel_mono (K.iCycles j), assoc, opcyclesToCycles_iCycles,
    p_fromOpcycles, toCycles_i]

@[reassoc (attr := simp)]
lemma homologyŒπ_opcyclesToCycles :
    K.homologyŒπ i ‚â´ K.opcyclesToCycles i j = 0 := by
  simp only [‚Üê cancel_mono (K.iCycles j), assoc, opcyclesToCycles_iCycles,
    homologyŒπ_comp_fromOpcycles, zero_comp]

@[reassoc (attr := simp)]
lemma opcyclesToCycles_homologyœÄ :
    K.opcyclesToCycles i j ‚â´ K.homologyœÄ j = 0 := by
  simp only [‚Üê cancel_epi (K.pOpcycles i),
    pOpcycles_opcyclesToCycles_assoc, toCycles_comp_homologyœÄ, comp_zero]

variable {K L}

@[reassoc (attr := simp)]
lemma opcyclesToCycles_naturality :
    opcyclesMap œÜ i ‚â´ opcyclesToCycles L i j = opcyclesToCycles K i j ‚â´ cyclesMap œÜ j := by
  simp only [‚Üê cancel_mono (L.iCycles j), ‚Üê cancel_epi (K.pOpcycles i),
    assoc, p_opcyclesMap_assoc, pOpcycles_opcyclesToCycles_iCycles, Hom.comm, cyclesMap_i,
    pOpcycles_opcyclesToCycles_iCycles_assoc]

<<<<<<< HEAD
variable (K)

@[simps]
noncomputable def shortComplex‚ÇÑ : ShortComplex‚ÇÑ C where
  f := K.homologyŒπ i
  g := K.opcyclesToCycles i j
  h := K.homologyœÄ j

instance : Mono (K.shortComplex‚ÇÑ i j).f := by
  dsimp
  infer_instance

instance : Epi (K.shortComplex‚ÇÑ i j).h := by
  dsimp
  infer_instance

instance [Mono œÜ] (i : Œπ) : Mono (œÜ.f i) := by
  change Mono ((HomologicalComplex.eval C c i).map œÜ)
  infer_instance

instance [Epi œÜ] (i : Œπ) : Epi (œÜ.f i) := by
  change Epi ((HomologicalComplex.eval C c i).map œÜ)
  infer_instance

lemma shortComplex‚ÇÑ_exact : (K.shortComplex‚ÇÑ i j).Exact where
  exact‚ÇÇ := by
    let S := ShortComplex.mk _ _ (K.homologyŒπ_comp_fromOpcycles i j)
    let œÜ : (K.shortComplex‚ÇÑ i j).shortComplex‚ÇÅ ‚ü∂ S :=
      { œÑ‚ÇÅ := ùüô _
        œÑ‚ÇÇ := ùüô _
        œÑ‚ÇÉ := K.iCycles j  }
    rw [ShortComplex.exact_iff_of_epi_of_isIso_of_mono œÜ]
    exact S.exact_of_f_is_kernel (K.homologyIsKernel i j (c.next_eq' hij))
  exact‚ÇÉ := by
    let S := ShortComplex.mk _ _ (K.toCycles_comp_homologyœÄ i j)
    let œÜ : S ‚ü∂ (K.shortComplex‚ÇÑ i j).shortComplex‚ÇÇ :=
      { œÑ‚ÇÅ := K.pOpcycles i
        œÑ‚ÇÇ := ùüô _
        œÑ‚ÇÉ := ùüô _  }
    rw [‚Üê ShortComplex.exact_iff_of_epi_of_isIso_of_mono œÜ]
    exact S.exact_of_g_is_cokernel (K.homologyIsCokernel i j (c.prev_eq' hij))

instance : Mono (K.shortComplex‚ÇÑ i j).shortComplex‚ÇÅ.f := by
  dsimp
  infer_instance

instance : Epi (K.shortComplex‚ÇÑ i j).shortComplex‚ÇÇ.g := by
  dsimp
  infer_instance

variable (C c)

@[simps]
noncomputable def natTransOpCyclesToCycles : opcyclesFunctor C c i ‚ü∂ cyclesFunctor C c j where
  app K := K.opcyclesToCycles i j

attribute [local simp] homologyMap_comp opcyclesMap_comp cyclesMap_comp

@[simps]
noncomputable def shortComplex‚ÇÑFunctor : HomologicalComplex C c ‚•§ ShortComplex‚ÇÑ C where
  obj K := K.shortComplex‚ÇÑ i j
  map {K‚ÇÅ K‚ÇÇ} œÜ :=
    { œÑ‚ÇÅ := homologyMap œÜ i
      œÑ‚ÇÇ := opcyclesMap œÜ i
      œÑ‚ÇÉ := cyclesMap œÜ j
      œÑ‚ÇÑ := homologyMap œÜ j }

namespace HomologySequence

instance : (opcyclesFunctor C c i).PreservesZeroMorphisms where
instance : (cyclesFunctor C c i).PreservesZeroMorphisms where

variable {C c i j}

instance [Mono (œÜ.f j)] : Mono (cyclesMap œÜ j) :=
  mono_of_mono_fac (cyclesMap_i œÜ j)

attribute [local instance] epi_comp

instance [Epi (œÜ.f i)] : Epi (opcyclesMap œÜ i) :=
  epi_of_epi_fac (p_opcyclesMap œÜ i)

variable (i j)

def opcyclesRightExact :
    (ShortComplex.mk (opcyclesMap S.f j) (opcyclesMap S.g j) (by rw [‚Üê opcyclesMap_comp, S.zero, opcyclesMap_zero])).Exact := by
  have := hS.epi_g
  have hj := (hS.map_of_exact (HomologicalComplex.eval C c j)).gIsCokernel
  apply ShortComplex.exact_of_g_is_cokernel
  refine' CokernelCofork.IsColimit.ofœÄ' _ _  (fun {A} k hk => by
    dsimp at k hk ‚ä¢
    have H := CokernelCofork.IsColimit.desc' hj (S.X‚ÇÇ.pOpcycles j ‚â´ k) (by
=======
variable (C c)

/-- The natural transformation `K.opcyclesToCycles i j : K.opcycles i ‚ü∂ K.cycles j` for all
`K : HomologicalComplex C c`. -/
@[simps]
noncomputable def natTransOpCyclesToCycles [CategoryWithHomology C] :
    opcyclesFunctor C c i ‚ü∂ cyclesFunctor C c j where
  app K := K.opcyclesToCycles i j

end HasZeroMorphisms

section Preadditive

variable {C Œπ : Type*} [Category C] [Preadditive C] {c : ComplexShape Œπ}
  (K : HomologicalComplex C c) (i j : Œπ) (hij : c.Rel i j)

namespace HomologySequence

/-- The diagram `K.homology i ‚ü∂ K.opcycles i ‚ü∂ K.cycles j ‚ü∂ K.homology j`. -/
@[simp]
noncomputable def composableArrows‚ÇÉ [K.HasHomology i] [K.HasHomology j] :
    ComposableArrows C 3 :=
  ComposableArrows.mk‚ÇÉ (K.homologyŒπ i) (K.opcyclesToCycles i j) (K.homologyœÄ j)

instance [K.HasHomology i] [K.HasHomology j] :
    Mono ((composableArrows‚ÇÉ K i j).map' 0 1) := by
  dsimp
  infer_instance

instance [K.HasHomology i] [K.HasHomology j] :
    Epi ((composableArrows‚ÇÉ K i j).map' 2 3) := by
  dsimp
  infer_instance

/-- The diagram `K.homology i ‚ü∂ K.opcycles i ‚ü∂ K.cycles j ‚ü∂ K.homology j` is exact
when `c.Rel i j`. -/
lemma composableArrows‚ÇÉ_exact [CategoryWithHomology C] :
    (composableArrows‚ÇÉ K i j).Exact := by
  let S := ShortComplex.mk (K.homologyŒπ i) (K.opcyclesToCycles i j) (by simp)
  let S' := ShortComplex.mk (K.homologyŒπ i) (K.fromOpcycles i j) (by simp)
  let Œπ : S ‚ü∂ S' :=
    { œÑ‚ÇÅ := ùüô _
      œÑ‚ÇÇ := ùüô _
      œÑ‚ÇÉ := K.iCycles j }
  have hS : S.Exact := by
    rw [ShortComplex.exact_iff_of_epi_of_isIso_of_mono Œπ]
    exact S'.exact_of_f_is_kernel (K.homologyIsKernel i j (c.next_eq' hij))
  let T := ShortComplex.mk (K.opcyclesToCycles i j) (K.homologyœÄ j) (by simp)
  let T' := ShortComplex.mk (K.toCycles i j) (K.homologyœÄ j) (by simp)
  let œÄ : T' ‚ü∂ T :=
    { œÑ‚ÇÅ := K.pOpcycles i
      œÑ‚ÇÇ := ùüô _
      œÑ‚ÇÉ := ùüô _ }
  have hT : T.Exact := by
    rw [‚Üê ShortComplex.exact_iff_of_epi_of_isIso_of_mono œÄ]
    exact T'.exact_of_g_is_cokernel (K.homologyIsCokernel i j (c.prev_eq' hij))
  apply ComposableArrows.exact_of_Œ¥‚ÇÄ
  ¬∑ exact hS.exact_toComposableArrows
  ¬∑ exact hT.exact_toComposableArrows

variable (C)

attribute [local simp] homologyMap_comp cyclesMap_comp opcyclesMap_comp

/-- The functor `HomologicalComplex C c ‚•§ ComposableArrows C 3` that maps `K` to the
diagram `K.homology i ‚ü∂ K.opcycles i ‚ü∂ K.cycles j ‚ü∂ K.homology j`. -/
@[simps]
noncomputable def composableArrows‚ÇÉFunctor [CategoryWithHomology C] :
    HomologicalComplex C c ‚•§ ComposableArrows C 3 where
  obj K := composableArrows‚ÇÉ K i j
  map {K L} œÜ := ComposableArrows.homMk‚ÇÉ (homologyMap œÜ i) (opcyclesMap œÜ i) (cyclesMap œÜ j)
    (homologyMap œÜ j) (by aesop_cat) (by aesop_cat) (by aesop_cat)

end HomologySequence

end Preadditive

section Abelian

variable {C Œπ : Type*} [Category C] [Abelian C] {c : ComplexShape Œπ}

/-- If `X‚ÇÅ ‚ü∂ X‚ÇÇ ‚ü∂ X‚ÇÉ ‚ü∂ 0` is an exact sequence of homological complexes, then
`X‚ÇÅ.opcycles i ‚ü∂ X‚ÇÇ.opcycles i ‚ü∂ X‚ÇÉ.opcycles i ‚ü∂ 0` is exact. This lemma states
the exactness at `X‚ÇÇ.opcycles i`, while the fact that `X‚ÇÇ.opcycles i ‚ü∂ X‚ÇÉ.opcycles i`
is an epi is an instance. -/
lemma opcycles_right_exact (S : ShortComplex (HomologicalComplex C c)) (hS : S.Exact) [Epi S.g]
    (i : Œπ) [S.X‚ÇÅ.HasHomology i] [S.X‚ÇÇ.HasHomology i] [S.X‚ÇÉ.HasHomology i] :
    (ShortComplex.mk (opcyclesMap S.f i) (opcyclesMap S.g i)
      (by rw [‚Üê opcyclesMap_comp, S.zero, opcyclesMap_zero])).Exact := by
  have : Epi (ShortComplex.map S (eval C c i)).g := by dsimp; infer_instance
  have hj := (hS.map (HomologicalComplex.eval C c i)).gIsCokernel
  apply ShortComplex.exact_of_g_is_cokernel
  refine' CokernelCofork.IsColimit.ofœÄ' _ _  (fun {A} k hk => by
    dsimp at k hk ‚ä¢
    have H := CokernelCofork.IsColimit.desc' hj (S.X‚ÇÇ.pOpcycles i ‚â´ k) (by
>>>>>>> origin/homology-sequence-computation
      dsimp
      rw [‚Üê p_opcyclesMap_assoc, hk, comp_zero])
    dsimp at H
    refine' ‚ü®S.X‚ÇÉ.descOpcycles H.1 _ rfl _, _‚ü©
<<<<<<< HEAD
    ¬∑ rw [‚Üê cancel_epi (S.g.f (c.prev j)), comp_zero, Hom.comm_assoc, H.2,
        d_pOpcycles_assoc, zero_comp]
    ¬∑ rw [‚Üê cancel_epi (S.X‚ÇÇ.pOpcycles j), opcyclesMap_comp_descOpcycles, p_descOpcycles, H.2])

def cyclesLeftExact :
    (ShortComplex.mk (cyclesMap S.f i) (cyclesMap S.g i) (by rw [‚Üê cyclesMap_comp, S.zero, cyclesMap_zero])).Exact := by
  have := hS.mono_f
  have hi := (hS.map_of_exact (HomologicalComplex.eval C c i)).fIsKernel
=======
    ¬∑ rw [‚Üê cancel_epi (S.g.f (c.prev i)), comp_zero, Hom.comm_assoc, H.2,
        d_pOpcycles_assoc, zero_comp]
    ¬∑ rw [‚Üê cancel_epi (S.X‚ÇÇ.pOpcycles i), opcyclesMap_comp_descOpcycles, p_descOpcycles, H.2])

/-- If `0 ‚ü∂ X‚ÇÅ ‚ü∂ X‚ÇÇ ‚ü∂ X‚ÇÉ` is an exact sequence of homological complex, then
`0 ‚ü∂ X‚ÇÅ.cycles i ‚ü∂ X‚ÇÇ.cycles i ‚ü∂ X‚ÇÉ.cycles i` is exact. This lemma states
the exactness at `X‚ÇÇ.cycles i`, while the fact that `X‚ÇÅ.cycles i ‚ü∂ X‚ÇÇ.cycles i`
is a mono is an instance. -/
lemma cycles_left_exact (S : ShortComplex (HomologicalComplex C c)) (hS : S.Exact) [Mono S.f]
    (i : Œπ) [S.X‚ÇÅ.HasHomology i] [S.X‚ÇÇ.HasHomology i] [S.X‚ÇÉ.HasHomology i] :
    (ShortComplex.mk (cyclesMap S.f i) (cyclesMap S.g i)
      (by rw [‚Üê cyclesMap_comp, S.zero, cyclesMap_zero])).Exact := by
  have : Mono (ShortComplex.map S (eval C c i)).f := by dsimp; infer_instance
  have hi := (hS.map (HomologicalComplex.eval C c i)).fIsKernel
>>>>>>> origin/homology-sequence-computation
  apply ShortComplex.exact_of_f_is_kernel
  exact KernelFork.IsLimit.ofŒπ' _ _ (fun {A} k hk => by
    dsimp at k hk ‚ä¢
    have H := KernelFork.IsLimit.lift' hi (k ‚â´ S.X‚ÇÇ.iCycles i) (by
      dsimp
      rw [assoc, ‚Üê cyclesMap_i, reassoc_of% hk, zero_comp])
    dsimp at H
    refine' ‚ü®S.X‚ÇÅ.liftCycles H.1 _ rfl _, _‚ü©
    ¬∑ rw [‚Üê cancel_mono (S.f.f _), assoc, zero_comp, ‚Üê Hom.comm, reassoc_of% H.2,
        iCycles_d, comp_zero]
    ¬∑ rw [‚Üê cancel_mono (S.X‚ÇÇ.iCycles i), liftCycles_comp_cyclesMap, liftCycles_i, H.2])

<<<<<<< HEAD
@[simps]
=======
variable  {S : ShortComplex (HomologicalComplex C c)}
  (hS : S.ShortExact) (i j : Œπ) (hij : c.Rel i j)

namespace HomologySequence

/-- Given a short exact short complex `S : HomologicalComplex C c`, and degrees `i` and `j`
such that `c.Rel i j`, this is the snake diagram whose four lines are respectively
obtained by applying the functors `homologyFunctor C c i`, `opcyclesFunctor C c i`,
`cyclesFunctor C c j`, `homologyFunctor C c j` to `S`. Applying the snake lemma to this
gives the homology sequence of `S`. -/
>>>>>>> origin/homology-sequence-computation
noncomputable def snakeInput : ShortComplex.SnakeInput C where
  L‚ÇÄ := (homologyFunctor C c i).mapShortComplex.obj S
  L‚ÇÅ := (opcyclesFunctor C c i).mapShortComplex.obj S
  L‚ÇÇ := (cyclesFunctor C c j).mapShortComplex.obj S
  L‚ÇÉ := (homologyFunctor C c j).mapShortComplex.obj S
  v‚ÇÄ‚ÇÅ := S.mapNatTrans (natTransHomologyŒπ C c i)
  v‚ÇÅ‚ÇÇ := S.mapNatTrans (natTransOpCyclesToCycles C c i j)
  v‚ÇÇ‚ÇÉ := S.mapNatTrans (natTransHomologyœÄ C c j)
<<<<<<< HEAD
  w‚ÇÄ‚ÇÇ := by ext <;> dsimp <;> simp
  w‚ÇÅ‚ÇÉ := by ext <;> dsimp <;> simp
  h‚ÇÄ := by
    apply ShortComplex.isLimitOfIsLimitœÄ
    all_goals
      refine' (KernelFork.isLimitMapConeEquiv _ _).symm _
      exact (HomologicalComplex.shortComplex‚ÇÑ_exact _ i j hij).exact‚ÇÇ.fIsKernel
  h‚ÇÉ := by
    apply ShortComplex.isColimitOfIsColimitœÄ
    all_goals
      refine' (CokernelCofork.isColimitMapCoconeEquiv _ _).symm _
      exact (HomologicalComplex.shortComplex‚ÇÑ_exact _ i j hij).exact‚ÇÉ.gIsCokernel
=======
  h‚ÇÄ := by
    apply ShortComplex.isLimitOfIsLimitœÄ
    all_goals
      exact (KernelFork.isLimitMapConeEquiv _ _).symm
        ((composableArrows‚ÇÉ_exact _ i j hij).exact 0).fIsKernel
  h‚ÇÉ := by
    apply ShortComplex.isColimitOfIsColimitœÄ
    all_goals
      exact (CokernelCofork.isColimitMapCoconeEquiv _ _).symm
        ((composableArrows‚ÇÉ_exact _ i j hij).exact 1).gIsCokernel
  L‚ÇÅ_exact := by
    have := hS.epi_g
    exact opcycles_right_exact S hS.exact i
  L‚ÇÇ_exact := by
    have := hS.mono_f
    exact cycles_left_exact S hS.exact j
>>>>>>> origin/homology-sequence-computation
  epi_L‚ÇÅ_g := by
    have := hS.epi_g
    dsimp
    infer_instance
  mono_L‚ÇÇ_f := by
    have := hS.mono_f
    dsimp
    infer_instance
<<<<<<< HEAD
  L‚ÇÅ_exact := opcyclesRightExact hS i
  L‚ÇÇ_exact := cyclesLeftExact hS j

@[simps]
noncomputable def snakeInputHom : snakeInput hS i j hij ‚ü∂ snakeInput hS' i j hij where
  f‚ÇÄ := (homologyFunctor C c i).mapShortComplex.map œÑ
  f‚ÇÅ := (opcyclesFunctor C c i).mapShortComplex.map œÑ
  f‚ÇÇ := (cyclesFunctor C c j).mapShortComplex.map œÑ
  f‚ÇÉ := (homologyFunctor C c j).mapShortComplex.map œÑ
  comm‚ÇÄ‚ÇÅ := by ext <;> dsimp <;> simp
  comm‚ÇÅ‚ÇÇ := by ext <;> dsimp <;> simp
  comm‚ÇÇ‚ÇÉ := by ext <;> dsimp <;> simp

end HomologySequence

=======

end HomologySequence

end Abelian

>>>>>>> origin/homology-sequence-computation
end HomologicalComplex

namespace CategoryTheory

<<<<<<< HEAD
=======
open HomologicalComplex HomologySequence

variable {C Œπ : Type*} [Category C] [Abelian C] {c : ComplexShape Œπ}
  {S : ShortComplex (HomologicalComplex C c)}
  (hS : S.ShortExact) (i j : Œπ) (hij : c.Rel i j)

>>>>>>> origin/homology-sequence-computation
namespace ShortComplex

namespace ShortExact

<<<<<<< HEAD
open HomologicalComplex HomologySequence

variable (i j)

noncomputable def Œ¥ : S.X‚ÇÉ.homology i ‚ü∂ S.X‚ÇÅ.homology j := (snakeInput hS i j hij).Œ¥

@[reassoc (attr := simp)]
lemma Œ¥_comp : hS.Œ¥ i j hij ‚â´ HomologicalComplex.homologyMap S.f j = 0 := (snakeInput hS i j hij).Œ¥_L‚ÇÉ_f

@[reassoc (attr := simp)]
lemma comp_Œ¥ : HomologicalComplex.homologyMap S.g i ‚â´ hS.Œ¥ i j hij = 0 := (snakeInput hS i j hij).L‚ÇÄ_g_Œ¥

lemma exact‚ÇÅ : (ShortComplex.mk _ _ (Œ¥_comp hS i j hij)).Exact :=
  (snakeInput hS i j hij).exact_L‚ÇÇ'

lemma exact‚ÇÉ : (ShortComplex.mk _ _ (comp_Œ¥ hS i j hij)).Exact :=
  (snakeInput hS i j hij).exact_L‚ÇÅ'

lemma exact‚ÇÇ : (ShortComplex.mk (HomologicalComplex.homologyMap S.f i) (HomologicalComplex.homologyMap S.g i)
    (by rw [‚Üê HomologicalComplex.homologyMap_comp, S.zero, HomologicalComplex.homologyMap_zero])).Exact := by
  by_cases c.Rel i (c.next i)
  ¬∑ exact (snakeInput hS i _ h).ex‚ÇÄ
  ¬∑ have : ‚àÄ (K : HomologicalComplex C c), IsIso (K.homologyŒπ i) :=
      fun K => ShortComplex.isIso_homologyŒπ (K.sc i) (K.shape _ _ h)
    have e : S.map (HomologicalComplex.homologyFunctor C c i) ‚âÖ S.map (HomologicalComplex.opcyclesFunctor C c i) :=
      ShortComplex.isoMk (asIso (S.X‚ÇÅ.homologyŒπ i))
        (asIso (S.X‚ÇÇ.homologyŒπ i)) (asIso (S.X‚ÇÉ.homologyŒπ i)) (by aesop_cat) (by aesop_cat)
    exact ShortComplex.exact_of_iso e.symm (opcyclesRightExact hS i)

lemma Œ¥_naturality : HomologicalComplex.homologyMap œÑ.œÑ‚ÇÉ i ‚â´ hS'.Œ¥ i j hij =
    hS.Œ¥ i j hij ‚â´ HomologicalComplex.homologyMap œÑ.œÑ‚ÇÅ j :=
  SnakeInput.naturality_Œ¥ (snakeInputHom hS hS' œÑ i j hij)

@[reassoc]
lemma comp_Œ¥_eq {A : C} (x‚ÇÉ : A ‚ü∂ S.X‚ÇÉ.X i) (x‚ÇÇ : A ‚ü∂ S.X‚ÇÇ.X i) (y‚ÇÅ : A ‚ü∂ S.X‚ÇÅ.X j)
    (hx‚ÇÉ : x‚ÇÉ ‚â´ S.X‚ÇÉ.d i j = 0) (hx‚ÇÇ : x‚ÇÇ ‚â´ S.g.f i = x‚ÇÉ)
    (hy‚ÇÅ : y‚ÇÅ ‚â´ S.f.f j = x‚ÇÇ ‚â´ S.X‚ÇÇ.d i j) :
    S.X‚ÇÉ.liftCycles x‚ÇÉ j (c.next_eq' hij) hx‚ÇÉ ‚â´ S.X‚ÇÉ.homologyœÄ i ‚â´ hS.Œ¥ i j hij =
      S.X‚ÇÅ.liftCycles y‚ÇÅ _ rfl (by
        have := hS.mono_f
        rw [‚Üê cancel_mono (S.f.f _), assoc, ‚Üê Hom.comm, reassoc_of% hy‚ÇÅ, S.X‚ÇÇ.d_comp_d,
          comp_zero, zero_comp]) ‚â´ S.X‚ÇÅ.homologyœÄ j := by
  have eq := (snakeInput hS i j hij).comp_Œ¥_eq
    (S.X‚ÇÉ.liftCycles x‚ÇÉ j (c.next_eq' hij) hx‚ÇÉ ‚â´ S.X‚ÇÉ.homologyœÄ i)
    (x‚ÇÇ ‚â´ S.X‚ÇÇ.pOpcycles i) (S.X‚ÇÅ.liftCycles y‚ÇÅ _ rfl (by
      have := hS.mono_f
      rw [‚Üê cancel_mono (S.f.f _), assoc, ‚Üê Hom.comm, reassoc_of% hy‚ÇÅ, S.X‚ÇÇ.d_comp_d,
        comp_zero, zero_comp])) (by simp [reassoc_of% hx‚ÇÇ]) (by
        rw [‚Üê cancel_mono (S.X‚ÇÇ.iCycles j)]
        simp [hy‚ÇÅ])
  simpa only [assoc] using eq
=======
/-- The connecting homoomorphism `S.X‚ÇÉ.homology i ‚ü∂ S.X‚ÇÅ.homology j` for a short exact
short complex `S`.  -/
noncomputable def Œ¥ : S.X‚ÇÉ.homology i ‚ü∂ S.X‚ÇÅ.homology j := (snakeInput hS i j hij).Œ¥

@[reassoc (attr := simp)]
lemma Œ¥_comp : hS.Œ¥ i j hij ‚â´ HomologicalComplex.homologyMap S.f j = 0 :=
  (snakeInput hS i j hij).Œ¥_L‚ÇÉ_f

@[reassoc (attr := simp)]
lemma comp_Œ¥ : HomologicalComplex.homologyMap S.g i ‚â´ hS.Œ¥ i j hij = 0 :=
  (snakeInput hS i j hij).L‚ÇÄ_g_Œ¥

/-- Exactness of `S.X‚ÇÉ.homology i ‚ü∂ S.X‚ÇÅ.homology j ‚ü∂ S.X‚ÇÇ.homology j`. -/
lemma homology_exact‚ÇÅ : (ShortComplex.mk _ _ (Œ¥_comp hS i j hij)).Exact :=
  (snakeInput hS i j hij).L‚ÇÇ'_exact

/-- Exactness of `S.X‚ÇÅ.homology i ‚ü∂ S.X‚ÇÇ.homology i ‚ü∂ S.X‚ÇÉ.homology i`. -/
lemma homology_exact‚ÇÇ : (ShortComplex.mk (HomologicalComplex.homologyMap S.f i)
    (HomologicalComplex.homologyMap S.g i) (by rw [‚Üê HomologicalComplex.homologyMap_comp,
      S.zero, HomologicalComplex.homologyMap_zero])).Exact := by
  by_cases h : c.Rel i (c.next i)
  ¬∑ exact (snakeInput hS i _ h).L‚ÇÄ_exact
  ¬∑ have := hS.epi_g
    have : ‚àÄ (K : HomologicalComplex C c), IsIso (K.homologyŒπ i) :=
      fun K => ShortComplex.isIso_homologyŒπ (K.sc i) (K.shape _ _ h)
    have e : S.map (HomologicalComplex.homologyFunctor C c i) ‚âÖ
        S.map (HomologicalComplex.opcyclesFunctor C c i) :=
      ShortComplex.isoMk (asIso (S.X‚ÇÅ.homologyŒπ i))
        (asIso (S.X‚ÇÇ.homologyŒπ i)) (asIso (S.X‚ÇÉ.homologyŒπ i)) (by aesop_cat) (by aesop_cat)
    exact ShortComplex.exact_of_iso e.symm (opcycles_right_exact S hS.exact i)

/-- Exactness of `S.X‚ÇÇ.homology i ‚ü∂ S.X‚ÇÉ.homology i ‚ü∂ S.X‚ÇÅ.homology j`. -/
lemma homology_exact‚ÇÉ : (ShortComplex.mk _ _ (comp_Œ¥ hS i j hij)).Exact :=
  (snakeInput hS i j hij).L‚ÇÅ'_exact

lemma Œ¥_eq' {A : C} (x‚ÇÉ : A ‚ü∂ S.X‚ÇÉ.homology i) (x‚ÇÇ : A ‚ü∂ S.X‚ÇÇ.opcycles i)
    (x‚ÇÅ : A ‚ü∂ S.X‚ÇÅ.cycles j)
    (h‚ÇÇ : x‚ÇÇ ‚â´ HomologicalComplex.opcyclesMap S.g i = x‚ÇÉ ‚â´ S.X‚ÇÉ.homologyŒπ i)
    (h‚ÇÅ : x‚ÇÅ ‚â´ HomologicalComplex.cyclesMap S.f j = x‚ÇÇ ‚â´ S.X‚ÇÇ.opcyclesToCycles i j) :
    x‚ÇÉ ‚â´ hS.Œ¥ i j hij = x‚ÇÅ ‚â´ S.X‚ÇÅ.homologyœÄ j :=
  (snakeInput hS i j hij).Œ¥_eq x‚ÇÉ x‚ÇÇ x‚ÇÅ h‚ÇÇ h‚ÇÅ

lemma Œ¥_eq {A : C} (x‚ÇÉ : A ‚ü∂ S.X‚ÇÉ.X i) (hx‚ÇÉ : x‚ÇÉ ‚â´ S.X‚ÇÉ.d i j = 0)
    (x‚ÇÇ : A ‚ü∂ S.X‚ÇÇ.X i) (hx‚ÇÇ : x‚ÇÇ ‚â´ S.g.f i = x‚ÇÉ)
    (x‚ÇÅ : A ‚ü∂ S.X‚ÇÅ.X j) (hx‚ÇÅ : x‚ÇÅ ‚â´ S.f.f j = x‚ÇÇ ‚â´ S.X‚ÇÇ.d i j)
    (k : Œπ) (hk : c.next j = k):
    S.X‚ÇÉ.liftCycles x‚ÇÉ j (c.next_eq' hij) hx‚ÇÉ ‚â´ S.X‚ÇÉ.homologyœÄ i ‚â´ hS.Œ¥ i j hij =
      S.X‚ÇÅ.liftCycles x‚ÇÅ k hk (by
        have := hS.mono_f
        rw [‚Üê cancel_mono (S.f.f k), assoc, ‚Üê S.f.comm, reassoc_of% hx‚ÇÅ,
          d_comp_d, comp_zero, zero_comp]) ‚â´ S.X‚ÇÅ.homologyœÄ j := by
  simpa only [assoc] using hS.Œ¥_eq' i j hij (S.X‚ÇÉ.liftCycles x‚ÇÉ j
    (c.next_eq' hij) hx‚ÇÉ ‚â´ S.X‚ÇÉ.homologyœÄ i)
    (x‚ÇÇ ‚â´ S.X‚ÇÇ.pOpcycles i) (S.X‚ÇÅ.liftCycles x‚ÇÅ k hk _)
      (by simp only [assoc, HomologicalComplex.p_opcyclesMap,
        HomologicalComplex.homology_œÄ_Œπ,
        HomologicalComplex.liftCycles_i_assoc, reassoc_of% hx‚ÇÇ])
      (by rw [‚Üê cancel_mono (S.X‚ÇÇ.iCycles j), HomologicalComplex.liftCycles_comp_cyclesMap,
        HomologicalComplex.liftCycles_i, assoc, assoc, opcyclesToCycles_iCycles,
        HomologicalComplex.p_fromOpcycles, hx‚ÇÅ])
>>>>>>> origin/homology-sequence-computation

end ShortExact

end ShortComplex

end CategoryTheory
