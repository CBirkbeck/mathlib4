import Mathlib.Algebra.Homology.Embedding.StupidFiltration
import Mathlib.Algebra.Homology.TotalComplex
import Mathlib.Algebra.Homology.TotalComplexShift

open CategoryTheory Category Limits ComplexShape

instance {C Œπ : Type*} [Category C] [HasZeroMorphisms C]
    {c : ComplexShape Œπ} (i : Œπ) :
    (HomologicalComplex.eval C c i).PreservesZeroMorphisms where

namespace CategoryTheory

variable {C : Type*} [Category C]

namespace Limits

lemma IsZero.obj' {X : C} (hX : IsZero X) {D : Type*} [Category D]
    (F : C ‚•§ D) [HasZeroMorphisms C] [HasZeroMorphisms D]
    [F.PreservesZeroMorphisms] : IsZero (F.obj X) := by
  rw [IsZero.iff_id_eq_zero, ‚Üê F.map_id, hX.eq_of_src (ùüô _) 0, F.map_zero]

section

variable [IsIdempotentComplete C] {I : Type*}
  {X : I ‚Üí C} (Y : I ‚Üí C)
  (hX : ‚àÄ (i : I), DirectFactor (X i) (Y i))

lemma hasCoproduct_of_direct_factor [HasCoproduct Y] : HasCoproduct X := by
  let p : ‚àê Y ‚ü∂ ‚àê Y := Sigma.map (fun i => (hX i).r ‚â´ (hX i).s)
  obtain ‚ü®S, h, fac‚ü© := directFactor_of_isIdempotentComplete _ p (by aesop_cat)
  refine ‚ü®Cofan.mk S (fun i => (hX i).s ‚â´ Sigma.Œπ Y i ‚â´ h.r),
    mkCofanColimit _ (fun c => h.s ‚â´ Sigma.desc (fun i => (hX i).r ‚â´ c.inj i))
      (fun c i => by simp [p, reassoc_of% fac])
      (fun c m hm => ?_)‚ü©
  dsimp at m ‚ä¢
  rw [‚Üê cancel_epi h.r]
  ext i
  simp [‚Üê hm, reassoc_of% fac, p]
  simp only [‚Üê assoc]
  congr 1
  rw [‚Üê cancel_mono h.s]
  simp [fac, p]

end

section

variable {I : Type*} (X : I ‚Üí C) (i : I)
    (hX : ‚àÄ j, j ‚â† i ‚Üí IsZero (X j))

open Classical in
@[simp]
noncomputable def cofanOfIsZeroButOne : Cofan X := Cofan.mk (X i)
  (fun j => if h : j = i then eqToHom (by rw [h]) else (hX _ h).to_ _)

@[simp]
lemma cofanOfIsZeroButOne_Œπ_self :
    (cofanOfIsZeroButOne X i hX).inj i = ùüô _ :=
  dif_pos rfl

def isColimitCofanOfIsZeroButOne :
    IsColimit (cofanOfIsZeroButOne X i hX) :=
  mkCofanColimit _ (fun s => s.inj i) (fun s j => by
    by_cases hj : j = i
    ¬∑ subst hj
      simp
    ¬∑ apply (hX _ hj).eq_of_src) (fun s m hm => by
      dsimp
      simpa using hm i)

lemma hasCoproduct_of_isZero_but_one : HasCoproduct X :=
  ‚ü®‚ü®_, isColimitCofanOfIsZeroButOne X i hX‚ü©‚ü©

end

end Limits

end CategoryTheory

namespace HomologicalComplex‚ÇÇ

variable {C : Type*} [Category C] [Preadditive C] [IsIdempotentComplete C]
  {Œπ‚ÇÅ Œπ‚ÇÇ Œπ : Type*} {c‚ÇÅ : ComplexShape Œπ‚ÇÅ} {c‚ÇÇ : ComplexShape Œπ‚ÇÇ}
  {K : HomologicalComplex‚ÇÇ C c‚ÇÅ c‚ÇÇ} (L : HomologicalComplex‚ÇÇ C c‚ÇÅ c‚ÇÇ)
  (c : ComplexShape Œπ) [TotalComplexShape c‚ÇÅ c‚ÇÇ c]
  (h : ‚àÄ i‚ÇÅ i‚ÇÇ, DirectFactor ((K.X i‚ÇÅ).X i‚ÇÇ) ((L.X i‚ÇÅ).X i‚ÇÇ))

lemma hasTotal_of_directFactor [L.HasTotal c] : K.HasTotal c :=
  fun i => hasCoproduct_of_direct_factor
    (GradedObject.mapObjFun L.toGradedObject (œÄ c‚ÇÅ c‚ÇÇ c) i) (fun _ => h _ _)

variable {Œπ‚ÇÅ' : Type*} {c‚ÇÅ' : ComplexShape Œπ‚ÇÅ'} (e : c‚ÇÅ'.Embedding c‚ÇÅ) [e.IsRelIff]
  [HasZeroObject C]

instance [K.HasTotal c] : HomologicalComplex‚ÇÇ.HasTotal (K.stupidTrunc e) c :=
  hasTotal_of_directFactor K c
    (fun i‚ÇÅ i‚ÇÇ => (K.stupidTruncDirectFactor e i‚ÇÅ).map (HomologicalComplex.eval _ _ i‚ÇÇ))

end HomologicalComplex‚ÇÇ

namespace ComplexShape

open Embedding

lemma embeddingUpIntGE_monotone (a a' : ‚Ñ§) (h : a' ‚â§ a):
    (embeddingUpIntGE a).Subset (embeddingUpIntGE a') where
  subset := by
    obtain ‚ü®k, rfl‚ü© := Int.eq_add_ofNat_of_le h
    rintro _ ‚ü®l, rfl‚ü©
    exact ‚ü®k + l, by dsimp; omega‚ü©

end ComplexShape

namespace CochainComplex

variable (C : Type*) [Category C] [HasZeroMorphisms C] [HasZeroObject C]

noncomputable abbrev stupidFiltrationGEFunctor :
    ‚Ñ§·µí·µñ ‚•§ CochainComplex C ‚Ñ§ ‚•§ CochainComplex C ‚Ñ§ :=
  ComplexShape.Embedding.stupidTruncGEFiltration
    (fun n => ComplexShape.embeddingUpIntGE n.unop)
      (fun _ _ œÜ => ComplexShape.embeddingUpIntGE_monotone _ _ (leOfHom œÜ.unop)) C

variable {C}
variable (K L : CochainComplex C ‚Ñ§)

noncomputable abbrev stupidFiltrationGE : ‚Ñ§·µí·µñ ‚•§ CochainComplex C ‚Ñ§ :=
  stupidFiltrationGEFunctor C ‚ãô ((evaluation _ _).obj K)

end CochainComplex

namespace HomologicalComplex‚ÇÇ

section

variable (C : Type*) [Category C] [HasZeroMorphisms C] [HasZeroObject C]
  {Œπ‚ÇÅ Œπ‚ÇÇ : Type*} [DecidableEq Œπ‚ÇÅ] (c‚ÇÅ : ComplexShape Œπ‚ÇÅ) (c‚ÇÇ : ComplexShape Œπ‚ÇÇ)

noncomputable def singleColumn (i‚ÇÅ : Œπ‚ÇÅ) :
    HomologicalComplex C c‚ÇÇ ‚•§ HomologicalComplex‚ÇÇ C c‚ÇÅ c‚ÇÇ :=
  HomologicalComplex.single (HomologicalComplex C c‚ÇÇ) c‚ÇÅ i‚ÇÅ

variable {C c‚ÇÇ}

lemma isZero_singleColumn_X (K : HomologicalComplex C c‚ÇÇ)
    (i‚ÇÅ i‚ÇÅ' : Œπ‚ÇÅ) (h : i‚ÇÅ' ‚â† i‚ÇÅ) :
    IsZero (((singleColumn C c‚ÇÅ c‚ÇÇ i‚ÇÅ).obj K).X i‚ÇÅ') :=
  HomologicalComplex.isZero_single_obj_X _ _ _ _ h

lemma isZero_singleColumn_X_X (K : HomologicalComplex C c‚ÇÇ)
    (i‚ÇÅ i‚ÇÅ' : Œπ‚ÇÅ) (h : i‚ÇÅ' ‚â† i‚ÇÅ) (i‚ÇÇ : Œπ‚ÇÇ) :
    IsZero ((((singleColumn C c‚ÇÅ c‚ÇÇ i‚ÇÅ).obj K).X i‚ÇÅ').X i‚ÇÇ) :=
  (isZero_singleColumn_X c‚ÇÅ K i‚ÇÅ i‚ÇÅ' h).obj' (HomologicalComplex.eval C c‚ÇÇ i‚ÇÇ)

noncomputable def singleColumnXIso (K : HomologicalComplex C c‚ÇÇ) (i‚ÇÅ : Œπ‚ÇÅ) :
    ((singleColumn C c‚ÇÅ c‚ÇÇ i‚ÇÅ).obj K).X i‚ÇÅ ‚âÖ K := by
  apply HomologicalComplex.singleObjXSelf

noncomputable def singleColumnXXIso (K : HomologicalComplex C c‚ÇÇ) (i‚ÇÅ : Œπ‚ÇÅ) (i‚ÇÇ : Œπ‚ÇÇ) :
    (((singleColumn C c‚ÇÅ c‚ÇÇ i‚ÇÅ).obj K).X i‚ÇÅ).X i‚ÇÇ ‚âÖ K.X i‚ÇÇ :=
  (HomologicalComplex.eval C c‚ÇÇ i‚ÇÇ).mapIso (singleColumnXIso c‚ÇÅ K i‚ÇÅ)

@[reassoc]
lemma singleColumn_obj_X_d (K : HomologicalComplex C c‚ÇÇ) (i‚ÇÅ : Œπ‚ÇÅ) (i‚ÇÇ i‚ÇÇ' : Œπ‚ÇÇ) :
    (((singleColumn C c‚ÇÅ c‚ÇÇ i‚ÇÅ).obj K).X i‚ÇÅ).d i‚ÇÇ i‚ÇÇ' =
      (singleColumnXXIso c‚ÇÅ K i‚ÇÅ i‚ÇÇ).hom ‚â´ K.d i‚ÇÇ i‚ÇÇ' ‚â´
        (singleColumnXXIso c‚ÇÅ K i‚ÇÅ i‚ÇÇ').inv := by
  dsimp only [singleColumn, singleColumnXXIso]
  simp only [Functor.mapIso_hom, HomologicalComplex.eval_map,
    Functor.mapIso_inv, HomologicalComplex.Hom.comm_assoc]
  rw [‚Üê HomologicalComplex.comp_f, Iso.hom_inv_id, HomologicalComplex.id_f,
    comp_id]

end

section

variable (C : Type*) [Category C] [Preadditive C] [HasZeroObject C]
  {Œπ‚ÇÅ Œπ‚ÇÇ Œπ : Type*} [DecidableEq Œπ‚ÇÅ] [DecidableEq Œπ] (c‚ÇÅ : ComplexShape Œπ‚ÇÅ) (c‚ÇÇ : ComplexShape Œπ‚ÇÇ)
  (K : HomologicalComplex C c‚ÇÇ) (i‚ÇÅ : Œπ‚ÇÅ) (c : ComplexShape Œπ)
  [TotalComplexShape c‚ÇÅ c‚ÇÇ c]
  [((singleColumn C c‚ÇÅ c‚ÇÇ i‚ÇÅ).obj K).HasTotal  c]

@[simp]
lemma singleColumn_d‚ÇÅ (x : Œπ‚ÇÅ) (y : Œπ‚ÇÇ) (n : Œπ) :
    ((singleColumn C c‚ÇÅ c‚ÇÇ i‚ÇÅ).obj K).d‚ÇÅ c x y n = 0 := by
  by_cases hx : c‚ÇÅ.Rel x (c‚ÇÅ.next x)
  ¬∑ by_cases hx' : œÄ c‚ÇÅ c‚ÇÇ c (next c‚ÇÅ x, y) = n
    ¬∑ rw [d‚ÇÅ_eq _ _ hx _ _ hx']
      simp [singleColumn]
    ¬∑ rw [d‚ÇÅ_eq_zero' _ _ hx _ _ hx']
  ¬∑ rw [d‚ÇÅ_eq_zero _ _ _ _ _ hx]

@[simp]
lemma singleColumn_d‚ÇÇ (y y' : Œπ‚ÇÇ) (hy : c‚ÇÇ.Rel y y') (n : Œπ)
    (hn : œÄ c‚ÇÅ c‚ÇÇ c (i‚ÇÅ, y') = n) :
    ((singleColumn C c‚ÇÅ c‚ÇÇ i‚ÇÅ).obj K).d‚ÇÇ c i‚ÇÅ y n =
      Œµ‚ÇÇ c‚ÇÅ c‚ÇÇ c (i‚ÇÅ, y) ‚Ä¢ (singleColumnXXIso c‚ÇÅ K i‚ÇÅ y).hom ‚â´ K.d y y' ‚â´
        (singleColumnXXIso c‚ÇÅ K i‚ÇÅ y').inv ‚â´
        ((singleColumn C c‚ÇÅ c‚ÇÇ i‚ÇÅ).obj K).ŒπTotal c i‚ÇÅ y' n hn := by
  simp [d‚ÇÇ_eq _ _ _ hy _ hn, singleColumn_obj_X_d]

end

end HomologicalComplex‚ÇÇ

namespace HomologicalComplex‚ÇÇ

variable (C : Type*) [Category C] [Abelian C] {Œπ : Type*} (c : ComplexShape Œπ)

noncomputable abbrev rowFiltrationGEFunctor :
    ‚Ñ§·µí·µñ ‚•§ HomologicalComplex‚ÇÇ C (up ‚Ñ§) c ‚•§ HomologicalComplex‚ÇÇ C (up ‚Ñ§) c :=
  CochainComplex.stupidFiltrationGEFunctor _

instance (n : ‚Ñ§·µí·µñ) {Œπ' : Type*} {c' : ComplexShape Œπ'}
    (K : HomologicalComplex‚ÇÇ C (up ‚Ñ§) c) [TotalComplexShape (up ‚Ñ§) c c'] [K.HasTotal c']:
    (((rowFiltrationGEFunctor C _).obj n).obj K).HasTotal c' := by
  dsimp [rowFiltrationGEFunctor]
  infer_instance

variable {C c}

noncomputable def rowFiltration (K : HomologicalComplex‚ÇÇ C (up ‚Ñ§) c) :
    ‚Ñ§·µí·µñ ‚•§ HomologicalComplex‚ÇÇ C (up ‚Ñ§) c :=
  rowFiltrationGEFunctor C c ‚ãô ((evaluation _ _).obj K)

noncomputable def rowFiltrationMap {K L : HomologicalComplex‚ÇÇ C (up ‚Ñ§) c} (œÜ : K ‚ü∂ L) :
    K.rowFiltration ‚ü∂ L.rowFiltration :=
  whiskerLeft _ ((evaluation _ _).map œÜ)

variable (K : HomologicalComplex‚ÇÇ C (up ‚Ñ§) (up ‚Ñ§))
variable [K.HasTotal (up ‚Ñ§)]

instance (n : ‚Ñ§·µí·µñ) : (K.rowFiltration.obj n).HasTotal (up ‚Ñ§) := by
  dsimp [rowFiltration]
  infer_instance

instance (L : CochainComplex C ‚Ñ§) (i‚ÇÇ : ‚Ñ§) :
    ((singleColumn C (up ‚Ñ§) (up ‚Ñ§) i‚ÇÇ).obj L).HasTotal (up ‚Ñ§) :=
  fun n => hasCoproduct_of_isZero_but_one _ ‚ü®‚ü®i‚ÇÇ, n - i‚ÇÇ‚ü©, by simp‚ü© (by
    rintro ‚ü®‚ü®x, y‚ü©, hxy‚ü© h
    apply isZero_singleColumn_X_X
    simp at hxy h
    omega)

@[simp]
noncomputable def cofanSingleColumnObjTotal (L : CochainComplex C ‚Ñ§) (x y n : ‚Ñ§) (h : x + y = n):
  GradedObject.CofanMapObjFun (((singleColumn C (up ‚Ñ§) (up ‚Ñ§) x).obj L).toGradedObject)
    (œÄ (up ‚Ñ§) (up ‚Ñ§) (up ‚Ñ§)) n :=
  cofanOfIsZeroButOne  _ ‚ü®‚ü®x, y‚ü©, h‚ü© (by
    rintro ‚ü®‚ü®x', y'‚ü©, hxy‚ü© h'
    apply isZero_singleColumn_X_X
    simp at hxy h'
    omega)

noncomputable def isColimitCofanSingleColumnObjTotal
    (L : CochainComplex C ‚Ñ§) (x y n : ‚Ñ§) (h : x + y = n) :
    IsColimit (cofanSingleColumnObjTotal L x y n h) := by
  apply isColimitCofanOfIsZeroButOne

noncomputable def singleColumnObjTotalXIso
    (L : CochainComplex C ‚Ñ§) (x y n : ‚Ñ§) (h : x + y = n) :
    (((singleColumn C (up ‚Ñ§) (up ‚Ñ§) x).obj L).total (up ‚Ñ§)).X n ‚âÖ L.X y :=
  ((cofanSingleColumnObjTotal L x y n h).iso
    (isColimitCofanSingleColumnObjTotal L x y n h)).symm ‚â™‚â´ (singleColumnXXIso (up ‚Ñ§) L x y)

lemma singleColumnObjTotalXIso_inv
    (L : CochainComplex C ‚Ñ§) (x y n : ‚Ñ§) (h : x + y = n) :
    (singleColumnObjTotalXIso L x y n h).inv =
      (singleColumnXXIso (up ‚Ñ§) L x y).inv ‚â´
        ((singleColumn C (up ‚Ñ§) (up ‚Ñ§) x).obj L).ŒπTotal (up ‚Ñ§) x y n h := by
  rfl

noncomputable def singleColumnObjTotal (L : CochainComplex C ‚Ñ§) (x x' : ‚Ñ§) (h : x + x' = 0) :
    ((singleColumn C (up ‚Ñ§) (up ‚Ñ§) x).obj L).total (up ‚Ñ§) ‚âÖ L‚ü¶x'‚üß :=
  Iso.symm (HomologicalComplex.Hom.isoOfComponents
    (fun n => (singleColumnObjTotalXIso L _ _ _ (by dsimp; omega)).symm) (by
      intro y y' h
      dsimp at h ‚ä¢
      simp [singleColumnObjTotalXIso_inv]
      rw [singleColumn_d‚ÇÇ _ _ _ _ _ _ _ (y' + x')
        (by dsimp; omega) _ (by dsimp; omega)]
      obtain rfl : x' = -x := by omega
      simp))

end HomologicalComplex‚ÇÇ
