/-
Copyright (c) 2021 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison, Jo√´l Riou
-/
import Mathlib.Algebra.Homology.Homotopy
import Mathlib.CategoryTheory.Abelian.Homology

#align_import algebra.homology.quasi_iso from "leanprover-community/mathlib"@"956af7c76589f444f2e1313911bad16366ea476d"

/-!
# Quasi-isomorphisms

A chain map is a quasi-isomorphism if it induces isomorphisms on homology.

## Future work

Define the derived category as the localization at quasi-isomorphisms?
-/


open CategoryTheory

open CategoryTheory.Limits

universe v u

variable {Œπ : Type*}

variable {V : Type u} [Category.{v} V] [HasZeroMorphisms V] [HasZeroObject V]

variable [HasEqualizers V] [HasImages V] [HasImageMaps V] [HasCokernels V]

variable {c : ComplexShape Œπ} {C D E : HomologicalComplex V c}

/-- A chain map is a quasi-isomorphism if it induces isomorphisms on homology.
-/
class QuasiIso (f : C ‚ü∂ D) : Prop where
  IsIso : ‚àÄ i, IsIso ((homologyFunctor V c i).map f)
#align quasi_iso QuasiIso

attribute [instance] QuasiIso.IsIso

instance (priority := 100) quasiIso_of_iso (f : C ‚ü∂ D) [IsIso f] : QuasiIso f where
  IsIso i := by
    change IsIso ((homologyFunctor V c i).mapIso (asIso f)).hom
    -- ‚ä¢ IsIso ((homologyFunctor V c i).mapIso (asIso f)).hom
    infer_instance
    -- üéâ no goals
#align quasi_iso_of_iso quasiIso_of_iso

instance quasiIso_comp (f : C ‚ü∂ D) [QuasiIso f] (g : D ‚ü∂ E) [QuasiIso g] : QuasiIso (f ‚â´ g) where
  IsIso i := by
    rw [Functor.map_comp]
    -- ‚ä¢ IsIso ((homologyFunctor V c i).map f ‚â´ (homologyFunctor V c i).map g)
    infer_instance
    -- üéâ no goals
#align quasi_iso_comp quasiIso_comp

theorem quasiIso_of_comp_left (f : C ‚ü∂ D) [QuasiIso f] (g : D ‚ü∂ E) [QuasiIso (f ‚â´ g)] :
    QuasiIso g :=
  { IsIso := fun i => IsIso.of_isIso_fac_left ((homologyFunctor V c i).map_comp f g).symm }
#align quasi_iso_of_comp_left quasiIso_of_comp_left

theorem quasiIso_of_comp_right (f : C ‚ü∂ D) (g : D ‚ü∂ E) [QuasiIso g] [QuasiIso (f ‚â´ g)] :
    QuasiIso f :=
  { IsIso := fun i => IsIso.of_isIso_fac_right ((homologyFunctor V c i).map_comp f g).symm }
#align quasi_iso_of_comp_right quasiIso_of_comp_right

namespace HomotopyEquiv

section

variable {W : Type*} [Category W] [Preadditive W] [HasCokernels W] [HasImages W] [HasEqualizers W]
  [HasZeroObject W] [HasImageMaps W]

/-- A homotopy equivalence is a quasi-isomorphism. -/
theorem toQuasiIso {C D : HomologicalComplex W c} (e : HomotopyEquiv C D) : QuasiIso e.hom :=
  ‚ü®fun i => by
    refine' ‚ü®‚ü®(homologyFunctor W c i).map e.inv, _‚ü©‚ü©
    -- ‚ä¢ (homologyFunctor W c i).map e.hom ‚â´ (homologyFunctor W c i).map e.inv = ùüô (( ‚Ä¶
    simp only [‚Üê Functor.map_comp, ‚Üê (homologyFunctor W c i).map_id]
    -- ‚ä¢ (homologyFunctor W c i).map (e.hom ‚â´ e.inv) = (homologyFunctor W c i).map (ùüô ‚Ä¶
    constructor <;> apply homology_map_eq_of_homotopy
    -- ‚ä¢ (homologyFunctor W c i).map (e.hom ‚â´ e.inv) = (homologyFunctor W c i).map (ùüô ‚Ä¶
                    -- ‚ä¢ Homotopy (e.hom ‚â´ e.inv) (ùüô C)
                    -- ‚ä¢ Homotopy (e.inv ‚â´ e.hom) (ùüô D)
    exacts [e.homotopyHomInvId, e.homotopyInvHomId]‚ü©
    -- üéâ no goals
#align homotopy_equiv.to_quasi_iso HomotopyEquiv.toQuasiIso

theorem toQuasiIso_inv {C D : HomologicalComplex W c} (e : HomotopyEquiv C D) (i : Œπ) :
    (@asIso _ _ _ _ _ (e.toQuasiIso.1 i)).inv = (homologyFunctor W c i).map e.inv := by
  symm
  -- ‚ä¢ (homologyFunctor W c i).map e.inv = (asIso ((homologyFunctor W c i).map e.ho ‚Ä¶
  haveI := e.toQuasiIso.1 i -- Porting note: Added this to get `asIso_hom` to work.
  -- ‚ä¢ (homologyFunctor W c i).map e.inv = (asIso ((homologyFunctor W c i).map e.ho ‚Ä¶
  simp only [‚Üê Iso.hom_comp_eq_id, asIso_hom, ‚Üê Functor.map_comp, ‚Üê (homologyFunctor W c i).map_id,
    homology_map_eq_of_homotopy e.homotopyHomInvId _]
#align homotopy_equiv.to_quasi_iso_inv HomotopyEquiv.toQuasiIso_inv

end

end HomotopyEquiv

namespace HomologicalComplex.Hom

section ToSingle‚ÇÄ

variable {W : Type*} [Category W] [Abelian W]

section

variable {X : ChainComplex W ‚Ñï} {Y : W} (f : X ‚ü∂ (ChainComplex.single‚ÇÄ _).obj Y) [hf : QuasiIso f]

/-- If a chain map `f : X ‚ü∂ Y[0]` is a quasi-isomorphism, then the cokernel of the differential
`d : X‚ÇÅ ‚Üí X‚ÇÄ` is isomorphic to `Y`. -/
noncomputable def toSingle‚ÇÄCokernelAtZeroIso : cokernel (X.d 1 0) ‚âÖ Y :=
  X.homologyZeroIso.symm.trans
    ((@asIso _ _ _ _ _ (hf.1 0)).trans ((ChainComplex.homologyFunctor0Single‚ÇÄ W).app Y))
#align homological_complex.hom.to_single‚ÇÄ_cokernel_at_zero_iso HomologicalComplex.Hom.toSingle‚ÇÄCokernelAtZeroIso

theorem toSingle‚ÇÄCokernelAtZeroIso_hom_eq [hf : QuasiIso f] :
    f.toSingle‚ÇÄCokernelAtZeroIso.hom =
      cokernel.desc (X.d 1 0) (f.f 0) (by rw [‚Üê f.2 1 0 rfl]; exact comp_zero) := by
                                          -- ‚ä¢ HomologicalComplex.Hom.f f 1 ‚â´ d ((ChainComplex.single‚ÇÄ W).obj Y) 1 0 = 0
                                                              -- üéâ no goals
  ext
  -- ‚ä¢ coequalizer.œÄ (d X 1 0) 0 ‚â´ (toSingle‚ÇÄCokernelAtZeroIso f).hom = coequalizer ‚Ä¶
  dsimp only [toSingle‚ÇÄCokernelAtZeroIso, ChainComplex.homologyZeroIso, homologyOfZeroRight,
    homology.mapIso, ChainComplex.homologyFunctor0Single‚ÇÄ, cokernel.map]
  dsimp [asIso]
  -- ‚ä¢ cokernel.œÄ (d X 1 0) ‚â´ ((cokernel.desc (d X 1 0) (cokernel.œÄ (image.Œπ (d X 1 ‚Ä¶
  simp only [cokernel.œÄ_desc, Category.assoc, homology.map_desc, cokernel.œÄ_desc_assoc]
  -- ‚ä¢ kernelZeroIsoSource.inv ‚â´ (kernelSubobjectIso 0).inv ‚â´ cokernel.œÄ (imageToKe ‚Ä¶
  simp [homology.desc, Iso.refl_inv (X.X 0)]
  -- üéâ no goals
#align homological_complex.hom.to_single‚ÇÄ_cokernel_at_zero_iso_hom_eq HomologicalComplex.Hom.toSingle‚ÇÄCokernelAtZeroIso_hom_eq

theorem to_single‚ÇÄ_epi_at_zero [hf : QuasiIso f] : Epi (f.f 0) := by
  constructor
  -- ‚ä¢ ‚àÄ {Z : W} (g h : HomologicalComplex.X ((ChainComplex.single‚ÇÄ W).obj Y) 0 ‚ü∂ Z ‚Ä¶
  intro Z g h Hgh
  -- ‚ä¢ g = h
  rw [‚Üê cokernel.œÄ_desc (X.d 1 0) (f.f 0) (by rw [‚Üê f.2 1 0 rfl]; exact comp_zero),
    ‚Üê toSingle‚ÇÄCokernelAtZeroIso_hom_eq] at Hgh
  rw [(@cancel_epi _ _ _ _ _ _ (epi_comp _ _) _ _).1 Hgh]
  -- üéâ no goals
#align homological_complex.hom.to_single‚ÇÄ_epi_at_zero HomologicalComplex.Hom.to_single‚ÇÄ_epi_at_zero

theorem to_single‚ÇÄ_exact_d_f_at_zero [hf : QuasiIso f] : Exact (X.d 1 0) (f.f 0) := by
  rw [Preadditive.exact_iff_homology_zero]
  -- ‚ä¢ ‚àÉ w, Nonempty (_root_.homology (d X 1 0) (HomologicalComplex.Hom.f f 0) w ‚âÖ 0)
  have h : X.d 1 0 ‚â´ f.f 0 = 0 := by
    simp only [‚Üê f.2 1 0 rfl, ChainComplex.single‚ÇÄ_obj_X_d, comp_zero]
  refine' ‚ü®h, Nonempty.intro (homologyIsoKernelDesc _ _ _ ‚â™‚â´ _)‚ü©
  -- ‚ä¢ kernel (cokernel.desc (d X 1 0) (HomologicalComplex.Hom.f f 0) h) ‚âÖ 0
  suffices IsIso (cokernel.desc _ _ h) by apply kernel.ofMono
  -- ‚ä¢ IsIso (cokernel.desc (d X 1 0) (HomologicalComplex.Hom.f f 0) h)
  rw [‚Üê toSingle‚ÇÄCokernelAtZeroIso_hom_eq]
  -- ‚ä¢ IsIso (toSingle‚ÇÄCokernelAtZeroIso f).hom
  infer_instance
  -- üéâ no goals
#align homological_complex.hom.to_single‚ÇÄ_exact_d_f_at_zero HomologicalComplex.Hom.to_single‚ÇÄ_exact_d_f_at_zero

theorem to_single‚ÇÄ_exact_at_succ [hf : QuasiIso f] (n : ‚Ñï) :
    Exact (X.d (n + 2) (n + 1)) (X.d (n + 1) n) :=
  (Preadditive.exact_iff_homology_zero _ _).2
    ‚ü®X.d_comp_d _ _ _,
      ‚ü®(ChainComplex.homologySuccIso _ _).symm.trans
          ((@asIso _ _ _ _ _ (hf.1 (n + 1))).trans homologyZeroZero)‚ü©‚ü©
#align homological_complex.hom.to_single‚ÇÄ_exact_at_succ HomologicalComplex.Hom.to_single‚ÇÄ_exact_at_succ

end

section

variable {X : CochainComplex W ‚Ñï} {Y : W} (f : (CochainComplex.single‚ÇÄ _).obj Y ‚ü∂ X)

/-- If a cochain map `f : Y[0] ‚ü∂ X` is a quasi-isomorphism, then the kernel of the differential
`d : X‚ÇÄ ‚Üí X‚ÇÅ` is isomorphic to `Y`. -/
noncomputable def fromSingle‚ÇÄKernelAtZeroIso [hf : QuasiIso f] : kernel (X.d 0 1) ‚âÖ Y :=
  X.homologyZeroIso.symm.trans
    ((@asIso _ _ _ _ _ (hf.1 0)).symm.trans ((CochainComplex.homologyFunctor0Single‚ÇÄ W).app Y))
#align homological_complex.hom.from_single‚ÇÄ_kernel_at_zero_iso HomologicalComplex.Hom.fromSingle‚ÇÄKernelAtZeroIso

theorem fromSingle‚ÇÄKernelAtZeroIso_inv_eq [hf : QuasiIso f] :
    f.fromSingle‚ÇÄKernelAtZeroIso.inv =
      kernel.lift (X.d 0 1) (f.f 0) (by rw [f.2 0 1 rfl]; exact zero_comp) := by
                                        -- ‚ä¢ d ((CochainComplex.single‚ÇÄ W).obj Y) 0 1 ‚â´ HomologicalComplex.Hom.f f 1 = 0
                                                          -- üéâ no goals
  ext
  -- ‚ä¢ (fromSingle‚ÇÄKernelAtZeroIso f).inv ‚â´ equalizer.Œπ (d X 0 1) 0 = kernel.lift ( ‚Ä¶
  dsimp only [fromSingle‚ÇÄKernelAtZeroIso, CochainComplex.homologyZeroIso, homologyOfZeroLeft,
    homology.mapIso, CochainComplex.homologyFunctor0Single‚ÇÄ, kernel.map]
  simp only [Iso.trans_inv, Iso.app_inv, Iso.symm_inv, Category.assoc, equalizer_as_kernel,
    kernel.lift_Œπ]
  dsimp [asIso]
  -- ‚ä¢ ((inv (Subobject.arrow (kernelSubobject 0)) ‚â´ homology.œÄ 0 0 (_ : 0 ‚â´ 0 = 0) ‚Ä¶
  simp only [Category.assoc, homology.œÄ_map, cokernelZeroIsoTarget_hom,
    cokernelIsoOfEq_hom_comp_desc, kernelSubobject_arrow, homology.œÄ_map_assoc, IsIso.inv_comp_eq]
  simp [homology.œÄ, kernelSubobjectMap_comp, Iso.refl_hom (X.X 0), Category.comp_id]
  -- üéâ no goals
#align homological_complex.hom.from_single‚ÇÄ_kernel_at_zero_iso_inv_eq HomologicalComplex.Hom.fromSingle‚ÇÄKernelAtZeroIso_inv_eq

theorem from_single‚ÇÄ_mono_at_zero [hf : QuasiIso f] : Mono (f.f 0) := by
  constructor
  -- ‚ä¢ ‚àÄ {Z : W} (g h : Z ‚ü∂ HomologicalComplex.X ((CochainComplex.single‚ÇÄ W).obj Y) ‚Ä¶
  intro Z g h Hgh
  -- ‚ä¢ g = h
  rw [‚Üê kernel.lift_Œπ (X.d 0 1) (f.f 0) (by rw [f.2 0 1 rfl]; exact zero_comp),
    ‚Üê fromSingle‚ÇÄKernelAtZeroIso_inv_eq] at Hgh
  rw [(@cancel_mono _ _ _ _ _ _ (mono_comp _ _) _ _).1 Hgh]
  -- üéâ no goals
#align homological_complex.hom.from_single‚ÇÄ_mono_at_zero HomologicalComplex.Hom.from_single‚ÇÄ_mono_at_zero

theorem from_single‚ÇÄ_exact_f_d_at_zero [hf : QuasiIso f] : Exact (f.f 0) (X.d 0 1) := by
  rw [Preadditive.exact_iff_homology_zero]
  -- ‚ä¢ ‚àÉ w, Nonempty (_root_.homology (HomologicalComplex.Hom.f f 0) (d X 0 1) w ‚âÖ 0)
  have h : f.f 0 ‚â´ X.d 0 1 = 0 := by
    simp only [HomologicalComplex.Hom.comm, CochainComplex.single‚ÇÄ_obj_X_d, zero_comp]
  refine' ‚ü®h, Nonempty.intro (homologyIsoCokernelLift _ _ _ ‚â™‚â´ _)‚ü©
  -- ‚ä¢ cokernel (kernel.lift (d X 0 1) (HomologicalComplex.Hom.f f 0) h) ‚âÖ 0
  suffices IsIso (kernel.lift (X.d 0 1) (f.f 0) h) by apply cokernel.ofEpi
  -- ‚ä¢ IsIso (kernel.lift (d X 0 1) (HomologicalComplex.Hom.f f 0) h)
  rw [‚Üê fromSingle‚ÇÄKernelAtZeroIso_inv_eq f]
  -- ‚ä¢ IsIso (fromSingle‚ÇÄKernelAtZeroIso f).inv
  infer_instance
  -- üéâ no goals
#align homological_complex.hom.from_single‚ÇÄ_exact_f_d_at_zero HomologicalComplex.Hom.from_single‚ÇÄ_exact_f_d_at_zero

theorem from_single‚ÇÄ_exact_at_succ [hf : QuasiIso f] (n : ‚Ñï) :
    Exact (X.d n (n + 1)) (X.d (n + 1) (n + 2)) :=
  (Preadditive.exact_iff_homology_zero _ _).2
    ‚ü®X.d_comp_d _ _ _,
      ‚ü®(CochainComplex.homologySuccIso _ _).symm.trans
          ((@asIso _ _ _ _ _ (hf.1 (n + 1))).symm.trans homologyZeroZero)‚ü©‚ü©
#align homological_complex.hom.from_single‚ÇÄ_exact_at_succ HomologicalComplex.Hom.from_single‚ÇÄ_exact_at_succ

end

end ToSingle‚ÇÄ

end HomologicalComplex.Hom

variable {A : Type*} [Category A] [Abelian A] {B : Type*} [Category B] [Abelian B] (F : A ‚•§ B)
  [Functor.Additive F] [PreservesFiniteLimits F] [PreservesFiniteColimits F] [Faithful F]

theorem CategoryTheory.Functor.quasiIso_of_map_quasiIso {C D : HomologicalComplex A c} (f : C ‚ü∂ D)
    (hf : QuasiIso ((F.mapHomologicalComplex _).map f)) : QuasiIso f :=
  ‚ü®fun i =>
    haveI : IsIso (F.map ((homologyFunctor A c i).map f)) := by
      rw [‚Üê Functor.comp_map, ‚Üê NatIso.naturality_2 (F.homologyFunctorIso i) f, Functor.comp_map]
      -- ‚ä¢ IsIso (NatTrans.app (homologyFunctorIso F i).hom C ‚â´ (homologyFunctor B c i) ‚Ä¶
      infer_instance
      -- üéâ no goals
    isIso_of_reflects_iso _ F‚ü©
#align category_theory.functor.quasi_iso_of_map_quasi_iso CategoryTheory.Functor.quasiIso_of_map_quasiIso
