import Mathlib.Algebra.Homology.HomotopyCategory.MappingCone
import Mathlib.CategoryTheory.Localization.Predicate
import Mathlib.CategoryTheory.Preadditive.Biproducts
import Mathlib.Algebra.Homology.HomologicalComplexLimits

open CategoryTheory Category Limits

variable {C : Type _} [Category C] [Preadditive C] [HasBinaryBiproducts C]
  [HasBinaryBiproducts (CochainComplex C ‚Ñ§)]

namespace CochainComplex

instance : HasBinaryBiproducts (CochainComplex C ‚Ñ§) := by
  apply HasBinaryBiproducts.of_hasBinaryProducts

open HomComplex HomologicalComplex

variable (K L : CochainComplex C ‚Ñ§)

noncomputable def cylinder : CochainComplex C ‚Ñ§ := mappingCone (biprod.lift (ùüô K) (-ùüô K))

namespace cylinder

variable {K L}

noncomputable def inl : K ‚ü∂ cylinder K := biprod.inl ‚â´ MappingCone.inr _
noncomputable def inr : K ‚ü∂ cylinder K := biprod.inr ‚â´ MappingCone.inr _

attribute [local simp] sub_eq_add_neg

noncomputable def desc (f‚ÇÅ f‚ÇÇ : K ‚ü∂ L) (h : Homotopy f‚ÇÅ f‚ÇÇ) : cylinder K ‚ü∂ L :=
  MappingCone.desc _ (Cochain.ofHomotopy h) (biprod.desc f‚ÇÅ f‚ÇÇ) (by simp)

@[reassoc (attr := simp)]
lemma inl_desc (f‚ÇÅ f‚ÇÇ : K ‚ü∂ L) (h : Homotopy f‚ÇÅ f‚ÇÇ) : inl ‚â´ desc f‚ÇÅ f‚ÇÇ h = f‚ÇÅ := by
  simp only [inl, desc, assoc, MappingCone.inr_desc, biprod.inl_desc]

@[reassoc (attr := simp)]
lemma inr_desc (f‚ÇÅ f‚ÇÇ : K ‚ü∂ L) (h : Homotopy f‚ÇÅ f‚ÇÇ) : inr ‚â´ desc f‚ÇÅ f‚ÇÇ h = f‚ÇÇ := by
  simp only [inr, desc, assoc, MappingCone.inr_desc, biprod.inr_desc]

@[simp]
noncomputable def œÄ : cylinder K ‚ü∂ K := desc _ _ (Homotopy.refl (ùüô K))

variable (K)

noncomputable def homotopyEquiv : HomotopyEquiv (cylinder K) K where
  hom := œÄ
  inv := inl
  homotopyHomInvId := MappingCone.descHomotopy _ _ _ 0
    ((Cochain.ofHom biprod.snd).comp (MappingCone.inl _) (zero_add (-1)))
    (by
      dsimp only [œÄ, inl, desc]
      rw [MappingCone.cochain_to_ext_iff _ _ _ _ (neg_add_self 1)]
      simp only [Cochain.ofHom_comp, Cochain.comp_assoc_of_second_is_zero_cochain,
        Cochain.comp_assoc_of_first_is_zero_cochain, MappingCone.inr_fst, Cochain.comp_zero,
        Œ¥_zero, zero_add, Cochain.add_comp, MappingCone.inl_fst, Cochain.comp_id,
        MappingCone.inr_snd, MappingCone.inl_snd]
      erw [Cochain.id_comp, Cochain.id_comp]
      constructor
      . erw [MappingCone.inl_fst, ‚Üê Cochain.ofHom_comp, biprod.lift_snd,
          Cochain.ofHom_neg, add_left_neg]
      . erw [MappingCone.inl_snd, MappingCone.ofHom_desc,
          ‚Üê Cochain.comp_assoc_of_third_is_zero_cochain,
          MappingCone.inl_descCochain, Cochain.ofHomotopy_refl, Cochain.zero_comp])
    (by
      dsimp only [œÄ, inl, desc]
      rw [MappingCone.cochain_to_ext_iff _ _ _ _ (zero_add 1)]
      simp only [Cochain.ofHomotopy_refl, MappingCone.inr_desc_assoc, Cochain.ofHom_comp,
        Cochain.comp_assoc_of_first_is_zero_cochain, MappingCone.inr_fst, Cochain.comp_zero,
        Œ¥_ofHom_comp, MappingCone.Œ¥_inl, Cochain.add_comp, zero_add,
        MappingCone.inr_snd, Cochain.comp_id]
      erw [Cochain.id_comp, Cochain.id_comp]
      constructor
      . simp only [MappingCone.inr_fst]
      . simp only [MappingCone.inr_snd, ‚Üê Cochain.ofHom_comp, ‚Üê Cochain.ofHom_add]
        apply congr_arg
        ext1 <;> ext1 <;> simp)
  homotopyInvHomId := Homotopy.ofEq (by simp)

end cylinder

lemma homotopyEquivalences_isInvertedBy_iff {D : Type _} [Category D]
    (F : CochainComplex C ‚Ñ§ ‚•§ D) :
    (homotopyEquivalences C (ComplexShape.up ‚Ñ§)).IsInvertedBy F ‚Üî
      ‚àÄ ‚¶ÉK L : CochainComplex C ‚Ñ§‚¶Ñ (f‚ÇÅ f‚ÇÇ : K ‚ü∂ L) (_ : Homotopy f‚ÇÅ f‚ÇÇ), F.map f‚ÇÅ = F.map f‚ÇÇ := by
  constructor
  . intros hF K L f‚ÇÅ f‚ÇÇ h
    have : IsIso (F.map (cylinder.œÄ : _ ‚ü∂ K)) := hF _ ‚ü®cylinder.homotopyEquiv K, rfl‚ü©
    have eq : F.map (cylinder.inl : K ‚ü∂ _) = F.map cylinder.inr := by
      simp only [‚Üê cancel_mono (F.map (cylinder.œÄ : _ ‚ü∂ K)), ‚Üê F.map_comp, cylinder.œÄ,
        cylinder.inl_desc, cylinder.inr_desc]
    simpa only [‚Üê F.map_comp, cylinder.inl_desc, cylinder.inr_desc]
      using eq =‚â´ F.map (cylinder.desc _ _ h)
  . rintro hF K L _ ‚ü®e, rfl‚ü©
    refine' ‚ü®‚ü®F.map e.inv, _, _‚ü©‚ü©
    . rw [‚Üê F.map_comp, hF  _ _ e.homotopyHomInvId, F.map_id]
    . rw [‚Üê F.map_comp, hF  _ _ e.homotopyInvHomId, F.map_id]

end CochainComplex

namespace HomotopyCategory

variable (C)

def localization_strict_universal_property (D : Type _) [Category D] :
    Localization.StrictUniversalPropertyFixedTarget (quotient C (ComplexShape.up ‚Ñ§))
      (HomologicalComplex.homotopyEquivalences _ _) D where
  inverts := by
    rw [CochainComplex.homotopyEquivalences_isInvertedBy_iff]
    intro K L f‚ÇÅ f‚ÇÇ h
    exact eq_of_homotopy _ _ h
  lift F hF := CategoryTheory.Quotient.lift _ F (fun K L f‚ÇÅ f‚ÇÇ ‚ü®h‚ü© => by
    rw [CochainComplex.homotopyEquivalences_isInvertedBy_iff] at hF
    exact hF _ _ h)
  fac F hF := Quotient.lift_spec _ _ _
  uniq F‚ÇÅ F‚ÇÇ h := by
    rw [Quotient.lift_unique _ _ _ F‚ÇÅ rfl, Quotient.lift_unique _ _ _ F‚ÇÇ h.symm]
    . rfl
    . intro K L f‚ÇÅ f‚ÇÇ ‚ü®h‚ü©
      dsimp
      rw [eq_of_homotopy _ _ h]

instance IsLocalization :
    (HomotopyCategory.quotient C (ComplexShape.up ‚Ñ§)).IsLocalization
      (HomologicalComplex.homotopyEquivalences _ _) :=
  Functor.IsLocalization.mk' _ _ (localization_strict_universal_property _ _)
  (localization_strict_universal_property _ _)

end HomotopyCategory
