/-
Copyright (c) 2024 María Inés de Frutos Fernández. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: María Inés de Frutos Fernández, Xavier Généreux
-/
import Mathlib.Algebra.Algebra.Equiv
import Mathlib.Algebra.Algebra.NonUnitalHom
import Mathlib.Algebra.Module.BigOperators
import Mathlib.LinearAlgebra.Finsupp

/-!

This file presents a skewed version of `Mathlib.Algebra.MonoidAlgebra.Basic`.

We define `SkewMonoidAlgebra k G` attached with a skewed convolution product.
Here, the product of two elements `f g : SkewMonoidAlgebra k G` is the finitely supported
function whose value at `a` is the sum of `f x * (x • g y)` over all pairs `x, y`
such that `x * y = a`.

The associativity of the skewed multiplication depends on the `[MulSemiringAction G k]` instance.
In particular, this means that unlike in `Mathlib.Algebra.MonoidAlgebra.Basic`, `G` will
need to be a monoid for most of our uses.
-/

set_option autoImplicit false

noncomputable section

section

/-- The skew monoid algebra over a semiring `k` generated by the monoid `G`.
It is the type of finite formal `k`-linear combinations of terms of `G`,
endowed with a skewed convolution product.
-/
@[ext]
structure SkewMonoidAlgebra (k : Type*) (G : Type*) [Zero k] where ofFinsupp ::
  /-- Map to the associated finitely supported function `G →₀ k`. -/
  toFinsupp : G →₀ k

open BigOperators
open Function hiding Commute
namespace SkewMonoidAlgebra

universe u₁ u₂

variable {k : Type u₁} {G : Type u₂} {H : Type*} {R : Type*}

section AddCommMonoid

variable [AddCommMonoid k]

@[simp]
theorem eta (f : (SkewMonoidAlgebra k G)) : ofFinsupp f.toFinsupp = f := by cases f; rfl

private irreducible_def add :
    (SkewMonoidAlgebra k G) → (SkewMonoidAlgebra k G) → (SkewMonoidAlgebra k G)
  | ⟨a⟩, ⟨b⟩ => ⟨a + b⟩

instance zero : Zero (SkewMonoidAlgebra k G) := ⟨⟨0⟩⟩

instance add' : Add (SkewMonoidAlgebra k G) := ⟨add⟩

instance smulZeroClass {S : Type*} [SMulZeroClass S k] :
    SMulZeroClass S (SkewMonoidAlgebra k G) where
  smul r p := ⟨r • p.toFinsupp⟩
  smul_zero a := congr_arg ofFinsupp (smul_zero a)

@[simp]
theorem ofFinsupp_zero : (⟨0⟩ : SkewMonoidAlgebra k G) = 0 := rfl

@[simp]
theorem ofFinsupp_add {a b} : (⟨a + b⟩ : SkewMonoidAlgebra k G) = ⟨a⟩ + ⟨b⟩ :=
  show _ = add _ _ by rw [add_def]

@[simp]
theorem ofFinsupp_smul {S : Type*} [SMulZeroClass S k] (a : S) (b) :
    (⟨a • b⟩ : SkewMonoidAlgebra k G) = (a • ⟨b⟩ : SkewMonoidAlgebra k G) :=
  rfl

@[simp]
theorem toFinsupp_zero : (0 : SkewMonoidAlgebra k G).toFinsupp = 0 := rfl

@[simp]
theorem toFinsupp_add (a b : SkewMonoidAlgebra k G) :
    (a + b).toFinsupp = a.toFinsupp + b.toFinsupp := by
  cases a
  cases b
  rw [← ofFinsupp_add]

@[simp]
theorem toFinsupp_smul {S : Type*} [SMulZeroClass S k] (a : S) (b : SkewMonoidAlgebra k G) :
    (a • b).toFinsupp = a • b.toFinsupp :=
  rfl

theorem _root_.IsSMulRegular.skewMonoidAlgebra {S : Type*} [Monoid S] [DistribMulAction S k] {a : S}
    (ha : IsSMulRegular k a) : IsSMulRegular (SkewMonoidAlgebra k G) a
  | ⟨_x⟩, ⟨_y⟩, h => congr_arg _ <| ha.finsupp (ofFinsupp.inj h)

theorem toFinsupp_injective :
    Function.Injective (toFinsupp : SkewMonoidAlgebra k G → Finsupp _ _) :=
  fun ⟨_x⟩ ⟨_y⟩ => congr_arg _

@[simp]
theorem toFinsupp_inj {a b : SkewMonoidAlgebra k G} : a.toFinsupp = b.toFinsupp ↔ a = b :=
  toFinsupp_injective.eq_iff

theorem ofFinsupp_injective :
    Function.Injective (ofFinsupp : Finsupp _ _ → SkewMonoidAlgebra k G) :=
  fun _x _y => congr_arg toFinsupp

@[simp]
theorem toFinsupp_eq_zero {a : SkewMonoidAlgebra k G} : a.toFinsupp = 0 ↔ a = 0 := by
  rw [← toFinsupp_zero, toFinsupp_inj]

/-- A more convenient spelling of `SkewMonoidAlgebra.ofFinsupp.injEq` in terms of `Iff`. -/
theorem ofFinsupp_inj {a b} : (⟨a⟩ : SkewMonoidAlgebra k G) = ⟨b⟩ ↔ a = b :=
  iff_of_eq (ofFinsupp.injEq _ _)

@[simp]
theorem ofFinsupp_eq_zero {a} : (⟨a⟩ : SkewMonoidAlgebra k G) = 0 ↔ a = 0 := by
  rw [← ofFinsupp_zero, ofFinsupp_inj]

instance inhabited : Inhabited (SkewMonoidAlgebra k G) := ⟨0⟩

instance nontrivial [Nontrivial k] [Nonempty G] :
    Nontrivial (SkewMonoidAlgebra k G) := Function.Injective.nontrivial ofFinsupp_injective

instance addCommMonoid : AddCommMonoid (SkewMonoidAlgebra k G) :=
{ Function.Injective.addCommMonoid toFinsupp toFinsupp_injective toFinsupp_zero
      toFinsupp_add (fun _ _ => toFinsupp_smul _ _) with
    toAdd  := SkewMonoidAlgebra.add'
    toZero := SkewMonoidAlgebra.zero
    nsmul  := (. • .) }

instance isCancelAdd [IsCancelAdd k] : IsCancelAdd (SkewMonoidAlgebra k G) :=
  Function.Injective.isCancelAdd toFinsupp toFinsupp_injective toFinsupp_add

instance coeFun : CoeFun (SkewMonoidAlgebra k G) fun _ => G → k := ⟨fun s ↦ s.toFinsupp⟩

@[simp, norm_cast]
theorem coe_smul [SMulZeroClass R k] (b : R) (v : SkewMonoidAlgebra k G) :
    ⇑(b • v) = b • ⇑v :=
  rfl

section Support

/-- For `f : SkewMonoidAlgebra k G`, `f.support` is the set of all `a ∈ G` such that
`f a ≠ 0`. -/
def support : SkewMonoidAlgebra k G → Finset G
  | ⟨p⟩ => p.support

@[simp]
theorem support_ofFinsupp (p) : support (⟨p⟩ : SkewMonoidAlgebra k G) = p.support := by
  rw [support]

theorem support_toFinsupp (p : SkewMonoidAlgebra k G) : p.toFinsupp.support = p.support := by
  rw [support]

@[simp]
theorem support_zero : (0 : SkewMonoidAlgebra k G).support = ∅ := rfl

@[simp]
theorem support_eq_empty {p} : p.support = ∅ ↔ (p : SkewMonoidAlgebra k G) = 0 := by
  rcases p with ⟨⟩
  simp only [support, Finsupp.support_eq_empty, ofFinsupp_eq_zero]

theorem card_support_eq_zero {p} : p.support.card = 0 ↔ (p : SkewMonoidAlgebra k G) = 0 := by
  simp only [Finset.card_eq_zero, support_eq_empty]

@[simp]
theorem mem_support_iff {f : SkewMonoidAlgebra k G} : ∀ {a : G}, a ∈ f.support ↔ f a ≠ 0 := by
  rcases f with ⟨⟩
  simp only [support_ofFinsupp, Finsupp.mem_support_iff, ne_eq, implies_true]

end Support

section Single

/-- `single a b` is the finitely supported function with value `b` at `a` and zero otherwise. -/
abbrev single (a : G) (b : k) : SkewMonoidAlgebra k G := ⟨Finsupp.single a b⟩

@[simp]
theorem toFinsupp_single (a : G) (b : k) : (single a b).toFinsupp = Finsupp.single a b := rfl

@[simp]
theorem ofFinsupp_single (a : G) (b : k) : ⟨Finsupp.single a b⟩ = single a b := rfl

theorem single_zero_right (a : G) : single a (0 : k) = 0 := by
  ext; simp only [Finsupp.single_zero, Finsupp.coe_zero, Pi.zero_apply, toFinsupp_zero]

@[simp]
theorem single_add (a : G) (b₁ b₂ : k) : single a (b₁ + b₂) = single a b₁ + single a b₂ :=
  by ext; simp only [Finsupp.single_add, Finsupp.coe_add, Pi.add_apply, toFinsupp_add]

theorem single_zero (a : G) : (single a 0 : SkewMonoidAlgebra k G) = 0 := by
  rw [ofFinsupp_eq_zero, Finsupp.single_zero]

theorem single_apply {a a' : G} {b : k} [Decidable (a = a')] :
    single a b a' = if a = a' then b else 0 :=
  Finsupp.single_apply

theorem single_eq_zero {a : G} {b : k} : single a b = 0 ↔ b = 0 := by
  simp only [ofFinsupp_eq_zero, Finsupp.single_eq_zero]

theorem toFinsupp_single' : single = (fun (a : G) (b : k) ↦ ofFinsupp (Finsupp.single a b)) := rfl

/-- Group isomorphism between `SkewMonoidAlgebra k G` and `G →₀ k`. This is an
implementation detail, but it can be useful to transfer results from `Finsupp`
to `SkewMonoidAlgebra`. -/
@[simps apply symm_apply]
def toFinsuppIso : SkewMonoidAlgebra k G ≃+ (G →₀ k) where
  toFun        := toFinsupp
  invFun       := ofFinsupp
  left_inv     := fun ⟨_p⟩ => rfl
  right_inv _p := rfl
  map_add'     := toFinsupp_add

theorem smul_single {S} [SMulZeroClass S k] (s : S) (a : G) (b : k) :
    s • single a b = single a (s • b) :=
  toFinsupp_injective <| by simp;

theorem single_injective (a : G) : Function.Injective (single a : k → SkewMonoidAlgebra k G) :=
  (toFinsuppIso).symm.injective.comp (Finsupp.single_injective a)

end Single

section One

variable [One G] [One k]

/-- The unit of the multiplication is `single 1 1`, i.e. the function that is `1` at `1` and
  zero elsewhere. -/
instance one : One (SkewMonoidAlgebra k G) :=
   ⟨⟨Finsupp.single 1 1⟩⟩

@[simp]
theorem ofFinsupp_one : (⟨Finsupp.single 1 1⟩ : SkewMonoidAlgebra k G) = 1 :=
  rfl

@[simp]
theorem toFinsupp_one : (1 : SkewMonoidAlgebra k G).toFinsupp = Finsupp.single 1 1 :=
  rfl

@[simp]
theorem toFinsupp_eq_one {a : SkewMonoidAlgebra k G} :
    a.toFinsupp = Finsupp.single 1 1 ↔ a = 1 := by
  rw [← toFinsupp_one, toFinsupp_inj]

@[simp]
theorem ofFinsupp_eq_one {a} :
    (⟨a⟩ : SkewMonoidAlgebra k G) = 1 ↔ a = Finsupp.single 1 1 := by
  rw [← ofFinsupp_one, ofFinsupp_inj]

-- This is not a `simp` lemma as `single_zero_left` is more general.
theorem single_zero_one  : single 1 (1 : k) = 1 :=
  rfl

theorem one_def : (1 : SkewMonoidAlgebra k G) = single 1 1 :=
  rfl

end One

section sum

instance [DecidableEq G] [DecidableEq k] : DecidableEq (SkewMonoidAlgebra k G) :=
  @Equiv.decidableEq (SkewMonoidAlgebra k G) _ (toFinsuppIso).toEquiv (Finsupp.instDecidableEq)

/-- `sum f g` is the sum of `g a (f a)` over the support of `f`. -/
def sum {N : Type*} [AddCommMonoid N] (f : SkewMonoidAlgebra k G) (g : G → k → N) : N :=
  (f.toFinsupp).sum g

theorem sum_def {N : Type*} [AddCommMonoid N] (f : SkewMonoidAlgebra k G) (g : G → k → N) :
    sum f g = Finsupp.sum f.toFinsupp g := rfl

@[simp]
theorem sum_single_index {N} [AddCommMonoid N] {a : G} {b : k} {h : G → k → N}
    (h_zero : h a 0 = 0) : (SkewMonoidAlgebra.single a b).sum h = h a b :=
  Finsupp.sum_single_index h_zero

theorem map_sum' {N P : Type*} [AddCommMonoid N] [AddCommMonoid P] {H : Type*} [FunLike H N P]
    [AddMonoidHomClass H N P] (h : H) (f : SkewMonoidAlgebra k G) (g : G → k → N) :
    h (sum f g) = sum f fun (a : G) (b : k) => h (g a b) :=
  map_sum h _ _

theorem ofFinsupp_sum {ι : Type*} (s : Finset ι) (f : ι → (G →₀ k)) :
    (⟨Finset.sum s f⟩ : SkewMonoidAlgebra k G) = Finset.sum s (fun i ↦ ⟨f i⟩) :=
  map_sum (toFinsuppIso).symm f s

@[simp]
theorem toFinsupp_sum {ι : Type*} (s : Finset ι) (f : ι → SkewMonoidAlgebra k G) :
    (Finset.sum s f : SkewMonoidAlgebra k G).toFinsupp = Finset.sum s (fun i ↦ (f i).toFinsupp) :=
  map_sum (toFinsuppIso) f s

theorem toFinsupp_sum' {k' G' : Type*} [AddCommMonoid k'] (f : SkewMonoidAlgebra k' G)
    (g : G → k' → SkewMonoidAlgebra k G') :
    (sum f g).toFinsupp = Finsupp.sum f.toFinsupp (fun (a : G) (b : k') ↦ (g a b).toFinsupp) :=
  map_sum (toFinsuppIso) (fun (a : G) => g a (f a)) (f.toFinsupp.support)

theorem sum_single (f : SkewMonoidAlgebra k G) : f.sum single = f :=
  (ofFinsupp_sum _ _).symm.trans (congr_arg _ <| Finsupp.sum_single _)

theorem sum_add_index' {S : Type*} [AddCommMonoid S] {f g : SkewMonoidAlgebra k G} {h : G → k → S}
    (hf : ∀ i, h i 0 = 0) (h_add : ∀ a b₁ b₂, h a (b₁ + b₂) = h a b₁ + h a b₂) :
    (f + g).sum h = f.sum h + g.sum h := by
  rw [show f + g = ⟨f.toFinsupp + g.toFinsupp⟩ from add_def f g]
  exact Finsupp.sum_add_index' (hf) (h_add)

theorem sum_add_index {S : Type*} [DecidableEq G] [AddCommMonoid S]
    {f g : SkewMonoidAlgebra k G} {h : G → k → S} (h_zero : ∀ a ∈ f.support ∪ g.support, h a 0 = 0)
    (h_add : ∀ a ∈ f.support ∪ g.support, ∀ (b₁ b₂ : k), h a (b₁ + b₂) = h a b₁ + h a b₂) :
    (f + g).sum h = f.sum h + g.sum h := by
  rw [show f + g = ⟨f.toFinsupp + g.toFinsupp⟩ from add_def f g]
  exact Finsupp.sum_add_index h_zero (h_add)

@[simp]
theorem sum_add' {S : Type*} [AddCommMonoid S] (p : SkewMonoidAlgebra k G) (f g : G → k → S) :
    p.sum (f + g) = p.sum f + p.sum g := Finsupp.sum_add

@[simp]
theorem sum_add {S : Type*} [AddCommMonoid S] (p : SkewMonoidAlgebra k G) (f g : G → k → S) :
    (p.sum fun n x => f n x + g n x) = p.sum f + p.sum g :=
  sum_add' _ _ _

theorem sum_smul_index' {N : Type*} [DistribSMul R k] [AddCommMonoid N]
    {g : SkewMonoidAlgebra k G} {b : R} {h : G → k → N} (h0 : ∀ i, h i 0 = 0) :
    (b • g).sum h = g.sum fun i c => h i (b • c) := by
  apply Finsupp.sum_mapRange_index h0
  simp only [smul_zero]

@[simp]
theorem sum_zero_index {S : Type*} [AddCommMonoid S] {f : G → k → S} :
    (0 : SkewMonoidAlgebra k G).sum f = 0 := by
  simp [sum]

@[simp]
theorem sum_zero {N : Type*} [AddCommMonoid N] {f : SkewMonoidAlgebra k G} :
    (f.sum fun _ _ => (0 : N)) = 0 :=
  Finset.sum_const_zero

theorem sum_sum_index {α β M N P : Type*} [AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P]
    {f : SkewMonoidAlgebra M α} {g : α → M → SkewMonoidAlgebra N β} {h : β → N → P}
    (h_zero : ∀ (a : β), h a 0 = 0)
    (h_add : ∀ (a : β) (b₁ b₂ : N), h a (b₁ + b₂) = h a b₁ + h a b₂) :
    sum (sum f g) h = sum f fun (a : α) (b : M) => sum (g a b) h := by
  rw [sum, toFinsupp_sum' f g, Finsupp.sum_sum_index h_zero h_add]; rfl

@[simp]
theorem sum_apply {k' G' : Type*} [AddCommMonoid k'] {f : SkewMonoidAlgebra k G}
    {g : G → k → SkewMonoidAlgebra k' G'} {a₂ : G'} :
    (f.sum g) a₂ = f.sum fun a₁ b => g a₁ b a₂ := by
  erw [toFinsupp_sum', Finsupp.finset_sum_apply]; rfl

theorem sum_mul {S : Type*} [NonUnitalNonAssocSemiring S] (b : S) (s : SkewMonoidAlgebra k G)
    {f : G → k → S} : s.sum f * b = s.sum fun a c => f a c * b := by
  simp only [sum, Finsupp.sum, Finset.sum_mul]

theorem mul_sum {S : Type*} [NonUnitalNonAssocSemiring S] (b : S) (s : SkewMonoidAlgebra k G)
    {f : G → k → S} : b * s.sum f = s.sum fun a c => b * f a c := by
  simp only [sum, Finsupp.sum, Finset.mul_sum]

@[simp]
theorem sum_ite_eq' {N : Type*} [AddCommMonoid N] [DecidableEq G] (f : SkewMonoidAlgebra k G)
    (a : G) (b : G → k → N) :
    (sum f fun (x : G) (v : k) => if x = a then b x v else 0) =
      if a ∈ f.support then b a (f a) else 0 := by
  simp only [sum, Finsupp.sum, f.toFinsupp.support.sum_ite_eq', support]

theorem smul_sum {M : Type*} [AddCommMonoid M] [DistribSMul R M]
    {v : SkewMonoidAlgebra k G} {c : R} {h : G → k → M} :
    c • v.sum h = v.sum fun a b => c • h a b :=
  Finset.smul_sum

end sum

section mapDomain

/-- Given `f : G → G'` and `v : SkewMonoidAlgebra k G`, `mapDomain f v : SkewMonoidAlgebra k G'`
is the finitely supported function whose value at `a : G'` is the sum of `v x` over all `x`
such that `f x = a`. -/
abbrev mapDomain {G' : Type*} (f : G → G') (v : SkewMonoidAlgebra k G) : SkewMonoidAlgebra k G' :=
  v.sum fun a => single (f a)

lemma toFinsupp_mapDomain {G' : Type*} (f : G → G') (v : SkewMonoidAlgebra k G) :
    (mapDomain f v).toFinsupp = Finsupp.mapDomain f v.toFinsupp := by
  rw [mapDomain, Finsupp.mapDomain, toFinsupp_sum']

@[simp]
theorem mapDomain_id {v : SkewMonoidAlgebra k G} : mapDomain id v = v := sum_single _

theorem mapDomain_comp {G' G'' : Type*} {f : G → G'} {g : G' → G''} {v : SkewMonoidAlgebra k G} :
    mapDomain (g ∘ f) v = mapDomain g (mapDomain f v) :=
  ((sum_sum_index (fun a => single_zero (g a)) (fun a => single_add (g a))).trans
    (Finsupp.sum_congr fun _ _ => sum_single_index (single_zero _))).symm

theorem mapDomain_zero {G' : Type*} {f : G → G'} :
    mapDomain f (0 : SkewMonoidAlgebra k G) = (0 : SkewMonoidAlgebra k G') :=
  sum_zero_index

theorem mapDomain_add {G' : Type*} {f : G → G'} {v₁ v₂ : SkewMonoidAlgebra k G} :
    mapDomain f (v₁ + v₂) = mapDomain f v₁ + mapDomain f v₂ :=
  sum_add_index' (fun _ => single_zero _) fun _ => single_add _

theorem mapDomain_sum {k' G' : Type*} [AddCommMonoid k'] {f : G → G'} {s : SkewMonoidAlgebra k' G}
    {v : G → k' → SkewMonoidAlgebra k G} :
    mapDomain f (s.sum v) = s.sum fun a b => mapDomain f (v a b) := by
  ext1
  simp only [toFinsupp_sum']
  exact Finsupp.mapDomain_sum

theorem sum_mapDomain_index {α β M N : Type*}
    [Semiring M] [AddCommMonoid N] {f : α → β} {s : SkewMonoidAlgebra M α} {h : β → M → N}
    (h_zero : ∀ (b : β), h b 0 = 0)
    (h_add : ∀ (b : β) (m₁ m₂ : M), h b (m₁ + m₂) = h b m₁ + h b m₂) :
    sum (mapDomain f s) h = sum s fun (a : α) (m : M) => h (f a) m :=
  (sum_sum_index h_zero h_add).trans <| Finsupp.sum_congr fun _ _ => sum_single_index (h_zero _)

theorem mapDomain_single {G' : Type*} {f : G → G'} {a : G} {b : k} :
    mapDomain f (single a b) = single (f a) b :=
  sum_single_index <| single_zero _

theorem mapDomain_smul {M α β : Type*} [Monoid R] [AddCommMonoid M] [DistribMulAction R M]
    {f : α → β} (b : R) (v : SkewMonoidAlgebra M α) : mapDomain f (b • v) = b • mapDomain f v := by
  ext
  simp only [toFinsupp_mapDomain, toFinsupp_smul, Finsupp.mapDomain_smul]

/-- A non-commutative version of `SkewMonoidAlgebra.lift`: given an additive homomorphism
`f : k →+ R` and a homomorphism `g : G → R`, returns the additive homomorphism from
`SkewMonoidAlgebra k G` such that `liftNC f g (single a b) = f b * g a`.

If `k` is a semiring and `f` is a ring homomorphism and for all `x : R`, `y : G` the equality
`(f (y • x)) * g y = (g y) * (f x))` holds, then the result is a ring homomorphism (see
`SkewMonoidAlgebra.liftNCRingHom`).

If `R` is a `k`-algebra and `f = algebraMap k R`, then the result is an algebra homomorphism called
`SkewMonoidAlgebra.lift`. -/
def liftNC [NonUnitalNonAssocSemiring R] (f : k →+ R) (g : G → R) :
    SkewMonoidAlgebra k G →+ R :=
  (Finsupp.liftAddHom fun x : G => (AddMonoidHom.mulRight (g x)).comp f).comp
    (AddEquiv.toAddMonoidHom toFinsuppIso)

@[simp] theorem liftNC_single [NonUnitalNonAssocSemiring R] (f : k →+ R) (g : G → R) (a : G)
    (b : k) : liftNC f g (single a b) = f b * g a :=
  Finsupp.liftAddHom_apply_single _ _ _

end mapDomain

end AddCommMonoid

section AddCommGroup

variable [AddCommGroup k]

private irreducible_def neg : (SkewMonoidAlgebra k G) → (SkewMonoidAlgebra k G)
  | ⟨a⟩ => ⟨-a⟩

instance neg' : Neg (SkewMonoidAlgebra k G) :=
  ⟨neg⟩

instance sub : Sub (SkewMonoidAlgebra k G) :=
  ⟨fun a b => a + -b⟩

@[simp]
theorem ofFinsupp_neg {a} : (⟨-a⟩ : SkewMonoidAlgebra k G) = -⟨a⟩ :=
  show _ = neg _ by rw [neg_def]

@[simp]
theorem ofFinsupp_sub {a b} : (⟨a - b⟩ : SkewMonoidAlgebra k G) = ⟨a⟩ - ⟨b⟩ := by
  rw [sub_eq_add_neg, ofFinsupp_add, ofFinsupp_neg]; rfl

@[simp]
theorem toFinsupp_neg  (a : SkewMonoidAlgebra k G) : (-a).toFinsupp = -a.toFinsupp := by
  cases a; rw [← ofFinsupp_neg]

@[simp]
theorem toFinsupp_sub (a b : SkewMonoidAlgebra k G) :
    (a - b).toFinsupp = a.toFinsupp - b.toFinsupp := by
  rw [sub_eq_add_neg, ← toFinsupp_neg, ← toFinsupp_add]; rfl

end AddCommGroup

section sum

theorem sum_smul_index {M : Type*} [NonUnitalNonAssocSemiring k] [AddCommMonoid M]
    {g : SkewMonoidAlgebra k G} {b : k} {h : G → k → M} (h0 : ∀ i, h i 0 = 0) :
    (b • g).sum h = g.sum fun i a => h i (b * a) := by
  apply Finsupp.sum_mapRange_index h0
  simp only [smul_eq_mul, mul_zero]

end sum

section Mul

variable [Mul G]

section SMul

variable [SMul G k] [NonAssocSemiring k]

/-- The product of `f g : SkewMonoidAlgebra k G` is the finitely supported function whose value
  at `a` is the sum of `f x * (x • g y)` over all pairs `x, y` such that `x * y = a`.
  (Think of a skew group ring.)-/
instance mul : Mul (SkewMonoidAlgebra k G) :=
  ⟨fun f g => f.sum fun a₁ b₁ => g.sum fun a₂ b₂ => single (a₁ * a₂) (b₁ * (a₁ • b₂))⟩

theorem mul_def {f g : SkewMonoidAlgebra k G} :
    f * g = f.sum fun a₁ b₁ => g.sum fun a₂ b₂ => single (a₁ * a₂) (b₁ * (a₁ • b₂)) :=
  rfl

end SMul

section DistribSMul

instance nonUnitalNonAssocSemiring [NonAssocSemiring k] [DistribSMul G k] :
    NonUnitalNonAssocSemiring (SkewMonoidAlgebra k G) :=
  { SkewMonoidAlgebra.addCommMonoid with
    left_distrib := fun f g h => by
      haveI := Classical.decEq G
      simp only [mul_def]
      refine Eq.trans (congr_arg (sum f) (funext₂ fun a₁ b₁ => sum_add_index ?_ ?_)) ?_ <;>
        simp only [smul_zero, smul_add, mul_add, mul_zero, single_zero, single_add,
          forall_true_iff, sum_add]
    right_distrib := fun f g h => by
      haveI := Classical.decEq G
      simp only [mul_def]
      refine Eq.trans (sum_add_index ?_ ?_) ?_ <;>
        simp only [add_mul, zero_mul, single_zero, single_add, forall_true_iff, sum_zero, sum_add]
    zero_mul := fun f => by
      simp only [mul_def]
      exact sum_zero_index
    mul_zero := fun f => by
      simp only [mul_def]
      exact Eq.trans (congr_arg (sum f) (funext₂ fun a₁ b₁ => sum_zero_index)) sum_zero }

variable [Semiring R] [Semiring k] [SMul G k]

theorem liftNC_mul {g_hom : Type*} [FunLike g_hom G R]
    [MulHomClass g_hom G R] (f : k →+* R) (g : g_hom) (a b : SkewMonoidAlgebra k G)
    (h_comm : ∀ {x y}, y ∈ a.support → (f (y • b x)) * g y = (g y) * (f (b x))) :
    liftNC (f : k →+ R) g (a * b) = liftNC (f : k →+ R) g a * liftNC (f : k →+ R) g b := by
  conv_rhs => rw [← sum_single a, ← sum_single b]
  simp_rw [mul_def, map_sum', liftNC_single, sum_mul, mul_sum]
  refine Finset.sum_congr rfl fun y hy => Finset.sum_congr rfl fun x _hx => ?_
  simp only [AddMonoidHom.coe_coe, map_mul]
  rw [mul_assoc, ← mul_assoc (f (y • b x)), h_comm hy, mul_assoc, mul_assoc]

end DistribSMul

end Mul

/-! #### Semiring structure -/

section Semiring

variable [Semiring k] [Monoid G] [MulSemiringAction G k]

open MulSemiringAction

instance nonUnitalSemiring : NonUnitalSemiring (SkewMonoidAlgebra k G) :=
  { SkewMonoidAlgebra.nonUnitalNonAssocSemiring with
    mul_assoc := fun f g h => by
      simp only [mul_def]
      rw [sum_sum_index]; congr; ext a₁ b₁
      rw [sum_sum_index, sum_sum_index]; congr; ext a₂ b₂
      rw [sum_sum_index, sum_single_index]; congr; ext a₃ b₃
      rw [sum_single_index, mul_assoc, mul_assoc]
      all_goals simp only [smul_add, mul_smul, smul_mul, smul_zero,
        mul_zero, forall_const, single_zero, single_add, forall_true_iff, add_mul,
        mul_add, zero_mul, mul_zero, sum_zero, sum_add] }

instance nonAssocSemiring : NonAssocSemiring (SkewMonoidAlgebra k G) :=
  { SkewMonoidAlgebra.nonUnitalNonAssocSemiring with
    natCast := fun n => single 1 n
    natCast_zero := by simp only [Nat.cast_zero, single_zero]
    natCast_succ := fun _ => by simp only [Nat.cast_add, Nat.cast_one, single_add]; rfl
    one_mul := fun f => by
      simp only [one_def, mul_def]
      rw [sum_single_index]
      simp only [one_mul, one_smul, zero_mul, single_zero, sum_zero,
       sum_single_index, sum_single]
      simp only [one_mul, one_smul, zero_mul, single_zero, sum_zero];
    mul_one := fun f => by
      simp only [one_def, mul_def, mul_one, smul_zero, mul_zero, single_zero, sum_single_index,
        MulDistribMulAction.smul_one]
      rw [sum_single] }

theorem nat_cast_def (n : ℕ) : (n : SkewMonoidAlgebra k G) = single (1 : G) (n : k) := rfl

instance semiring : Semiring (SkewMonoidAlgebra k G) :=
  { SkewMonoidAlgebra.nonUnitalSemiring,
    SkewMonoidAlgebra.nonAssocSemiring with }

variable [Semiring R]

@[simp]
theorem liftNC_one {g_hom : Type*} [FunLike g_hom G R] [OneHomClass g_hom G R] (f : k →+* R)
    (g : g_hom) : liftNC (f : k →+ R) g 1 = 1 := by
  simp only [one_def, liftNC_single, AddMonoidHom.coe_coe, map_one, mul_one]

/-- `liftNC` as a `RingHom`, for when `f x` and `g y` commute -/
def liftNCRingHom (f : k →+* R) (g : G →* R) (h_comm : ∀ {x y}, (f (y • x)) * g y = (g y) * (f x)) :
    SkewMonoidAlgebra k G →+* R :=
  { liftNC (f : k →+ R) g with
    map_one' := liftNC_one _ _
    map_mul' := fun _a _b => liftNC_mul _ _ _ _ fun {_ _} _ => h_comm }

end Semiring

/-! #### Derived instances -/

section DerivedInstances

instance unique [AddCommMonoid k] [Subsingleton k] : Unique (SkewMonoidAlgebra k G) :=
  Function.Injective.unique toFinsupp_injective

instance addCommGroup [AddCommGroup k] : AddCommGroup (SkewMonoidAlgebra k G) :=
  { Function.Injective.addCommGroup toFinsupp toFinsupp_injective (toFinsupp_zero (k := k))
      toFinsupp_add toFinsupp_neg toFinsupp_sub (fun _ _ => toFinsupp_smul _ _)
      (fun _ _ => toFinsupp_smul _ _) with
   toAdd := SkewMonoidAlgebra.add' }

instance nonUnitalNonAssocRing [Ring k] [Monoid G] [MulSemiringAction G k] :
    NonUnitalNonAssocRing (SkewMonoidAlgebra k G) :=
  { SkewMonoidAlgebra.addCommGroup, SkewMonoidAlgebra.nonUnitalNonAssocSemiring with }

instance nonUnitalRing [Ring k] [Monoid G] [MulSemiringAction G k] :
    NonUnitalRing (SkewMonoidAlgebra k G) :=
  { SkewMonoidAlgebra.addCommGroup, SkewMonoidAlgebra.nonUnitalSemiring with }

instance nonAssocRing [Ring k] [Monoid G] [MulSemiringAction G k] :
    NonAssocRing (SkewMonoidAlgebra k G) :=
  { SkewMonoidAlgebra.addCommGroup,
    SkewMonoidAlgebra.nonAssocSemiring with
    intCast := fun z => single 1 (z : k)
    intCast_ofNat := fun n => by simp; rfl
    intCast_negSucc := fun n => by
      simp only [Int.cast_negSucc, Nat.cast_add, Nat.cast_one, neg_add_rev, single_add]
      rw [single]; rw [single];
      simp only [Finsupp.single_neg, ofFinsupp_neg, ofFinsupp_single, ofFinsupp_one, add_right_inj]
      rfl }

theorem int_cast_def [Ring k] [Monoid G] [MulSemiringAction G k] (z : ℤ) :
    (z : SkewMonoidAlgebra k G) = single (1 : G) (z : k) :=
  rfl

instance ring [Ring k] [Monoid G] [MulSemiringAction G k]: Ring (SkewMonoidAlgebra k G) :=
  { SkewMonoidAlgebra.nonAssocRing, SkewMonoidAlgebra.semiring with }

variable {S : Type*}

instance distribSMul {S} [AddCommMonoid k] [DistribSMul S k] :
    DistribSMul S (SkewMonoidAlgebra k G) :=
  { Function.Injective.distribSMul ⟨⟨toFinsupp, toFinsupp_zero⟩, toFinsupp_add⟩ toFinsupp_injective
      toFinsupp_smul with
    toSMulZeroClass := SkewMonoidAlgebra.smulZeroClass }

instance distribMulAction {S} [Monoid S] [AddCommMonoid k]  [DistribMulAction S k] :
    DistribMulAction S (SkewMonoidAlgebra k G) :=
  { Function.Injective.distribMulAction ⟨⟨toFinsupp, toFinsupp_zero (k := k)⟩, toFinsupp_add⟩
      toFinsupp_injective toFinsupp_smul with
    toSMul := smulZeroClass.toSMul }

instance module {S} [Semiring S] [AddCommMonoid k] [Module S k] :
    Module S (SkewMonoidAlgebra k G) :=
  { Function.Injective.module _ ⟨⟨toFinsupp, toFinsupp_zero⟩, toFinsupp_add⟩ toFinsupp_injective
      toFinsupp_smul with
    toDistribMulAction := distribMulAction }

instance faithfulSMul {S} [AddCommMonoid k] [SMulZeroClass S k] [FaithfulSMul S k] [Nonempty G] :
    FaithfulSMul S (SkewMonoidAlgebra k G) where
  eq_of_smul_eq_smul {_s₁ _s₂} h :=
    eq_of_smul_eq_smul fun a : G →₀ k => congr_arg toFinsupp (h ⟨a⟩)

instance isScalarTower {S₁ S₂} [AddCommMonoid k] [SMul S₁ S₂] [SMulZeroClass S₁ k]
    [SMulZeroClass S₂ k] [IsScalarTower S₁ S₂ k] : IsScalarTower S₁ S₂ (SkewMonoidAlgebra k G) :=
  ⟨by
    rintro _ _ ⟨⟩
    simp_rw [← ofFinsupp_smul, smul_assoc]⟩

instance smulCommClass {S₁ S₂} [AddCommMonoid k] [SMulZeroClass S₁ k] [SMulZeroClass S₂ k]
    [SMulCommClass S₁ S₂ k] : SMulCommClass S₁ S₂ (SkewMonoidAlgebra k G) :=
  ⟨by
    rintro m n ⟨f⟩
    simp_rw [← ofFinsupp_smul, smul_comm m n f]⟩

instance isCentralScalar {S} [AddCommMonoid k] [SMulZeroClass S k] [SMulZeroClass Sᵐᵒᵖ k]
    [IsCentralScalar S k] : IsCentralScalar S (SkewMonoidAlgebra k G)  :=
  ⟨by
    rintro _ ⟨⟩
    simp_rw [← ofFinsupp_smul, op_smul_eq_smul]⟩

variable {M α : Type*} [Monoid G] [AddCommMonoid M] [MulAction G α]

/-- Scalar multiplication acting on the domain.

This is not an instance as it would conflict with the action on the range.
See the `instance_diamonds` test for examples of such conflicts. -/
def comapSMul [AddCommMonoid M] : SMul G (SkewMonoidAlgebra M α) where smul g := mapDomain (g • ·)

attribute [local instance] comapSMul

theorem comapSMul_def (g : G) (f : SkewMonoidAlgebra M α) : g • f = mapDomain (g • ·) f := rfl

@[simp]
theorem comapSMul_single (g : G) (a : α) (b : M) : g • single a b = single (g • a) b :=
  mapDomain_single

/-- `comapSMul` is multiplicative -/
def comapMulAction : MulAction G (SkewMonoidAlgebra M α) where
  one_smul f := by rw [comapSMul_def, one_smul_eq_id, mapDomain_id]
  mul_smul g g' f := by
    rw [comapSMul_def, comapSMul_def, comapSMul_def, ← comp_smul_left, mapDomain_comp]

attribute [local instance] comapMulAction
/-- This is not an instance as it conflicts with `SkewMonoidAlgebra.distribMulAction`
  when `G = kˣ`. -/
def comapDistribMulActionSelf [AddCommMonoid k] :
    DistribMulAction G (SkewMonoidAlgebra k G) where
  smul_zero g := by
    ext
    simp only [comapSMul_def, smul_eq_mul, sum_zero_index, toFinsupp_zero, Finsupp.coe_zero,
      Pi.zero_apply]
  smul_add g f f' := by
    ext
    simp only [comapSMul_def, mapDomain_add]


end DerivedInstances

section MiscTheorems

variable [Semiring k]

theorem mul_apply [DecidableEq G] [Monoid G] [MulSemiringAction G k] (f g : SkewMonoidAlgebra k G)
    (x : G) : (f * g) x = f.sum fun a₁ b₁ => g.sum fun a₂ b₂ =>
      if a₁ * a₂ = x then b₁ * a₁ • b₂ else 0 := by
  rw [mul_def, sum_apply]; congr; ext
  rw [sum_apply]; congr; ext
  apply single_apply

open BigOperators

theorem mul_apply_antidiagonal [Monoid G] (f g : SkewMonoidAlgebra k G) [MulSemiringAction G k]
    (x : G) (s : Finset (G × G)) (hs : ∀ {p : G × G}, p ∈ s ↔ p.1 * p.2 = x) :
    (f * g) x = ∑ p in s, f p.1 * p.1 • g p.2:= by
  classical
  let F : G × G → k := fun p => if p.1 * p.2 = x then f p.1 * p.1 • g p.2 else 0
  calc
    (f * g) x = ∑ a₁ in f.support, ∑ a₂ in g.support, F (a₁, a₂) := mul_apply f g x
    _ = ∑ p in f.support ×ˢ g.support, F p := Finset.sum_product.symm
    _ = ∑ p in (f.support ×ˢ g.support).filter fun p : G × G =>
        p.1 * p.2 = x, f p.1 * p.1 • g p.2 := (Finset.sum_filter _ _).symm
    _ = ∑ p in s.filter fun p : G × G => p.1 ∈ f.support ∧ p.2 ∈ g.support, f p.1 * p.1 • g p.2 :=
      (Finset.sum_congr
        (by ext; simp only [Finset.mem_filter, Finset.mem_product, hs, and_comm])
        fun _ _ => rfl)
    _ = ∑ p in s, f p.1 * p.1 • g p.2 :=
      Finset.sum_subset (Finset.filter_subset _ _) fun p hps hp => by
        simp only [Finset.mem_filter, mem_support_iff, not_and, Classical.not_not] at hp ⊢
        by_cases h1 : f p.1 = 0
        · rw [h1, zero_mul]
        · rw [hp hps h1, smul_zero, mul_zero]

@[simp]
theorem single_mul_single [Monoid G] [MulSemiringAction G k] {a₁ a₂ : G} {b₁ b₂ : k} :
    (single a₁ b₁) * (single a₂ b₂) = single (a₁ * a₂) (b₁ * a₁ • b₂) :=
  (sum_single_index (by simp only [zero_mul, single_zero, sum_zero])).trans
    (sum_single_index (by simp only [smul_zero, mul_zero, single_zero]))

/-- Like `mapDomain_zero`, but for the `1` we define in this file -/
theorem mapDomain_one {α : Type*} {β : Type*} {α₂ : Type*} [Semiring β] [Monoid α] [Monoid α₂]
    {F : Type*} [FunLike F α α₂] [MonoidHomClass F α α₂] (f : F) :
    (mapDomain f (1 : SkewMonoidAlgebra β α) : SkewMonoidAlgebra β α₂) =
      (1 : SkewMonoidAlgebra β α₂) := by
  simp_rw [one_def, single, mapDomain_single, map_one]

/- Like `mapDomain_add`, but for the skewed convolutive multiplication we define in this
  file. This theorem holds assuming that `(hf : ∀ (a : α) (x : β), a • x = (f a) • x)`. -/
theorem mapDomain_mul {α : Type*} {β : Type*} {α₂ : Type*} [Semiring β] [Monoid α]
    [MulSemiringAction α β] [Monoid α₂] [MulSemiringAction α₂ β]
    {F : Type*} [FunLike F α α₂] [MulHomClass F α α₂] {f : F} (x y : SkewMonoidAlgebra β α)
    (hf : ∀ (a : α) (x : β), a • x = (f a) • x) :
    mapDomain f (x * y) = mapDomain f x * mapDomain f y := by
  rw [mul_def, mapDomain_sum]
  have : (sum x fun a b => sum y fun a₂ b₂ =>
      mapDomain (↑f) (single (a * a₂) (b * a • b₂))) =
      sum (mapDomain (↑f) x) fun a₁ b₁ =>
        sum (mapDomain (↑f) y) fun a₂ b₂ => single (a₁ * a₂) (b₁ * a₁ • b₂) := by
    simp_rw [mapDomain_single, map_mul]
    rw [sum_mapDomain_index]
    · congr
      ext a b c
      rw [sum_mapDomain_index]
      · congr
        ext a₂ b₂ a₃
        rw [hf]
      · simp only [smul_zero, mul_zero, ofFinsupp_eq_zero, Finsupp.single_zero, forall_const]
      · intros a₂ b₁ b₂
        simp only [smul_add, mul_add]
        rw [single_add]
    · simp only [zero_mul, single_zero, sum_zero, forall_const]
    · simp only [add_mul, single_add, sum_add, forall_const]
  convert this using 4
  rw [mapDomain_sum]

variable (k G)

/-- The embedding of a monoid into its skew monoid algebra. -/
def of [Monoid G] [MulSemiringAction G k] : G →* SkewMonoidAlgebra k G where
  toFun a      := single a 1
  map_one'     := rfl
  map_mul' a b := by simp only [single_mul_single, smul_one, mul_one]

@[simp]
lemma of_apply [inst : Semiring k] [inst : Monoid G]
    [inst : MulSemiringAction G k] (a : G) : (of k G) a = single a 1 := by
  simp only [of, MonoidHom.coe_mk, OneHom.coe_mk]

theorem smul_of [Monoid G] [MulSemiringAction G k] (g : G) (r : k) : r • of k G g = single g r := by
  rw [of_apply, smul_single, smul_eq_mul, mul_one];

theorem of_injective [Monoid G] [MulSemiringAction G k] [Nontrivial k] :
    Function.Injective (of k G) := fun a b h => by
  simp_rw [of_apply, SkewMonoidAlgebra.ext_iff _ _] at h
  simpa using (Finsupp.single_eq_single_iff _ _ _ _).mp h

theorem mul_single_apply_aux [Monoid G] [MulSemiringAction G k] (f : SkewMonoidAlgebra k G) {r : k}
    {x y z : G} (H : ∀ a, a * x = z ↔ a = y) : (f * single x r) z = f y * y • r := by
  classical
  have A : ∀ a₁ b₁, ((single x r).sum fun a₂ b₂ => ite (a₁ * a₂ = z) (b₁ * a₁ • b₂) 0) =
      ite (a₁ * x = z) (b₁ * a₁ • r) 0 :=
    fun a₁ b₁ => sum_single_index <| by simp
  calc
    (HMul.hMul (β := SkewMonoidAlgebra k G) f (single x r)) z =
        sum f fun a b => if a = y then b * y • r else 0 := by
          simp only [mul_apply, A, H, sum_ite_eq']
    _ = if y ∈ f.support then f y * y • r else 0 := (f.support.sum_ite_eq' _ _)
    _ = f y * y • r := by split_ifs with h <;> simp [support] at h <;> simp [h]

theorem mul_single_one_apply [Monoid G] [MulSemiringAction G k] (f : SkewMonoidAlgebra k G) (r : k)
    (x : G) : (HMul.hMul (β := SkewMonoidAlgebra k G) f (single 1 r)) x = f x * x • r :=
  f.mul_single_apply_aux fun a => by rw [mul_one]

theorem mul_single_apply_of_not_exists_mul [Monoid G] [MulSemiringAction G k] (r : k) {g g' : G}
    (x : SkewMonoidAlgebra k G) (h : ¬∃ d, g' = d * g) : (x * single g r) g' = 0 := by
  classical
  simp_rw [mul_apply, sum]
  rw [Finsupp.sum_comm, Finsupp.sum_single_index]
  · apply Finset.sum_eq_zero
    simp_rw [ite_eq_right_iff]
    rintro g'' _ rfl
    exact absurd ⟨_, rfl⟩ h
  · simp_rw [Finsupp.sum, smul_zero, mul_zero, ite_self, Finset.sum_const_zero]

theorem single_mul_apply_aux [Monoid G] [MulSemiringAction G k] (f : SkewMonoidAlgebra k G) {r : k}
    {x y z : G} (H : ∀ a, x * a = y ↔ a = z) : (single x r * f) y = r * x • f z := by
  classical
  have : (f.sum fun a b => ite (x * a = y) (0 * x • b) 0) = 0 := by
    simp only [zero_mul, ite_self,sum_zero]
  calc
    (HMul.hMul (α := SkewMonoidAlgebra k G) (single x r) f) y =
        sum f fun a b => ite (x * a = y) (r * x • b) 0 :=
      (mul_apply _ _ _).trans <| sum_single_index this
    _ = f.sum fun a b => ite (a = z) (r * x • b) 0 := by simp only [H]
    _ = if z ∈ f.support then r * x • f z else 0 := (f.support.sum_ite_eq' _ _)
    _ = _ := by split_ifs with h <;> simp [support] at h <;> simp [h]

theorem single_one_mul_apply [Monoid G] [MulSemiringAction G k] (f : SkewMonoidAlgebra k G) (r : k)
    (x : G) : (single (1 : G) r * f) x = r * f x := by
  rw [single_mul_apply_aux, one_smul]
  simp only [one_mul, forall_const]

theorem single_mul_apply_of_not_exists_mul [Monoid G] [MulSemiringAction G k] (r : k) {g g' : G}
    (x : SkewMonoidAlgebra k G) (h : ¬∃ d, g' = g * d) : (single g r * x) g' = 0 := by
  classical
  rw [mul_apply, sum_single_index]
  · apply Finset.sum_eq_zero
    simp_rw [ite_eq_right_iff]
    rintro g'' _hg'' rfl
    exact absurd ⟨_, rfl⟩ h
  · simp_rw [sum, Finsupp.sum, zero_mul, ite_self, Finset.sum_const_zero]

end MiscTheorems

section AddHom

variable [AddCommMonoid k]

theorem addHom_ext {N : Type*} [AddZeroClass N] ⦃f g : (SkewMonoidAlgebra k G) →+ N⦄
    (H : ∀ x y, f (single x y) = g (single x y)) : f = g := by
  have hf (x : G →₀ k) {f : (SkewMonoidAlgebra k G) →+ N} :
    f (ofFinsupp x) = (AddMonoidHom.comp f
      ⟨⟨ofFinsupp, ofFinsupp_zero⟩, (fun _ _ ↦ ofFinsupp_add)⟩) _ := by rfl
  simp_rw [hf] at H
  convert Finsupp.addHom_ext H
  refine' ⟨fun heq => by rw [heq], fun heq => by ext x; rw [← eta x]; simp_rw [hf, heq]⟩

/-- `single` as an `AddMonoidHom`.

See `lsingle` for the stronger version as a linear map. -/
@[simps]
def singleAddHom (a : G) : k →+ SkewMonoidAlgebra k G where
  toFun := single a
  map_zero' := single_zero a
  map_add' _ := single_add a _

lemma singleAddHom_apply (a : G) (b : k) : ((singleAddHom a) b) = single a b := by
  simp only [singleAddHom, AddMonoidHom.coe_mk, ZeroHom.coe_mk]

@[ext high]
theorem addHom_ext' {N : Type*} [AddZeroClass N] ⦃f g : (SkewMonoidAlgebra k G) →+ N⦄
    (H : ∀ x, f.comp (singleAddHom x) = g.comp (singleAddHom x)) : f = g :=
  addHom_ext fun x => DFunLike.congr_fun (H x)

end AddHom

/-! #### Non-unital, non-associative algebra structure -/
section NonUnitalNonAssocAlgebra

variable [Semiring k] [Monoid G] [MulSemiringAction G k]

theorem liftNC_smul [MulOneClass G] {R : Type*} [Semiring R] (f : k →+* R) (g : G →* R) (c : k)
    (φ : SkewMonoidAlgebra k G) :
    liftNC (f : k →+ R) g (c • φ) = f c * liftNC (f : k →+ R) g φ := by
  suffices this :
    (liftNC (↑f) g).comp (smulAddHom k (SkewMonoidAlgebra k G) c) =
      (AddMonoidHom.mulLeft (f c)).comp (liftNC (↑f) g) by exact DFunLike.congr_fun this φ
  refine addHom_ext' fun a => AddMonoidHom.ext fun b => ?_
  simp only [AddMonoidHom.coe_comp, Function.comp_apply, singleAddHom_apply, smulAddHom_apply,
    smul_single, smul_eq_mul, AddMonoidHom.coe_mulLeft]
  erw [liftNC_single, liftNC_single, AddMonoidHom.coe_coe, map_mul, mul_assoc]

variable (k) (G)

instance isScalarTower_self [IsScalarTower k k k] :
    IsScalarTower k (SkewMonoidAlgebra k G) (SkewMonoidAlgebra k G) :=
  ⟨fun t a b => by
    ext m
    classical
    simp only [smul_eq_mul, mul_apply, coe_smul]
    refine Eq.trans (sum_smul_index' (g := a) (b := t) ?_) ?_ <;>
      simp only [mul_apply, smul_sum, smul_ite, smul_mul_assoc,
        zero_mul, ite_self, imp_true_iff, sum_zero, Pi.smul_apply, smul_zero]⟩

end NonUnitalNonAssocAlgebra

section DistribMulActionHom

variable [Semiring R] {M N : Type*} [AddCommMonoid M] [AddCommMonoid N]
variable [DistribMulAction R M] [DistribMulAction R N]

/-- `single` as a `DistribMulActionSemiHom`.

See also `lsingle` for the version as a linear map. -/
@[simps]
def DistribMulActionHom.single {α : Type*} (a : α) : M →+[R] SkewMonoidAlgebra M α :=
  { singleAddHom a with
    map_smul' := fun k m => by
      simp only [singleAddHom, smul_single, MonoidHom.id_apply] }

theorem distribMulActionHom_ext {α : Type*} {f g : (SkewMonoidAlgebra M α) →+[R] N}
    (h : ∀ (a : α) (m : M), f (single a m) = g (single a m)) : f = g :=
  DistribMulActionHom.toAddMonoidHom_injective <| addHom_ext h

/-- See note [partially-applied ext lemmas]. -/
@[ext]
theorem distribMulActionHom_ext' {α : Type*} {f g : (SkewMonoidAlgebra M α) →+[R] N}
    (h : ∀ a : α, f.comp (DistribMulActionHom.single a) = g.comp (DistribMulActionHom.single a)) :
    f = g :=
  distribMulActionHom_ext fun a => DistribMulActionHom.congr_fun (h a)

/-- Interpret `single a` as a linear map. -/
def lsingle {α : Type*} (a : α) [Module R M] : M →ₗ[R] (SkewMonoidAlgebra M α) :=
  { singleAddHom a with map_smul' := fun _ _ => (smul_single _ _ _).symm }

/-- Two `R`-linear maps from `SkewMonoidAlgebra M α` which agree on each `single x y`
  agree everywhere. -/
theorem lhom_ext {α : Type*} [Module R M] [Module R N] ⦃φ ψ : (SkewMonoidAlgebra M α) →ₗ[R] N⦄
    (h : ∀ a b, φ (single a b) = ψ (single a b)) : φ = ψ :=
  LinearMap.toAddMonoidHom_injective <| addHom_ext h

@[ext high]
theorem lhom_ext' {α : Type*} [Module R M] [Module R N] ⦃φ ψ : (SkewMonoidAlgebra M α) →ₗ[R] N⦄
    (h : ∀ a, φ.comp (lsingle a) = ψ.comp (lsingle a)) : φ = ψ :=
  lhom_ext fun a => LinearMap.congr_fun (h a)

variable {A : Type*} [NonUnitalNonAssocSemiring A]
variable [Semiring k] [Monoid G] [MulSemiringAction G k]

/-- A non_unital `k`-algebra homomorphism from `SkewMonoidAlgebra k G` is uniquely defined by its
values on the functions `single a 1`. -/
theorem nonUnitalAlgHom_ext [DistribMulAction k A] {φ₁ φ₂ : SkewMonoidAlgebra k G →ₙₐ[k] A}
    (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ := by
  apply NonUnitalAlgHom.to_distribMulActionHom_injective
  apply distribMulActionHom_ext'
  intro a
  ext
  simp only [DistribMulActionHom.comp_apply, NonUnitalAlgHom.coe_to_distribMulActionHom,
    DistribMulActionHom.single_toFun, ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe,
    singleAddHom_apply, h]

/-- See note [partially-applied ext lemmas]. -/
@[ext high]
theorem nonUnitalAlgHom_ext' [DistribMulAction k A] {φ₁ φ₂ : SkewMonoidAlgebra k G →ₙₐ[k] A}
    (h : φ₁.toMulHom.comp (of k G).toMulHom = φ₂.toMulHom.comp (of k G).toMulHom) : φ₁ = φ₂ :=
  nonUnitalAlgHom_ext <| DFunLike.congr_fun h

end DistribMulActionHom

/-! #### Algebra structure -/

section Algebra

variable [Monoid G]

section Semiring

variable [Semiring k] [MulSemiringAction G k]


/-- `single 1` as a `RingHom` -/
def singleOneRingHom : k →+* SkewMonoidAlgebra k G :=
  { singleAddHom 1 with
    map_one' := rfl
    map_mul' := fun x y => by
      simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe, singleAddHom_apply,
        single_mul_single, mul_one]
      simp only [one_smul] }

/-- `mapDomain` is an `AddMonoidHom`. -/
@[simps]
def mapDomain.addMonoidHom {M α β : Type*} [AddCommMonoid M] (f : α → β) :
    (SkewMonoidAlgebra M α) →+ SkewMonoidAlgebra M β where
  toFun        := mapDomain f
  map_zero'    := mapDomain_zero
  map_add' _ _ := mapDomain_add

/-- If f : G → H is a multiplicative homomorphism between two monoids and
  `∀ (a : G) (x : k), a • x = (f a) • x`, then `mapDomain f` is a ring homomorphism
  between their skew monoid algebras. -/
def mapDomainRingHom {H F : Type*} [Monoid H] [FunLike F G H] [MonoidHomClass F G H]
    [MulSemiringAction H k] {f : F} (hf : ∀ (a : G) (x : k), a • x = (f a) • x) :
    SkewMonoidAlgebra k G →+* SkewMonoidAlgebra k H :=
  { (mapDomain.addMonoidHom f : SkewMonoidAlgebra k G →+ SkewMonoidAlgebra k H) with
    map_one' := mapDomain_one f
    map_mul' := fun x y => mapDomain_mul x y hf }

/-- If two ring homomorphisms from `SkewMonoidAlgebra k G` are equal on all `single a 1`
and `single 1 b`, then they are equal. -/
theorem ringHom_ext {f g : SkewMonoidAlgebra k G →+* k} (h₁ : ∀ b, f (single 1 b) = g (single 1 b))
    (h_of : ∀ a, f (single a 1) = g (single a 1)) : f = g :=
  have {a : G} {b₁ b₂ : k} : (single 1 b₁) * (single a b₂) = single a (b₁ * b₂) := by
    simp only [single_mul_single, one_mul, one_smul]
  RingHom.coe_addMonoidHom_injective <|
    addHom_ext fun a b => by
      rw [← mul_one b, ← this]
      erw [AddMonoidHom.coe_coe f, AddMonoidHom.coe_coe g]; rw [f.map_mul, g.map_mul, h₁, h_of]

/-- If two ring homomorphisms from `SkewMonoidAlgebra k G` are equal on all `single a 1`
and `single 1 b`, then they are equal.

See note [partially-applied ext lemmas]. -/
@[ext high]
theorem ringHom_ext' {f g : SkewMonoidAlgebra k G →+* k}
    (h₁ : f.comp singleOneRingHom = g.comp singleOneRingHom)
    (h_of : (f : SkewMonoidAlgebra k G →* k).comp (of k G) =
      (g : SkewMonoidAlgebra k G →* k).comp (of k G)) : f = g :=
  ringHom_ext (RingHom.congr_fun h₁) (DFunLike.congr_fun h_of)

end Semiring

section CommSemiring

variable [CommSemiring k]

/-- The instance `Algebra k (SkewMonoidAlgebra A G)` whenever we have `Algebra k A`.
  In particular this provides the instance `Algebra k (SkewMonoidAlgebra k G)`.
  This requires `SmulTrivAction G k A`. -/
instance algebra {A : Type*} [Semiring A] [MulSemiringAction G A] [Algebra k A]
    [SMulCommClass G k A] : Algebra k (SkewMonoidAlgebra A G) :=
  { singleOneRingHom.comp (algebraMap k A) with
    smul_def' := fun r a => by
      simp only [RingHom.coe_comp, comp_apply]
      ext
      simp only [toFinsupp_smul, Finsupp.coe_smul, Pi.smul_apply, Algebra.smul_def,
        singleOneRingHom, singleAddHom, ZeroHom.toFun_eq_coe, ZeroHom.coe_mk, RingHom.coe_mk,
        MonoidHom.coe_mk, OneHom.coe_mk, single_one_mul_apply]
    commutes' := fun r f => by
      simp only [RingHom.coe_comp, comp_apply]
      ext
      simp only [singleOneRingHom, singleAddHom, ZeroHom.toFun_eq_coe, ZeroHom.coe_mk,
        RingHom.coe_mk, MonoidHom.coe_mk, OneHom.coe_mk, single_one_mul_apply, mul_single_one_apply,
        smul_algebraMap, Algebra.commutes]
         }
--SMulCommClass.smul_triv
@[simp]
theorem coe_algebraMap {A : Type*} [Semiring A] [Algebra k A] [MulSemiringAction G A]
    [SMulCommClass G k A] :
    ⇑(@algebraMap k (SkewMonoidAlgebra A G) _ _ _) = single 1 ∘ algebraMap k A :=
  rfl

theorem single_eq_algebraMap_mul_of (a : G) (b : k) [MulSemiringAction G k] [SMulCommClass G k k] :
    single a b = (@algebraMap k (SkewMonoidAlgebra k G) _ _ _) b * of k G a := by
  simp only [coe_algebraMap, Algebra.id.map_eq_id, comp_apply, RingHom.id_apply, of_apply,
    single_mul_single, one_mul, smul_one, mul_one]

theorem single_algebraMap_eq_algebraMap_mul_of {A : Type*} [Semiring A] [Algebra k A] (a : G)
    (b : k) [MulSemiringAction G A] [SMulCommClass G k A] :
    single a (algebraMap k A b) = (algebraMap k (SkewMonoidAlgebra A G)) b * of A G a := by
  simp only [coe_algebraMap, comp_apply, of_apply, single_mul_single, one_mul, smul_one, mul_one]

end CommSemiring

end Algebra

section lift

variable [CommSemiring k] [Monoid G] [Monoid H] [MulSemiringAction G k] [MulSemiringAction H k]
variable {A : Type*} [Semiring A] [Algebra k A] {B : Type*} [Semiring B] [Algebra k B]
variable [MulSemiringAction G A]

/-- `liftNCRingHom` as an `AlgHom`, for when `f` is an `AlgHom` and
  `∀ {x y}, (f (y • x)) * g y = (g y) * (f x)`.-/
def liftNCAlgHom (f : A →ₐ[k] B) (g : G →* B) (h_comm : ∀ {x y}, (f (y • x)) * g y = (g y) * (f x))
    [SMulCommClass G k A] : AlgHom k (SkewMonoidAlgebra A G) B := by
  use liftNCRingHom (f : A →+* B) g h_comm
  simp [liftNCRingHom]

/- Hypothesis needed for `k`-algebra homomorphism from `SkewMonoidAlgebra k G`-/
variable [SMulCommClass G k k]

/-- A `k`-algebra homomorphism from `SkewMonoidAlgebra k G` is uniquely defined by its
values on the functions `single a 1`. -/
theorem algHom_ext ⦃φ₁ φ₂ : AlgHom k (SkewMonoidAlgebra k G) A⦄
    (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ :=
    AlgHom.toLinearMap_injective (lhom_ext' fun a => (LinearMap.ext_ring (h a)))

@[ext high]
theorem algHom_ext' ⦃φ₁ φ₂ : AlgHom k (SkewMonoidAlgebra k G) A⦄
    (h : (φ₁ : SkewMonoidAlgebra k G →* A).comp (of k G) =
      (φ₂ : SkewMonoidAlgebra k G →* A).comp (of k G)) :
    φ₁ = φ₂ :=  algHom_ext <| DFunLike.congr_fun h

variable (k G A)
-- _ (algebraMap k k _)
/-- Any monoid homomorphism `G →* A` can be lifted to an algebra homomorphism
  `SkewMonoidAlgebra k G →ₐ[k] A`. -/
def lift : (G →* A) ≃ (AlgHom k (SkewMonoidAlgebra k G) A) where
  invFun f := (f : SkewMonoidAlgebra k G →* A).comp  (of k G)
  toFun F := by
    apply liftNCAlgHom (Algebra.ofId k A) F
    simp_rw [show ∀ (g : G) (r : k), g • r = r by
        exact fun _ _ ↦ smul_algebraMap _ (algebraMap k k _)]
    exact Algebra.commutes _ _
  left_inv f := by
    ext
    simp [liftNCAlgHom, liftNCRingHom]
  right_inv F := by
    ext
    simp [liftNCAlgHom, liftNCRingHom]

variable {k G A}

theorem lift_apply' (F : G →* A) (f : SkewMonoidAlgebra k G) :
    lift k G A F f = f.sum fun a b => algebraMap k A b * F a := rfl

theorem lift_apply (F : G →* A) (f : SkewMonoidAlgebra k G) :
    lift k G A F f = f.sum fun a b => b • F a := by simp only [lift_apply', Algebra.smul_def]

theorem lift_def (F : G →* A) : ⇑(lift k G A F) =
    liftNC ((algebraMap k A : k →+* A) : k →+ A) F := rfl

@[simp]
theorem lift_symm_apply (F : AlgHom k (SkewMonoidAlgebra k G) A) (x : G) :
    (lift k G A).symm F x = F (single x 1) := rfl

theorem lift_of (F : G →* A) (x) : lift k G A F (of k G x) = F x := by
  rw [of_apply, ← lift_symm_apply, Equiv.symm_apply_apply]

@[simp]
theorem lift_single (F : G →* A) (a b) : lift k G A F (single a b) = b • F a := by
  rw [lift_def, liftNC_single, Algebra.smul_def, AddMonoidHom.coe_coe]

theorem lift_unique' (F : AlgHom k (SkewMonoidAlgebra k G) A) :
    F = lift k G A ((F : SkewMonoidAlgebra k G →* A).comp (of k G)) :=
  ((lift k G A).apply_symm_apply F).symm

/-- Decomposition of a `k`-algebra homomorphism from `SkewMonoidAlgebra k G` by
  its values on `F (single a 1)`. -/
theorem lift_unique (F : AlgHom k (SkewMonoidAlgebra k G) A)
    (f : SkewMonoidAlgebra k G) : F f  = f.sum fun a b => b • F (single a 1) := by
  conv_lhs =>
    rw [lift_unique' F]
    simp [lift_apply]

theorem mapDomain_algebraMap {F : Type*} [FunLike F G H] [MonoidHomClass F G H]
    [MulSemiringAction G A] [MulSemiringAction H A] [SMulCommClass G k A] [SMulCommClass H k A]
    (f : F) (r : k) : mapDomain f (algebraMap k (SkewMonoidAlgebra A G) r) =
      algebraMap k (SkewMonoidAlgebra A H) r := by
  simp only [coe_algebraMap, mapDomain_single, map_one, (· ∘ ·)]

/-- If `f : G → H` is a multiplicative homomorphism between two monoids, then
`mapDomain f` is an algebra homomorphism between their monoid algebras. -/
@[simps!]
def mapDomainAlgHom (k A : Type*) [CommSemiring k] [Semiring A] [Algebra k A] {H F : Type*}
    [Monoid H] [FunLike F G H] [MonoidHomClass F G H] [MulSemiringAction G A]
    [MulSemiringAction H A] [SMulCommClass G k A] [SMulCommClass H k A] {f : F}
    (hf : ∀ (a : G) (x : A), a • x = (f a) • x) :
    SkewMonoidAlgebra A G →ₐ[k] SkewMonoidAlgebra A H :=
  { mapDomainRingHom hf with
    commutes' := mapDomain_algebraMap f }

end lift
section CommSemiring

instance commSemiring [CommSemiring k] [CommMonoid G] [MulSemiringAction G k]
    [SMulCommClass G k k] : CommSemiring (SkewMonoidAlgebra k G) :=
  { SkewMonoidAlgebra.semiring with
    mul_comm := by
      intro a b
      simp only [mul_def]
      have hgk (g : G) (r : k) : g • r = r := by
        rw [← Algebra.id.map_eq_self r, smul_algebraMap g r]
      simp_rw [hgk, sum]
      rw [Finsupp.sum_comm]
      apply Finsupp.sum_congr
      intro x _
      apply Finsupp.sum_congr
      intro y _
      rw [mul_comm, mul_comm (a.toFinsupp y) _] }

end CommSemiring


section equivMapDomain

variable [AddCommMonoid k]

/-- Given `f : G ≃ H`, we can map `l : SkewMonoidAlgebra k G` to
`equivMapDomain f l : SkewMonoidAlgebra k H` (computably) by mapping the support forwards
and the function backwards. -/
def equivMapDomain (f : G ≃ H) (l : SkewMonoidAlgebra k G) : SkewMonoidAlgebra k H where
  toFinsupp := ⟨l.support.map f.toEmbedding, fun a ↦ l (f.symm a),
    by simp only [Finset.mem_map_equiv, mem_support_iff, ne_eq, implies_true]⟩

@[simp]
theorem equivMapDomain_apply (f : G ≃ H) (l : SkewMonoidAlgebra k G) (b : H) :
    equivMapDomain f l b = l (f.symm b) :=
  rfl

lemma toFinsupp_equivMapDomain (f : G ≃ H) (l : SkewMonoidAlgebra k G) :
    (equivMapDomain f l).toFinsupp = Finsupp.equivMapDomain f l.toFinsupp := rfl

theorem equivMapDomain_eq_mapDomain (f : G ≃ H) (l : SkewMonoidAlgebra k G) :
    equivMapDomain f l = mapDomain f l := by
  ext x
  simp only [toFinsupp_equivMapDomain, Finsupp.equivMapDomain_apply, toFinsupp_mapDomain,
    Finsupp.mapDomain_equiv_apply]

theorem equivMapDomain_trans {G' G'' : Type*} (f : G ≃ G') (g : G' ≃ G'')
    (l : SkewMonoidAlgebra k G) :
    equivMapDomain (f.trans g) l = equivMapDomain g (equivMapDomain f l) := by
  ext x; rfl

@[simp]
theorem equivMapDomain_refl (l : SkewMonoidAlgebra k G) : equivMapDomain (Equiv.refl _) l = l := by
  ext x; rfl

@[simp]
theorem equivMapDomain_single (f : G ≃ H) (a : G) (b : k) :
    equivMapDomain f (single a b) = single (f a) b := by
  classical
  ext x
  simp only [Finsupp.single_apply, Equiv.apply_eq_iff_eq_symm_apply, equivMapDomain_apply]

end equivMapDomain

section

variable {A : Type*}

/-- Given `AddCommMonoid A` and `e : G ≃ H`, `domCongr e` is the corresponding `Equiv` between
`SkewMonoidAlgebra A G` and `SkewMonoidAlgebra A H`.-/
@[simps apply]
def domCongr [AddCommMonoid A] (e : G ≃ H) : (SkewMonoidAlgebra A G) ≃+ SkewMonoidAlgebra A H where
  toFun        := equivMapDomain e
  invFun       := equivMapDomain e.symm
  left_inv v   := by simp only [← equivMapDomain_trans, Equiv.self_trans_symm, equivMapDomain_refl]
  right_inv v  := by simp only [← equivMapDomain_trans, Equiv.symm_trans_self, equivMapDomain_refl]
  map_add' a b := by simp only [equivMapDomain_eq_mapDomain, mapDomain_add]

/-- An equivalence of domains induces a linear equivalence of finitely supported functions.

This is `domCongr` as a `LinearEquiv`. -/
def domLCongr [Semiring k] [AddCommMonoid A] [Module k A] (e : G ≃ H) :
    (SkewMonoidAlgebra A G) ≃ₗ[k] SkewMonoidAlgebra A H :=
  (domCongr e : (SkewMonoidAlgebra A G) ≃+ (SkewMonoidAlgebra A H)).toLinearEquiv <| by
    simp only [domCongr_apply]
    intro c x
    simp only [equivMapDomain_eq_mapDomain, mapDomain_smul]

variable (k A)

variable [Monoid G] [Monoid H] [Semiring A] [CommSemiring k] [Algebra k A] [MulSemiringAction G A]
  [MulSemiringAction H A] [SMulCommClass G k A] [SMulCommClass H k A]

/-- If `e : G ≃* H` is a multiplicative equivalence between two monoids and
 ` ∀ (a : G) (x : A), a • x = (e a) • x`, then `SkewMonoidAlgebra.domCongr e` is an
  algebra equivalence between their skew monoid algebras. -/
def domCongrAlg  {e : G ≃* H} (he : ∀ (a : G) (x : A), a • x = (e a) • x) :
    SkewMonoidAlgebra A G ≃ₐ[k] SkewMonoidAlgebra A H :=
  AlgEquiv.ofLinearEquiv
    (domLCongr e : (SkewMonoidAlgebra A G) ≃ₗ[k] (SkewMonoidAlgebra A H))
    ((equivMapDomain_eq_mapDomain _ _).trans <| mapDomain_one e)
    (fun f g => (equivMapDomain_eq_mapDomain _ _).trans <| (mapDomain_mul f g he).trans <|
        congr_arg₂ _ (equivMapDomain_eq_mapDomain _ _).symm (equivMapDomain_eq_mapDomain _ _).symm)

theorem domCongrAlg_toAlgHom {e : G ≃* H} (he : ∀ (a : G) (x : A), a • x = (e a) • x) :
    (domCongrAlg k A he).toAlgHom = mapDomainAlgHom k A he :=
  AlgHom.ext <| fun _ => equivMapDomain_eq_mapDomain _ _

@[simp] theorem domCongrAlg_apply {e : G ≃* H} (he : ∀ (a : G) (x : A), a • x = (e a) • x)
    (f : SkewMonoidAlgebra A G) (h : H) : domCongrAlg k A he f h = f (e.symm h) :=
  rfl

@[simp] theorem domCongr_support [MulSemiringAction G A] [MulSemiringAction H A]
    [SMulCommClass G k A] [SMulCommClass H k A] {e : G ≃* H}
    (he : ∀ (a : G) (x : A), a • x = (e a) • x) (f : SkewMonoidAlgebra A G) :
    (domCongrAlg k A he f).support = f.support.map e :=
  rfl

@[simp] theorem domCongr_single [MulSemiringAction G A] [MulSemiringAction H A]
    [SMulCommClass G k A] [SMulCommClass H k A] {e : G ≃* H}
    (he : ∀ (a : G) (x : A), a • x = (e a) • x) (g : G) (a : A) :
    domCongrAlg k A he (single g a) = single (e g) a := equivMapDomain_single _ _ _

theorem domCongr_refl [MulSemiringAction G A] [SMulCommClass G k A] :
    @domCongrAlg k _ _ A _ _ _ _ _ _ _ _ _ (MulEquiv.refl G) (fun _ _ => rfl) = AlgEquiv.refl := by
  apply AlgEquiv.ext
  intro a
  ext
  simp only [domCongrAlg_apply, MulEquiv.refl_symm, MulEquiv.refl_apply, AlgEquiv.coe_refl, id_eq]

@[simp] theorem domCongr_symm [MulSemiringAction G A] [MulSemiringAction H A]
    [SMulCommClass G k A] [SMulCommClass H k A] {e : G ≃* H}
    (he : ∀ (a : G) (x : A), a • x = (e a) • x) :
    (domCongrAlg k A he).symm = @domCongrAlg k _ _ A _ _ _ _ _ _ _ _ _ e.symm
      (fun a x => by rw [he, MulEquiv.apply_symm_apply]) := rfl

end

section erase

variable {M α : Type*}

/--
`erase a f` is the finitely supported function equal to `f` except at `a` where it is equal to `0`.
If `a` is not in the support of `f` then `erase a f = f`.
-/
def erase [AddCommMonoid M] (a : α) (f : (SkewMonoidAlgebra M α)) : (SkewMonoidAlgebra M α) where
  toFinsupp :=
    ⟨ haveI := Classical.decEq α
      f.support.erase a,
      fun a' ↦ haveI := Classical.decEq α
        if a' = a then 0 else f a', by
      classical
      intro a
      simp only [Finset.mem_erase, mem_support_iff, ne_eq]
      split_ifs with h
      · exact ⟨fun H _ => H.1 h, fun H => (H rfl).elim⟩
      · exact and_iff_right h⟩

@[simp]
theorem toFinsupp_erase [AddCommMonoid M] (f : (SkewMonoidAlgebra M α)) (a : α) :
    (f.erase a).toFinsupp = f.toFinsupp.erase a := rfl

@[simp]
theorem support_erase [AddCommMonoid M] [DecidableEq α] {a : α} {f : SkewMonoidAlgebra M α} :
    (f.erase a).support = f.support.erase a := by
  rcases f with ⟨⟩
  ext
  simp only [support, erase, Finsupp.support_erase, Finset.mem_erase, Finsupp.mem_support_iff]

theorem single_add_erase [AddCommMonoid M] (a : α) (f : SkewMonoidAlgebra M α) :
    single a (f a) + f.erase a = f := by
  ext
  simp only [toFinsupp_add, toFinsupp_erase, Finsupp.single_add_erase]

@[elab_as_elim]
theorem induction [AddCommMonoid M] {p : (SkewMonoidAlgebra M α) → Prop}
    (f : SkewMonoidAlgebra M α) (h0 : p 0)
    (ha : ∀ (a b) (f : SkewMonoidAlgebra M α), a ∉ f.support → b ≠ 0 → p f → p (single a b + f)) :
    p f :=
  suffices ∀ (s) (f : SkewMonoidAlgebra M α), f.support = s → p f from this _ _ rfl
  fun s =>
  Finset.cons_induction_on s (fun f hf => by rwa [support_eq_empty.1 hf]) fun a s has ih f hf => by
    suffices p (single a (f a) + f.erase a) by rwa [single_add_erase] at this
    classical
    apply ha
    · rw [support_erase, Finset.mem_erase]
      exact fun H => H.1 rfl
    · simp only [← mem_support_iff, hf, Finset.mem_cons_self]
    · apply ih _ _
      rw [support_erase, hf, Finset.erase_cons]

variable [Monoid G] [CommSemiring k] {V W : Type*} [AddCommMonoid V] [Module k V]
  [MulSemiringAction G k] [Module (SkewMonoidAlgebra k G) V]
  [IsScalarTower k (SkewMonoidAlgebra k G) V] [AddCommMonoid W] [Module k W]
  [Module (SkewMonoidAlgebra k G) W] [IsScalarTower k (SkewMonoidAlgebra k G) W] (f : V →ₗ[k] W)
  (h : ∀ (g : G) (v : V), f (single g (1 : k) • v) = single g (1 : k) • f v)

/-- Build a `k[G]`-linear map from a `k`-linear map and evidence that it is `G`-equivariant. -/
def equivariantOfLinearOfComm [SMulCommClass G k k] : V →ₗ[SkewMonoidAlgebra k G] W where
  toFun         := f
  map_add'      := map_add _
  map_smul' c v := by
    dsimp only
    refine induction c ?_ ?_
    · simp only [zero_smul, map_zero]
    · intro g r c' _nm _nz w
      dsimp only [RingHom.id_apply] at w ⊢
      simp only [add_smul, f.map_add, w, add_left_inj, single_eq_algebraMap_mul_of, ← smul_smul]
      erw [algebraMap_smul (SkewMonoidAlgebra k G) r, algebraMap_smul (SkewMonoidAlgebra k G) r,
        f.map_smul, h g v, of_apply]

@[simp]
theorem equivariantOfLinearOfComm_apply [SMulCommClass G k k] (v : V) :
    (equivariantOfLinearOfComm f h) v = f v :=
  rfl

end erase

section mul_apply

-- We now prove some additional statements that hold for group algebras.
variable [Semiring k] [Group G] [MulSemiringAction G k]

@[simp]
theorem mul_single_apply (f : SkewMonoidAlgebra k G) (r : k) (x y : G) :
    (f * single x r) y = f (y * x⁻¹) * (y * x⁻¹) • r :=
  f.mul_single_apply_aux fun _a => eq_mul_inv_iff_mul_eq.symm

@[simp]
theorem single_mul_apply (r : k) (x : G) (f : SkewMonoidAlgebra k G) (y : G) :
    (single x r * f) y = r * x • f (x⁻¹ * y) :=
  f.single_mul_apply_aux fun _z => eq_inv_mul_iff_mul_eq.symm

theorem mul_apply_left (f g : SkewMonoidAlgebra k G) (x : G) :
    (f * g) x = f.sum fun a b => b * a • g (a⁻¹ * x) :=
  calc
    (f * g) x = sum f fun a b => (single a b * g) x := by
      rw [← sum_apply, ← sum_mul g f, f.sum_single]
    _ = _ := by simp only [single_mul_apply, Finsupp.sum]

theorem mul_apply_right (f g : SkewMonoidAlgebra k G) (x : G) :
    (f * g) x = g.sum fun a b => f (x * a⁻¹) * (x * a⁻¹) • b :=
  calc
    (f * g) x = sum g fun a b => (f * single a b) x := by
      rw [← sum_apply, ← mul_sum f g, g.sum_single]
    _ = _ := by simp only [mul_single_apply, Finsupp.sum]

end mul_apply

section Submodule

variable [CommSemiring k] [Monoid G] [MulSemiringAction G k]

variable {V : Type*} [AddCommMonoid V]

variable [Module k V] [Module (SkewMonoidAlgebra k G) V] [IsScalarTower k (SkewMonoidAlgebra k G) V]

/-- A submodule over `k` which is stable under scalar multiplication by elements of `G` is a
submodule over `SkewMonoidAlgebra k G`  -/
def submoduleOfSmulMem (W : Submodule k V) (h : ∀ (g : G) (v : V), v ∈ W → of k G g • v ∈ W) :
    Submodule (SkewMonoidAlgebra k G) V where
  carrier   := W
  zero_mem' := W.zero_mem'
  add_mem'  := W.add_mem'
  smul_mem' := by
    intro f v hv
    rw [← sum_single f, sum, Finsupp.sum, Finset.sum_smul]
    simp_rw [← smul_of, smul_assoc]
    exact Submodule.sum_smul_mem W _ fun g _ => h g v hv

end Submodule

end SkewMonoidAlgebra
