/-
Copyright (c) 2024 Lucas Whitfield. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Lucas Whitfield
-/
import Mathlib.Algebra.Lie.Solvable
import Mathlib.Algebra.Lie.Weights.Basic
import Batteries.Tactic.ShowUnused

/-!
# Lie's theorem for Solvable Lie algebras.

This file proves Lie's theorem, the statement that Lie modules of solvable Lie algebras over
algebraically closed fields of characteristic 0 have a common eigenvector for the action of all
elements of the Lie algebra. This result is named `LieModule.exists_forall_lie_eq_smul_of_Solvable`.
-/

-- move this
open LieAlgebra in
instance (R L : Type*) [CommRing R] [LieRing L] [LieAlgebra R L]
  (A : LieIdeal R L) [IsSolvable R L] : IsSolvable R A :=
  A.incl_injective.lieAlgebra_isSolvable

-- move this
lemma IsCoatom.lt_top {α : Type*} [PartialOrder α] [OrderTop α] {a : α} (h : IsCoatom a) : a < ⊤ :=
  h.lt_iff.mpr rfl

-- move this
lemma Submodule.disjoint_span_of_not_mem
    {k V : Type*} [Field k] [AddCommGroup V] [Module k V]
    (A : Submodule k V) (x : V) (hx : x ∉ A) :
    Disjoint A (k ∙ x) := by
  rw [disjoint_iff_inf_le]
  rintro y ⟨(hyA : y ∈ A), (hyx : y ∈ k ∙ x)⟩
  obtain ⟨c, rfl⟩ : ∃ c, c • x = y := by rwa [Submodule.mem_span_singleton] at hyx
  apply A.smul_mem c⁻¹ at hyA
  rcases eq_or_ne c 0 with (rfl | hc) <;> simp_all

-- move this
lemma Submodule.isCompl_span_of_iscoatom_of_not_mem
    {k V : Type*} [Field k] [AddCommGroup V] [Module k V]
    (A : Submodule k V) (x : V) (hA : IsCoatom A) (hx : x ∉ A) :
    IsCompl A (k ∙ x) := by
  refine ⟨disjoint_span_of_not_mem A x hx, ?_⟩ 
  rw [codisjoint_iff_le_sup]
  apply (hA.2 _ _).ge
  rw [left_lt_sup]
  contrapose! hx
  exact hx <| Submodule.mem_span_singleton_self x

-- move this
@[simp]
lemma LinearEquiv.toSpanNonzeroSingleton_symm_apply_smul
    {R M : Type*} [Ring R] [AddCommGroup M] [Module R M] [NoZeroSMulDivisors R M]
    (x : M) (h : x ≠ 0) (y) :
    (toSpanNonzeroSingleton R M x h).symm y • x = y := by
  set e := toSpanNonzeroSingleton R M x h
  show (e (e.symm y) : M) = y
  simp

open LieAlgebra

-- let k be a field (later on assumed to be of characteristic zero)
variable {k : Type*} [Field k]
-- Let L be a Lie algebra over k
variable {L : Type*} [LieRing L] [LieAlgebra k L]
-- and let V be a k-representation of L (later on assumed to be nontrivial / finite-dimensional)
variable {V : Type*} [AddCommGroup V] [Module k V] [LieRingModule L V] [LieModule k L V]

/- We define the Submodules generated by repeatedly applying a linear map `f: V →ₗ[F] V`
to a vector `v`-/

namespace LinearMap.End

variable {R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M]
variable (x : M) (f : Module.End R M)

/-- The submodule generated by `v`, `f v`, `f f v`, ... , `f^[n-1] v`.-/
abbrev iteratedRange (n : ℕ) : Submodule R M :=
  Submodule.span R {(f^a) x | a < n}

lemma iteratedRange_mono {a b : ℕ} (h : a ≤ b) : iteratedRange x f a ≤ iteratedRange x f b :=
  Submodule.span_mono (fun _ ⟨c, hc, hw⟩ ↦ ⟨c, lt_of_lt_of_le hc h, hw⟩)

lemma map_iteratedRange_le (n : ℕ) :
    Submodule.map f (iteratedRange x f n) ≤ iteratedRange x f (n + 1) := by
  rw [Submodule.map_span]
  apply Submodule.span_mono
  suffices ∀ a < n, ∃ b < n + 1, (f ^ b) x = (f ^ (a + 1)) x by simpa [pow_succ']
  aesop

/-- The union of `iteratedRange` for all `n : ℕ`.-/
abbrev iSup_iteratedRange : Submodule R M := ⨆ k : ℕ, iteratedRange x f k

lemma map_iteratedRange_iSup_le_iSup :
    Submodule.map f (iSup_iteratedRange x f) ≤ iSup_iteratedRange x f := by
  rw [Submodule.map_iSup, iSup_le_iff]
  exact fun i ↦ (map_iteratedRange_le x f i).trans (le_iSup _ _)

end LinearMap.End

open LinearMap.End

-- the lie action of `L` on `V`
local notation "π" => LieModule.toEnd k L V

variable (k L) in
class LieThmPkg where
  A : LieIdeal k L
  χ : Module.Dual k A

namespace LieThmPkg

variable [LieThmPkg k L]

open LieThmPkg

abbrev T (w : (A : LieIdeal k L)) : Module.End k V := (π w) - χ w • 1

/- private def W' : Submodule k V := -/
/-   (⨅ w : A, (LinearMap.ker (M := V) (T w))).copy {v | ∀ a : A, ⁅a.val, v⁆ = (χ a) • v} <| by -/
/-   ext v -/
/-   simp only [Subtype.forall, Set.mem_setOf_eq, T, Submodule.iInf_coe, Set.mem_iInter, -/
/-     SetLike.mem_coe, LinearMap.mem_ker, LinearMap.sub_apply, LieModule.toEnd_apply_apply, -/
/-     LinearMap.smul_apply, LinearMap.one_apply, sub_eq_zero] -/

end LieThmPkg

section

variable (A : LieIdeal k L) (χ : Module.Dual k A)

/-- Temporary definition until we clear up `altWeightSpace`.

See also `LieModule.shiftedWeightSpace`. -/
abbrev T (w : A) : Module.End k V := (π w) - χ w • 1

/-- The intersection of all eigenspaces of `V` of weight `χ : A → k`
with respect to the action of all elements in a Lie ideal `A`.

Notes:
- This is a variant of `LieModule.weightSpace`.
  The latter assumes a nilpotent Lie algebra and works with generalized eigenspaces.
- This is a `LieSubmodule`, see `altWeightSpace`. -/
private def altWeightSpace' : Submodule k V :=
  (⨅ w : A, (LinearMap.ker (M := V) (T A χ w))).copy {v | ∀ a : A, ⁅a.val, v⁆ = (χ a) • v} <| by
  ext v
  simp only [Subtype.forall, Set.mem_setOf_eq, T, Submodule.iInf_coe, Set.mem_iInter,
    SetLike.mem_coe, LinearMap.mem_ker, LinearMap.sub_apply, LieModule.toEnd_apply_apply,
    LinearMap.smul_apply, LinearMap.one_apply, sub_eq_zero]

variable (z : L) (w : A) {v : V} (hv : ∀ w : A, ⁅w.val, v⁆ = (χ w) • v)

include hv in
lemma T_apply_succ (n : ℕ) :
    Submodule.map (T A χ w) (iteratedRange v (π z) (n + 1)) ≤ iteratedRange v (π z) n := by
  rw [Submodule.map_span, Submodule.span_le, Set.image_subset_iff]
  simp only [Set.subset_def, Set.mem_setOf_eq, Set.mem_preimage, SetLike.mem_coe,
    forall_exists_index, and_imp, forall_apply_eq_imp_iff₂]
  induction n generalizing w
  · simp only [zero_add, Nat.lt_one_iff, LinearMap.sub_apply, LieModule.toEnd_apply_apply,
      LinearMap.smul_apply, LinearMap.one_apply, forall_eq, pow_zero, hv w, sub_self, zero_mem]
  · next n hn =>
    intro m hm
    obtain (hm | rfl) : m < n + 1 ∨ m = n + 1 := by omega
    · exact iteratedRange_mono v _ (Nat.le_succ n) (hn w m hm)
    let wz : A := ⟨⁅w, z⁆, lie_mem_left k L A w.val z w.prop⟩
    have hwz : wz.val = ⁅w.val, z⁆ := rfl
    have H : ∀ w, ⁅w.val, (π z ^ n) v⁆ = (T A χ w) ((π z ^ n) v) + χ w • ((π z ^ n) v) := by simp
    rw [T, LinearMap.sub_apply, pow_succ', LinearMap.mul_apply, LieModule.toEnd_apply_apply,
      LieModule.toEnd_apply_apply, LinearMap.smul_apply, LinearMap.one_apply, leibniz_lie,
      ← hwz, H, H, lie_add, lie_smul, add_sub_assoc, add_sub_assoc, sub_self, add_zero]
    refine add_mem (add_mem ?_ ?_) ?_
    · exact iteratedRange_mono v _ n.le_succ (hn wz n n.lt_succ_self)
    · exact Submodule.smul_mem _ _ (Submodule.subset_span ⟨n, n.lt_succ_self, rfl⟩)
    · exact map_iteratedRange_le _ _ _ <| Submodule.mem_map_of_mem <| hn w n n.lt_succ_self

include hv in
lemma T_map_iSup_iteratedRange' :
    Submodule.map (T A χ w) (iSup_iteratedRange v (π z)) ≤ iSup_iteratedRange v (π z) := by
  rw [Submodule.map_iSup, iSup_le_iff]
  rintro (_|i)
  · simp [Submodule.map_span]
  · exact (T_apply_succ A χ z w hv i).trans (le_iSup _ _)

include hv in
lemma T_map_iSup_iteratedRange (x : V)
    (hx : x ∈ iSup_iteratedRange v (π z)) : (T A χ w) x ∈ iSup_iteratedRange v (π z) :=
  T_map_iSup_iteratedRange' A χ z w hv <| Submodule.mem_map_of_mem hx

def iSupIR : LieSubmodule k A V where
  toSubmodule := iSup_iteratedRange v (π z)
  lie_mem {w} x hx := by
    simp only [AddSubsemigroup.mem_carrier, AddSubmonoid.mem_toSubsemigroup,
      Submodule.mem_toAddSubmonoid]
    have hx' : ⁅w, x⁆ = (T A χ w) x + χ w • x := by simp
    rw [hx']
    exact add_mem (T_map_iSup_iteratedRange A χ z w hv x hx)
      (Submodule.smul_mem (iSup_iteratedRange v (π z)) _ hx)

include hv in
lemma T_map_iteratedRange_nilpotent (N : ℕ) :
    ∀ x ∈ (iteratedRange v (π z)) N, (T A χ w ^ N) x = 0 := by
  induction' N with N ih
  · simp [iteratedRange]
  · intro x hx
    rw [pow_succ, LinearMap.mul_apply, ih]
    exact T_apply_succ A χ z w hv N <| Submodule.mem_map_of_mem hx

theorem trace_πza_zero (a : A) :
    LinearMap.trace k (iSupIR A χ z hv) (LieModule.toEnd k A _ ⁅z, a⁆) = 0 := by
  set U := iSupIR A χ z hv
  have hzU : ∀ x ∈ U, (π z) x ∈ U :=
    fun _ hx ↦ (map_iteratedRange_iSup_le_iSup v (π z)) (Submodule.mem_map_of_mem hx)
  have hres : LieModule.toEnd k A U ⁅z, a⁆ = ⁅(π z).restrict hzU, LieModule.toEnd k A U a⁆ := by
    ext ⟨x, hx⟩
    simp only [LieModule.toEnd_apply_apply, LieSubmodule.coe_bracket,
      LieIdeal.coe_bracket_of_module, lie_lie, LieHom.lie_apply, Module.End.lie_apply,
      AddSubgroupClass.coe_sub, LinearMap.restrict_coe_apply]
  rw [hres, LieRing.of_associative_ring_bracket, map_sub, LinearMap.trace_mul_comm, sub_self]

variable [Module.Finite k V]

theorem T_res_nilpotent :
    IsNilpotent ((T A χ w).restrict (T_map_iSup_iteratedRange A χ z w hv)) := by
  suffices iSup_iteratedRange v (π z) ≤ Module.End.maxGenEigenspace (T A χ w) 0 by
    rw [Module.Finite.Module.End.isNilpotent_iff_of_finite]
    intro x
    obtain ⟨n, hn⟩ : ∃ n : ℕ, (T A χ w ^ n) x.1 = 0 := by
      simpa [Module.End.mem_maxGenEigenspace, zero_smul, sub_zero] using this x.2
    use n
    rw [LinearMap.pow_restrict, Subtype.ext_iff, LinearMap.restrict_apply, Subtype.coe_mk, hn,
      ZeroMemClass.coe_zero]
  apply iSup_le
  intro i x hx
  simp only [Module.End.mem_maxGenEigenspace, zero_smul, sub_zero]
  use i
  exact T_map_iteratedRange_nilpotent A χ z w hv i x hx

lemma trace_T_res_zero :
    LinearMap.trace k (iSup_iteratedRange v (π z))
      ((T A χ w).restrict (T_map_iSup_iteratedRange A χ z w hv)) = 0 := by
  apply IsNilpotent.eq_zero
  exact LinearMap.isNilpotent_trace_of_isNilpotent (T_res_nilpotent A χ z w hv)

open FiniteDimensional

lemma trace_πza (a : A) :
    LinearMap.trace k (iSupIR A χ z hv) (LieModule.toEnd k A _ ⁅z, a⁆) =
      χ ⁅z, a⁆ • (finrank k (iSupIR A χ z hv)) := by
  rw [← LinearMap.trace_id, ← LinearMap.map_smul, ← sub_eq_zero, ← LinearMap.map_sub]
  exact trace_T_res_zero A χ z ⁅z, a⁆ hv

variable [CharZero k]

include hv in
lemma chi_za_zero (a : A) (hv' : v ≠ 0) :
    χ ⁅z, a⁆ = 0 := by
  have h := trace_πza A χ z hv a
  rw [trace_πza_zero A χ z hv a] at h
  suffices h' : finrank k ↥(iSupIR A χ z hv).toSubmodule ≠ 0 by
    aesop
  have hvU : v ∈ iSupIR A χ z hv := by
    apply Submodule.mem_iSup_of_mem 1
    apply Submodule.subset_span
    use 0, zero_lt_one
    rw [pow_zero, LinearMap.one_apply]
  have iSup_iteratedRange_nontrivial : Nontrivial (iSupIR A χ z hv) :=
    ⟨⟨v,hvU⟩,0, by simp only [ne_eq, Submodule.mk_eq_zero, hv', not_false_eq_true]⟩
  apply Nat.ne_of_lt'
  apply FiniteDimensional.finrank_pos

/--
The intersection of all eigenspaces of `V` of weight `χ : A → k`
with respect to the action of all elements in a Lie ideal `A`.

Note:
- This is a variant of `LieModule.weightSpace`.
  The latter assumes a nilpotent Lie algebra and works with generalized eigenspaces.
-/
def altWeightSpace : LieSubmodule k L V where
  toSubmodule := altWeightSpace' A χ
  lie_mem {z v} hv := by
    intro a
    rcases eq_or_ne v 0 with (rfl | hv')
    · simp only [lie_zero, smul_zero]
    · have aux : ⁅a.val, z⁆ = (-⁅z, a⁆).val := by
        simp only [NegMemClass.coe_neg, LieSubmodule.coe_bracket, lie_skew]
      rw [leibniz_lie, hv a, lie_smul, aux, hv, map_neg,
        chi_za_zero A χ z hv a hv', neg_zero, zero_smul, zero_add]

end

variable [CharZero k] [Module.Finite k V]

open LieModule Submodule in
theorem extend_weight [LieModule.IsTriangularizable k L V]
    (A : LieIdeal k L) (z : L) (hA : IsCoatom A.toSubmodule) (hz : z ∉ A)
    (χ₀ : Module.Dual k A) (v₀ : V)
    (hv₀ : v₀ ≠ 0) (hv₀A : ∀ (x : A), ⁅x, v₀⁆ = χ₀ x • v₀) :
    ∃ (χ : Module.Dual k L) (v : V), v ≠ 0 ∧ ∀ (x : L), ⁅x, v⁆ = χ x • v := by
  let e : (k ∙ z) ≃ₗ[k] k := (LinearEquiv.toSpanNonzeroSingleton k L z <| by aesop).symm
  have he : ∀ x, e x • z = x := by simp [e]
  have hA : IsCompl A.toSubmodule (k ∙ z) := isCompl_span_of_iscoatom_of_not_mem _ _ hA hz
  let π₁ : L →ₗ[k] A       := A.toSubmodule.linearProjOfIsCompl (k ∙ z) hA
  let π₂ : L →ₗ[k] (k ∙ z) := (k ∙ z).linearProjOfIsCompl ↑A hA.symm
  have hπ : ∀ x, (π₁ x : L) + π₂ x = x := linear_proj_add_linearProjOfIsCompl_eq_self hA

  set Vχ₀ := altWeightSpace (V := V) A χ₀
  obtain ⟨c, hc⟩ : ∃ c, (toEnd k _ Vχ₀ z).HasEigenvalue c := by
    have : Nontrivial Vχ₀ := nontrivial_of_ne ⟨v₀, hv₀A⟩ 0 <| Subtype.coe_ne_coe.mp hv₀
    apply Module.End.exists_hasEigenvalue_of_iSup_genEigenspace_eq_top
    exact LieModule.IsTriangularizable.iSup_eq_top z
  obtain ⟨⟨v, hv⟩, hvc⟩ := hc.exists_hasEigenvector

  use (χ₀.comp π₁) + c • (e.comp π₂), v
  constructor
  · simpa only [ne_eq, AddSubmonoid.mk_eq_zero] using hvc.right
  · intro x
    suffices ⁅(π₂ x : L), v⁆ = (c • e (π₂ x)) • v by
      calc ⁅x, v⁆
          = ⁅(π₁ x : L), v⁆ + ⁅(π₂ x : L), v⁆    := by rw [← add_lie, hπ x]
        _ =  χ₀ (π₁ x) • v  + (c • e (π₂ x)) • v := by rw [hv (π₁ x), this]
        _ = _ := by simp [add_smul]
    calc ⁅(π₂ x : L), v⁆
        = e (π₂ x) • ↑(c • ⟨v, hv⟩ : Vχ₀) := by rw [← he, smul_lie, ← hvc.apply_eq_smul]; rfl
      _ = (c • e (π₂ x)) • v              := by rw [smul_assoc, smul_comm]; rfl

theorem LieModule.exists_forall_lie_eq_smul_of_isSolvable_of_finite [Nontrivial V]
    (L : Type*) [LieRing L] [LieAlgebra k L] [LieRingModule L V] [LieModule k L V]
    [IsSolvable k L] [LieModule.IsTriangularizable k L V] [Module.Finite k L] :
    ∃ χ : Module.Dual k L, ∃ v : V, v ≠ 0 ∧ ∀ x : L, ⁅x, v⁆ = χ x • v := by
  obtain H|⟨A, hcoatomA, hAL⟩ := eq_top_or_exists_le_coatom (derivedSeries k L 1).toSubmodule
  · obtain _inst|_inst := subsingleton_or_nontrivial L
    · use 0
      simpa using exists_ne _
    · rw [LieSubmodule.coeSubmodule_eq_top_iff] at H
      exact ((derivedSeries_lt_top_of_solvable k L).ne H).elim
  lift A to LieIdeal k L
  · intros
    exact hAL <| LieSubmodule.lie_mem_lie (LieSubmodule.mem_top _) (LieSubmodule.mem_top _)
  change LieIdeal k L at A -- remove this line when bug in `lift` is fixed (#15865)
  obtain ⟨χ', v, hv, hvA⟩ := exists_forall_lie_eq_smul_of_isSolvable_of_finite A
  obtain ⟨z, -, hz⟩ := SetLike.exists_of_lt (hcoatomA.lt_top)
  exact extend_weight A z hcoatomA hz χ' v hv hvA
termination_by FiniteDimensional.finrank k L
decreasing_by
  simp_wf
  rw [← finrank_top k L]
  apply Submodule.finrank_lt_finrank_of_lt
  exact hcoatomA.lt_top

-- If `L` is solvable, we can find a non-zero eigenvector
theorem LieModule.exists_forall_lie_eq_smul_of_isSolvable [Nontrivial V]
    [IsSolvable k L] [LieModule.IsTriangularizable k L V] :
    ∃ χ : Module.Dual k L, ∃ v : V, v ≠ 0 ∧ ∀ x : L, ⁅x, v⁆ = χ x • v := by
  let imL := (π).range
  have hdim : FiniteDimensional k imL := Submodule.finiteDimensional_of_le (le_top)
  suffices h : ∃ χ : Module.Dual k imL, ∃ v : V, v ≠ 0 ∧ ∀ x : imL, ⁅x, v⁆ = χ x • v by
    rcases h with ⟨χ', v, hv, hχ'⟩
    let toEndo : L →ₗ[k] imL := LinearMap.codRestrict imL.toSubmodule π
        (fun x ↦ LinearMap.mem_range.mpr ⟨x, rfl⟩ : ∀ x : L, π x ∈ imL)
    use χ'.comp toEndo, v, hv
    intro x
    have : ⁅x, v⁆ = ⁅toEndo x, v⁆ := rfl
    rw [LinearMap.comp_apply, this, hχ' (toEndo x)]
  have hsolv : IsSolvable k imL := LieHom.isSolvable_range π
  apply exists_forall_lie_eq_smul_of_isSolvable_of_finite (L := imL)

/- #show_unused LieModule.exists_forall_lie_eq_smul_of_isSolvable -/
