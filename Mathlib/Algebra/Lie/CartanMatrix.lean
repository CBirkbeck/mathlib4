/-
Copyright (c) 2021 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash
-/
import Mathlib.Algebra.Lie.CartanSubalgebra
import Mathlib.Algebra.Lie.Free
import Mathlib.Algebra.Lie.Quotient
import Mathlib.Data.Matrix.Notation

#align_import algebra.lie.cartan_matrix from "leanprover-community/mathlib"@"65ec59902eb17e4ab7da8d7e3d0bd9774d1b8b99"

/-!
# Lie algebras from Cartan matrices

Split semi-simple Lie algebras are uniquely determined by their Cartan matrix. Indeed, if `A` is
an `l × l` Cartan matrix, the corresponding Lie algebra may be obtained as the Lie algebra on
`3l` generators: $H_1, H_2, \ldots H_l, E_1, E_2, \ldots, E_l, F_1, F_2, \ldots, F_l$
subject to the following relations:
$$
\begin{align}
  [H_i, H_j] &= 0\\
  [E_i, F_i] &= H_i\\
  [E_i, F_j] &= 0 \quad\text{if $i \ne j$}\\
  [H_i, E_j] &= A_{ij}E_j\\
  [H_i, F_j] &= -A_{ij}F_j\\
  ad(E_i)^{1 - A_{ij}}(E_j) &= 0 \quad\text{if $i \ne j$}\\
  ad(F_i)^{1 - A_{ij}}(F_j) &= 0 \quad\text{if $i \ne j$}\\
\end{align}
$$

In this file we provide the above construction. It is defined for any square matrix of integers but
the results for non-Cartan matrices should be regarded as junk.

Recall that a Cartan matrix is a square matrix of integers `A` such that:
 * For diagonal values we have: `A i i = 2`.
 * For off-diagonal values (`i ≠ j`) we have: `A i j ∈ {-3, -2, -1, 0}`.
 * `A i j = 0 ↔ A j i = 0`.
 * There exists a diagonal matrix `D` over ℝ such that `D * A * D⁻¹` is symmetric positive definite.

## Alternative construction

This construction is sometimes performed within the free unital associative algebra
`FreeAlgebra R X`, rather than within the free Lie algebra `FreeLieAlgebra R X`, as we do here.
However the difference is illusory since the construction stays inside the Lie subalgebra of
`FreeAlgebra R X` generated by `X`, and this is naturally isomorphic to `FreeLieAlgebra R X`
(though the proof of this seems to require Poincaré–Birkhoff–Witt).

## Definitions of exceptional Lie algebras

This file also contains the Cartan matrices of the exceptional Lie algebras. By using these in the
above construction, it thus provides definitions of the exceptional Lie algebras. These definitions
make sense over any commutative ring. When the ring is ℝ, these are the split real forms of the
exceptional semisimple Lie algebras.

## References

* [N. Bourbaki, *Lie Groups and Lie Algebras, Chapters 4--6*](bourbaki1968) plates V -- IX,
  pages 275--290

* [N. Bourbaki, *Lie Groups and Lie Algebras, Chapters 7--9*](bourbaki1975b) chapter VIII, §4.3

* [J.P. Serre, *Complex Semisimple Lie Algebras*](serre1965) chapter VI, appendix

## Main definitions

  * `Matrix.ToLieAlgebra`
  * `CartanMatrix.E₆`
  * `CartanMatrix.E₇`
  * `CartanMatrix.E₈`
  * `CartanMatrix.F₄`
  * `CartanMatrix.G₂`
  * `LieAlgebra.e₆`
  * `LieAlgebra.e₇`
  * `LieAlgebra.e₈`
  * `LieAlgebra.f₄`
  * `LieAlgebra.g₂`

## Tags

lie algebra, semi-simple, cartan matrix
-/

set_option linter.uppercaseLean3 false

universe u v w

noncomputable section

variable (R : Type u) {B : Type v} [CommRing R] [DecidableEq B] [Fintype B]
variable (A : Matrix B B ℤ)

namespace CartanMatrix

variable (B)

/-- The generators of the free Lie algebra from which we construct the Lie algebra of a Cartan
matrix as a quotient. -/
inductive Generators
  | H : B → Generators
  | E : B → Generators
  | F : B → Generators
#align cartan_matrix.generators CartanMatrix.Generators

instance [Inhabited B] : Inhabited (Generators B) :=
  ⟨Generators.H default⟩

variable {B}

namespace Relations

open Function

local notation "H" => FreeLieAlgebra.of R ∘ Generators.H
local notation "E" => FreeLieAlgebra.of R ∘ Generators.E
local notation "F" => FreeLieAlgebra.of R ∘ Generators.F
local notation "ad" => LieAlgebra.ad R (FreeLieAlgebra R (Generators B))

/-- The terms corresponding to the `⁅H, H⁆`-relations. -/
def HH : B × B → FreeLieAlgebra R (Generators B) :=
  uncurry fun i j => ⁅H i, H j⁆
#align cartan_matrix.relations.HH CartanMatrix.Relations.HH

/-- The terms corresponding to the `⁅E, F⁆`-relations. -/
def EF : B × B → FreeLieAlgebra R (Generators B) :=
  uncurry fun i j => if i = j then ⁅E i, F i⁆ - H i else ⁅E i, F j⁆
#align cartan_matrix.relations.EF CartanMatrix.Relations.EF

/-- The terms corresponding to the `⁅H, E⁆`-relations. -/
def HE : B × B → FreeLieAlgebra R (Generators B) :=
  uncurry fun i j => ⁅H i, E j⁆ - A i j • E j
#align cartan_matrix.relations.HE CartanMatrix.Relations.HE

/-- The terms corresponding to the `⁅H, F⁆`-relations. -/
def HF : B × B → FreeLieAlgebra R (Generators B) :=
  uncurry fun i j => ⁅H i, F j⁆ + A i j • F j
#align cartan_matrix.relations.HF CartanMatrix.Relations.HF

/-- The terms corresponding to the `ad E`-relations.

Note that we use `Int.toNat` so that we can take the power and that we do not bother
restricting to the case `i ≠ j` since these relations are zero anyway. We also defensively
ensure this with `adE_of_eq_eq_zero`. -/
def adE : B × B → FreeLieAlgebra R (Generators B) :=
  uncurry fun i j => ad (E i) ^ (-A i j).toNat <| ⁅E i, E j⁆
#align cartan_matrix.relations.ad_E CartanMatrix.Relations.adE

/-- The terms corresponding to the `ad F`-relations.

See also `adE` docstring. -/
def adF : B × B → FreeLieAlgebra R (Generators B) :=
  uncurry fun i j => ad (F i) ^ (-A i j).toNat <| ⁅F i, F j⁆
#align cartan_matrix.relations.ad_F CartanMatrix.Relations.adF

private theorem adE_of_eq_eq_zero (i : B) : adE R A ⟨i, i⟩ = 0 := by simp [adE]

private theorem adF_of_eq_eq_zero (i : B) : adF R A ⟨i, i⟩ = 0 := by simp [adF]

/-- The union of all the relations as a subset of the free Lie algebra. -/
def toSet : Set (FreeLieAlgebra R (Generators B)) :=
  (Set.range <| HH R) ∪ (Set.range <| EF R) ∪ (Set.range <| HE R A) ∪ (Set.range <| HF R A) ∪
      (Set.range <| adE R A) ∪
    (Set.range <| adF R A)
#align cartan_matrix.relations.to_set CartanMatrix.Relations.toSet

/-- The ideal of the free Lie algebra generated by the relations. -/
def toIdeal : LieIdeal R (FreeLieAlgebra R (Generators B)) :=
  LieSubmodule.lieSpan R _ <| toSet R A
#align cartan_matrix.relations.to_ideal CartanMatrix.Relations.toIdeal

end Relations

end CartanMatrix

/-- The Lie algebra corresponding to a Cartan matrix.

Note that it is defined for any matrix of integers. Its value for non-Cartan matrices should be
regarded as junk. -/
def Matrix.ToLieAlgebra :=
  FreeLieAlgebra R _ ⧸ CartanMatrix.Relations.toIdeal R A
#align matrix.to_lie_algebra Matrix.ToLieAlgebra

namespace Matrix.ToLieAlgebra

-- Porting note: the following were derived automatically in mathlib3.
instance instLieRing : LieRing (Matrix.ToLieAlgebra R A) :=
  inferInstanceAs (LieRing (FreeLieAlgebra R _ ⧸ CartanMatrix.Relations.toIdeal R A))
#align matrix.to_lie_algebra.lie_ring Matrix.ToLieAlgebra.instLieRing

instance instInhabited : Inhabited (Matrix.ToLieAlgebra R A) :=
  inferInstanceAs (Inhabited (FreeLieAlgebra R _ ⧸ CartanMatrix.Relations.toIdeal R A))
#align matrix.to_lie_algebra.inhabited Matrix.ToLieAlgebra.instInhabited

instance instLieAlgebra : LieAlgebra R (Matrix.ToLieAlgebra R A) :=
  inferInstanceAs (LieAlgebra R (FreeLieAlgebra R _ ⧸ CartanMatrix.Relations.toIdeal R A))
#align matrix.to_lie_algebra.lie_algebra Matrix.ToLieAlgebra.instLieAlgebra

instance instLieRingModule :
    LieRingModule (FreeLieAlgebra R (CartanMatrix.Generators B)) (ToLieAlgebra R A) :=
  inferInstanceAs (LieRingModule (FreeLieAlgebra R (CartanMatrix.Generators B))
    (FreeLieAlgebra R _ ⧸ CartanMatrix.Relations.toIdeal R A))

section
open CartanMatrix

def q : FreeLieAlgebra R (Generators B) →ₗ⁅R,FreeLieAlgebra R (Generators B)⁆
  A.ToLieAlgebra R := LieSubmodule.Quotient.mk' (Relations.toIdeal R A)

lemma lie_q_q : ∀ x y, ⁅q R A x, q R A y⁆ = q R A ⁅x, y⁆ :=
  LieSubmodule.Quotient.mk_bracket

lemma q_apply_eq_zero (x) : q R A x = 0 ↔ x ∈ Relations.toIdeal R A :=
  LieSubmodule.Quotient.mk_eq_zero' _

def E : B → Matrix.ToLieAlgebra R A := q R A ∘ FreeLieAlgebra.of R ∘ Generators.E

def F : B → Matrix.ToLieAlgebra R A := q R A ∘ FreeLieAlgebra.of R ∘ Generators.F

def H : B → Matrix.ToLieAlgebra R A := q R A ∘ FreeLieAlgebra.of R ∘ Generators.H

@[simp]
lemma lie_H_H (i j : B) : ⁅H R A i, H R A j⁆ = 0 := by
  simp only [H, Function.comp_apply, lie_q_q, q_apply_eq_zero]
  apply LieSubmodule.subset_lieSpan
  simp only [Relations.toSet, Set.union_assoc]
  left
  simp only [Relations.HH, Function.comp_apply, Set.mem_range, Prod.exists,
    Function.uncurry_apply_pair, exists_apply_eq_apply2]

@[simp]
lemma lie_H_E (i j : B) : ⁅H R A i, E R A j⁆ = A i j • E R A j := by
  simp only [H, E, Function.comp_apply]
  have hq : ∀ x, q R A (A i j • x) = A i j • q R A x :=
    fun x ↦ (q R A).toAddMonoidHom.map_zsmul x (A i j)
  rw [← sub_eq_zero, ← hq, lie_q_q, ← (q R A).map_sub, q_apply_eq_zero]
  apply LieSubmodule.subset_lieSpan
  simp only [CartanMatrix.Relations.toSet, Set.union_assoc]
  right; right; left
  simp only [CartanMatrix.Relations.HE, Function.comp_apply, Set.mem_range, Prod.exists,
    Function.uncurry_apply_pair, exists_apply_eq_apply2]

@[simp]
lemma lie_H_F (i j : B) : ⁅H R A i, F R A j⁆ = -A i j • F R A j := by
  simp only [H, F, Function.comp_apply]
  have hq : ∀ x, q R A (A i j • x) = A i j • q R A x :=
    fun x ↦ (q R A).toAddMonoidHom.map_zsmul x (A i j)
  rw [← sub_eq_zero, neg_smul, sub_neg_eq_add, ← hq, lie_q_q, ← (q R A).map_add, q_apply_eq_zero]
  apply LieSubmodule.subset_lieSpan
  simp only [CartanMatrix.Relations.toSet]
  left; left; right
  simp only [CartanMatrix.Relations.HF, Function.comp_apply, Set.mem_range, Prod.exists,
    Function.uncurry_apply_pair, exists_apply_eq_apply2]

end

def cartanSubalgebra : LieSubalgebra R (Matrix.ToLieAlgebra R A) :=
  LieSubalgebra.lieSpan _ _ <| Set.range (Matrix.ToLieAlgebra.H R A)

namespace cartanSubalgebra

open LieSubalgebra in
instance : IsLieAbelian (cartanSubalgebra R A) where
  trivial := by
    rintro ⟨x, hx⟩ ⟨y, hy⟩
    ext
    dsimp
    revert y
    refine lieSpan_induction _ hx ?_ (fun y _ ↦ zero_lie y) ?_ ?_ ?_
      (p := fun x ↦ ∀ y ∈ cartanSubalgebra R A, ⁅x, y⁆ = 0)
    all_goals dsimp
    · simp only [Set.mem_range, Function.comp_apply, forall_exists_index, forall_apply_eq_imp_iff]
      intro a y hy
      refine lieSpan_induction _ hy ?_ (lie_zero _) ?_ ?_ ?_ (p := fun y ↦ ⁅H R A a, y⁆ = 0)
      · simp only [Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff, lie_H_H,
          implies_true]
      · simp (config := { contextual := true }) only [lie_smul, smul_zero, implies_true]
      · simp (config := { contextual := true }) only [lie_add, zero_add, implies_true]
      · dsimp
        intro x y ihx ihy
        rw [← lie_skew, lie_lie, ← lie_skew y, ihy, neg_zero, lie_zero,
            ← lie_skew x, ihx, neg_zero, lie_zero, sub_zero, neg_zero]
    · simp (config := { contextual := true }) only [smul_lie, smul_zero, implies_true]
    · simp (config := { contextual := true }) only [add_lie, add_zero, implies_true]
    · simp (config := { contextual := true }) only [lie_lie, zero_mem, sub_self, implies_true]

open LieSubalgebra in
instance instCartanSubalgebra : IsCartanSubalgebra (cartanSubalgebra R A) where
  nilpotent := inferInstance
  self_normalizing := by
    apply le_antisymm _ (le_normalizer _)
    intro x hx
    rw [mem_normalizer_iff] at hx
    -- TODO: we will need to assume that `A` is a Cartan matrix
    sorry

end cartanSubalgebra

end Matrix.ToLieAlgebra

namespace CartanMatrix

/-- The Cartan matrix of type e₆. See [bourbaki1968] plate V, page 277.

The corresponding Dynkin diagram is:
```
            o
            |
o --- o --- o --- o --- o
```
-/
def E₆ : Matrix (Fin 6) (Fin 6) ℤ :=
  !![2, 0, -1, 0, 0, 0;
    0, 2, 0, -1, 0, 0;
    -1, 0, 2, -1, 0, 0;
    0, -1, -1, 2, -1, 0;
    0, 0, 0, -1, 2, -1;
    0, 0, 0, 0, -1, 2]
#align cartan_matrix.E₆ CartanMatrix.E₆

/-- The Cartan matrix of type e₇. See [bourbaki1968] plate VI, page 281.

The corresponding Dynkin diagram is:
```
            o
            |
o --- o --- o --- o --- o --- o
```
-/
def E₇ : Matrix (Fin 7) (Fin 7) ℤ :=
  !![2, 0, -1, 0, 0, 0, 0;
    0, 2, 0, -1, 0, 0, 0;
    -1, 0, 2, -1, 0, 0, 0;
    0, -1, -1, 2, -1, 0, 0;
    0, 0, 0, -1, 2, -1, 0;
    0, 0, 0, 0, -1, 2, -1;
    0, 0, 0, 0, 0, -1, 2]
#align cartan_matrix.E₇ CartanMatrix.E₇

/-- The Cartan matrix of type e₈. See [bourbaki1968] plate VII, page 285.

The corresponding Dynkin diagram is:
```
            o
            |
o --- o --- o --- o --- o --- o --- o
```
-/
def E₈ : Matrix (Fin 8) (Fin 8) ℤ :=
  !![2, 0, -1, 0, 0, 0, 0, 0;
    0, 2, 0, -1, 0, 0, 0, 0;
    -1, 0, 2, -1, 0, 0, 0, 0;
    0, -1, -1, 2, -1, 0, 0, 0;
    0, 0, 0, -1, 2, -1, 0, 0;
    0, 0, 0, 0, -1, 2, -1, 0;
    0, 0, 0, 0, 0, -1, 2, -1;
    0, 0, 0, 0, 0, 0, -1, 2]
#align cartan_matrix.E₈ CartanMatrix.E₈

/-- The Cartan matrix of type f₄. See [bourbaki1968] plate VIII, page 288.

The corresponding Dynkin diagram is:
```
o --- o =>= o --- o
```
-/
def F₄ : Matrix (Fin 4) (Fin 4) ℤ :=
  !![2, -1, 0, 0; -1, 2, -2, 0; 0, -1, 2, -1; 0, 0, -1, 2]
#align cartan_matrix.F₄ CartanMatrix.F₄

/-- The Cartan matrix of type g₂. See [bourbaki1968] plate IX, page 290.

The corresponding Dynkin diagram is:
```
o ≡>≡ o
```
Actually we are using the transpose of Bourbaki's matrix. This is to make this matrix consistent
with `CartanMatrix.F₄`, in the sense that all non-zero values below the diagonal are -1. -/
def G₂ : Matrix (Fin 2) (Fin 2) ℤ :=
  !![2, -3; -1, 2]
#align cartan_matrix.G₂ CartanMatrix.G₂

end CartanMatrix

namespace LieAlgebra

/-- The exceptional split Lie algebra of type e₆. -/
abbrev e₆ :=
  CartanMatrix.E₆.ToLieAlgebra R
#align lie_algebra.e₆ LieAlgebra.e₆

/-- The exceptional split Lie algebra of type e₇. -/
abbrev e₇ :=
  CartanMatrix.E₇.ToLieAlgebra R
#align lie_algebra.e₇ LieAlgebra.e₇

/-- The exceptional split Lie algebra of type e₈. -/
abbrev e₈ :=
  CartanMatrix.E₈.ToLieAlgebra R
#align lie_algebra.e₈ LieAlgebra.e₈

/-- The exceptional split Lie algebra of type f₄. -/
abbrev f₄ :=
  CartanMatrix.F₄.ToLieAlgebra R
#align lie_algebra.f₄ LieAlgebra.f₄

/-- The exceptional split Lie algebra of type g₂. -/
abbrev g₂ :=
  CartanMatrix.G₂.ToLieAlgebra R
#align lie_algebra.g₂ LieAlgebra.g₂

end LieAlgebra
