/-
Copyright (c) 2023 Christopher Hoskin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christopher Hoskin
-/

import Mathlib.Logic.Equiv.Defs
import Mathlib.Order.Directed
import Mathlib.Order.UpperLower.Basic
import Mathlib.Topology.Basic
import Mathlib.Topology.Order
import Mathlib.Topology.ContinuousFunction.Basic

/-!
# Scott topology
This file introduces the Scott topology on a preorder.
## Main definitions
- `preserve_lub_on_directed` - a function between preorders which preserves least upper bounds.
- `with_scott_topology.topological_space` - the Scott topology is defined as the join of the
  topology of upper sets and the topological space where a set `u` is open if, when the least upper
  bound of a directed set `d` lies in `u` then there is a tail of `d` which is a subset of `u`..
## Main statements
- `with_scott_topology.is_open_is_upper` - Scott open sets are upper
- `with_scott_topology.is_closed_is_lower` - Scott closed sets are lower
- `with_scott_topology.continuous_monotone` - Scott continuous functions are monotone.
- `preserve_lub_on_directed_iff_scott_continuity` - a function preserves least upper bounds of
  directed sets if and only if it is Scott continuous
- `with_scott_topology.t0_space` - the Scott topology on a partial order is T₀
## Implementation notes
A type synonym `with_scott_topology` is introduced and for a preorder `α`, `with_scott_topology α`
is made an instance of `topological_space` by the topology generated by the complements of the
closed intervals to infinity.
A class `Scott` is defined in `topology.omega_complete_partial_order` and made an instance of a
topological space by defining the open sets to be those which have characteristic functions which
are monotone and preserve limits of countable chains. Whilst this definition of the Scott topology
coincides with the one given here in some special cases, in general they are not the same
[Domain Theory, 2.2.4][abramsky_gabbay_maibaum_1994].
## References
* [Gierz et al, *A Compendium of Continuous Lattices*][GierzEtAl1980]
* [Abramsky and Jung, *Domain Theory*][abramsky_gabbay_maibaum_1994]
## Tags
Scott topology, preorder
-/

variable (α β : Type _)

open Set

section preorder

variable {α} {β}

variable [Preorder α] [Preorder β]

lemma is_upper_set_iff_forall_le  {s : Set α} : IsUpperSet s ↔ ∀ ⦃a b : α⦄, a ≤ b →
  a ∈ s → b ∈ s := Iff.rfl

/--
The set of upper sets forms a topology
-/
def upper_set_topology : TopologicalSpace α :=
{ IsOpen := IsUpperSet,
  isOpen_univ := isUpperSet_univ,
  isOpen_inter := fun _ _ => IsUpperSet.inter,
  isOpen_unionₛ := fun _ h => isUpperSet_unionₛ h, }

lemma pair_is_chain (a b : α) (hab: a ≤ b) : IsChain (· ≤ ·) ({a, b} : Set α) := by
  apply IsChain.insert (Set.Subsingleton.isChain subsingleton_singleton)
  intros c h₁ h₂
  rw [mem_singleton_iff] at h₁
  rw [h₁]
  exact Or.inl hab

lemma directed_on_pair (a b : α) (hab: a ≤ b) : DirectedOn (· ≤ ·) ({a, b} : Set α) :=
  (pair_is_chain _ _ hab).directedOn

/--
A function which preserves lub on directed sets
-/
def preserve_lub_on_directed (f : α → β) := ∀ (d : Set α) (a : α), d.Nonempty → DirectedOn (· ≤ ·)
  d → IsLUB d a → IsLUB (f '' d) (f a)

lemma preserve_lub_on_directed_montotone (f : α → β) (h: preserve_lub_on_directed f): Monotone f := by
  intro a b hab
  rw [preserve_lub_on_directed] at h
  let d := ({a, b} : Set α)
  have e1: IsLUB (f '' d) (f b) := by
    apply h
    . exact insert_nonempty a {b}
    . exact directed_on_pair a b hab
    . rw [IsLUB]
      constructor
      . simp only [upperBounds_insert, upperBounds_singleton, mem_inter_iff, mem_Ici, le_refl,
          and_true]
        exact hab
      . simp only [upperBounds_insert, upperBounds_singleton]
        rw [(inter_eq_self_of_subset_right (Ici_subset_Ici.mpr hab))]
        exact fun {x : α} => mem_Ici.mpr
  rw [IsLUB, IsLeast] at e1
  apply e1.1
  rw [mem_image]
  use a
  simp only [mem_insert_iff, eq_self_iff_true, true_or, and_self]

end preorder

/--
Type synonym for a preorder equipped with the Scott topology
-/
def with_scott_topology := α

variable {α β}

namespace with_scott_topology

/-- `to_scott` is the identity function to the `with_scott_topology` of a type.  -/
@[match_pattern] def to_scott : α ≃ with_scott_topology α := Equiv.refl _

/-- `of_scott` is the identity function from the `with_scott_topology` of a type.  -/
@[match_pattern] def of_scott : with_scott_topology α ≃ α := Equiv.refl _

@[simp] lemma to_scott_symm_eq : (@to_scott α).symm = of_scott := rfl
@[simp] lemma of_scott_symm_eq : (@of_scott α).symm = to_scott := rfl
@[simp] lemma to_scott_of_scott (a : with_scott_topology α) : to_scott (of_scott a) = a := rfl
@[simp] lemma of_scott_to_scott (a : α) : of_scott (to_scott a) = a := rfl
@[simp] lemma to_scott_inj {a b : α} : to_scott a = to_scott b ↔ a = b := Iff.rfl
@[simp] lemma of_scott_inj {a b : with_scott_topology α} : of_scott a = of_scott b ↔ a = b :=
Iff.rfl

/-- A recursor for `with_scott_topology`. Use as `induction x using with_scott_topology.rec`. -/
protected def rec {β : with_scott_topology α → Sort _}
  (h : ∀ a, β (to_scott a)) : ∀ a, β a := fun a => h (of_scott a)


instance [Nonempty α] : Nonempty (with_scott_topology α) := ‹Nonempty α›
instance [Inhabited α] : Inhabited (with_scott_topology α) := ‹Inhabited α›

end with_scott_topology

section preorder

variable [Preorder α] [Preorder β]

instance : Preorder (with_scott_topology α) := ‹Preorder α›

instance : TopologicalSpace (with_scott_topology α) :=
  (upper_set_topology ⊔
    { IsOpen := fun u => ∀ (d : Set α) (a : α), d.Nonempty → DirectedOn (· ≤ ·) d → IsLUB d a →
      a ∈ u → ∃ b ∈ d, (Ici b) ∩ d ⊆ u,
      isOpen_univ := by
        intros d _ hd₁ _ _ _
        cases' hd₁ with b hb
        use b
        constructor
        . exact hb
        . exact (Ici b ∩ d).subset_univ,
      isOpen_inter := by
        intros s t
        intros hs
        intro ht
        intros d a hd₁ hd₂ hd₃ ha
        obtain ⟨ b₁, ⟨hb₁_w, hb₁_h ⟩ ⟩  := hs d a hd₁ hd₂ hd₃ ha.1
        obtain ⟨ b₂, ⟨hb₂_w, hb₂_h ⟩ ⟩  := ht d a hd₁ hd₂ hd₃ ha.2
        rw [DirectedOn] at hd₂
        obtain ⟨ c, ⟨hc_w, hc_h ⟩ ⟩ := hd₂ b₁ hb₁_w b₂ hb₂_w
        use c
        constructor
        . exact hc_w
        . calc
            Ici c ∩ d ⊆ (Ici b₁ ∩ Ici b₂) ∩ d := by
            { apply inter_subset_inter_left d
              apply subset_inter (Ici_subset_Ici.mpr hc_h.1) (Ici_subset_Ici.mpr hc_h.2) }
            _ = ((Ici b₁)∩d) ∩ ((Ici b₂)∩d) := by rw [inter_inter_distrib_right]
            _ ⊆ s ∩ t := by { exact inter_subset_inter hb₁_h hb₂_h }
      isOpen_unionₛ := by
        intros s h
        intros d a hd₁ hd₂ hd₃ ha
        rw [mem_unionₛ] at ha
        obtain ⟨s₀, ⟨hs₀_w, hs₀_h⟩⟩ := ha
        obtain ⟨b, ⟨hb_w, hb_h⟩⟩ := h s₀ hs₀_w d a hd₁ hd₂ hd₃ hs₀_h
        use b
        constructor
        . exact hb_w
        . exact Set.subset_unionₛ_of_subset s s₀ hb_h hs₀_w
      })

namespace with_scott_topology

lemma is_open_eq_upper_and_lub_mem_implies_tail_subset (u : Set (with_scott_topology α)) : IsOpen u
= (IsUpperSet u ∧ ∀ (d : Set α) (a : α), d.Nonempty → DirectedOn (· ≤ ·) d → IsLUB d a → a ∈ u
  → ∃ b ∈ d, (Ici b) ∩ d ⊆ u) := rfl

lemma is_open_iff_upper_and_lub_mem_implies_inter_nonempty (u : Set (with_scott_topology α)) :
IsOpen u ↔ (IsUpperSet u ∧ ∀ (d : Set α) (a : α), d.Nonempty → DirectedOn (· ≤ ·) d → IsLUB d a →
a ∈ u → (d ∩ u).Nonempty) := by
  rw [is_open_eq_upper_and_lub_mem_implies_tail_subset]
  constructor
  . refine' And.imp_right _
    intros h d a d₁ d₂ d₃ ha
    obtain ⟨b, ⟨h_1_w, h_1_h⟩⟩ := h d a d₁ d₂ d₃ ha
    rw [inter_nonempty_iff_exists_left]
    use b
    constructor
    . exact h_1_w
    . apply mem_of_subset_of_mem h_1_h
      rw [mem_inter_iff]
      constructor
      . exact left_mem_Ici
      . exact h_1_w
  . intros h
    constructor
    . exact h.1
    . intros d a d₁ d₂ d₃ ha
      have e1 : (d ∩ u).Nonempty := by exact h.2 d a d₁ d₂ d₃ ha
      rw [inter_nonempty_iff_exists_left] at e1
      obtain ⟨b, ⟨e1_h_w, e1_h_h⟩⟩ := e1
      use b
      constructor
      . exact e1_h_w
      . have e2 : Ici b ⊆ u := by exact isUpperSet_iff_Ici_subset.mp h.1 e1_h_h
        apply Subset.trans _ e2
        apply inter_subset_left

lemma is_closed_eq_lower_and_subset_implies_lub_mem (s : Set (with_scott_topology α)) : IsClosed s
  = (IsLowerSet s ∧
  ∀ (d : Set α) (a : α), d.Nonempty → DirectedOn (· ≤ ·) d → IsLUB d a → d ⊆ s → a ∈ s ) := by
  rw [← isOpen_compl_iff, is_open_iff_upper_and_lub_mem_implies_inter_nonempty,
    isLowerSet_compl.symm, compl_compl]
  refine' let_value_eq (And (IsLowerSet s)) _
  rw [eq_iff_iff]
  constructor
  . intros h d a d₁ d₂ d₃ d₄
    by_contra h'
    rw [← mem_compl_iff] at h'
    have c1: (d ∩ sᶜ).Nonempty := by exact h d a d₁ d₂ d₃ h'
    have c2: (d ∩ sᶜ) =  ∅ := by
      rw [← subset_empty_iff, ← inter_compl_self s]
      exact inter_subset_inter_left _ d₄
    rw [c2] at c1
    simp only [Set.not_nonempty_empty] at c1
  . intros h d a d₁ d₂ d₃ d₄
    by_contra h'
    rw [inter_compl_nonempty_iff, not_not] at h'
    have c1: a ∈ s := by exact h d a d₁ d₂ d₃ h'
    contradiction


lemma is_open_is_upper {s : Set (with_scott_topology α)} : IsOpen s → IsUpperSet s := by
  intros h
  rw [is_open_eq_upper_and_lub_mem_implies_tail_subset] at h
  exact h.1

lemma is_closed_is_lower {s : Set (with_scott_topology α)} : IsClosed s → IsLowerSet s := by
  intro h
  rw [is_closed_eq_lower_and_subset_implies_lub_mem] at h
  exact h.1

/--
The closure of a singleton `{a}` in the Scott topology is the right-closed left-infinite interval
(-∞,a].
-/
@[simp] lemma closure_singleton (a : with_scott_topology α) : closure {a} = Iic a := by
  rw [← LowerSet.coe_Iic, ← lowerClosure_singleton]
  refine' subset_antisymm _ _
  . apply closure_minimal subset_lowerClosure
    rw [is_closed_eq_lower_and_subset_implies_lub_mem]
    constructor
    . exact (lowerClosure {a}).lower
    . rw [lowerClosure_singleton]
      intros d b _ _ d₃ d₄
      rw [LowerSet.coe_Iic, mem_Iic]
      exact (isLUB_le_iff d₃).mpr d₄
  . apply lowerClosure_min subset_closure (is_closed_is_lower _)
    apply isClosed_closure

lemma continuous_monotone {f : with_scott_topology α → with_scott_topology β}
  (hf : Continuous f) : Monotone f := by
  rw [Monotone]
  intros a b hab
  let u := (Iic (f b))ᶜ
  by_contra h
  have u2 : a ∈ (f⁻¹'  u) := h
  have s1 : IsOpen u
  { rw [isOpen_compl_iff, ← closure_singleton]
    exact isClosed_closure }
  have s2 :  IsOpen (f⁻¹'  u) := IsOpen.preimage hf s1
  have u3 : b ∈ (f⁻¹'  u) := is_upper_set_iff_forall_le.mp s2.1 hab u2
  have c1 : f b ∈ (Iic (f b))ᶜ := by
    simp only [mem_compl_iff, mem_preimage, mem_Iic, le_refl, not_true] at u3
  simp only [mem_compl_iff, mem_Iic, le_refl, not_true] at c1

end with_scott_topology

lemma preserve_lub_on_directed_iff_scott_continuity
  (f : (with_scott_topology α) → (with_scott_topology β)) :
  preserve_lub_on_directed f ↔ Continuous f := by
  constructor
  . intro h
    rw [continuous_def]
    intros u hu
    rw [with_scott_topology.is_open_iff_upper_and_lub_mem_implies_inter_nonempty]
    constructor
    . apply IsUpperSet.preimage (with_scott_topology.is_open_is_upper hu)
      apply preserve_lub_on_directed_montotone
      exact h
    . intros d a hd₁ hd₂ hd₃ ha
      have e1: IsLUB (f '' d) (f a) := by
        apply h
        apply hd₁
        apply hd₂
        apply hd₃
      rw [with_scott_topology.is_open_iff_upper_and_lub_mem_implies_inter_nonempty] at hu
      have e2: ((f '' d) ∩ u).Nonempty := by
        apply hu.2
        exact Nonempty.image f hd₁
        have e3: Monotone f := by
          apply preserve_lub_on_directed_montotone
          exact h
        apply directedOn_image.mpr
        apply DirectedOn.mono hd₂
        apply e3
        apply e1
        exact ha
      exact image_inter_nonempty_iff.mp e2
  . intros hf d a d₁ d₂ d₃
    rw [IsLUB]
    constructor
    . apply Monotone.mem_upperBounds_image (with_scott_topology.continuous_monotone hf)
      rw [← isLUB_le_iff]
      exact d₃
    . rw [lowerBounds, mem_setOf_eq]
      intros b hb
      let u := (Iic b)ᶜ
      by_contra h
      have e1: a ∈ (f⁻¹'  u) := h
      have s1 : IsOpen u := by
        rw [isOpen_compl_iff, ← with_scott_topology.closure_singleton]
        exact isClosed_closure
      have s2 : IsOpen (f⁻¹'  u) := IsOpen.preimage hf s1
      rw [with_scott_topology.is_open_iff_upper_and_lub_mem_implies_inter_nonempty] at s2
      obtain ⟨c, ⟨h_1_left, h_1_right⟩⟩ := s2.2 d a d₁ d₂ d₃ e1
      simp at h_1_right
      rw [upperBounds] at hb
      simp at hb
      have c1: f c ≤ b := by
        apply hb
        exact h_1_left
      contradiction

end preorder

section partial_order
variable [PartialOrder α]

instance : PartialOrder (with_scott_topology α) := ‹PartialOrder α›

/--
The Scott topology on a partial order is T₀.
-/
-- see Note [lower instance priority]
instance (priority := 90): T0Space (with_scott_topology α) :=
(t0Space_iff_inseparable (with_scott_topology α)).2 $ fun x y h => Iic_injective $
  by simpa only [inseparable_iff_closure_eq, with_scott_topology.closure_singleton] using h

end partial_order

section complete_lattice

lemma is_open_eq_upper_and_Sup_mem_implies_tail_subset [CompleteLattice α]
(u : Set (with_scott_topology α)) : IsOpen u =
(IsUpperSet u ∧
  ∀ (d : Set α), d.Nonempty → DirectedOn (· ≤ ·) d → supₛ d ∈ u → ∃ b ∈ d, (Ici b) ∩ d ⊆ u) := by
  rw [with_scott_topology.is_open_eq_upper_and_lub_mem_implies_tail_subset]
  refine' let_value_eq (And (IsUpperSet u)) _
  rw [eq_iff_iff]
  constructor
  . intros h d hd₁ hd₂ hd₃
    exact h d (supₛ d) hd₁ hd₂ (isLUB_supₛ d) hd₃
  . intros h d a hd₁ hd₂ hd₃ ha
    apply h d hd₁ hd₂
    rw [(IsLUB.supₛ_eq hd₃)]
    exact ha

lemma is_open_eq_upper_and_Sup_mem_implies_inter_nonempty [CompleteLattice α]
(u : Set (with_scott_topology α)) : IsOpen u =
(IsUpperSet u ∧  ∀ (d : Set α), d.Nonempty → DirectedOn (· ≤ ·) d → supₛ d ∈ u →
(d∩u).Nonempty) := by
  rw [with_scott_topology.is_open_iff_upper_and_lub_mem_implies_inter_nonempty]
  refine' let_value_eq (And (IsUpperSet u)) _
  rw [eq_iff_iff]
  constructor
  . intros h d hd₁ hd₂ hd₃
    exact h d (supₛ d) hd₁ hd₂ (isLUB_supₛ d) hd₃
  . intros h d a hd₁ hd₂ hd₃ ha
    apply h d hd₁ hd₂
    rw [(IsLUB.supₛ_eq hd₃)]
    exact ha

end complete_lattice
