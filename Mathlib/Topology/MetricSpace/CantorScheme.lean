/-
Copyright (c) 2023 Felix Weilacher. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Felix Weilacher
-/
import Mathlib.Topology.MetricSpace.PiNat

#align_import topology.metric_space.cantor_scheme from "leanprover-community/mathlib"@"49b7f94aab3a3bdca1f9f34c5d818afb253b3993"

/-!
# (Topological) Schemes and their induced maps

In topology, and especially descriptive set theory, one often constructs functions `(‚Ñï ‚Üí Œ≤) ‚Üí Œ±`,
where Œ± is some topological space and Œ≤ is a discrete space, as an appropriate limit of some map
`List Œ≤ ‚Üí Set Œ±`. We call the latter type of map a "`Œ≤`-scheme on `Œ±`".

This file develops the basic, abstract theory of these schemes and the functions they induce.

## Main Definitions

* `CantorScheme.inducedMap A` : The aforementioned "limit" of a scheme `A : List Œ≤ ‚Üí Set Œ±`.
  This is a partial function from `‚Ñï ‚Üí Œ≤` to `a`,
  implemented here as an object of type `Œ£ s : Set (‚Ñï ‚Üí Œ≤), s ‚Üí Œ±`.
  That is, `(inducedMap A).1` is the domain and `(inducedMap A).2` is the function.

## Implementation Notes

We consider end-appending to be the fundamental way to build lists (say on `Œ≤`) inductively,
as this interacts better with the topology on `‚Ñï ‚Üí Œ≤`.
As a result, functions like `List.get?` or `Stream'.take` do not have their intended meaning
in this file. See instead `PiNat.res`.

## References

* [kechris1995] (Chapters 6-7)

## Tags

scheme, cantor scheme, lusin scheme, approximation.

-/


namespace CantorScheme

open List Function Filter Set PiNat

open Classical Topology

variable {Œ≤ Œ± : Type*} (A : List Œ≤ ‚Üí Set Œ±)

/-- From a `Œ≤`-scheme on `Œ±` `A`, we define a partial function from `(‚Ñï ‚Üí Œ≤)` to `Œ±`
which sends each infinite sequence `x` to an element of the intersection along the
branch corresponding to `x`, if it exists.
We call this the map induced by the scheme. -/
noncomputable def inducedMap : Œ£s : Set (‚Ñï ‚Üí Œ≤), s ‚Üí Œ± :=
  ‚ü®fun x => Set.Nonempty (‚ãÇ n : ‚Ñï, A (res x n)), fun x => x.property.some‚ü©
#align cantor_scheme.induced_map CantorScheme.inducedMap

section Topology

/-- A scheme is antitone if each set contains its children. -/
protected def Antitone : Prop :=
  ‚àÄ l : List Œ≤, ‚àÄ a : Œ≤, A (a :: l) ‚äÜ A l
#align cantor_scheme.antitone CantorScheme.Antitone

/-- A useful strengthening of being antitone is to require that each set contains
the closure of each of its children. -/
def ClosureAntitone [TopologicalSpace Œ±] : Prop :=
  ‚àÄ l : List Œ≤, ‚àÄ a : Œ≤, closure (A (a :: l)) ‚äÜ A l
#align cantor_scheme.closure_antitone CantorScheme.ClosureAntitone

/-- A scheme is disjoint if the children of each set of pairwise disjoint. -/
protected def Disjoint : Prop :=
  ‚àÄ l : List Œ≤, Pairwise fun a b => Disjoint (A (a :: l)) (A (b :: l))
#align cantor_scheme.disjoint CantorScheme.Disjoint

variable {A}

/-- If `x` is in the domain of the induced map of a scheme `A`,
its image under this map is in each set along the corresponding branch. -/
theorem map_mem (x : (inducedMap A).1) (n : ‚Ñï) : (inducedMap A).2 x ‚àà A (res x n) := by
  have := x.property.some_mem
  -- ‚ä¢ Sigma.snd (inducedMap A) x ‚àà A (res (‚Üëx) n)
  rw [mem_iInter] at this
  -- ‚ä¢ Sigma.snd (inducedMap A) x ‚àà A (res (‚Üëx) n)
  exact this n
  -- üéâ no goals
#align cantor_scheme.map_mem CantorScheme.map_mem

protected theorem ClosureAntitone.antitone [TopologicalSpace Œ±] (hA : ClosureAntitone A) :
    CantorScheme.Antitone A := fun l a => subset_closure.trans (hA l a)
#align cantor_scheme.closure_antitone.antitone CantorScheme.ClosureAntitone.antitone

protected theorem Antitone.closureAntitone [TopologicalSpace Œ±] (hanti : CantorScheme.Antitone A)
    (hclosed : ‚àÄ l, IsClosed (A l)) : ClosureAntitone A := fun _ _ =>
  (hclosed _).closure_eq.subset.trans (hanti _ _)
#align cantor_scheme.antitone.closure_antitone CantorScheme.Antitone.closureAntitone

/-- A scheme where the children of each set are pairwise disjoint induces an injective map. -/
theorem Disjoint.map_injective (hA : CantorScheme.Disjoint A) : Injective (inducedMap A).2 := by
  rintro ‚ü®x, hx‚ü© ‚ü®y, hy‚ü© hxy
  -- ‚ä¢ { val := x, property := hx } = { val := y, property := hy }
  refine' Subtype.coe_injective (res_injective _)
  -- ‚ä¢ res ((fun a => ‚Üëa) { val := x, property := hx }) = res ((fun a => ‚Üëa) { val  ‚Ä¶
  dsimp
  -- ‚ä¢ res x = res y
  ext n : 1
  -- ‚ä¢ res x n = res y n
  induction' n with n ih; ¬∑ simp
  -- ‚ä¢ res x Nat.zero = res y Nat.zero
                            -- üéâ no goals
  simp only [res_succ, cons.injEq]
  -- ‚ä¢ x n = y n ‚àß res x n = res y n
  refine' ‚ü®_, ih‚ü©
  -- ‚ä¢ x n = y n
  contrapose hA
  -- ‚ä¢ ¬¨CantorScheme.Disjoint A
  simp only [CantorScheme.Disjoint, _root_.Pairwise, Ne.def, not_forall, exists_prop]
  -- ‚ä¢ ‚àÉ x x_1 x_2, ¬¨x_1 = x_2 ‚àß ¬¨_root_.Disjoint (A (x_1 :: x)) (A (x_2 :: x))
  refine' ‚ü®res x n, _, _, hA, _‚ü©
  -- ‚ä¢ ¬¨_root_.Disjoint (A (x n :: res x n)) (A (y n :: res x n))
  rw [not_disjoint_iff]
  -- ‚ä¢ ‚àÉ x_1, x_1 ‚àà A (x n :: res x n) ‚àß x_1 ‚àà A (y n :: res x n)
  refine' ‚ü®(inducedMap A).2 ‚ü®x, hx‚ü©, _, _‚ü©
  -- ‚ä¢ Sigma.snd (inducedMap A) { val := x, property := hx } ‚àà A (x n :: res x n)
  ¬∑ rw [‚Üê res_succ]
    -- ‚ä¢ Sigma.snd (inducedMap A) { val := x, property := hx } ‚àà A (res x (Nat.succ n))
    apply map_mem
    -- üéâ no goals
  rw [hxy, ih, ‚Üê res_succ]
  -- ‚ä¢ Sigma.snd (inducedMap A) { val := y, property := hy } ‚àà A (res y (Nat.succ n))
  apply map_mem
  -- üéâ no goals
#align cantor_scheme.disjoint.map_injective CantorScheme.Disjoint.map_injective

end Topology

section Metric

variable [PseudoMetricSpace Œ±]

/-- A scheme on a metric space has vanishing diameter if diameter approaches 0 along each branch. -/
def VanishingDiam : Prop :=
  ‚àÄ x : ‚Ñï ‚Üí Œ≤, Tendsto (fun n : ‚Ñï => EMetric.diam (A (res x n))) atTop (ùìù 0)
#align cantor_scheme.vanishing_diam CantorScheme.VanishingDiam

variable {A}

theorem VanishingDiam.dist_lt (hA : VanishingDiam A) (Œµ : ‚Ñù) (Œµ_pos : 0 < Œµ) (x : ‚Ñï ‚Üí Œ≤) :
    ‚àÉ n : ‚Ñï, ‚àÄ (y) (_ : y ‚àà A (res x n)) (z) (_ : z ‚àà A (res x n)), dist y z < Œµ := by
  specialize hA x
  -- ‚ä¢ ‚àÉ n, ‚àÄ (y : Œ±), y ‚àà A (res x n) ‚Üí ‚àÄ (z : Œ±), z ‚àà A (res x n) ‚Üí dist y z < Œµ
  rw [ENNReal.tendsto_atTop_zero] at hA
  -- ‚ä¢ ‚àÉ n, ‚àÄ (y : Œ±), y ‚àà A (res x n) ‚Üí ‚àÄ (z : Œ±), z ‚àà A (res x n) ‚Üí dist y z < Œµ
  cases' hA (ENNReal.ofReal (Œµ / 2)) (by
    simp only [gt_iff_lt, ENNReal.ofReal_pos]
    linarith) with n hn
  use n
  -- ‚ä¢ ‚àÄ (y : Œ±), y ‚àà A (res x n) ‚Üí ‚àÄ (z : Œ±), z ‚àà A (res x n) ‚Üí dist y z < Œµ
  intro y hy z hz
  -- ‚ä¢ dist y z < Œµ
  rw [‚Üê ENNReal.ofReal_lt_ofReal_iff Œµ_pos, ‚Üê edist_dist]
  -- ‚ä¢ edist y z < ENNReal.ofReal Œµ
  apply lt_of_le_of_lt (EMetric.edist_le_diam_of_mem hy hz)
  -- ‚ä¢ EMetric.diam (A (res x n)) < ENNReal.ofReal Œµ
  apply lt_of_le_of_lt (hn _ (le_refl _))
  -- ‚ä¢ ENNReal.ofReal (Œµ / 2) < ENNReal.ofReal Œµ
  rw [ENNReal.ofReal_lt_ofReal_iff Œµ_pos]
  -- ‚ä¢ Œµ / 2 < Œµ
  linarith
  -- üéâ no goals
#align cantor_scheme.vanishing_diam.dist_lt CantorScheme.VanishingDiam.dist_lt

/-- A scheme with vanishing diameter along each branch induces a continuous map. -/
theorem VanishingDiam.map_continuous [TopologicalSpace Œ≤] [DiscreteTopology Œ≤]
    (hA : VanishingDiam A) : Continuous (inducedMap A).2 := by
  rw [Metric.continuous_iff']
  -- ‚ä¢ ‚àÄ (a : ‚Üë(inducedMap A).fst) (Œµ : ‚Ñù), Œµ > 0 ‚Üí ‚àÄ·∂† (x : ‚Üë(inducedMap A).fst) in ‚Ä¶
  rintro ‚ü®x, hx‚ü© Œµ Œµ_pos
  -- ‚ä¢ ‚àÄ·∂† (x_1 : ‚Üë(inducedMap A).fst) in ùìù { val := x, property := hx }, dist (Sigm ‚Ä¶
  cases' hA.dist_lt _ Œµ_pos x with n hn
  -- ‚ä¢ ‚àÄ·∂† (x_1 : ‚Üë(inducedMap A).fst) in ùìù { val := x, property := hx }, dist (Sigm ‚Ä¶
  rw [_root_.eventually_nhds_iff]
  -- ‚ä¢ ‚àÉ t, (‚àÄ (x_1 : ‚Üë(inducedMap A).fst), x_1 ‚àà t ‚Üí dist (Sigma.snd (inducedMap A ‚Ä¶
  refine' ‚ü®(‚Üë)‚Åª¬π' cylinder x n, _, _, by simp‚ü©
  -- ‚ä¢ ‚àÄ (x_1 : ‚Üë(inducedMap A).fst), x_1 ‚àà Subtype.val ‚Åª¬π' cylinder x n ‚Üí dist (Si ‚Ä¶
  ¬∑ rintro ‚ü®y, hy‚ü© hyx
    -- ‚ä¢ dist (Sigma.snd (inducedMap A) { val := y, property := hy }) (Sigma.snd (ind ‚Ä¶
    rw [mem_preimage, Subtype.coe_mk, cylinder_eq_res, mem_setOf] at hyx
    -- ‚ä¢ dist (Sigma.snd (inducedMap A) { val := y, property := hy }) (Sigma.snd (ind ‚Ä¶
    apply hn
    -- ‚ä¢ Sigma.snd (inducedMap A) { val := y, property := hy } ‚àà A (res x n)
    ¬∑ rw [‚Üê hyx]
      -- ‚ä¢ Sigma.snd (inducedMap A) { val := y, property := hy } ‚àà A (res y n)
      apply map_mem
      -- üéâ no goals
    apply map_mem
    -- üéâ no goals
  apply continuous_subtype_val.isOpen_preimage
  -- ‚ä¢ IsOpen (cylinder x n)
  apply isOpen_cylinder
  -- üéâ no goals
#align cantor_scheme.vanishing_diam.map_continuous CantorScheme.VanishingDiam.map_continuous

/-- A scheme on a complete space with vanishing diameter
such that each set contains the closure of its children
induces a total map. -/
theorem ClosureAntitone.map_of_vanishingDiam [CompleteSpace Œ±] (hdiam : VanishingDiam A)
    (hanti : ClosureAntitone A) (hnonempty : ‚àÄ l, (A l).Nonempty) : (inducedMap A).1 = univ := by
  rw [eq_univ_iff_forall]
  -- ‚ä¢ ‚àÄ (x : ‚Ñï ‚Üí Œ≤), x ‚àà (inducedMap A).fst
  intro x
  -- ‚ä¢ x ‚àà (inducedMap A).fst
  choose u hu using fun n => hnonempty (res x n)
  -- ‚ä¢ x ‚àà (inducedMap A).fst
  have umem : ‚àÄ n m : ‚Ñï, n ‚â§ m ‚Üí u m ‚àà A (res x n) := by
    have : Antitone fun n : ‚Ñï => A (res x n) := by
      refine' antitone_nat_of_succ_le _
      intro n
      apply hanti.antitone
    intro n m hnm
    exact this hnm (hu _)
  have : CauchySeq u := by
    rw [Metric.cauchySeq_iff]
    intro Œµ Œµ_pos
    cases' hdiam.dist_lt _ Œµ_pos x with n hn
    use n
    intro m‚ÇÄ hm‚ÇÄ m‚ÇÅ hm‚ÇÅ
    apply hn <;> apply umem <;> assumption
  cases' cauchySeq_tendsto_of_complete this with y hy
  -- ‚ä¢ x ‚àà (inducedMap A).fst
  use y
  -- ‚ä¢ y ‚àà ‚ãÇ (n : ‚Ñï), A (res x n)
  rw [mem_iInter]
  -- ‚ä¢ ‚àÄ (i : ‚Ñï), y ‚àà A (res x i)
  intro n
  -- ‚ä¢ y ‚àà A (res x n)
  apply hanti _ (x n)
  -- ‚ä¢ y ‚àà closure (A (x n :: res x n))
  apply mem_closure_of_tendsto hy
  -- ‚ä¢ ‚àÄ·∂† (x_1 : ‚Ñï) in atTop, u x_1 ‚àà A (x n :: res x n)
  rw [eventually_atTop]
  -- ‚ä¢ ‚àÉ a, ‚àÄ (b : ‚Ñï), b ‚â• a ‚Üí u b ‚àà A (x n :: res x n)
  exact ‚ü®n.succ, umem _‚ü©
  -- üéâ no goals
#align cantor_scheme.closure_antitone.map_of_vanishing_diam CantorScheme.ClosureAntitone.map_of_vanishingDiam

end Metric

end CantorScheme
