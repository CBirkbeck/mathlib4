/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl
-/
import Mathlib.Topology.Instances.NNReal
import Mathlib.Topology.Algebra.Order.MonotoneContinuity
import Mathlib.Topology.Algebra.InfiniteSum.Real
import Mathlib.Topology.Algebra.Order.LiminfLimsup
import Mathlib.Topology.Algebra.Order.T5
import Mathlib.Topology.MetricSpace.Lipschitz

#align_import topology.instances.ennreal from "leanprover-community/mathlib"@"ec4b2eeb50364487f80421c0b4c41328a611f30d"

/-!
# Topology on extended non-negative reals
-/

noncomputable section

open Set Filter Metric Function
open scoped Classical Topology ENNReal NNReal BigOperators Filter

variable {Œ± : Type*} {Œ≤ : Type*} {Œ≥ : Type*}

namespace ENNReal

variable {a b c d : ‚Ñù‚â•0‚àû} {r p q : ‚Ñù‚â•0} {x y z : ‚Ñù‚â•0‚àû} {Œµ Œµ‚ÇÅ Œµ‚ÇÇ : ‚Ñù‚â•0‚àû} {s : Set ‚Ñù‚â•0‚àû}

section TopologicalSpace

open TopologicalSpace

/-- Topology on `‚Ñù‚â•0‚àû`.

Note: this is different from the `EMetricSpace` topology. The `EMetricSpace` topology has
`IsOpen {‚ä§}`, while this topology doesn't have singleton elements. -/
instance : TopologicalSpace ‚Ñù‚â•0‚àû := Preorder.topology ‚Ñù‚â•0‚àû

instance : OrderTopology ‚Ñù‚â•0‚àû := ‚ü®rfl‚ü©

-- short-circuit type class inference
instance : T2Space ‚Ñù‚â•0‚àû := inferInstance
instance : T5Space ‚Ñù‚â•0‚àû := inferInstance
instance : NormalSpace ‚Ñù‚â•0‚àû := inferInstance

instance : SecondCountableTopology ‚Ñù‚â•0‚àû :=
  orderIsoUnitIntervalBirational.toHomeomorph.embedding.secondCountableTopology

theorem embedding_coe : Embedding ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0‚àû) :=
  coe_strictMono.embedding_of_ordConnected <| by rw [range_coe']; exact ordConnected_Iio
                                                 -- ‚ä¢ OrdConnected (Iio ‚ä§)
                                                                  -- üéâ no goals
#align ennreal.embedding_coe ENNReal.embedding_coe

theorem isOpen_ne_top : IsOpen { a : ‚Ñù‚â•0‚àû | a ‚â† ‚ä§ } := isOpen_ne
#align ennreal.is_open_ne_top ENNReal.isOpen_ne_top

theorem isOpen_Ico_zero : IsOpen (Ico 0 b) := by
  rw [ENNReal.Ico_eq_Iio]
  -- ‚ä¢ IsOpen (Iio b)
  exact isOpen_Iio
  -- üéâ no goals
#align ennreal.is_open_Ico_zero ENNReal.isOpen_Ico_zero

theorem openEmbedding_coe : OpenEmbedding ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0‚àû) :=
  ‚ü®embedding_coe, by rw [range_coe']; exact isOpen_Iio‚ü©
                     -- ‚ä¢ IsOpen (Iio ‚ä§)
                                      -- üéâ no goals
#align ennreal.open_embedding_coe ENNReal.openEmbedding_coe

theorem coe_range_mem_nhds : range ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0‚àû) ‚àà ùìù (r : ‚Ñù‚â•0‚àû) :=
  IsOpen.mem_nhds openEmbedding_coe.open_range <| mem_range_self _
#align ennreal.coe_range_mem_nhds ENNReal.coe_range_mem_nhds

@[norm_cast]
theorem tendsto_coe {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù‚â•0} {a : ‚Ñù‚â•0} :
    Tendsto (fun a => (m a : ‚Ñù‚â•0‚àû)) f (ùìù ‚Üëa) ‚Üî Tendsto m f (ùìù a) :=
  embedding_coe.tendsto_nhds_iff.symm
#align ennreal.tendsto_coe ENNReal.tendsto_coe

theorem continuous_coe : Continuous ((‚Üë) : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0‚àû) :=
  embedding_coe.continuous
#align ennreal.continuous_coe ENNReal.continuous_coe

theorem continuous_coe_iff {Œ±} [TopologicalSpace Œ±] {f : Œ± ‚Üí ‚Ñù‚â•0} :
    (Continuous fun a => (f a : ‚Ñù‚â•0‚àû)) ‚Üî Continuous f :=
  embedding_coe.continuous_iff.symm
#align ennreal.continuous_coe_iff ENNReal.continuous_coe_iff

theorem nhds_coe {r : ‚Ñù‚â•0} : ùìù (r : ‚Ñù‚â•0‚àû) = (ùìù r).map (‚Üë) :=
  (openEmbedding_coe.map_nhds_eq r).symm
#align ennreal.nhds_coe ENNReal.nhds_coe

theorem tendsto_nhds_coe_iff {Œ± : Type*} {l : Filter Œ±} {x : ‚Ñù‚â•0} {f : ‚Ñù‚â•0‚àû ‚Üí Œ±} :
    Tendsto f (ùìù ‚Üëx) l ‚Üî Tendsto (f ‚àò (‚Üë) : ‚Ñù‚â•0 ‚Üí Œ±) (ùìù x) l := by
  rw [nhds_coe, tendsto_map'_iff]
  -- üéâ no goals
#align ennreal.tendsto_nhds_coe_iff ENNReal.tendsto_nhds_coe_iff

theorem continuousAt_coe_iff {Œ± : Type*} [TopologicalSpace Œ±] {x : ‚Ñù‚â•0} {f : ‚Ñù‚â•0‚àû ‚Üí Œ±} :
    ContinuousAt f ‚Üëx ‚Üî ContinuousAt (f ‚àò (‚Üë) : ‚Ñù‚â•0 ‚Üí Œ±) x :=
  tendsto_nhds_coe_iff
#align ennreal.continuous_at_coe_iff ENNReal.continuousAt_coe_iff

theorem nhds_coe_coe {r p : ‚Ñù‚â•0} :
    ùìù ((r : ‚Ñù‚â•0‚àû), (p : ‚Ñù‚â•0‚àû)) = (ùìù (r, p)).map fun p : ‚Ñù‚â•0 √ó ‚Ñù‚â•0 => (‚Üëp.1, ‚Üëp.2) :=
  ((openEmbedding_coe.prod openEmbedding_coe).map_nhds_eq (r, p)).symm
#align ennreal.nhds_coe_coe ENNReal.nhds_coe_coe

theorem continuous_ofReal : Continuous ENNReal.ofReal :=
  (continuous_coe_iff.2 continuous_id).comp continuous_real_toNNReal
#align ennreal.continuous_of_real ENNReal.continuous_ofReal

theorem tendsto_ofReal {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù} {a : ‚Ñù} (h : Tendsto m f (ùìù a)) :
    Tendsto (fun a => ENNReal.ofReal (m a)) f (ùìù (ENNReal.ofReal a)) :=
  (continuous_ofReal.tendsto a).comp h
#align ennreal.tendsto_of_real ENNReal.tendsto_ofReal

theorem tendsto_toNNReal {a : ‚Ñù‚â•0‚àû} (ha : a ‚â† ‚ä§) :
    Tendsto ENNReal.toNNReal (ùìù a) (ùìù a.toNNReal) := by
  lift a to ‚Ñù‚â•0 using ha
  -- ‚ä¢ Tendsto ENNReal.toNNReal (ùìù ‚Üëa) (ùìù (ENNReal.toNNReal ‚Üëa))
  rw [nhds_coe, tendsto_map'_iff]
  -- ‚ä¢ Tendsto (ENNReal.toNNReal ‚àò some) (ùìù a) (ùìù (ENNReal.toNNReal ‚Üëa))
  exact tendsto_id
  -- üéâ no goals
#align ennreal.tendsto_to_nnreal ENNReal.tendsto_toNNReal

theorem eventuallyEq_of_toReal_eventuallyEq {l : Filter Œ±} {f g : Œ± ‚Üí ‚Ñù‚â•0‚àû}
    (hfi : ‚àÄ·∂† x in l, f x ‚â† ‚àû) (hgi : ‚àÄ·∂† x in l, g x ‚â† ‚àû)
    (hfg : (fun x => (f x).toReal) =·∂†[l] fun x => (g x).toReal) : f =·∂†[l] g := by
  filter_upwards [hfi, hgi, hfg]with _ hfx hgx _
  -- ‚ä¢ f a‚úù¬π = g a‚úù¬π
  rwa [‚Üê ENNReal.toReal_eq_toReal hfx hgx]
  -- üéâ no goals
#align ennreal.eventually_eq_of_to_real_eventually_eq ENNReal.eventuallyEq_of_toReal_eventuallyEq

theorem continuousOn_toNNReal : ContinuousOn ENNReal.toNNReal { a | a ‚â† ‚àû } := fun _a ha =>
  ContinuousAt.continuousWithinAt (tendsto_toNNReal ha)
#align ennreal.continuous_on_to_nnreal ENNReal.continuousOn_toNNReal

theorem tendsto_toReal {a : ‚Ñù‚â•0‚àû} (ha : a ‚â† ‚ä§) : Tendsto ENNReal.toReal (ùìù a) (ùìù a.toReal) :=
  NNReal.tendsto_coe.2 <| tendsto_toNNReal ha
#align ennreal.tendsto_to_real ENNReal.tendsto_toReal

/-- The set of finite `‚Ñù‚â•0‚àû` numbers is homeomorphic to `‚Ñù‚â•0`. -/
def neTopHomeomorphNNReal : { a | a ‚â† ‚àû } ‚âÉ‚Çú ‚Ñù‚â•0 where
  toEquiv := neTopEquivNNReal
  continuous_toFun := continuousOn_iff_continuous_restrict.1 continuousOn_toNNReal
  continuous_invFun := continuous_coe.subtype_mk _
#align ennreal.ne_top_homeomorph_nnreal ENNReal.neTopHomeomorphNNReal

/-- The set of finite `‚Ñù‚â•0‚àû` numbers is homeomorphic to `‚Ñù‚â•0`. -/
def ltTopHomeomorphNNReal : { a | a < ‚àû } ‚âÉ‚Çú ‚Ñù‚â•0 := by
  refine' (Homeomorph.setCongr _).trans neTopHomeomorphNNReal
  -- ‚ä¢ {a | a < ‚ä§} = {a | a ‚â† ‚ä§}
  simp only [mem_setOf_eq, lt_top_iff_ne_top]
  -- üéâ no goals
#align ennreal.lt_top_homeomorph_nnreal ENNReal.ltTopHomeomorphNNReal

theorem nhds_top : ùìù ‚àû = ‚®Ö (a) (_ : a ‚â† ‚àû), ùìü (Ioi a) :=
  nhds_top_order.trans <| by simp [lt_top_iff_ne_top, Ioi]
                             -- üéâ no goals
#align ennreal.nhds_top ENNReal.nhds_top

theorem nhds_top' : ùìù ‚àû = ‚®Ö r : ‚Ñù‚â•0, ùìü (Ioi ‚Üër) :=
  nhds_top.trans <| iInf_ne_top _
#align ennreal.nhds_top' ENNReal.nhds_top'

theorem nhds_top_basis : (ùìù ‚àû).HasBasis (fun a => a < ‚àû) fun a => Ioi a :=
  _root_.nhds_top_basis
#align ennreal.nhds_top_basis ENNReal.nhds_top_basis

theorem tendsto_nhds_top_iff_nnreal {m : Œ± ‚Üí ‚Ñù‚â•0‚àû} {f : Filter Œ±} :
    Tendsto m f (ùìù ‚ä§) ‚Üî ‚àÄ x : ‚Ñù‚â•0, ‚àÄ·∂† a in f, ‚Üëx < m a := by
  simp only [nhds_top', tendsto_iInf, tendsto_principal, mem_Ioi]
  -- üéâ no goals
#align ennreal.tendsto_nhds_top_iff_nnreal ENNReal.tendsto_nhds_top_iff_nnreal

theorem tendsto_nhds_top_iff_nat {m : Œ± ‚Üí ‚Ñù‚â•0‚àû} {f : Filter Œ±} :
    Tendsto m f (ùìù ‚ä§) ‚Üî ‚àÄ n : ‚Ñï, ‚àÄ·∂† a in f, ‚Üën < m a :=
  tendsto_nhds_top_iff_nnreal.trans
    ‚ü®fun h n => by simpa only [ENNReal.coe_nat] using h n, fun h x =>
                   -- üéâ no goals
      let ‚ü®n, hn‚ü© := exists_nat_gt x
      (h n).mono fun y => lt_trans <| by rwa [‚Üê ENNReal.coe_nat, coe_lt_coe]‚ü©
                                         -- üéâ no goals
#align ennreal.tendsto_nhds_top_iff_nat ENNReal.tendsto_nhds_top_iff_nat

theorem tendsto_nhds_top {m : Œ± ‚Üí ‚Ñù‚â•0‚àû} {f : Filter Œ±} (h : ‚àÄ n : ‚Ñï, ‚àÄ·∂† a in f, ‚Üën < m a) :
    Tendsto m f (ùìù ‚ä§) :=
  tendsto_nhds_top_iff_nat.2 h
#align ennreal.tendsto_nhds_top ENNReal.tendsto_nhds_top

theorem tendsto_nat_nhds_top : Tendsto (fun n : ‚Ñï => ‚Üën) atTop (ùìù ‚àû) :=
  tendsto_nhds_top fun n =>
    mem_atTop_sets.2 ‚ü®n + 1, fun _m hm => mem_setOf.2 <| Nat.cast_lt.2 <| Nat.lt_of_succ_le hm‚ü©
#align ennreal.tendsto_nat_nhds_top ENNReal.tendsto_nat_nhds_top

@[simp, norm_cast]
theorem tendsto_coe_nhds_top {f : Œ± ‚Üí ‚Ñù‚â•0} {l : Filter Œ±} :
    Tendsto (fun x => (f x : ‚Ñù‚â•0‚àû)) l (ùìù ‚àû) ‚Üî Tendsto f l atTop := by
  rw [tendsto_nhds_top_iff_nnreal, atTop_basis_Ioi.tendsto_right_iff]; simp
  -- ‚ä¢ (‚àÄ (x : ‚Ñù‚â•0), ‚àÄ·∂† (a : Œ±) in l, ‚Üëx < ‚Üë(f a)) ‚Üî ‚àÄ (i : ‚Ñù‚â•0), True ‚Üí ‚àÄ·∂† (x : Œ±) ‚Ä¶
                                                                       -- üéâ no goals
#align ennreal.tendsto_coe_nhds_top ENNReal.tendsto_coe_nhds_top

theorem tendsto_ofReal_atTop : Tendsto ENNReal.ofReal atTop (ùìù ‚àû) :=
  tendsto_coe_nhds_top.2 tendsto_real_toNNReal_atTop
#align ennreal.tendsto_of_real_at_top ENNReal.tendsto_ofReal_atTop

theorem nhds_zero : ùìù (0 : ‚Ñù‚â•0‚àû) = ‚®Ö (a) (_ : a ‚â† 0), ùìü (Iio a) :=
  nhds_bot_order.trans <| by simp [pos_iff_ne_zero, Iio]
                             -- üéâ no goals
#align ennreal.nhds_zero ENNReal.nhds_zero

theorem nhds_zero_basis : (ùìù (0 : ‚Ñù‚â•0‚àû)).HasBasis (fun a : ‚Ñù‚â•0‚àû => 0 < a) fun a => Iio a :=
  nhds_bot_basis
#align ennreal.nhds_zero_basis ENNReal.nhds_zero_basis

theorem nhds_zero_basis_Iic : (ùìù (0 : ‚Ñù‚â•0‚àû)).HasBasis (fun a : ‚Ñù‚â•0‚àû => 0 < a) Iic :=
  nhds_bot_basis_Iic
#align ennreal.nhds_zero_basis_Iic ENNReal.nhds_zero_basis_Iic

-- porting note: todo: add a TC for `‚â† ‚àû`?
@[instance]
theorem nhdsWithin_Ioi_coe_neBot {r : ‚Ñù‚â•0} : (ùìù[>] (r : ‚Ñù‚â•0‚àû)).NeBot :=
  nhdsWithin_Ioi_self_neBot' ‚ü®‚ä§, ENNReal.coe_lt_top‚ü©
#align ennreal.nhds_within_Ioi_coe_ne_bot ENNReal.nhdsWithin_Ioi_coe_neBot

@[instance]
theorem nhdsWithin_Ioi_zero_neBot : (ùìù[>] (0 : ‚Ñù‚â•0‚àû)).NeBot :=
  nhdsWithin_Ioi_coe_neBot
#align ennreal.nhds_within_Ioi_zero_ne_bot ENNReal.nhdsWithin_Ioi_zero_neBot

@[instance]
theorem nhdsWithin_Ioi_one_neBot : (ùìù[>] (1 : ‚Ñù‚â•0‚àû)).NeBot := nhdsWithin_Ioi_coe_neBot

@[instance]
theorem nhdsWithin_Ioi_nat_neBot (n : ‚Ñï) : (ùìù[>] (n : ‚Ñù‚â•0‚àû)).NeBot := nhdsWithin_Ioi_coe_neBot

@[instance]
theorem nhdsWithin_Ioi_ofNat_nebot (n : ‚Ñï) [n.AtLeastTwo] :
    (ùìù[>] (OfNat.ofNat n : ‚Ñù‚â•0‚àû)).NeBot := nhdsWithin_Ioi_coe_neBot

@[instance]
theorem nhdsWithin_Iio_neBot [NeZero x] : (ùìù[<] x).NeBot :=
  nhdsWithin_Iio_self_neBot' ‚ü®0, NeZero.pos x‚ü©

/-- Closed intervals `Set.Icc (x - Œµ) (x + Œµ)`, `Œµ ‚â† 0`, form a basis of neighborhoods of an
extended nonnegative real number `x ‚â† ‚àû`. We use `Set.Icc` instead of `Set.Ioo` because this way the
statement works for `x = 0`.
-/
theorem hasBasis_nhds_of_ne_top' (xt : x ‚â† ‚àû) :
    (ùìù x).HasBasis (¬∑ ‚â† 0) (fun Œµ => Icc (x - Œµ) (x + Œµ)) := by
  rcases (zero_le x).eq_or_gt with rfl | x0
  -- ‚ä¢ HasBasis (ùìù 0) (fun x => x ‚â† 0) fun Œµ => Icc (0 - Œµ) (0 + Œµ)
  ¬∑ simp_rw [zero_tsub, zero_add, ‚Üê bot_eq_zero, Icc_bot, ‚Üê bot_lt_iff_ne_bot]
    -- ‚ä¢ HasBasis (ùìù ‚ä•) (fun x => ‚ä• < x) fun Œµ => Iic Œµ
    exact nhds_bot_basis_Iic
    -- üéâ no goals
  ¬∑ refine (nhds_basis_Ioo' ‚ü®_, x0‚ü© ‚ü®_, xt.lt_top‚ü©).to_hasBasis ?_ fun Œµ Œµ0 => ?_
    -- ‚ä¢ ‚àÄ (i : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû), i.fst < x ‚àß x < i.snd ‚Üí ‚àÉ i', i' ‚â† 0 ‚àß Icc (x - i') (x  ‚Ä¶
    ¬∑ rintro ‚ü®a, b‚ü© ‚ü®ha, hb‚ü©
      -- ‚ä¢ ‚àÉ i', i' ‚â† 0 ‚àß Icc (x - i') (x + i') ‚äÜ Ioo (a, b).fst (a, b).snd
      rcases exists_between (tsub_pos_of_lt ha) with ‚ü®Œµ, Œµ0, hŒµ‚ü©
      -- ‚ä¢ ‚àÉ i', i' ‚â† 0 ‚àß Icc (x - i') (x + i') ‚äÜ Ioo (a, b).fst (a, b).snd
      rcases lt_iff_exists_add_pos_lt.1 hb with ‚ü®Œ¥, Œ¥0, hŒ¥‚ü©
      -- ‚ä¢ ‚àÉ i', i' ‚â† 0 ‚àß Icc (x - i') (x + i') ‚äÜ Ioo (a, b).fst (a, b).snd
      refine ‚ü®min Œµ Œ¥, (lt_min Œµ0 (coe_pos.2 Œ¥0)).ne', Icc_subset_Ioo ?_ ?_‚ü©
      -- ‚ä¢ (a, b).fst < x - min Œµ ‚ÜëŒ¥
      ¬∑ exact lt_tsub_comm.2 ((min_le_left _ _).trans_lt hŒµ)
        -- üéâ no goals
      ¬∑ exact (add_le_add_left (min_le_right _ _) _).trans_lt hŒ¥
        -- üéâ no goals
    ¬∑ exact ‚ü®(x - Œµ, x + Œµ), ‚ü®ENNReal.sub_lt_self xt x0.ne' Œµ0,
        lt_add_right xt Œµ0‚ü©, Ioo_subset_Icc_self‚ü©

theorem hasBasis_nhds_of_ne_top (xt : x ‚â† ‚àû) :
    (ùìù x).HasBasis (0 < ¬∑) (fun Œµ => Icc (x - Œµ) (x + Œµ)) := by
  simpa only [pos_iff_ne_zero] using hasBasis_nhds_of_ne_top' xt
  -- üéâ no goals

theorem Icc_mem_nhds (xt : x ‚â† ‚àû) (Œµ0 : Œµ ‚â† 0) : Icc (x - Œµ) (x + Œµ) ‚àà ùìù x :=
  (hasBasis_nhds_of_ne_top' xt).mem_of_mem Œµ0
#align ennreal.Icc_mem_nhds ENNReal.Icc_mem_nhds

theorem nhds_of_ne_top (xt : x ‚â† ‚ä§) : ùìù x = ‚®Ö Œµ > 0, ùìü (Icc (x - Œµ) (x + Œµ)) :=
  (hasBasis_nhds_of_ne_top xt).eq_biInf
#align ennreal.nhds_of_ne_top ENNReal.nhds_of_ne_top

theorem biInf_le_nhds : ‚àÄ x : ‚Ñù‚â•0‚àû, ‚®Ö Œµ > 0, ùìü (Icc (x - Œµ) (x + Œµ)) ‚â§ ùìù x
  | ‚ä§ => iInf‚ÇÇ_le_of_le 1 one_pos <| by
    simpa only [‚Üê coe_one, top_sub_coe, top_add, Icc_self, principal_singleton] using pure_le_nhds _
    -- üéâ no goals
  | (x : ‚Ñù‚â•0) => (nhds_of_ne_top coe_ne_top).ge

-- porting note: new lemma
protected theorem tendsto_nhds_of_Icc {f : Filter Œ±} {u : Œ± ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû}
    (h : ‚àÄ Œµ > 0, ‚àÄ·∂† x in f, u x ‚àà Icc (a - Œµ) (a + Œµ)) : Tendsto u f (ùìù a) := by
  refine Tendsto.mono_right ?_ (biInf_le_nhds _)
  -- ‚ä¢ Tendsto u f (‚®Ö (Œµ : ‚Ñù‚â•0‚àû) (_ : Œµ > 0), ùìü (Icc (a - Œµ) (a + Œµ)))
  simpa only [tendsto_iInf, tendsto_principal]
  -- üéâ no goals

/-- Characterization of neighborhoods for `‚Ñù‚â•0‚àû` numbers. See also `tendsto_order`
for a version with strict inequalities. -/
protected theorem tendsto_nhds {f : Filter Œ±} {u : Œ± ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû} (ha : a ‚â† ‚ä§) :
    Tendsto u f (ùìù a) ‚Üî ‚àÄ Œµ > 0, ‚àÄ·∂† x in f, u x ‚àà Icc (a - Œµ) (a + Œµ) := by
  simp only [nhds_of_ne_top ha, tendsto_iInf, tendsto_principal]
  -- üéâ no goals
#align ennreal.tendsto_nhds ENNReal.tendsto_nhds

protected theorem tendsto_nhds_zero {f : Filter Œ±} {u : Œ± ‚Üí ‚Ñù‚â•0‚àû} :
    Tendsto u f (ùìù 0) ‚Üî ‚àÄ Œµ > 0, ‚àÄ·∂† x in f, u x ‚â§ Œµ :=
  nhds_zero_basis_Iic.tendsto_right_iff
#align ennreal.tendsto_nhds_zero ENNReal.tendsto_nhds_zero

protected theorem tendsto_atTop [Nonempty Œ≤] [SemilatticeSup Œ≤] {f : Œ≤ ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû}
    (ha : a ‚â† ‚ä§) : Tendsto f atTop (ùìù a) ‚Üî ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ n ‚â• N, f n ‚àà Icc (a - Œµ) (a + Œµ) :=
  .trans (atTop_basis.tendsto_iff (hasBasis_nhds_of_ne_top ha)) (by simp only [true_and]; rfl)
                                                                    -- ‚ä¢ (‚àÄ (ib : ‚Ñù‚â•0‚àû), 0 < ib ‚Üí ‚àÉ ia, ‚àÄ (x : Œ≤), x ‚àà Ici ia ‚Üí f x ‚àà Icc (a - ib) (a ‚Ä¶
                                                                                          -- üéâ no goals
#align ennreal.tendsto_at_top ENNReal.tendsto_atTop

instance : ContinuousAdd ‚Ñù‚â•0‚àû := by
  refine' ‚ü®continuous_iff_continuousAt.2 _‚ü©
  -- ‚ä¢ ‚àÄ (x : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû), ContinuousAt (fun p => p.fst + p.snd) x
  rintro ‚ü®_ | a, b‚ü©
  -- ‚ä¢ ContinuousAt (fun p => p.fst + p.snd) (none, b)
  ¬∑ exact tendsto_nhds_top_mono' continuousAt_fst fun p => le_add_right le_rfl
    -- üéâ no goals
  rcases b with (_ | b)
  -- ‚ä¢ ContinuousAt (fun p => p.fst + p.snd) (Option.some a, none)
  ¬∑ exact tendsto_nhds_top_mono' continuousAt_snd fun p => le_add_left le_rfl
    -- üéâ no goals
  simp only [ContinuousAt, some_eq_coe, nhds_coe_coe, ‚Üê coe_add, tendsto_map'_iff, (¬∑ ‚àò ¬∑),
    tendsto_coe, tendsto_add]

protected theorem tendsto_atTop_zero [Nonempty Œ≤] [SemilatticeSup Œ≤] {f : Œ≤ ‚Üí ‚Ñù‚â•0‚àû} :
    Tendsto f atTop (ùìù 0) ‚Üî ‚àÄ Œµ > 0, ‚àÉ N, ‚àÄ n ‚â• N, f n ‚â§ Œµ :=
  .trans (atTop_basis.tendsto_iff nhds_zero_basis_Iic) (by simp only [true_and]; rfl)
                                                           -- ‚ä¢ (‚àÄ (ib : ‚Ñù‚â•0‚àû), 0 < ib ‚Üí ‚àÉ ia, ‚àÄ (x : Œ≤), x ‚àà Ici ia ‚Üí f x ‚àà Iic ib) ‚Üî ‚àÄ (Œµ  ‚Ä¶
                                                                                 -- üéâ no goals
#align ennreal.tendsto_at_top_zero ENNReal.tendsto_atTop_zero

theorem tendsto_sub : ‚àÄ {a b : ‚Ñù‚â•0‚àû}, (a ‚â† ‚àû ‚à® b ‚â† ‚àû) ‚Üí
    Tendsto (fun p : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû => p.1 - p.2) (ùìù (a, b)) (ùìù (a - b))
  | ‚ä§, ‚ä§, h => by simp only at h
                  -- üéâ no goals
  | ‚ä§, (b : ‚Ñù‚â•0), _ => by
    rw [top_sub_coe, tendsto_nhds_top_iff_nnreal]
    -- ‚ä¢ ‚àÄ (x : ‚Ñù‚â•0), ‚àÄ·∂† (a : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû) in ùìù (‚ä§, ‚Üëb), ‚Üëx < a.fst - a.snd
    refine fun x => ((lt_mem_nhds <| @coe_lt_top (b + 1 + x)).prod_nhds
      (ge_mem_nhds <| coe_lt_coe.2 <| lt_add_one b)).mono fun y hy => ?_
    rw [lt_tsub_iff_left]
    -- ‚ä¢ y.snd + ‚Üëx < y.fst
    calc y.2 + x ‚â§ ‚Üë(b + 1) + x := add_le_add_right hy.2 _
    _ < y.1 := hy.1
  | (a : ‚Ñù‚â•0), ‚ä§, _ => by
    rw [sub_top]
    -- ‚ä¢ Tendsto (fun p => p.fst - p.snd) (ùìù (‚Üëa, ‚ä§)) (ùìù 0)
    refine (tendsto_pure.2 ?_).mono_right (pure_le_nhds _)
    -- ‚ä¢ ‚àÄ·∂† (x : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû) in ùìù (‚Üëa, ‚ä§), x.fst - x.snd = 0
    exact ((gt_mem_nhds <| coe_lt_coe.2 <| lt_add_one a).prod_nhds
      (lt_mem_nhds <| @coe_lt_top (a + 1))).mono fun x hx =>
        tsub_eq_zero_iff_le.2 (hx.1.trans hx.2).le
  | (a : ‚Ñù‚â•0), (b : ‚Ñù‚â•0), _ => by
    simp only [nhds_coe_coe, tendsto_map'_iff, ‚Üê ENNReal.coe_sub, (¬∑ ‚àò ¬∑), tendsto_coe]
    -- ‚ä¢ Tendsto (fun a => a.fst - a.snd) (ùìù (a, b)) (ùìù (a - b))
    exact continuous_sub.tendsto (a, b)
    -- üéâ no goals
#align ennreal.tendsto_sub ENNReal.tendsto_sub

protected theorem Tendsto.sub {f : Filter Œ±} {ma : Œ± ‚Üí ‚Ñù‚â•0‚àû} {mb : Œ± ‚Üí ‚Ñù‚â•0‚àû} {a b : ‚Ñù‚â•0‚àû}
    (hma : Tendsto ma f (ùìù a)) (hmb : Tendsto mb f (ùìù b)) (h : a ‚â† ‚àû ‚à® b ‚â† ‚àû) :
    Tendsto (fun a => ma a - mb a) f (ùìù (a - b)) :=
  show Tendsto ((fun p : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû => p.1 - p.2) ‚àò fun a => (ma a, mb a)) f (ùìù (a - b)) from
    Tendsto.comp (ENNReal.tendsto_sub h) (hma.prod_mk_nhds hmb)
#align ennreal.tendsto.sub ENNReal.Tendsto.sub

protected theorem tendsto_mul (ha : a ‚â† 0 ‚à® b ‚â† ‚ä§) (hb : b ‚â† 0 ‚à® a ‚â† ‚ä§) :
    Tendsto (fun p : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû => p.1 * p.2) (ùìù (a, b)) (ùìù (a * b)) := by
  have ht : ‚àÄ b : ‚Ñù‚â•0‚àû, b ‚â† 0 ‚Üí
      Tendsto (fun p : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû => p.1 * p.2) (ùìù ((‚ä§ : ‚Ñù‚â•0‚àû), b)) (ùìù ‚ä§) := fun b hb => by
    refine' tendsto_nhds_top_iff_nnreal.2 fun n => _
    rcases lt_iff_exists_nnreal_btwn.1 (pos_iff_ne_zero.2 hb) with ‚ü®Œµ, hŒµ, hŒµb‚ü©
    have : ‚àÄ·∂† c : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû in ùìù (‚àû, b), ‚Üën / ‚ÜëŒµ < c.1 ‚àß ‚ÜëŒµ < c.2 :=
      (lt_mem_nhds <| div_lt_top coe_ne_top hŒµ.ne').prod_nhds (lt_mem_nhds hŒµb)
    refine' this.mono fun c hc => _
    exact (ENNReal.div_mul_cancel hŒµ.ne' coe_ne_top).symm.trans_lt (mul_lt_mul hc.1 hc.2)
  induction a using recTopCoe with
  | top => simp only [ne_eq, or_false] at hb; simp [ht b hb, top_mul hb]
  | coe a =>
    induction b using recTopCoe with
    | top =>
      simp only [ne_eq, or_false] at ha
      simpa [(¬∑ ‚àò ¬∑), mul_comm, mul_top ha]
        using (ht a ha).comp (continuous_swap.tendsto (some a, ‚ä§))
    | coe b =>
      simp only [nhds_coe_coe, ‚Üê coe_mul, tendsto_coe, tendsto_map'_iff, (¬∑ ‚àò ¬∑), tendsto_mul]
#align ennreal.tendsto_mul ENNReal.tendsto_mul

protected theorem Tendsto.mul {f : Filter Œ±} {ma : Œ± ‚Üí ‚Ñù‚â•0‚àû} {mb : Œ± ‚Üí ‚Ñù‚â•0‚àû} {a b : ‚Ñù‚â•0‚àû}
    (hma : Tendsto ma f (ùìù a)) (ha : a ‚â† 0 ‚à® b ‚â† ‚ä§) (hmb : Tendsto mb f (ùìù b))
    (hb : b ‚â† 0 ‚à® a ‚â† ‚ä§) : Tendsto (fun a => ma a * mb a) f (ùìù (a * b)) :=
  show Tendsto ((fun p : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû => p.1 * p.2) ‚àò fun a => (ma a, mb a)) f (ùìù (a * b)) from
    Tendsto.comp (ENNReal.tendsto_mul ha hb) (hma.prod_mk_nhds hmb)
#align ennreal.tendsto.mul ENNReal.Tendsto.mul

theorem _root_.ContinuousOn.ennreal_mul [TopologicalSpace Œ±] {f g : Œ± ‚Üí ‚Ñù‚â•0‚àû} {s : Set Œ±}
    (hf : ContinuousOn f s) (hg : ContinuousOn g s) (h‚ÇÅ : ‚àÄ x ‚àà s, f x ‚â† 0 ‚à® g x ‚â† ‚àû)
    (h‚ÇÇ : ‚àÄ x ‚àà s, g x ‚â† 0 ‚à® f x ‚â† ‚àû) : ContinuousOn (fun x => f x * g x) s := fun x hx =>
  ENNReal.Tendsto.mul (hf x hx) (h‚ÇÅ x hx) (hg x hx) (h‚ÇÇ x hx)
#align continuous_on.ennreal_mul ContinuousOn.ennreal_mul

theorem _root_.Continuous.ennreal_mul [TopologicalSpace Œ±] {f g : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : Continuous f)
    (hg : Continuous g) (h‚ÇÅ : ‚àÄ x, f x ‚â† 0 ‚à® g x ‚â† ‚àû) (h‚ÇÇ : ‚àÄ x, g x ‚â† 0 ‚à® f x ‚â† ‚àû) :
    Continuous fun x => f x * g x :=
  continuous_iff_continuousAt.2 fun x =>
    ENNReal.Tendsto.mul hf.continuousAt (h‚ÇÅ x) hg.continuousAt (h‚ÇÇ x)
#align continuous.ennreal_mul Continuous.ennreal_mul

protected theorem Tendsto.const_mul {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù‚â•0‚àû} {a b : ‚Ñù‚â•0‚àû}
    (hm : Tendsto m f (ùìù b)) (hb : b ‚â† 0 ‚à® a ‚â† ‚ä§) : Tendsto (fun b => a * m b) f (ùìù (a * b)) :=
  by_cases (fun (this : a = 0) => by simp [this, tendsto_const_nhds]) fun ha : a ‚â† 0 =>
                                     -- üéâ no goals
    ENNReal.Tendsto.mul tendsto_const_nhds (Or.inl ha) hm hb
#align ennreal.tendsto.const_mul ENNReal.Tendsto.const_mul

protected theorem Tendsto.mul_const {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù‚â•0‚àû} {a b : ‚Ñù‚â•0‚àû}
    (hm : Tendsto m f (ùìù a)) (ha : a ‚â† 0 ‚à® b ‚â† ‚ä§) : Tendsto (fun x => m x * b) f (ùìù (a * b)) := by
  simpa only [mul_comm] using ENNReal.Tendsto.const_mul hm ha
  -- üéâ no goals
#align ennreal.tendsto.mul_const ENNReal.Tendsto.mul_const

theorem tendsto_finset_prod_of_ne_top {Œπ : Type*} {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {x : Filter Œ±} {a : Œπ ‚Üí ‚Ñù‚â•0‚àû}
    (s : Finset Œπ) (h : ‚àÄ i ‚àà s, Tendsto (f i) x (ùìù (a i))) (h' : ‚àÄ i ‚àà s, a i ‚â† ‚àû) :
    Tendsto (fun b => ‚àè c in s, f c b) x (ùìù (‚àè c in s, a c)) := by
  induction' s using Finset.induction with a s has IH
  -- ‚ä¢ Tendsto (fun b => ‚àè c in ‚àÖ, f c b) x (ùìù (‚àè c in ‚àÖ, a c))
  ¬∑ simp [tendsto_const_nhds]
    -- üéâ no goals
  simp only [Finset.prod_insert has]
  -- ‚ä¢ Tendsto (fun b => f a b * ‚àè c in s, f c b) x (ùìù (a‚úù a * ‚àè c in s, a‚úù c))
  apply Tendsto.mul (h _ (Finset.mem_insert_self _ _))
  ¬∑ right
    -- ‚ä¢ ‚àè c in s, a‚úù c ‚â† ‚ä§
    exact (prod_lt_top fun i hi => h' _ (Finset.mem_insert_of_mem hi)).ne
    -- üéâ no goals
  ¬∑ exact IH (fun i hi => h _ (Finset.mem_insert_of_mem hi)) fun i hi =>
      h' _ (Finset.mem_insert_of_mem hi)
  ¬∑ exact Or.inr (h' _ (Finset.mem_insert_self _ _))
    -- üéâ no goals
#align ennreal.tendsto_finset_prod_of_ne_top ENNReal.tendsto_finset_prod_of_ne_top

protected theorem continuousAt_const_mul {a b : ‚Ñù‚â•0‚àû} (h : a ‚â† ‚ä§ ‚à® b ‚â† 0) :
    ContinuousAt ((¬∑ * ¬∑) a) b :=
  Tendsto.const_mul tendsto_id h.symm
#align ennreal.continuous_at_const_mul ENNReal.continuousAt_const_mul

protected theorem continuousAt_mul_const {a b : ‚Ñù‚â•0‚àû} (h : a ‚â† ‚ä§ ‚à® b ‚â† 0) :
    ContinuousAt (fun x => x * a) b :=
  Tendsto.mul_const tendsto_id h.symm
#align ennreal.continuous_at_mul_const ENNReal.continuousAt_mul_const

protected theorem continuous_const_mul {a : ‚Ñù‚â•0‚àû} (ha : a ‚â† ‚ä§) : Continuous ((¬∑ * ¬∑) a) :=
  continuous_iff_continuousAt.2 fun _ => ENNReal.continuousAt_const_mul (Or.inl ha)
#align ennreal.continuous_const_mul ENNReal.continuous_const_mul

protected theorem continuous_mul_const {a : ‚Ñù‚â•0‚àû} (ha : a ‚â† ‚ä§) : Continuous fun x => x * a :=
  continuous_iff_continuousAt.2 fun _ => ENNReal.continuousAt_mul_const (Or.inl ha)
#align ennreal.continuous_mul_const ENNReal.continuous_mul_const

protected theorem continuous_div_const (c : ‚Ñù‚â•0‚àû) (c_ne_zero : c ‚â† 0) :
    Continuous fun x : ‚Ñù‚â•0‚àû => x / c := by
  simp_rw [div_eq_mul_inv, continuous_iff_continuousAt]
  -- ‚ä¢ ‚àÄ (x : ‚Ñù‚â•0‚àû), ContinuousAt (fun x => x * c‚Åª¬π) x
  intro x
  -- ‚ä¢ ContinuousAt (fun x => x * c‚Åª¬π) x
  exact ENNReal.continuousAt_mul_const (Or.intro_left _ (inv_ne_top.mpr c_ne_zero))
  -- üéâ no goals
#align ennreal.continuous_div_const ENNReal.continuous_div_const

@[continuity]
theorem continuous_pow (n : ‚Ñï) : Continuous fun a : ‚Ñù‚â•0‚àû => a ^ n := by
  induction' n with n IH
  -- ‚ä¢ Continuous fun a => a ^ Nat.zero
  ¬∑ simp [continuous_const]
    -- üéâ no goals
  simp_rw [Nat.succ_eq_add_one, pow_add, pow_one, continuous_iff_continuousAt]
  -- ‚ä¢ ‚àÄ (x : ‚Ñù‚â•0‚àû), ContinuousAt (fun a => a ^ n * a) x
  intro x
  -- ‚ä¢ ContinuousAt (fun a => a ^ n * a) x
  refine' ENNReal.Tendsto.mul (IH.tendsto _) _ tendsto_id _ <;> by_cases H : x = 0
  -- ‚ä¢ x ^ n ‚â† 0 ‚à® x ‚â† ‚ä§
                                                                -- ‚ä¢ x ^ n ‚â† 0 ‚à® x ‚â† ‚ä§
                                                                -- ‚ä¢ x ‚â† 0 ‚à® x ^ n ‚â† ‚ä§
  ¬∑ simp only [H, zero_ne_top, Ne.def, or_true_iff, not_false_iff]
    -- üéâ no goals
  ¬∑ exact Or.inl fun h => H (pow_eq_zero h)
    -- üéâ no goals
  ¬∑ simp only [H, pow_eq_top_iff, zero_ne_top, false_or_iff, eq_self_iff_true, not_true, Ne.def,
      not_false_iff, false_and_iff]
  ¬∑ simp only [H, true_or_iff, Ne.def, not_false_iff]
    -- üéâ no goals
#align ennreal.continuous_pow ENNReal.continuous_pow

theorem continuousOn_sub :
    ContinuousOn (fun p : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû => p.fst - p.snd) { p : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû | p ‚â† ‚ü®‚àû, ‚àû‚ü© } := by
  rw [ContinuousOn]
  -- ‚ä¢ ‚àÄ (x : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû), x ‚àà {p | p ‚â† (‚ä§, ‚ä§)} ‚Üí ContinuousWithinAt (fun p => p.f ‚Ä¶
  rintro ‚ü®x, y‚ü© hp
  -- ‚ä¢ ContinuousWithinAt (fun p => p.fst - p.snd) {p | p ‚â† (‚ä§, ‚ä§)} (x, y)
  simp only [Ne.def, Set.mem_setOf_eq, Prod.mk.inj_iff] at hp
  -- ‚ä¢ ContinuousWithinAt (fun p => p.fst - p.snd) {p | p ‚â† (‚ä§, ‚ä§)} (x, y)
  refine' tendsto_nhdsWithin_of_tendsto_nhds (tendsto_sub (not_and_or.mp hp))
  -- üéâ no goals
#align ennreal.continuous_on_sub ENNReal.continuousOn_sub

theorem continuous_sub_left {a : ‚Ñù‚â•0‚àû} (a_ne_top : a ‚â† ‚ä§) : Continuous (a - ¬∑) := by
  change Continuous (Function.uncurry Sub.sub ‚àò (a, ¬∑))
  -- ‚ä¢ Continuous (uncurry Sub.sub ‚àò fun x => (a, x))
  refine continuousOn_sub.comp_continuous (Continuous.Prod.mk a) fun x => ?_
  -- ‚ä¢ (a, x) ‚àà {p | p ‚â† (‚ä§, ‚ä§)}
  simp only [a_ne_top, Ne.def, mem_setOf_eq, Prod.mk.inj_iff, false_and_iff, not_false_iff]
  -- üéâ no goals
#align ennreal.continuous_sub_left ENNReal.continuous_sub_left

theorem continuous_nnreal_sub {a : ‚Ñù‚â•0} : Continuous fun x : ‚Ñù‚â•0‚àû => (a : ‚Ñù‚â•0‚àû) - x :=
  continuous_sub_left coe_ne_top
#align ennreal.continuous_nnreal_sub ENNReal.continuous_nnreal_sub

theorem continuousOn_sub_left (a : ‚Ñù‚â•0‚àû) : ContinuousOn (a - ¬∑) { x : ‚Ñù‚â•0‚àû | x ‚â† ‚àû } := by
  rw [show (fun x => a - x) = (fun p : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû => p.fst - p.snd) ‚àò fun x => ‚ü®a, x‚ü© by rfl]
  -- ‚ä¢ ContinuousOn ((fun p => p.fst - p.snd) ‚àò fun x => (a, x)) {x | x ‚â† ‚ä§}
  apply ContinuousOn.comp continuousOn_sub (Continuous.continuousOn (Continuous.Prod.mk a))
  -- ‚ä¢ MapsTo (fun b => (a, b)) {x | x ‚â† ‚ä§} {p | p ‚â† (‚ä§, ‚ä§)}
  rintro _ h (_ | _)
  -- ‚ä¢ False
  exact h none_eq_top
  -- üéâ no goals
#align ennreal.continuous_on_sub_left ENNReal.continuousOn_sub_left

theorem continuous_sub_right (a : ‚Ñù‚â•0‚àû) : Continuous fun x : ‚Ñù‚â•0‚àû => x - a := by
  by_cases a_infty : a = ‚àû
  -- ‚ä¢ Continuous fun x => x - a
  ¬∑ simp [a_infty, continuous_const]
    -- üéâ no goals
  ¬∑ rw [show (fun x => x - a) = (fun p : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû => p.fst - p.snd) ‚àò fun x => ‚ü®x, a‚ü© by rfl]
    -- ‚ä¢ Continuous ((fun p => p.fst - p.snd) ‚àò fun x => (x, a))
    apply ContinuousOn.comp_continuous continuousOn_sub (continuous_id'.prod_mk continuous_const)
    -- ‚ä¢ ‚àÄ (x : ‚Ñù‚â•0‚àû), (x, a) ‚àà {p | p ‚â† (‚ä§, ‚ä§)}
    intro x
    -- ‚ä¢ (x, a) ‚àà {p | p ‚â† (‚ä§, ‚ä§)}
    simp only [a_infty, Ne.def, mem_setOf_eq, Prod.mk.inj_iff, and_false_iff, not_false_iff]
    -- üéâ no goals
#align ennreal.continuous_sub_right ENNReal.continuous_sub_right

protected theorem Tendsto.pow {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû} {n : ‚Ñï}
    (hm : Tendsto m f (ùìù a)) : Tendsto (fun x => m x ^ n) f (ùìù (a ^ n)) :=
  ((continuous_pow n).tendsto a).comp hm
#align ennreal.tendsto.pow ENNReal.Tendsto.pow

theorem le_of_forall_lt_one_mul_le {x y : ‚Ñù‚â•0‚àû} (h : ‚àÄ a < 1, a * x ‚â§ y) : x ‚â§ y := by
  have : Tendsto (¬∑ * x) (ùìù[<] 1) (ùìù (1 * x)) :=
    (ENNReal.continuousAt_mul_const (Or.inr one_ne_zero)).mono_left inf_le_left
  rw [one_mul] at this
  -- ‚ä¢ x ‚â§ y
  exact le_of_tendsto this (eventually_nhdsWithin_iff.2 <| eventually_of_forall h)
  -- üéâ no goals
#align ennreal.le_of_forall_lt_one_mul_le ENNReal.le_of_forall_lt_one_mul_le

theorem iInf_mul_left' {Œπ} {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû} (h : a = ‚ä§ ‚Üí ‚®Ö i, f i = 0 ‚Üí ‚àÉ i, f i = 0)
    (h0 : a = 0 ‚Üí Nonempty Œπ) : ‚®Ö i, a * f i = a * ‚®Ö i, f i := by
  by_cases H : a = ‚ä§ ‚àß ‚®Ö i, f i = 0
  -- ‚ä¢ ‚®Ö (i : Œπ), a * f i = a * ‚®Ö (i : Œπ), f i
  ¬∑ rcases h H.1 H.2 with ‚ü®i, hi‚ü©
    -- ‚ä¢ ‚®Ö (i : Œπ), a * f i = a * ‚®Ö (i : Œπ), f i
    rw [H.2, mul_zero, ‚Üê bot_eq_zero, iInf_eq_bot]
    -- ‚ä¢ ‚àÄ (b : ‚Ñù‚â•0‚àû), b > ‚ä• ‚Üí ‚àÉ i, a * f i < b
    exact fun b hb => ‚ü®i, by rwa [hi, mul_zero, ‚Üê bot_eq_zero]‚ü©
    -- üéâ no goals
  ¬∑ rw [not_and_or] at H
    -- ‚ä¢ ‚®Ö (i : Œπ), a * f i = a * ‚®Ö (i : Œπ), f i
    cases isEmpty_or_nonempty Œπ
    -- ‚ä¢ ‚®Ö (i : Œπ), a * f i = a * ‚®Ö (i : Œπ), f i
    ¬∑ rw [iInf_of_empty, iInf_of_empty, mul_top]
      -- ‚ä¢ a ‚â† 0
      exact mt h0 (not_nonempty_iff.2 ‚Äπ_‚Ä∫)
      -- üéâ no goals
    ¬∑ exact (ENNReal.mul_left_mono.map_iInf_of_continuousAt'
        (ENNReal.continuousAt_const_mul H)).symm
#align ennreal.infi_mul_left' ENNReal.iInf_mul_left'

theorem iInf_mul_left {Œπ} [Nonempty Œπ] {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû}
    (h : a = ‚ä§ ‚Üí ‚®Ö i, f i = 0 ‚Üí ‚àÉ i, f i = 0) : ‚®Ö i, a * f i = a * ‚®Ö i, f i :=
  iInf_mul_left' h fun _ => ‚ÄπNonempty Œπ‚Ä∫
#align ennreal.infi_mul_left ENNReal.iInf_mul_left

theorem iInf_mul_right' {Œπ} {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû} (h : a = ‚ä§ ‚Üí ‚®Ö i, f i = 0 ‚Üí ‚àÉ i, f i = 0)
    (h0 : a = 0 ‚Üí Nonempty Œπ) : ‚®Ö i, f i * a = (‚®Ö i, f i) * a := by
  simpa only [mul_comm a] using iInf_mul_left' h h0
  -- üéâ no goals
#align ennreal.infi_mul_right' ENNReal.iInf_mul_right'

theorem iInf_mul_right {Œπ} [Nonempty Œπ] {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû}
    (h : a = ‚ä§ ‚Üí ‚®Ö i, f i = 0 ‚Üí ‚àÉ i, f i = 0) : ‚®Ö i, f i * a = (‚®Ö i, f i) * a :=
  iInf_mul_right' h fun _ => ‚ÄπNonempty Œπ‚Ä∫
#align ennreal.infi_mul_right ENNReal.iInf_mul_right

theorem inv_map_iInf {Œπ : Sort*} {x : Œπ ‚Üí ‚Ñù‚â•0‚àû} : (iInf x)‚Åª¬π = ‚®Ü i, (x i)‚Åª¬π :=
  OrderIso.invENNReal.map_iInf x
#align ennreal.inv_map_infi ENNReal.inv_map_iInf

theorem inv_map_iSup {Œπ : Sort*} {x : Œπ ‚Üí ‚Ñù‚â•0‚àû} : (iSup x)‚Åª¬π = ‚®Ö i, (x i)‚Åª¬π :=
  OrderIso.invENNReal.map_iSup x
#align ennreal.inv_map_supr ENNReal.inv_map_iSup

theorem inv_limsup {Œπ : Sort _} {x : Œπ ‚Üí ‚Ñù‚â•0‚àû} {l : Filter Œπ} :
    (limsup x l)‚Åª¬π = liminf (fun i => (x i)‚Åª¬π) l :=
  OrderIso.invENNReal.limsup_apply
#align ennreal.inv_limsup ENNReal.inv_limsup

theorem inv_liminf {Œπ : Sort _} {x : Œπ ‚Üí ‚Ñù‚â•0‚àû} {l : Filter Œπ} :
    (liminf x l)‚Åª¬π = limsup (fun i => (x i)‚Åª¬π) l :=
  OrderIso.invENNReal.liminf_apply
#align ennreal.inv_liminf ENNReal.inv_liminf

instance : ContinuousInv ‚Ñù‚â•0‚àû := ‚ü®OrderIso.invENNReal.continuous‚ü©

@[simp] -- porting note: todo: generalize to `[InvolutiveInv _] [ContinuousInv _]`
protected theorem tendsto_inv_iff {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû} :
    Tendsto (fun x => (m x)‚Åª¬π) f (ùìù a‚Åª¬π) ‚Üî Tendsto m f (ùìù a) :=
  ‚ü®fun h => by simpa only [inv_inv] using Tendsto.inv h, Tendsto.inv‚ü©
               -- üéâ no goals
#align ennreal.tendsto_inv_iff ENNReal.tendsto_inv_iff

protected theorem Tendsto.div {f : Filter Œ±} {ma : Œ± ‚Üí ‚Ñù‚â•0‚àû} {mb : Œ± ‚Üí ‚Ñù‚â•0‚àû} {a b : ‚Ñù‚â•0‚àû}
    (hma : Tendsto ma f (ùìù a)) (ha : a ‚â† 0 ‚à® b ‚â† 0) (hmb : Tendsto mb f (ùìù b))
    (hb : b ‚â† ‚ä§ ‚à® a ‚â† ‚ä§) : Tendsto (fun a => ma a / mb a) f (ùìù (a / b)) := by
  apply Tendsto.mul hma _ (ENNReal.tendsto_inv_iff.2 hmb) _ <;> simp [ha, hb]
  -- ‚ä¢ a ‚â† 0 ‚à® b‚Åª¬π ‚â† ‚ä§
                                                                -- üéâ no goals
                                                                -- üéâ no goals
#align ennreal.tendsto.div ENNReal.Tendsto.div

protected theorem Tendsto.const_div {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù‚â•0‚àû} {a b : ‚Ñù‚â•0‚àû}
    (hm : Tendsto m f (ùìù b)) (hb : b ‚â† ‚ä§ ‚à® a ‚â† ‚ä§) : Tendsto (fun b => a / m b) f (ùìù (a / b)) := by
  apply Tendsto.const_mul (ENNReal.tendsto_inv_iff.2 hm)
  -- ‚ä¢ b‚Åª¬π ‚â† 0 ‚à® a ‚â† ‚ä§
  simp [hb]
  -- üéâ no goals
#align ennreal.tendsto.const_div ENNReal.Tendsto.const_div

protected theorem Tendsto.div_const {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù‚â•0‚àû} {a b : ‚Ñù‚â•0‚àû}
    (hm : Tendsto m f (ùìù a)) (ha : a ‚â† 0 ‚à® b ‚â† 0) : Tendsto (fun x => m x / b) f (ùìù (a / b)) := by
  apply Tendsto.mul_const hm
  -- ‚ä¢ a ‚â† 0 ‚à® b‚Åª¬π ‚â† ‚ä§
  simp [ha]
  -- üéâ no goals
#align ennreal.tendsto.div_const ENNReal.Tendsto.div_const

protected theorem tendsto_inv_nat_nhds_zero : Tendsto (fun n : ‚Ñï => (n : ‚Ñù‚â•0‚àû)‚Åª¬π) atTop (ùìù 0) :=
  ENNReal.inv_top ‚ñ∏ ENNReal.tendsto_inv_iff.2 tendsto_nat_nhds_top
#align ennreal.tendsto_inv_nat_nhds_zero ENNReal.tendsto_inv_nat_nhds_zero

theorem iSup_add {Œπ : Sort*} {s : Œπ ‚Üí ‚Ñù‚â•0‚àû} [Nonempty Œπ] : iSup s + a = ‚®Ü b, s b + a :=
  Monotone.map_iSup_of_continuousAt' (continuousAt_id.add continuousAt_const) <|
    monotone_id.add monotone_const
#align ennreal.supr_add ENNReal.iSup_add

theorem biSup_add' {Œπ : Sort*} {p : Œπ ‚Üí Prop} (h : ‚àÉ i, p i) {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} :
    (‚®Ü (i) (_ : p i), f i) + a = ‚®Ü (i) (_ : p i), f i + a := by
  haveI : Nonempty { i // p i } := nonempty_subtype.2 h
  -- ‚ä¢ (‚®Ü (i : Œπ) (_ : p i), f i) + a = ‚®Ü (i : Œπ) (_ : p i), f i + a
  simp only [iSup_subtype', iSup_add]
  -- üéâ no goals
#align ennreal.bsupr_add' ENNReal.biSup_add'

theorem add_biSup' {Œπ : Sort*} {p : Œπ ‚Üí Prop} (h : ‚àÉ i, p i) {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} :
    (a + ‚®Ü (i) (_ : p i), f i) = ‚®Ü (i) (_ : p i), a + f i := by
  simp only [add_comm a, biSup_add' h]
  -- üéâ no goals
#align ennreal.add_bsupr' ENNReal.add_biSup'

theorem biSup_add {Œπ} {s : Set Œπ} (hs : s.Nonempty) {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} :
    (‚®Ü i ‚àà s, f i) + a = ‚®Ü i ‚àà s, f i + a :=
  biSup_add' hs
#align ennreal.bsupr_add ENNReal.biSup_add

theorem add_biSup {Œπ} {s : Set Œπ} (hs : s.Nonempty) {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} :
    (a + ‚®Ü i ‚àà s, f i) = ‚®Ü i ‚àà s, a + f i :=
  add_biSup' hs
#align ennreal.add_bsupr ENNReal.add_biSup

theorem sSup_add {s : Set ‚Ñù‚â•0‚àû} (hs : s.Nonempty) : sSup s + a = ‚®Ü b ‚àà s, b + a := by
  rw [sSup_eq_iSup, biSup_add hs]
  -- üéâ no goals
#align ennreal.Sup_add ENNReal.sSup_add

theorem add_iSup {Œπ : Sort*} {s : Œπ ‚Üí ‚Ñù‚â•0‚àû} [Nonempty Œπ] : a + iSup s = ‚®Ü b, a + s b := by
  rw [add_comm, iSup_add]; simp [add_comm]
  -- ‚ä¢ ‚®Ü (b : Œπ), s b + a = ‚®Ü (b : Œπ), a + s b
                           -- üéâ no goals
#align ennreal.add_supr ENNReal.add_iSup

theorem iSup_add_iSup_le {Œπ Œπ' : Sort*} [Nonempty Œπ] [Nonempty Œπ'] {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} {g : Œπ' ‚Üí ‚Ñù‚â•0‚àû}
    {a : ‚Ñù‚â•0‚àû} (h : ‚àÄ i j, f i + g j ‚â§ a) : iSup f + iSup g ‚â§ a := by
  simp_rw [iSup_add, add_iSup]; exact iSup‚ÇÇ_le h
  -- ‚ä¢ ‚®Ü (b : Œπ) (b_1 : Œπ'), f b + g b_1 ‚â§ a
                                -- üéâ no goals
#align ennreal.supr_add_supr_le ENNReal.iSup_add_iSup_le

theorem biSup_add_biSup_le' {Œπ Œπ'} {p : Œπ ‚Üí Prop} {q : Œπ' ‚Üí Prop} (hp : ‚àÉ i, p i) (hq : ‚àÉ j, q j)
    {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} {g : Œπ' ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû} (h : ‚àÄ i, p i ‚Üí ‚àÄ j, q j ‚Üí f i + g j ‚â§ a) :
    ((‚®Ü (i) (_ : p i), f i) + ‚®Ü (j) (_ : q j), g j) ‚â§ a := by
  simp_rw [biSup_add' hp, add_biSup' hq]
  -- ‚ä¢ ‚®Ü (i : Œπ) (_ : p i) (i_1 : Œπ') (_ : q i_1), f i + g i_1 ‚â§ a
  exact iSup‚ÇÇ_le fun i hi => iSup‚ÇÇ_le (h i hi)
  -- üéâ no goals
#align ennreal.bsupr_add_bsupr_le' ENNReal.biSup_add_biSup_le'

theorem biSup_add_biSup_le {Œπ Œπ'} {s : Set Œπ} {t : Set Œπ'} (hs : s.Nonempty) (ht : t.Nonempty)
    {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} {g : Œπ' ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû} (h : ‚àÄ i ‚àà s, ‚àÄ j ‚àà t, f i + g j ‚â§ a) :
    ((‚®Ü i ‚àà s, f i) + ‚®Ü j ‚àà t, g j) ‚â§ a :=
  biSup_add_biSup_le' hs ht h
#align ennreal.bsupr_add_bsupr_le ENNReal.biSup_add_biSup_le

theorem iSup_add_iSup {Œπ : Sort*} {f g : Œπ ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ i j, ‚àÉ k, f i + g j ‚â§ f k + g k) :
    iSup f + iSup g = ‚®Ü a, f a + g a := by
  cases isEmpty_or_nonempty Œπ
  -- ‚ä¢ iSup f + iSup g = ‚®Ü (a : Œπ), f a + g a
  ¬∑ simp only [iSup_of_empty, bot_eq_zero, zero_add]
    -- üéâ no goals
  ¬∑ refine' le_antisymm _ (iSup_le fun a => add_le_add (le_iSup _ _) (le_iSup _ _))
    -- ‚ä¢ iSup f + iSup g ‚â§ ‚®Ü (a : Œπ), f a + g a
    refine' iSup_add_iSup_le fun i j => _
    -- ‚ä¢ f i + g j ‚â§ ‚®Ü (a : Œπ), f a + g a
    rcases h i j with ‚ü®k, hk‚ü©
    -- ‚ä¢ f i + g j ‚â§ ‚®Ü (a : Œπ), f a + g a
    exact le_iSup_of_le k hk
    -- üéâ no goals
#align ennreal.supr_add_supr ENNReal.iSup_add_iSup

theorem iSup_add_iSup_of_monotone {Œπ : Type*} [SemilatticeSup Œπ] {f g : Œπ ‚Üí ‚Ñù‚â•0‚àû} (hf : Monotone f)
    (hg : Monotone g) : iSup f + iSup g = ‚®Ü a, f a + g a :=
  iSup_add_iSup fun i j => ‚ü®i ‚äî j, add_le_add (hf <| le_sup_left) (hg <| le_sup_right)‚ü©
#align ennreal.supr_add_supr_of_monotone ENNReal.iSup_add_iSup_of_monotone

theorem finset_sum_iSup_nat {Œ±} {Œπ} [SemilatticeSup Œπ] {s : Finset Œ±} {f : Œ± ‚Üí Œπ ‚Üí ‚Ñù‚â•0‚àû}
    (hf : ‚àÄ a, Monotone (f a)) : (‚àë a in s, iSup (f a)) = ‚®Ü n, ‚àë a in s, f a n := by
  refine' Finset.induction_on s _ _
  -- ‚ä¢ ‚àë a in ‚àÖ, iSup (f a) = ‚®Ü (n : Œπ), ‚àë a in ‚àÖ, f a n
  ¬∑ simp
    -- üéâ no goals
  ¬∑ intro a s has ih
    -- ‚ä¢ ‚àë a in insert a s, iSup (f a) = ‚®Ü (n : Œπ), ‚àë a in insert a s, f a n
    simp only [Finset.sum_insert has]
    -- ‚ä¢ iSup (f a) + ‚àë a in s, iSup (f a) = ‚®Ü (n : Œπ), f a n + ‚àë a in s, f a n
    rw [ih, iSup_add_iSup_of_monotone (hf a)]
    -- ‚ä¢ Monotone fun n => ‚àë a in s, f a n
    intro i j h
    -- ‚ä¢ (fun n => ‚àë a in s, f a n) i ‚â§ (fun n => ‚àë a in s, f a n) j
    exact Finset.sum_le_sum fun a _ => hf a h
    -- üéâ no goals
#align ennreal.finset_sum_supr_nat ENNReal.finset_sum_iSup_nat

theorem mul_iSup {Œπ : Sort*} {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû} : a * iSup f = ‚®Ü i, a * f i := by
  by_cases hf : ‚àÄ i, f i = 0
  -- ‚ä¢ a * iSup f = ‚®Ü (i : Œπ), a * f i
  ¬∑ obtain rfl : f = fun _ => 0
    -- ‚ä¢ f = fun x => 0
    exact funext hf
    -- ‚ä¢ a * ‚®Ü (x : Œπ), 0 = ‚®Ü (i : Œπ), a * (fun x => 0) i
    simp only [iSup_zero_eq_zero, mul_zero]
    -- üéâ no goals
  ¬∑ refine' (monotone_id.const_mul' _).map_iSup_of_continuousAt _ (mul_zero a)
    -- ‚ä¢ ContinuousAt (fun x => a * id x) (‚®Ü (i : Œπ), f i)
    refine' ENNReal.Tendsto.const_mul tendsto_id (Or.inl _)
    -- ‚ä¢ id (‚®Ü (i : Œπ), f i) ‚â† 0
    exact mt iSup_eq_zero.1 hf
    -- üéâ no goals
#align ennreal.mul_supr ENNReal.mul_iSup

theorem mul_sSup {s : Set ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû} : a * sSup s = ‚®Ü i ‚àà s, a * i := by
  simp only [sSup_eq_iSup, mul_iSup]
  -- üéâ no goals
#align ennreal.mul_Sup ENNReal.mul_sSup

theorem iSup_mul {Œπ : Sort*} {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû} : iSup f * a = ‚®Ü i, f i * a := by
  rw [mul_comm, mul_iSup]; congr; funext; rw [mul_comm]
  -- ‚ä¢ ‚®Ü (i : Œπ), a * f i = ‚®Ü (i : Œπ), f i * a
                           -- ‚ä¢ (fun i => a * f i) = fun i => f i * a
                                  -- ‚ä¢ a * f x‚úù = f x‚úù * a
                                          -- üéâ no goals
#align ennreal.supr_mul ENNReal.iSup_mul

theorem smul_iSup {Œπ : Sort*} {R} [SMul R ‚Ñù‚â•0‚àû] [IsScalarTower R ‚Ñù‚â•0‚àû ‚Ñù‚â•0‚àû] (f : Œπ ‚Üí ‚Ñù‚â•0‚àû)
    (c : R) : (c ‚Ä¢ ‚®Ü i, f i) = ‚®Ü i, c ‚Ä¢ f i := by
  -- Porting note: replaced `iSup _` with `iSup f`
  simp only [‚Üê smul_one_mul c (f _), ‚Üê smul_one_mul c (iSup f), ENNReal.mul_iSup]
  -- üéâ no goals
#align ennreal.smul_supr ENNReal.smul_iSup

theorem smul_sSup {R} [SMul R ‚Ñù‚â•0‚àû] [IsScalarTower R ‚Ñù‚â•0‚àû ‚Ñù‚â•0‚àû] (s : Set ‚Ñù‚â•0‚àû) (c : R) :
    c ‚Ä¢ sSup s = ‚®Ü i ‚àà s, c ‚Ä¢ i := by
  -- Porting note: replaced `_` with `s`
  simp_rw [‚Üê smul_one_mul c (sSup s), ENNReal.mul_sSup, smul_one_mul]
  -- üéâ no goals
#align ennreal.smul_Sup ENNReal.smul_sSup

theorem iSup_div {Œπ : Sort*} {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû} : iSup f / a = ‚®Ü i, f i / a :=
  iSup_mul
#align ennreal.supr_div ENNReal.iSup_div

protected theorem tendsto_coe_sub {b : ‚Ñù‚â•0‚àû} :
    Tendsto (fun b : ‚Ñù‚â•0‚àû => ‚Üër - b) (ùìù b) (ùìù (‚Üër - b)) :=
  continuous_nnreal_sub.tendsto _
#align ennreal.tendsto_coe_sub ENNReal.tendsto_coe_sub

theorem sub_iSup {Œπ : Sort*} [Nonempty Œπ] {b : Œπ ‚Üí ‚Ñù‚â•0‚àû} (hr : a < ‚ä§) :
    (a - ‚®Ü i, b i) = ‚®Ö i, a - b i :=
  antitone_const_tsub.map_iSup_of_continuousAt' (continuous_sub_left hr.ne).continuousAt
#align ennreal.sub_supr ENNReal.sub_iSup

theorem exists_countable_dense_no_zero_top :
    ‚àÉ s : Set ‚Ñù‚â•0‚àû, s.Countable ‚àß Dense s ‚àß 0 ‚àâ s ‚àß ‚àû ‚àâ s := by
  obtain ‚ü®s, s_count, s_dense, hs‚ü© :
    ‚àÉ s : Set ‚Ñù‚â•0‚àû, s.Countable ‚àß Dense s ‚àß (‚àÄ x, IsBot x ‚Üí x ‚àâ s) ‚àß ‚àÄ x, IsTop x ‚Üí x ‚àâ s :=
    exists_countable_dense_no_bot_top ‚Ñù‚â•0‚àû
  exact ‚ü®s, s_count, s_dense, fun h => hs.1 0 (by simp) h, fun h => hs.2 ‚àû (by simp) h‚ü©
  -- üéâ no goals
#align ennreal.exists_countable_dense_no_zero_top ENNReal.exists_countable_dense_no_zero_top

theorem exists_lt_add_of_lt_add {x y z : ‚Ñù‚â•0‚àû} (h : x < y + z) (hy : y ‚â† 0) (hz : z ‚â† 0) :
    ‚àÉ y' z', y' < y ‚àß z' < z ‚àß x < y' + z' := by
  have : NeZero y := ‚ü®hy‚ü©
  -- ‚ä¢ ‚àÉ y' z', y' < y ‚àß z' < z ‚àß x < y' + z'
  have : NeZero z := ‚ü®hz‚ü©
  -- ‚ä¢ ‚àÉ y' z', y' < y ‚àß z' < z ‚àß x < y' + z'
  have A : Tendsto (fun p : ‚Ñù‚â•0‚àû √ó ‚Ñù‚â•0‚àû => p.1 + p.2) (ùìù[<] y √óÀ¢ ùìù[<] z) (ùìù (y + z)) := by
    apply Tendsto.mono_left _ (Filter.prod_mono nhdsWithin_le_nhds nhdsWithin_le_nhds)
    rw [‚Üê nhds_prod_eq]
    exact tendsto_add
  rcases ((A.eventually (lt_mem_nhds h)).and
      (Filter.prod_mem_prod self_mem_nhdsWithin self_mem_nhdsWithin)).exists with
    ‚ü®‚ü®y', z'‚ü©, hx, hy', hz'‚ü©
  exact ‚ü®y', z', hy', hz', hx‚ü©
  -- üéâ no goals
#align ennreal.exists_lt_add_of_lt_add ENNReal.exists_lt_add_of_lt_add

end TopologicalSpace

section Liminf

theorem exists_frequently_lt_of_liminf_ne_top {Œπ : Type*} {l : Filter Œπ} {x : Œπ ‚Üí ‚Ñù}
    (hx : liminf (fun n => (Real.nnabs (x n) : ‚Ñù‚â•0‚àû)) l ‚â† ‚àû) : ‚àÉ R, ‚àÉ·∂† n in l, x n < R := by
  by_contra h
  -- ‚ä¢ False
  simp_rw [not_exists, not_frequently, not_lt] at h
  -- ‚ä¢ False
  refine hx (ENNReal.eq_top_of_forall_nnreal_le fun r => le_limsInf_of_le (by isBoundedDefault) ?_)
  -- ‚ä¢ ‚àÄ·∂† (n : ‚Ñù‚â•0‚àû) in map (fun n => ‚Üë(‚ÜëReal.nnabs (x n))) l, ‚Üër ‚â§ n
  simp only [eventually_map, ENNReal.coe_le_coe]
  -- ‚ä¢ ‚àÄ·∂† (a : Œπ) in l, r ‚â§ ‚ÜëReal.nnabs (x a)
  filter_upwards [h r] with i hi using hi.trans (le_abs_self (x i))
  -- üéâ no goals
#align ennreal.exists_frequently_lt_of_liminf_ne_top ENNReal.exists_frequently_lt_of_liminf_ne_top

theorem exists_frequently_lt_of_liminf_ne_top' {Œπ : Type*} {l : Filter Œπ} {x : Œπ ‚Üí ‚Ñù}
    (hx : liminf (fun n => (Real.nnabs (x n) : ‚Ñù‚â•0‚àû)) l ‚â† ‚àû) : ‚àÉ R, ‚àÉ·∂† n in l, R < x n := by
  by_contra h
  -- ‚ä¢ False
  simp_rw [not_exists, not_frequently, not_lt] at h
  -- ‚ä¢ False
  refine hx (ENNReal.eq_top_of_forall_nnreal_le fun r => le_limsInf_of_le (by isBoundedDefault) ?_)
  -- ‚ä¢ ‚àÄ·∂† (n : ‚Ñù‚â•0‚àû) in map (fun n => ‚Üë(‚ÜëReal.nnabs (x n))) l, ‚Üër ‚â§ n
  simp only [eventually_map, ENNReal.coe_le_coe]
  -- ‚ä¢ ‚àÄ·∂† (a : Œπ) in l, r ‚â§ ‚ÜëReal.nnabs (x a)
  filter_upwards [h (-r)]with i hi using(le_neg.1 hi).trans (neg_le_abs_self _)
  -- üéâ no goals
#align ennreal.exists_frequently_lt_of_liminf_ne_top' ENNReal.exists_frequently_lt_of_liminf_ne_top'

theorem exists_upcrossings_of_not_bounded_under {Œπ : Type*} {l : Filter Œπ} {x : Œπ ‚Üí ‚Ñù}
    (hf : liminf (fun i => (Real.nnabs (x i) : ‚Ñù‚â•0‚àû)) l ‚â† ‚àû)
    (hbdd : ¬¨IsBoundedUnder (¬∑ ‚â§ ¬∑) l fun i => |x i|) :
    ‚àÉ a b : ‚Ñö, a < b ‚àß (‚àÉ·∂† i in l, x i < a) ‚àß ‚àÉ·∂† i in l, ‚Üëb < x i := by
  rw [isBoundedUnder_le_abs, not_and_or] at hbdd
  -- ‚ä¢ ‚àÉ a b, a < b ‚àß (‚àÉ·∂† (i : Œπ) in l, x i < ‚Üëa) ‚àß ‚àÉ·∂† (i : Œπ) in l, ‚Üëb < x i
  obtain hbdd | hbdd := hbdd
  -- ‚ä¢ ‚àÉ a b, a < b ‚àß (‚àÉ·∂† (i : Œπ) in l, x i < ‚Üëa) ‚àß ‚àÉ·∂† (i : Œπ) in l, ‚Üëb < x i
  ¬∑ obtain ‚ü®R, hR‚ü© := exists_frequently_lt_of_liminf_ne_top hf
    -- ‚ä¢ ‚àÉ a b, a < b ‚àß (‚àÉ·∂† (i : Œπ) in l, x i < ‚Üëa) ‚àß ‚àÉ·∂† (i : Œπ) in l, ‚Üëb < x i
    obtain ‚ü®q, hq‚ü© := exists_rat_gt R
    -- ‚ä¢ ‚àÉ a b, a < b ‚àß (‚àÉ·∂† (i : Œπ) in l, x i < ‚Üëa) ‚àß ‚àÉ·∂† (i : Œπ) in l, ‚Üëb < x i
    refine' ‚ü®q, q + 1, (lt_add_iff_pos_right _).2 zero_lt_one, _, _‚ü©
    -- ‚ä¢ ‚àÉ·∂† (i : Œπ) in l, x i < ‚Üëq
    ¬∑ refine' fun hcon => hR _
      -- ‚ä¢ ‚àÄ·∂† (x_1 : Œπ) in l, ¬¨(fun n => x n < R) x_1
      filter_upwards [hcon]with x hx using not_lt.2 (lt_of_lt_of_le hq (not_lt.1 hx)).le
      -- üéâ no goals
    ¬∑ simp only [IsBoundedUnder, IsBounded, eventually_map, eventually_atTop, ge_iff_le,
        not_exists, not_forall, not_le, exists_prop] at hbdd
      refine' fun hcon => hbdd ‚Üë(q + 1) _
      -- ‚ä¢ ‚àÄ·∂† (a : Œπ) in l, x a ‚â§ ‚Üë(q + 1)
      filter_upwards [hcon]with x hx using not_lt.1 hx
      -- üéâ no goals
  ¬∑ obtain ‚ü®R, hR‚ü© := exists_frequently_lt_of_liminf_ne_top' hf
    -- ‚ä¢ ‚àÉ a b, a < b ‚àß (‚àÉ·∂† (i : Œπ) in l, x i < ‚Üëa) ‚àß ‚àÉ·∂† (i : Œπ) in l, ‚Üëb < x i
    obtain ‚ü®q, hq‚ü© := exists_rat_lt R
    -- ‚ä¢ ‚àÉ a b, a < b ‚àß (‚àÉ·∂† (i : Œπ) in l, x i < ‚Üëa) ‚àß ‚àÉ·∂† (i : Œπ) in l, ‚Üëb < x i
    refine' ‚ü®q - 1, q, (sub_lt_self_iff _).2 zero_lt_one, _, _‚ü©
    -- ‚ä¢ ‚àÉ·∂† (i : Œπ) in l, x i < ‚Üë(q - 1)
    ¬∑ simp only [IsBoundedUnder, IsBounded, eventually_map, eventually_atTop, ge_iff_le,
        not_exists, not_forall, not_le, exists_prop] at hbdd
      refine' fun hcon => hbdd ‚Üë(q - 1) _
      -- ‚ä¢ ‚àÄ·∂† (a : Œπ) in l, ‚Üë(q - 1) ‚â§ x a
      filter_upwards [hcon]with x hx using not_lt.1 hx
      -- üéâ no goals
    ¬∑ refine' fun hcon => hR _
      -- ‚ä¢ ‚àÄ·∂† (x_1 : Œπ) in l, ¬¨(fun n => R < x n) x_1
      filter_upwards [hcon]with x hx using not_lt.2 ((not_lt.1 hx).trans hq.le)
      -- üéâ no goals
#align ennreal.exists_upcrossings_of_not_bounded_under ENNReal.exists_upcrossings_of_not_bounded_under

end Liminf

section tsum

variable {f g : Œ± ‚Üí ‚Ñù‚â•0‚àû}

@[norm_cast]
protected theorem hasSum_coe {f : Œ± ‚Üí ‚Ñù‚â•0} {r : ‚Ñù‚â•0} :
    HasSum (fun a => (f a : ‚Ñù‚â•0‚àû)) ‚Üër ‚Üî HasSum f r := by
  simp only [HasSum, ‚Üê coe_finset_sum, tendsto_coe]
  -- üéâ no goals
#align ennreal.has_sum_coe ENNReal.hasSum_coe

protected theorem tsum_coe_eq {f : Œ± ‚Üí ‚Ñù‚â•0} (h : HasSum f r) : (‚àë' a, (f a : ‚Ñù‚â•0‚àû)) = r :=
  (ENNReal.hasSum_coe.2 h).tsum_eq
#align ennreal.tsum_coe_eq ENNReal.tsum_coe_eq

protected theorem coe_tsum {f : Œ± ‚Üí ‚Ñù‚â•0} : Summable f ‚Üí ‚Üë(tsum f) = ‚àë' a, (f a : ‚Ñù‚â•0‚àû)
  | ‚ü®r, hr‚ü© => by rw [hr.tsum_eq, ENNReal.tsum_coe_eq hr]
                  -- üéâ no goals
#align ennreal.coe_tsum ENNReal.coe_tsum

protected theorem hasSum : HasSum f (‚®Ü s : Finset Œ±, ‚àë a in s, f a) :=
  tendsto_atTop_iSup fun _ _ => Finset.sum_le_sum_of_subset
#align ennreal.has_sum ENNReal.hasSum

@[simp]
protected theorem summable : Summable f :=
  ‚ü®_, ENNReal.hasSum‚ü©
#align ennreal.summable ENNReal.summable

theorem tsum_coe_ne_top_iff_summable {f : Œ≤ ‚Üí ‚Ñù‚â•0} : (‚àë' b, (f b : ‚Ñù‚â•0‚àû)) ‚â† ‚àû ‚Üî Summable f := by
  refine ‚ü®fun h => ?_, fun h => ENNReal.coe_tsum h ‚ñ∏ ENNReal.coe_ne_top‚ü©
  -- ‚ä¢ Summable f
  lift ‚àë' b, (f b : ‚Ñù‚â•0‚àû) to ‚Ñù‚â•0 using h with a ha
  -- ‚ä¢ Summable f
  refine' ‚ü®a, ENNReal.hasSum_coe.1 _‚ü©
  -- ‚ä¢ HasSum (fun a => ‚Üë(f a)) ‚Üëa
  rw [ha]
  -- ‚ä¢ HasSum (fun a => ‚Üë(f a)) (‚àë' (b : Œ≤), ‚Üë(f b))
  exact ENNReal.summable.hasSum
  -- üéâ no goals
#align ennreal.tsum_coe_ne_top_iff_summable ENNReal.tsum_coe_ne_top_iff_summable

protected theorem tsum_eq_iSup_sum : ‚àë' a, f a = ‚®Ü s : Finset Œ±, ‚àë a in s, f a :=
  ENNReal.hasSum.tsum_eq
#align ennreal.tsum_eq_supr_sum ENNReal.tsum_eq_iSup_sum

protected theorem tsum_eq_iSup_sum' {Œπ : Type*} (s : Œπ ‚Üí Finset Œ±) (hs : ‚àÄ t, ‚àÉ i, t ‚äÜ s i) :
    ‚àë' a, f a = ‚®Ü i, ‚àë a in s i, f a := by
  rw [ENNReal.tsum_eq_iSup_sum]
  -- ‚ä¢ ‚®Ü (s : Finset Œ±), ‚àë a in s, f a = ‚®Ü (i : Œπ), ‚àë a in s i, f a
  symm
  -- ‚ä¢ ‚®Ü (i : Œπ), ‚àë a in s i, f a = ‚®Ü (s : Finset Œ±), ‚àë a in s, f a
  change ‚®Ü i : Œπ, (fun t : Finset Œ± => ‚àë a in t, f a) (s i) = ‚®Ü s : Finset Œ±, ‚àë a in s, f a
  -- ‚ä¢ ‚®Ü (i : Œπ), (fun t => ‚àë a in t, f a) (s i) = ‚®Ü (s : Finset Œ±), ‚àë a in s, f a
  exact (Finset.sum_mono_set f).iSup_comp_eq hs
  -- üéâ no goals
#align ennreal.tsum_eq_supr_sum' ENNReal.tsum_eq_iSup_sum'

protected theorem tsum_sigma {Œ≤ : Œ± ‚Üí Type*} (f : ‚àÄ a, Œ≤ a ‚Üí ‚Ñù‚â•0‚àû) :
    ‚àë' p : Œ£a, Œ≤ a, f p.1 p.2 = ‚àë' (a) (b), f a b :=
  tsum_sigma' (fun _ => ENNReal.summable) ENNReal.summable
#align ennreal.tsum_sigma ENNReal.tsum_sigma

protected theorem tsum_sigma' {Œ≤ : Œ± ‚Üí Type*} (f : (Œ£a, Œ≤ a) ‚Üí ‚Ñù‚â•0‚àû) :
    ‚àë' p : Œ£a, Œ≤ a, f p = ‚àë' (a) (b), f ‚ü®a, b‚ü© :=
  tsum_sigma' (fun _ => ENNReal.summable) ENNReal.summable
#align ennreal.tsum_sigma' ENNReal.tsum_sigma'

protected theorem tsum_prod {f : Œ± ‚Üí Œ≤ ‚Üí ‚Ñù‚â•0‚àû} : ‚àë' p : Œ± √ó Œ≤, f p.1 p.2 = ‚àë' (a) (b), f a b :=
  tsum_prod' ENNReal.summable fun _ => ENNReal.summable
#align ennreal.tsum_prod ENNReal.tsum_prod

protected theorem tsum_prod' {f : Œ± √ó Œ≤ ‚Üí ‚Ñù‚â•0‚àû} : ‚àë' p : Œ± √ó Œ≤, f p = ‚àë' (a) (b), f (a, b) :=
  tsum_prod' ENNReal.summable fun _ => ENNReal.summable
#align ennreal.tsum_prod' ENNReal.tsum_prod'

protected theorem tsum_comm {f : Œ± ‚Üí Œ≤ ‚Üí ‚Ñù‚â•0‚àû} : ‚àë' a, ‚àë' b, f a b = ‚àë' b, ‚àë' a, f a b :=
  tsum_comm' ENNReal.summable (fun _ => ENNReal.summable) fun _ => ENNReal.summable
#align ennreal.tsum_comm ENNReal.tsum_comm

protected theorem tsum_add : ‚àë' a, (f a + g a) = ‚àë' a, f a + ‚àë' a, g a :=
  tsum_add ENNReal.summable ENNReal.summable
#align ennreal.tsum_add ENNReal.tsum_add

protected theorem tsum_le_tsum (h : ‚àÄ a, f a ‚â§ g a) : ‚àë' a, f a ‚â§ ‚àë' a, g a :=
  tsum_le_tsum h ENNReal.summable ENNReal.summable
#align ennreal.tsum_le_tsum ENNReal.tsum_le_tsum

protected theorem sum_le_tsum {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (s : Finset Œ±) : ‚àë x in s, f x ‚â§ ‚àë' x, f x :=
  sum_le_tsum s (fun _ _ => zero_le _) ENNReal.summable
#align ennreal.sum_le_tsum ENNReal.sum_le_tsum

protected theorem tsum_eq_iSup_nat' {f : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} {N : ‚Ñï ‚Üí ‚Ñï} (hN : Tendsto N atTop atTop) :
    ‚àë' i : ‚Ñï, f i = ‚®Ü i : ‚Ñï, ‚àë a in Finset.range (N i), f a :=
  ENNReal.tsum_eq_iSup_sum' _ fun t =>
    let ‚ü®n, hn‚ü© := t.exists_nat_subset_range
    let ‚ü®k, _, hk‚ü© := exists_le_of_tendsto_atTop hN 0 n
    ‚ü®k, Finset.Subset.trans hn (Finset.range_mono hk)‚ü©
#align ennreal.tsum_eq_supr_nat' ENNReal.tsum_eq_iSup_nat'

protected theorem tsum_eq_iSup_nat {f : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} :
    ‚àë' i : ‚Ñï, f i = ‚®Ü i : ‚Ñï, ‚àë a in Finset.range i, f a :=
  ENNReal.tsum_eq_iSup_sum' _ Finset.exists_nat_subset_range
#align ennreal.tsum_eq_supr_nat ENNReal.tsum_eq_iSup_nat

protected theorem tsum_eq_liminf_sum_nat {f : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} :
    ‚àë' i, f i = liminf (fun n => ‚àë i in Finset.range n, f i) atTop :=
  ENNReal.summable.hasSum.tendsto_sum_nat.liminf_eq.symm
#align ennreal.tsum_eq_liminf_sum_nat ENNReal.tsum_eq_liminf_sum_nat

protected theorem tsum_eq_limsup_sum_nat {f : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} :
    ‚àë' i, f i = limsup (fun n => ‚àë i in Finset.range n, f i) atTop :=
  ENNReal.summable.hasSum.tendsto_sum_nat.limsup_eq.symm

protected theorem le_tsum (a : Œ±) : f a ‚â§ ‚àë' a, f a :=
  le_tsum' ENNReal.summable a
#align ennreal.le_tsum ENNReal.le_tsum

@[simp]
protected theorem tsum_eq_zero : ‚àë' i, f i = 0 ‚Üî ‚àÄ i, f i = 0 :=
  tsum_eq_zero_iff ENNReal.summable
#align ennreal.tsum_eq_zero ENNReal.tsum_eq_zero

protected theorem tsum_eq_top_of_eq_top : (‚àÉ a, f a = ‚àû) ‚Üí ‚àë' a, f a = ‚àû
  | ‚ü®a, ha‚ü© => top_unique <| ha ‚ñ∏ ENNReal.le_tsum a
#align ennreal.tsum_eq_top_of_eq_top ENNReal.tsum_eq_top_of_eq_top

protected theorem lt_top_of_tsum_ne_top {a : Œ± ‚Üí ‚Ñù‚â•0‚àû} (tsum_ne_top : ‚àë' i, a i ‚â† ‚àû) (j : Œ±) :
    a j < ‚àû := by
  contrapose! tsum_ne_top with h
  -- ‚ä¢ ‚àë' (i : Œ±), a i = ‚ä§
  exact ENNReal.tsum_eq_top_of_eq_top ‚ü®j, top_unique h‚ü©
  -- üéâ no goals
#align ennreal.lt_top_of_tsum_ne_top ENNReal.lt_top_of_tsum_ne_top

@[simp]
protected theorem tsum_top [Nonempty Œ±] : ‚àë' _ : Œ±, ‚àû = ‚àû :=
  let ‚ü®a‚ü© := ‚ÄπNonempty Œ±‚Ä∫
  ENNReal.tsum_eq_top_of_eq_top ‚ü®a, rfl‚ü©
#align ennreal.tsum_top ENNReal.tsum_top

theorem tsum_const_eq_top_of_ne_zero {Œ± : Type*} [Infinite Œ±] {c : ‚Ñù‚â•0‚àû} (hc : c ‚â† 0) :
    ‚àë' _ : Œ±, c = ‚àû := by
  have A : Tendsto (fun n : ‚Ñï => (n : ‚Ñù‚â•0‚àû) * c) atTop (ùìù (‚àû * c)) := by
    apply ENNReal.Tendsto.mul_const tendsto_nat_nhds_top
    simp only [true_or_iff, top_ne_zero, Ne.def, not_false_iff]
  have B : ‚àÄ n : ‚Ñï, (n : ‚Ñù‚â•0‚àû) * c ‚â§ ‚àë' _ : Œ±, c := fun n => by
    rcases Infinite.exists_subset_card_eq Œ± n with ‚ü®s, hs‚ü©
    simpa [hs] using @ENNReal.sum_le_tsum Œ± (fun _ => c) s
  simpa [hc] using le_of_tendsto' A B
  -- üéâ no goals
#align ennreal.tsum_const_eq_top_of_ne_zero ENNReal.tsum_const_eq_top_of_ne_zero

protected theorem ne_top_of_tsum_ne_top (h : ‚àë' a, f a ‚â† ‚àû) (a : Œ±) : f a ‚â† ‚àû := fun ha =>
  h <| ENNReal.tsum_eq_top_of_eq_top ‚ü®a, ha‚ü©
#align ennreal.ne_top_of_tsum_ne_top ENNReal.ne_top_of_tsum_ne_top

protected theorem tsum_mul_left : ‚àë' i, a * f i = a * ‚àë' i, f i := by
  by_cases hf : ‚àÄ i, f i = 0
  -- ‚ä¢ ‚àë' (i : Œ±), a * f i = a * ‚àë' (i : Œ±), f i
  ¬∑ simp [hf]
    -- üéâ no goals
  ¬∑ rw [‚Üê ENNReal.tsum_eq_zero] at hf
    -- ‚ä¢ ‚àë' (i : Œ±), a * f i = a * ‚àë' (i : Œ±), f i
    have : Tendsto (fun s : Finset Œ± => ‚àë j in s, a * f j) atTop (ùìù (a * ‚àë' i, f i)) := by
      simp only [‚Üê Finset.mul_sum]
      exact ENNReal.Tendsto.const_mul ENNReal.summable.hasSum (Or.inl hf)
    exact HasSum.tsum_eq this
    -- üéâ no goals
#align ennreal.tsum_mul_left ENNReal.tsum_mul_left

protected theorem tsum_mul_right : ‚àë' i, f i * a = (‚àë' i, f i) * a := by
  simp [mul_comm, ENNReal.tsum_mul_left]
  -- üéâ no goals
#align ennreal.tsum_mul_right ENNReal.tsum_mul_right

protected theorem tsum_const_smul {R} [SMul R ‚Ñù‚â•0‚àû] [IsScalarTower R ‚Ñù‚â•0‚àû ‚Ñù‚â•0‚àû] (a : R) :
    ‚àë' i, a ‚Ä¢ f i = a ‚Ä¢ ‚àë' i, f i := by
  simpa only [smul_one_mul] using @ENNReal.tsum_mul_left _ (a ‚Ä¢ (1 : ‚Ñù‚â•0‚àû)) _
  -- üéâ no goals
#align ennreal.tsum_const_smul ENNReal.tsum_const_smul

@[simp]
theorem tsum_iSup_eq {Œ± : Type*} (a : Œ±) {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} : (‚àë' b : Œ±, ‚®Ü _ : a = b, f b) = f a :=
  (tsum_eq_single a fun _ h => by simp [h.symm]).trans <| by simp
                                  -- üéâ no goals
                                                             -- üéâ no goals
#align ennreal.tsum_supr_eq ENNReal.tsum_iSup_eq

theorem hasSum_iff_tendsto_nat {f : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} (r : ‚Ñù‚â•0‚àû) :
    HasSum f r ‚Üî Tendsto (fun n : ‚Ñï => ‚àë i in Finset.range n, f i) atTop (ùìù r) := by
  refine' ‚ü®HasSum.tendsto_sum_nat, fun h => _‚ü©
  -- ‚ä¢ HasSum f r
  rw [‚Üê iSup_eq_of_tendsto _ h, ‚Üê ENNReal.tsum_eq_iSup_nat]
  -- ‚ä¢ HasSum f (‚àë' (i : ‚Ñï), f i)
  ¬∑ exact ENNReal.summable.hasSum
    -- üéâ no goals
  ¬∑ exact fun s t hst => Finset.sum_le_sum_of_subset (Finset.range_subset.2 hst)
    -- üéâ no goals
#align ennreal.has_sum_iff_tendsto_nat ENNReal.hasSum_iff_tendsto_nat

theorem tendsto_nat_tsum (f : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû) :
    Tendsto (fun n : ‚Ñï => ‚àë i in Finset.range n, f i) atTop (ùìù (‚àë' n, f n)) := by
  rw [‚Üê hasSum_iff_tendsto_nat]
  -- ‚ä¢ HasSum (fun i => f i) (‚àë' (n : ‚Ñï), f n)
  exact ENNReal.summable.hasSum
  -- üéâ no goals
#align ennreal.tendsto_nat_tsum ENNReal.tendsto_nat_tsum

theorem toNNReal_apply_of_tsum_ne_top {Œ± : Type*} {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : ‚àë' i, f i ‚â† ‚àû) (x : Œ±) :
    (((ENNReal.toNNReal ‚àò f) x : ‚Ñù‚â•0) : ‚Ñù‚â•0‚àû) = f x :=
  coe_toNNReal <| ENNReal.ne_top_of_tsum_ne_top hf _
#align ennreal.to_nnreal_apply_of_tsum_ne_top ENNReal.toNNReal_apply_of_tsum_ne_top

theorem summable_toNNReal_of_tsum_ne_top {Œ± : Type*} {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : ‚àë' i, f i ‚â† ‚àû) :
    Summable (ENNReal.toNNReal ‚àò f) := by
  simpa only [‚Üê tsum_coe_ne_top_iff_summable, toNNReal_apply_of_tsum_ne_top hf] using hf
  -- üéâ no goals
#align ennreal.summable_to_nnreal_of_tsum_ne_top ENNReal.summable_toNNReal_of_tsum_ne_top

theorem tendsto_cofinite_zero_of_tsum_ne_top {Œ±} {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : ‚àë' x, f x ‚â† ‚àû) :
    Tendsto f cofinite (ùìù 0) := by
  have f_ne_top : ‚àÄ n, f n ‚â† ‚àû := ENNReal.ne_top_of_tsum_ne_top hf
  -- ‚ä¢ Tendsto f cofinite (ùìù 0)
  have h_f_coe : f = fun n => ((f n).toNNReal : ENNReal) :=
    funext fun n => (coe_toNNReal (f_ne_top n)).symm
  rw [h_f_coe, ‚Üê @coe_zero, tendsto_coe]
  -- ‚ä¢ Tendsto (fun n => ENNReal.toNNReal (f n)) cofinite (ùìù 0)
  exact NNReal.tendsto_cofinite_zero_of_summable (summable_toNNReal_of_tsum_ne_top hf)
  -- üéâ no goals
#align ennreal.tendsto_cofinite_zero_of_tsum_ne_top ENNReal.tendsto_cofinite_zero_of_tsum_ne_top

theorem tendsto_atTop_zero_of_tsum_ne_top {f : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} (hf : ‚àë' x, f x ‚â† ‚àû) :
    Tendsto f atTop (ùìù 0) := by
  rw [‚Üê Nat.cofinite_eq_atTop]
  -- ‚ä¢ Tendsto f cofinite (ùìù 0)
  exact tendsto_cofinite_zero_of_tsum_ne_top hf
  -- üéâ no goals
#align ennreal.tendsto_at_top_zero_of_tsum_ne_top ENNReal.tendsto_atTop_zero_of_tsum_ne_top

/-- The sum over the complement of a finset tends to `0` when the finset grows to cover the whole
space. This does not need a summability assumption, as otherwise all sums are zero. -/
theorem tendsto_tsum_compl_atTop_zero {Œ± : Type*} {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : ‚àë' x, f x ‚â† ‚àû) :
    Tendsto (fun s : Finset Œ± => ‚àë' b : { x // x ‚àâ s }, f b) atTop (ùìù 0) := by
  lift f to Œ± ‚Üí ‚Ñù‚â•0 using ENNReal.ne_top_of_tsum_ne_top hf
  -- ‚ä¢ Tendsto (fun s => ‚àë' (b : { x // ¬¨x ‚àà s }), (fun i => ‚Üë(f i)) ‚Üëb) atTop (ùìù 0)
  convert ENNReal.tendsto_coe.2 (NNReal.tendsto_tsum_compl_atTop_zero f)
  -- ‚ä¢ ‚àë' (b : { x // ¬¨x ‚àà x‚úù }), (fun i => ‚Üë(f i)) ‚Üëb = ‚Üë(‚àë' (b : { x // ¬¨x ‚àà x‚úù } ‚Ä¶
  rw [ENNReal.coe_tsum]
  -- ‚ä¢ Summable fun b => f ‚Üëb
  exact NNReal.summable_comp_injective (tsum_coe_ne_top_iff_summable.1 hf) Subtype.coe_injective
  -- üéâ no goals
#align ennreal.tendsto_tsum_compl_at_top_zero ENNReal.tendsto_tsum_compl_atTop_zero

protected theorem tsum_apply {Œπ Œ± : Type*} {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} {x : Œ±} :
    (‚àë' i, f i) x = ‚àë' i, f i x :=
  tsum_apply <| Pi.summable.mpr fun _ => ENNReal.summable
#align ennreal.tsum_apply ENNReal.tsum_apply

theorem tsum_sub {f : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} {g : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} (h‚ÇÅ : ‚àë' i, g i ‚â† ‚àû) (h‚ÇÇ : g ‚â§ f) :
    ‚àë' i, (f i - g i) = ‚àë' i, f i - ‚àë' i, g i :=
  have : ‚àÄ i, f i - g i + g i = f i := fun i => tsub_add_cancel_of_le (h‚ÇÇ i)
  ENNReal.eq_sub_of_add_eq h‚ÇÅ <| by simp only [‚Üê ENNReal.tsum_add, this]
                                    -- üéâ no goals
#align ennreal.tsum_sub ENNReal.tsum_sub

theorem tsum_comp_le_tsum_of_injective {f : Œ± ‚Üí Œ≤} (hf : Injective f) (g : Œ≤ ‚Üí ‚Ñù‚â•0‚àû) :
    ‚àë' x, g (f x) ‚â§ ‚àë' y, g y :=
  tsum_le_tsum_of_inj f hf (fun _ _ => zero_le _) (fun _ => le_rfl) ENNReal.summable
    ENNReal.summable

theorem tsum_le_tsum_comp_of_surjective {f : Œ± ‚Üí Œ≤} (hf : Surjective f) (g : Œ≤ ‚Üí ‚Ñù‚â•0‚àû) :
    ‚àë' y, g y ‚â§ ‚àë' x, g (f x) :=
  calc ‚àë' y, g y = ‚àë' y, g (f (surjInv hf y)) := by simp only [surjInv_eq hf]
                                                    -- üéâ no goals
  _ ‚â§ ‚àë' x, g (f x) := tsum_comp_le_tsum_of_injective (injective_surjInv hf) _

theorem tsum_mono_subtype (f : Œ± ‚Üí ‚Ñù‚â•0‚àû) {s t : Set Œ±} (h : s ‚äÜ t) :
    ‚àë' x : s, f x ‚â§ ‚àë' x : t, f x :=
  tsum_comp_le_tsum_of_injective (inclusion_injective h) _
#align ennreal.tsum_mono_subtype ENNReal.tsum_mono_subtype

theorem tsum_iUnion_le_tsum {Œπ : Type*} (f : Œ± ‚Üí ‚Ñù‚â•0‚àû) (t : Œπ ‚Üí Set Œ±) :
    ‚àë' x : ‚ãÉ i, t i, f x ‚â§ ‚àë' i, ‚àë' x : t i, f x :=
  calc ‚àë' x : ‚ãÉ i, t i, f x ‚â§ ‚àë' x : Œ£ i, t i, f x.2 :=
    tsum_le_tsum_comp_of_surjective (sigmaToiUnion_surjective t) _
  _ = ‚àë' i, ‚àë' x : t i, f x := ENNReal.tsum_sigma' _

theorem tsum_biUnion_le_tsum {Œπ : Type*} (f : Œ± ‚Üí ‚Ñù‚â•0‚àû) (s : Set Œπ) (t : Œπ ‚Üí Set Œ±) :
    ‚àë' x : ‚ãÉ i ‚àà s , t i, f x ‚â§ ‚àë' i : s, ‚àë' x : t i, f x :=
  calc ‚àë' x : ‚ãÉ i ‚àà s, t i, f x = ‚àë' x : ‚ãÉ i : s, t i, f x := tsum_congr_subtype _ <| by simp
                                                                                         -- üéâ no goals
  _ ‚â§ ‚àë' i : s, ‚àë' x : t i, f x := tsum_iUnion_le_tsum _ _

theorem tsum_biUnion_le {Œπ : Type*} (f : Œ± ‚Üí ‚Ñù‚â•0‚àû) (s : Finset Œπ) (t : Œπ ‚Üí Set Œ±) :
    ‚àë' x : ‚ãÉ i ‚àà s, t i, f x ‚â§ ‚àë i in s, ‚àë' x : t i, f x :=
  (tsum_biUnion_le_tsum f s.toSet t).trans_eq (Finset.tsum_subtype s fun i => ‚àë' x : t i, f x)
#align ennreal.tsum_bUnion_le ENNReal.tsum_biUnion_le

theorem tsum_iUnion_le {Œπ : Type*} [Fintype Œπ] (f : Œ± ‚Üí ‚Ñù‚â•0‚àû) (t : Œπ ‚Üí Set Œ±) :
    ‚àë' x : ‚ãÉ i, t i, f x ‚â§ ‚àë i, ‚àë' x : t i, f x := by
  rw [‚Üê tsum_fintype]
  -- ‚ä¢ ‚àë' (x : ‚Üë(‚ãÉ (i : Œπ), t i)), f ‚Üëx ‚â§ ‚àë' (b : Œπ) (x : ‚Üë(t b)), f ‚Üëx
  exact tsum_iUnion_le_tsum f t
  -- üéâ no goals
#align ennreal.tsum_Union_le ENNReal.tsum_iUnion_le

theorem tsum_union_le (f : Œ± ‚Üí ‚Ñù‚â•0‚àû) (s t : Set Œ±) :
    ‚àë' x : ‚Üë(s ‚à™ t), f x ‚â§ ‚àë' x : s, f x + ‚àë' x : t, f x :=
  calc ‚àë' x : ‚Üë(s ‚à™ t), f x = ‚àë' x : ‚ãÉ b, cond b s t, f x := tsum_congr_subtype _ union_eq_iUnion
  _ ‚â§ _ := by simpa using tsum_iUnion_le f (cond ¬∑ s t)
              -- üéâ no goals
#align ennreal.tsum_union_le ENNReal.tsum_union_le

theorem tsum_eq_add_tsum_ite {f : Œ≤ ‚Üí ‚Ñù‚â•0‚àû} (b : Œ≤) :
    ‚àë' x, f x = f b + ‚àë' x, ite (x = b) 0 (f x) :=
  tsum_eq_add_tsum_ite' b ENNReal.summable
#align ennreal.tsum_eq_add_tsum_ite ENNReal.tsum_eq_add_tsum_ite

theorem tsum_add_one_eq_top {f : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} (hf : ‚àë' n, f n = ‚àû) (hf0 : f 0 ‚â† ‚àû) :
    ‚àë' n, f (n + 1) = ‚àû := by
  rw [tsum_eq_zero_add' ENNReal.summable, add_eq_top] at hf
  -- ‚ä¢ ‚àë' (n : ‚Ñï), f (n + 1) = ‚ä§
  exact hf.resolve_left hf0
  -- üéâ no goals
#align ennreal.tsum_add_one_eq_top ENNReal.tsum_add_one_eq_top

/-- A sum of extended nonnegative reals which is finite can have only finitely many terms
above any positive threshold.-/
theorem finite_const_le_of_tsum_ne_top {Œπ : Type*} {a : Œπ ‚Üí ‚Ñù‚â•0‚àû} (tsum_ne_top : ‚àë' i, a i ‚â† ‚àû)
    {Œµ : ‚Ñù‚â•0‚àû} (Œµ_ne_zero : Œµ ‚â† 0) : { i : Œπ | Œµ ‚â§ a i }.Finite := by
  by_contra h
  -- ‚ä¢ False
  have := Infinite.to_subtype h
  -- ‚ä¢ False
  refine tsum_ne_top (top_unique ?_)
  -- ‚ä¢ ‚ä§ ‚â§ ‚àë' (i : Œπ), a i
  calc ‚ä§ = ‚àë' _ : { i | Œµ ‚â§ a i }, Œµ := (tsum_const_eq_top_of_ne_zero Œµ_ne_zero).symm
  _ ‚â§ ‚àë' i, a i := tsum_le_tsum_of_inj (‚Üë) Subtype.val_injective (fun _ _ => zero_le _)
    (fun i => i.2) ENNReal.summable ENNReal.summable
#align ennreal.finite_const_le_of_tsum_ne_top ENNReal.finite_const_le_of_tsum_ne_top

/-- Markov's inequality for `Finset.card` and `tsum` in `‚Ñù‚â•0‚àû`. -/
theorem finset_card_const_le_le_of_tsum_le {Œπ : Type*} {a : Œπ ‚Üí ‚Ñù‚â•0‚àû} {c : ‚Ñù‚â•0‚àû} (c_ne_top : c ‚â† ‚àû)
    (tsum_le_c : ‚àë' i, a i ‚â§ c) {Œµ : ‚Ñù‚â•0‚àû} (Œµ_ne_zero : Œµ ‚â† 0) :
    ‚àÉ hf : { i : Œπ | Œµ ‚â§ a i }.Finite, ‚Üëhf.toFinset.card ‚â§ c / Œµ := by
  have hf : { i : Œπ | Œµ ‚â§ a i }.Finite :=
    finite_const_le_of_tsum_ne_top (ne_top_of_le_ne_top c_ne_top tsum_le_c) Œµ_ne_zero
  refine ‚ü®hf, (ENNReal.le_div_iff_mul_le (.inl Œµ_ne_zero) (.inr c_ne_top)).2 ?_‚ü©
  -- ‚ä¢ ‚Üë(Finset.card (Finite.toFinset hf)) * Œµ ‚â§ c
  calc ‚Üëhf.toFinset.card * Œµ = ‚àë _i in hf.toFinset, Œµ := by rw [Finset.sum_const, nsmul_eq_mul]
    _ ‚â§ ‚àë i in hf.toFinset, a i := Finset.sum_le_sum fun i => hf.mem_toFinset.1
    _ ‚â§ ‚àë' i, a i := ENNReal.sum_le_tsum _
    _ ‚â§ c := tsum_le_c
#align ennreal.finset_card_const_le_le_of_tsum_le ENNReal.finset_card_const_le_le_of_tsum_le

end tsum

theorem tendsto_toReal_iff {Œπ} {fi : Filter Œπ} {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} (hf : ‚àÄ i, f i ‚â† ‚àû) {x : ‚Ñù‚â•0‚àû}
    (hx : x ‚â† ‚àû) : Tendsto (fun n => (f n).toReal) fi (ùìù x.toReal) ‚Üî Tendsto f fi (ùìù x) := by
  lift f to Œπ ‚Üí ‚Ñù‚â•0 using hf
  -- ‚ä¢ Tendsto (fun n => ENNReal.toReal ((fun i => ‚Üë(f i)) n)) fi (ùìù (ENNReal.toRea ‚Ä¶
  lift x to ‚Ñù‚â•0 using hx
  -- ‚ä¢ Tendsto (fun n => ENNReal.toReal ((fun i => ‚Üë(f i)) n)) fi (ùìù (ENNReal.toRea ‚Ä¶
  simp [tendsto_coe]
  -- üéâ no goals
#align ennreal.tendsto_to_real_iff ENNReal.tendsto_toReal_iff

theorem tsum_coe_ne_top_iff_summable_coe {f : Œ± ‚Üí ‚Ñù‚â•0} :
    (‚àë' a, (f a : ‚Ñù‚â•0‚àû)) ‚â† ‚àû ‚Üî Summable fun a => (f a : ‚Ñù) := by
  rw [NNReal.summable_coe]
  -- ‚ä¢ ‚àë' (a : Œ±), ‚Üë(f a) ‚â† ‚ä§ ‚Üî Summable fun a => f a
  exact tsum_coe_ne_top_iff_summable
  -- üéâ no goals
#align ennreal.tsum_coe_ne_top_iff_summable_coe ENNReal.tsum_coe_ne_top_iff_summable_coe

theorem tsum_coe_eq_top_iff_not_summable_coe {f : Œ± ‚Üí ‚Ñù‚â•0} :
    (‚àë' a, (f a : ‚Ñù‚â•0‚àû)) = ‚àû ‚Üî ¬¨Summable fun a => (f a : ‚Ñù) :=
  tsum_coe_ne_top_iff_summable_coe.not_right
#align ennreal.tsum_coe_eq_top_iff_not_summable_coe ENNReal.tsum_coe_eq_top_iff_not_summable_coe

theorem hasSum_toReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hsum : ‚àë' x, f x ‚â† ‚àû) :
    HasSum (fun x => (f x).toReal) (‚àë' x, (f x).toReal) := by
  lift f to Œ± ‚Üí ‚Ñù‚â•0 using ENNReal.ne_top_of_tsum_ne_top hsum
  -- ‚ä¢ HasSum (fun x => ENNReal.toReal ((fun i => ‚Üë(f i)) x)) (‚àë' (x : Œ±), ENNReal. ‚Ä¶
  simp only [coe_toReal, ‚Üê NNReal.coe_tsum, NNReal.hasSum_coe]
  -- ‚ä¢ HasSum (fun a => f a) (‚àë' (a : Œ±), f a)
  exact (tsum_coe_ne_top_iff_summable.1 hsum).hasSum
  -- üéâ no goals
#align ennreal.has_sum_to_real ENNReal.hasSum_toReal

theorem summable_toReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hsum : ‚àë' x, f x ‚â† ‚àû) : Summable fun x => (f x).toReal :=
  (hasSum_toReal hsum).summable
#align ennreal.summable_to_real ENNReal.summable_toReal

end ENNReal

namespace NNReal

theorem tsum_eq_toNNReal_tsum {f : Œ≤ ‚Üí ‚Ñù‚â•0} : ‚àë' b, f b = (‚àë' b, (f b : ‚Ñù‚â•0‚àû)).toNNReal := by
  by_cases h : Summable f
  -- ‚ä¢ ‚àë' (b : Œ≤), f b = ENNReal.toNNReal (‚àë' (b : Œ≤), ‚Üë(f b))
  ¬∑ rw [‚Üê ENNReal.coe_tsum h, ENNReal.toNNReal_coe]
    -- üéâ no goals
  ¬∑ have A := tsum_eq_zero_of_not_summable h
    -- ‚ä¢ ‚àë' (b : Œ≤), f b = ENNReal.toNNReal (‚àë' (b : Œ≤), ‚Üë(f b))
    simp only [‚Üê ENNReal.tsum_coe_ne_top_iff_summable, Classical.not_not] at h
    -- ‚ä¢ ‚àë' (b : Œ≤), f b = ENNReal.toNNReal (‚àë' (b : Œ≤), ‚Üë(f b))
    simp only [h, ENNReal.top_toNNReal, A]
    -- üéâ no goals
#align nnreal.tsum_eq_to_nnreal_tsum NNReal.tsum_eq_toNNReal_tsum

/-- Comparison test of convergence of `‚Ñù‚â•0`-valued series. -/
theorem exists_le_hasSum_of_le {f g : Œ≤ ‚Üí ‚Ñù‚â•0} {r : ‚Ñù‚â•0} (hgf : ‚àÄ b, g b ‚â§ f b) (hfr : HasSum f r) :
    ‚àÉ p ‚â§ r, HasSum g p :=
  have : (‚àë' b, (g b : ‚Ñù‚â•0‚àû)) ‚â§ r := by
    refine hasSum_le (fun b => ?_) ENNReal.summable.hasSum (ENNReal.hasSum_coe.2 hfr)
    -- ‚ä¢ ‚Üë(g b) ‚â§ ‚Üë(f b)
    exact ENNReal.coe_le_coe.2 (hgf _)
    -- üéâ no goals
  let ‚ü®p, Eq, hpr‚ü© := ENNReal.le_coe_iff.1 this
  ‚ü®p, hpr, ENNReal.hasSum_coe.1 <| Eq ‚ñ∏ ENNReal.summable.hasSum‚ü©
#align nnreal.exists_le_has_sum_of_le NNReal.exists_le_hasSum_of_le

/-- Comparison test of convergence of `‚Ñù‚â•0`-valued series. -/
theorem summable_of_le {f g : Œ≤ ‚Üí ‚Ñù‚â•0} (hgf : ‚àÄ b, g b ‚â§ f b) : Summable f ‚Üí Summable g
  | ‚ü®_r, hfr‚ü© =>
    let ‚ü®_p, _, hp‚ü© := exists_le_hasSum_of_le hgf hfr
    hp.summable
#align nnreal.summable_of_le NNReal.summable_of_le

/-- Summable non-negative functions have countable support -/
theorem _root_.Summable.countable_support_nnreal (f : Œ± ‚Üí ‚Ñù‚â•0) (h : Summable f) :
    f.support.Countable := by
  rw [‚Üê NNReal.summable_coe] at h
  -- ‚ä¢ Set.Countable (support f)
  simpa [support] using h.countable_support
  -- üéâ no goals

/-- A series of non-negative real numbers converges to `r` in the sense of `HasSum` if and only if
the sequence of partial sum converges to `r`. -/
theorem hasSum_iff_tendsto_nat {f : ‚Ñï ‚Üí ‚Ñù‚â•0} {r : ‚Ñù‚â•0} :
    HasSum f r ‚Üî Tendsto (fun n : ‚Ñï => ‚àë i in Finset.range n, f i) atTop (ùìù r) := by
  rw [‚Üê ENNReal.hasSum_coe, ENNReal.hasSum_iff_tendsto_nat]
  -- ‚ä¢ Tendsto (fun n => ‚àë i in Finset.range n, ‚Üë(f i)) atTop (ùìù ‚Üër) ‚Üî Tendsto (fun ‚Ä¶
  simp only [‚Üê ENNReal.coe_finset_sum]
  -- ‚ä¢ Tendsto (fun n => ‚Üë(‚àë a in Finset.range n, f a)) atTop (ùìù ‚Üër) ‚Üî Tendsto (fun ‚Ä¶
  exact ENNReal.tendsto_coe
  -- üéâ no goals
#align nnreal.has_sum_iff_tendsto_nat NNReal.hasSum_iff_tendsto_nat

theorem not_summable_iff_tendsto_nat_atTop {f : ‚Ñï ‚Üí ‚Ñù‚â•0} :
    ¬¨Summable f ‚Üî Tendsto (fun n : ‚Ñï => ‚àë i in Finset.range n, f i) atTop atTop := by
  constructor
  -- ‚ä¢ ¬¨Summable f ‚Üí Tendsto (fun n => ‚àë i in Finset.range n, f i) atTop atTop
  ¬∑ intro h
    -- ‚ä¢ Tendsto (fun n => ‚àë i in Finset.range n, f i) atTop atTop
    refine' ((tendsto_of_monotone _).resolve_right h).comp _
    -- ‚ä¢ Monotone fun s => ‚àë b in s, f b
    exacts [Finset.sum_mono_set _, tendsto_finset_range]
    -- üéâ no goals
  ¬∑ rintro hnat ‚ü®r, hr‚ü©
    -- ‚ä¢ False
    exact not_tendsto_nhds_of_tendsto_atTop hnat _ (hasSum_iff_tendsto_nat.1 hr)
    -- üéâ no goals
#align nnreal.not_summable_iff_tendsto_nat_at_top NNReal.not_summable_iff_tendsto_nat_atTop

theorem summable_iff_not_tendsto_nat_atTop {f : ‚Ñï ‚Üí ‚Ñù‚â•0} :
    Summable f ‚Üî ¬¨Tendsto (fun n : ‚Ñï => ‚àë i in Finset.range n, f i) atTop atTop := by
  rw [‚Üê not_iff_not, Classical.not_not, not_summable_iff_tendsto_nat_atTop]
  -- üéâ no goals
#align nnreal.summable_iff_not_tendsto_nat_at_top NNReal.summable_iff_not_tendsto_nat_atTop

theorem summable_of_sum_range_le {f : ‚Ñï ‚Üí ‚Ñù‚â•0} {c : ‚Ñù‚â•0}
    (h : ‚àÄ n, ‚àë i in Finset.range n, f i ‚â§ c) : Summable f := by
  refine summable_iff_not_tendsto_nat_atTop.2 fun H => ?_
  -- ‚ä¢ False
  rcases exists_lt_of_tendsto_atTop H 0 c with ‚ü®n, -, hn‚ü©
  -- ‚ä¢ False
  exact lt_irrefl _ (hn.trans_le (h n))
  -- üéâ no goals
#align nnreal.summable_of_sum_range_le NNReal.summable_of_sum_range_le

theorem tsum_le_of_sum_range_le {f : ‚Ñï ‚Üí ‚Ñù‚â•0} {c : ‚Ñù‚â•0}
    (h : ‚àÄ n, ‚àë i in Finset.range n, f i ‚â§ c) : ‚àë' n, f n ‚â§ c :=
  _root_.tsum_le_of_sum_range_le (summable_of_sum_range_le h) h
#align nnreal.tsum_le_of_sum_range_le NNReal.tsum_le_of_sum_range_le

theorem tsum_comp_le_tsum_of_inj {Œ≤ : Type*} {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : Summable f) {i : Œ≤ ‚Üí Œ±}
    (hi : Function.Injective i) : (‚àë' x, f (i x)) ‚â§ ‚àë' x, f x :=
  tsum_le_tsum_of_inj i hi (fun _ _ => zero_le _) (fun _ => le_rfl) (summable_comp_injective hf hi)
    hf
#align nnreal.tsum_comp_le_tsum_of_inj NNReal.tsum_comp_le_tsum_of_inj

theorem summable_sigma {Œ≤ : Œ± ‚Üí Type*} {f : (Œ£ x, Œ≤ x) ‚Üí ‚Ñù‚â•0} :
    Summable f ‚Üî (‚àÄ x, Summable fun y => f ‚ü®x, y‚ü©) ‚àß Summable fun x => ‚àë' y, f ‚ü®x, y‚ü© := by
  constructor
  -- ‚ä¢ Summable f ‚Üí (‚àÄ (x : Œ±), Summable fun y => f { fst := x, snd := y }) ‚àß Summa ‚Ä¶
  ¬∑ simp only [‚Üê NNReal.summable_coe, NNReal.coe_tsum]
    -- ‚ä¢ (Summable fun a => ‚Üë(f a)) ‚Üí (‚àÄ (x : Œ±), Summable fun a => ‚Üë(f { fst := x, s ‚Ä¶
    exact fun h => ‚ü®h.sigma_factor, h.sigma‚ü©
    -- üéâ no goals
  ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    -- ‚ä¢ Summable f
    simpa only [‚Üê ENNReal.tsum_coe_ne_top_iff_summable, ENNReal.tsum_sigma',
      ENNReal.coe_tsum (h‚ÇÅ _)] using h‚ÇÇ
#align nnreal.summable_sigma NNReal.summable_sigma

theorem indicator_summable {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : Summable f) (s : Set Œ±) :
    Summable (s.indicator f) := by
  refine' NNReal.summable_of_le (fun a => le_trans (le_of_eq (s.indicator_apply f a)) _) hf
  -- ‚ä¢ (if a ‚àà s then f a else 0) ‚â§ f a
  split_ifs
  -- ‚ä¢ f a ‚â§ f a
  exact le_refl (f a)
  -- ‚ä¢ 0 ‚â§ f a
  exact zero_le_coe
  -- üéâ no goals
#align nnreal.indicator_summable NNReal.indicator_summable

theorem tsum_indicator_ne_zero {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : Summable f) {s : Set Œ±} (h : ‚àÉ a ‚àà s, f a ‚â† 0) :
    (‚àë' x, (s.indicator f) x) ‚â† 0 := fun h' =>
  let ‚ü®a, ha, hap‚ü© := h
  hap ((Set.indicator_apply_eq_self.mpr (absurd ha)).symm.trans
    ((tsum_eq_zero_iff (indicator_summable hf s)).1 h' a))
#align nnreal.tsum_indicator_ne_zero NNReal.tsum_indicator_ne_zero

open Finset

/-- For `f : ‚Ñï ‚Üí ‚Ñù‚â•0`, then `‚àë' k, f (k + i)` tends to zero. This does not require a summability
assumption on `f`, as otherwise all sums are zero. -/
theorem tendsto_sum_nat_add (f : ‚Ñï ‚Üí ‚Ñù‚â•0) : Tendsto (fun i => ‚àë' k, f (k + i)) atTop (ùìù 0) := by
  rw [‚Üê tendsto_coe]
  -- ‚ä¢ Tendsto (fun a => ‚Üë(‚àë' (k : ‚Ñï), f (k + a))) atTop (ùìù ‚Üë0)
  convert _root_.tendsto_sum_nat_add fun i => (f i : ‚Ñù)
  -- ‚ä¢ ‚Üë(‚àë' (k : ‚Ñï), f (k + x‚úù)) = ‚àë' (k : ‚Ñï), ‚Üë(f (k + x‚úù))
  norm_cast
  -- üéâ no goals
#align nnreal.tendsto_sum_nat_add NNReal.tendsto_sum_nat_add

nonrec theorem hasSum_lt {f g : Œ± ‚Üí ‚Ñù‚â•0} {sf sg : ‚Ñù‚â•0} {i : Œ±} (h : ‚àÄ a : Œ±, f a ‚â§ g a)
    (hi : f i < g i) (hf : HasSum f sf) (hg : HasSum g sg) : sf < sg := by
  have A : ‚àÄ a : Œ±, (f a : ‚Ñù) ‚â§ g a := fun a => NNReal.coe_le_coe.2 (h a)
  -- ‚ä¢ sf < sg
  have : (sf : ‚Ñù) < sg := hasSum_lt A (NNReal.coe_lt_coe.2 hi) (hasSum_coe.2 hf) (hasSum_coe.2 hg)
  -- ‚ä¢ sf < sg
  exact NNReal.coe_lt_coe.1 this
  -- üéâ no goals
#align nnreal.has_sum_lt NNReal.hasSum_lt

@[mono]
theorem hasSum_strict_mono {f g : Œ± ‚Üí ‚Ñù‚â•0} {sf sg : ‚Ñù‚â•0} (hf : HasSum f sf) (hg : HasSum g sg)
    (h : f < g) : sf < sg :=
  let ‚ü®hle, _i, hi‚ü© := Pi.lt_def.mp h
  hasSum_lt hle hi hf hg
#align nnreal.has_sum_strict_mono NNReal.hasSum_strict_mono

theorem tsum_lt_tsum {f g : Œ± ‚Üí ‚Ñù‚â•0} {i : Œ±} (h : ‚àÄ a : Œ±, f a ‚â§ g a) (hi : f i < g i)
    (hg : Summable g) : ‚àë' n, f n < ‚àë' n, g n :=
  hasSum_lt h hi (summable_of_le h hg).hasSum hg.hasSum
#align nnreal.tsum_lt_tsum NNReal.tsum_lt_tsum

@[mono]
theorem tsum_strict_mono {f g : Œ± ‚Üí ‚Ñù‚â•0} (hg : Summable g) (h : f < g) : ‚àë' n, f n < ‚àë' n, g n :=
  let ‚ü®hle, _i, hi‚ü© := Pi.lt_def.mp h
  tsum_lt_tsum hle hi hg
#align nnreal.tsum_strict_mono NNReal.tsum_strict_mono

theorem tsum_pos {g : Œ± ‚Üí ‚Ñù‚â•0} (hg : Summable g) (i : Œ±) (hi : 0 < g i) : 0 < ‚àë' b, g b := by
  rw [‚Üê tsum_zero]
  -- ‚ä¢ ‚àë' (x : ?m.347291), 0 < ‚àë' (b : Œ±), g b
  exact tsum_lt_tsum (fun a => zero_le _) hi hg
  -- üéâ no goals
#align nnreal.tsum_pos NNReal.tsum_pos

theorem tsum_eq_add_tsum_ite {f : Œ± ‚Üí ‚Ñù‚â•0} (hf : Summable f) (i : Œ±) :
    ‚àë' x, f x = f i + ‚àë' x, ite (x = i) 0 (f x) := by
  refine' tsum_eq_add_tsum_ite' i (NNReal.summable_of_le (fun i' => _) hf)
  -- ‚ä¢ update (fun x => f x) i 0 i' ‚â§ f i'
  rw [Function.update_apply]
  -- ‚ä¢ (if i' = i then 0 else f i') ‚â§ f i'
  split_ifs <;> simp only [zero_le', le_rfl]
  -- ‚ä¢ 0 ‚â§ f i'
                -- üéâ no goals
                -- üéâ no goals
#align nnreal.tsum_eq_add_tsum_ite NNReal.tsum_eq_add_tsum_ite

end NNReal

namespace ENNReal

theorem tsum_toNNReal_eq {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : ‚àÄ a, f a ‚â† ‚àû) :
    (‚àë' a, f a).toNNReal = ‚àë' a, (f a).toNNReal :=
  (congr_arg ENNReal.toNNReal (tsum_congr fun x => (coe_toNNReal (hf x)).symm)).trans
    NNReal.tsum_eq_toNNReal_tsum.symm
#align ennreal.tsum_to_nnreal_eq ENNReal.tsum_toNNReal_eq

theorem tsum_toReal_eq {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : ‚àÄ a, f a ‚â† ‚àû) :
    (‚àë' a, f a).toReal = ‚àë' a, (f a).toReal := by
  simp only [ENNReal.toReal, tsum_toNNReal_eq hf, NNReal.coe_tsum]
  -- üéâ no goals
#align ennreal.tsum_to_real_eq ENNReal.tsum_toReal_eq

theorem tendsto_sum_nat_add (f : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû) (hf : ‚àë' i, f i ‚â† ‚àû) :
    Tendsto (fun i => ‚àë' k, f (k + i)) atTop (ùìù 0) := by
  lift f to ‚Ñï ‚Üí ‚Ñù‚â•0 using ENNReal.ne_top_of_tsum_ne_top hf
  -- ‚ä¢ Tendsto (fun i => ‚àë' (k : ‚Ñï), (fun i => ‚Üë(f i)) (k + i)) atTop (ùìù 0)
  replace hf : Summable f := tsum_coe_ne_top_iff_summable.1 hf
  -- ‚ä¢ Tendsto (fun i => ‚àë' (k : ‚Ñï), (fun i => ‚Üë(f i)) (k + i)) atTop (ùìù 0)
  simp only [‚Üê ENNReal.coe_tsum, NNReal.summable_nat_add _ hf, ‚Üê ENNReal.coe_zero]
  -- ‚ä¢ Tendsto (fun i => ‚Üë(‚àë' (a : ‚Ñï), f (a + i))) atTop (ùìù ‚Üë0)
  exact_mod_cast NNReal.tendsto_sum_nat_add f
  -- üéâ no goals
#align ennreal.tendsto_sum_nat_add ENNReal.tendsto_sum_nat_add

theorem tsum_le_of_sum_range_le {f : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} {c : ‚Ñù‚â•0‚àû}
    (h : ‚àÄ n, ‚àë i in Finset.range n, f i ‚â§ c) : ‚àë' n, f n ‚â§ c :=
  _root_.tsum_le_of_sum_range_le ENNReal.summable h
#align ennreal.tsum_le_of_sum_range_le ENNReal.tsum_le_of_sum_range_le

theorem hasSum_lt {f g : Œ± ‚Üí ‚Ñù‚â•0‚àû} {sf sg : ‚Ñù‚â•0‚àû} {i : Œ±} (h : ‚àÄ a : Œ±, f a ‚â§ g a) (hi : f i < g i)
    (hsf : sf ‚â† ‚ä§) (hf : HasSum f sf) (hg : HasSum g sg) : sf < sg := by
  by_cases hsg : sg = ‚ä§
  -- ‚ä¢ sf < sg
  ¬∑ exact hsg.symm ‚ñ∏ lt_of_le_of_ne le_top hsf
    -- üéâ no goals
  ¬∑ have hg' : ‚àÄ x, g x ‚â† ‚ä§ := ENNReal.ne_top_of_tsum_ne_top (hg.tsum_eq.symm ‚ñ∏ hsg)
    -- ‚ä¢ sf < sg
    lift f to Œ± ‚Üí ‚Ñù‚â•0 using fun x =>
      ne_of_lt (lt_of_le_of_lt (h x) <| lt_of_le_of_ne le_top (hg' x))
    lift g to Œ± ‚Üí ‚Ñù‚â•0 using hg'
    -- ‚ä¢ sf < sg
    lift sf to ‚Ñù‚â•0 using hsf
    -- ‚ä¢ ‚Üësf < sg
    lift sg to ‚Ñù‚â•0 using hsg
    -- ‚ä¢ ‚Üësf < ‚Üësg
    simp only [coe_le_coe, coe_lt_coe] at h hi ‚ä¢
    -- ‚ä¢ sf < sg
    exact NNReal.hasSum_lt h hi (ENNReal.hasSum_coe.1 hf) (ENNReal.hasSum_coe.1 hg)
    -- üéâ no goals
#align ennreal.has_sum_lt ENNReal.hasSum_lt

theorem tsum_lt_tsum {f g : Œ± ‚Üí ‚Ñù‚â•0‚àû} {i : Œ±} (hfi : tsum f ‚â† ‚ä§) (h : ‚àÄ a : Œ±, f a ‚â§ g a)
    (hi : f i < g i) : ‚àë' x, f x < ‚àë' x, g x :=
  hasSum_lt h hi hfi ENNReal.summable.hasSum ENNReal.summable.hasSum
#align ennreal.tsum_lt_tsum ENNReal.tsum_lt_tsum

end ENNReal

theorem tsum_comp_le_tsum_of_inj {Œ≤ : Type*} {f : Œ± ‚Üí ‚Ñù} (hf : Summable f) (hn : ‚àÄ a, 0 ‚â§ f a)
    {i : Œ≤ ‚Üí Œ±} (hi : Function.Injective i) : tsum (f ‚àò i) ‚â§ tsum f := by
  lift f to Œ± ‚Üí ‚Ñù‚â•0 using hn
  -- ‚ä¢ tsum ((fun i => ‚Üë(f i)) ‚àò i) ‚â§ ‚àë' (i : Œ±), ‚Üë(f i)
  rw [NNReal.summable_coe] at hf
  -- ‚ä¢ tsum ((fun i => ‚Üë(f i)) ‚àò i) ‚â§ ‚àë' (i : Œ±), ‚Üë(f i)
  simpa only [(¬∑ ‚àò ¬∑), ‚Üê NNReal.coe_tsum] using NNReal.tsum_comp_le_tsum_of_inj hf hi
  -- üéâ no goals
#align tsum_comp_le_tsum_of_inj tsum_comp_le_tsum_of_inj

/-- Comparison test of convergence of series of non-negative real numbers. -/
theorem summable_of_nonneg_of_le {f g : Œ≤ ‚Üí ‚Ñù} (hg : ‚àÄ b, 0 ‚â§ g b) (hgf : ‚àÄ b, g b ‚â§ f b)
    (hf : Summable f) : Summable g := by
  lift f to Œ≤ ‚Üí ‚Ñù‚â•0 using fun b => (hg b).trans (hgf b)
  -- ‚ä¢ Summable g
  lift g to Œ≤ ‚Üí ‚Ñù‚â•0 using hg
  -- ‚ä¢ Summable fun i => ‚Üë(g i)
  rw [NNReal.summable_coe] at hf ‚ä¢
  -- ‚ä¢ Summable fun i => g i
  exact NNReal.summable_of_le (fun b => NNReal.coe_le_coe.1 (hgf b)) hf
  -- üéâ no goals
#align summable_of_nonneg_of_le summable_of_nonneg_of_le

theorem Summable.toNNReal {f : Œ± ‚Üí ‚Ñù} (hf : Summable f) : Summable fun n => (f n).toNNReal := by
  apply NNReal.summable_coe.1
  -- ‚ä¢ Summable fun a => ‚Üë(Real.toNNReal (f a))
  refine' summable_of_nonneg_of_le (fun n => NNReal.coe_nonneg _) (fun n => _) hf.abs
  -- ‚ä¢ ‚Üë(Real.toNNReal (f n)) ‚â§ |f n|
  simp only [le_abs_self, Real.coe_toNNReal', max_le_iff, abs_nonneg, and_self_iff]
  -- üéâ no goals
#align summable.to_nnreal Summable.toNNReal

/-- Finitely summable non-negative functions have countable support -/
theorem _root_.Summable.countable_support_ennreal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àë' (i : Œ±), f i ‚â† ‚ä§) :
    f.support.Countable := by
  lift f to Œ± ‚Üí ‚Ñù‚â•0 using ENNReal.ne_top_of_tsum_ne_top h
  -- ‚ä¢ Set.Countable (support fun i => ‚Üë(f i))
  simpa [support] using (ENNReal.tsum_coe_ne_top_iff_summable.1 h).countable_support_nnreal
  -- üéâ no goals

/-- A series of non-negative real numbers converges to `r` in the sense of `HasSum` if and only if
the sequence of partial sum converges to `r`. -/
theorem hasSum_iff_tendsto_nat_of_nonneg {f : ‚Ñï ‚Üí ‚Ñù} (hf : ‚àÄ i, 0 ‚â§ f i) (r : ‚Ñù) :
    HasSum f r ‚Üî Tendsto (fun n : ‚Ñï => ‚àë i in Finset.range n, f i) atTop (ùìù r) := by
  lift f to ‚Ñï ‚Üí ‚Ñù‚â•0 using hf
  -- ‚ä¢ HasSum (fun i => ‚Üë(f i)) r ‚Üî Tendsto (fun n => ‚àë i in Finset.range n, (fun i ‚Ä¶
  simp only [HasSum, ‚Üê NNReal.coe_sum, NNReal.tendsto_coe']
  -- ‚ä¢ (‚àÉ hx, Tendsto (fun a => ‚àë a in a, f a) atTop (ùìù { val := r, property := hx  ‚Ä¶
  exact exists_congr fun hr => NNReal.hasSum_iff_tendsto_nat
  -- üéâ no goals
#align has_sum_iff_tendsto_nat_of_nonneg hasSum_iff_tendsto_nat_of_nonneg

theorem ENNReal.ofReal_tsum_of_nonneg {f : Œ± ‚Üí ‚Ñù} (hf_nonneg : ‚àÄ n, 0 ‚â§ f n) (hf : Summable f) :
    ENNReal.ofReal (‚àë' n, f n) = ‚àë' n, ENNReal.ofReal (f n) := by
  simp_rw [ENNReal.ofReal, ENNReal.tsum_coe_eq (NNReal.hasSum_real_toNNReal_of_nonneg hf_nonneg hf)]
  -- üéâ no goals
#align ennreal.of_real_tsum_of_nonneg ENNReal.ofReal_tsum_of_nonneg

theorem not_summable_iff_tendsto_nat_atTop_of_nonneg {f : ‚Ñï ‚Üí ‚Ñù} (hf : ‚àÄ n, 0 ‚â§ f n) :
    ¬¨Summable f ‚Üî Tendsto (fun n : ‚Ñï => ‚àë i in Finset.range n, f i) atTop atTop := by
  lift f to ‚Ñï ‚Üí ‚Ñù‚â•0 using hf
  -- ‚ä¢ (¬¨Summable fun i => ‚Üë(f i)) ‚Üî Tendsto (fun n => ‚àë i in Finset.range n, (fun  ‚Ä¶
  exact_mod_cast NNReal.not_summable_iff_tendsto_nat_atTop
  -- üéâ no goals
#align not_summable_iff_tendsto_nat_at_top_of_nonneg not_summable_iff_tendsto_nat_atTop_of_nonneg

theorem summable_iff_not_tendsto_nat_atTop_of_nonneg {f : ‚Ñï ‚Üí ‚Ñù} (hf : ‚àÄ n, 0 ‚â§ f n) :
    Summable f ‚Üî ¬¨Tendsto (fun n : ‚Ñï => ‚àë i in Finset.range n, f i) atTop atTop := by
  rw [‚Üê not_iff_not, Classical.not_not, not_summable_iff_tendsto_nat_atTop_of_nonneg hf]
  -- üéâ no goals
#align summable_iff_not_tendsto_nat_at_top_of_nonneg summable_iff_not_tendsto_nat_atTop_of_nonneg

theorem summable_sigma_of_nonneg {Œ≤ : Œ± ‚Üí Type*} {f : (Œ£ x, Œ≤ x) ‚Üí ‚Ñù} (hf : ‚àÄ x, 0 ‚â§ f x) :
    Summable f ‚Üî (‚àÄ x, Summable fun y => f ‚ü®x, y‚ü©) ‚àß Summable fun x => ‚àë' y, f ‚ü®x, y‚ü© := by
  lift f to (Œ£x, Œ≤ x) ‚Üí ‚Ñù‚â•0 using hf
  -- ‚ä¢ (Summable fun i => ‚Üë(f i)) ‚Üî (‚àÄ (x : Œ±), Summable fun y => (fun i => ‚Üë(f i)) ‚Ä¶
  exact_mod_cast NNReal.summable_sigma
  -- üéâ no goals
#align summable_sigma_of_nonneg summable_sigma_of_nonneg

theorem summable_prod_of_nonneg {f : (Œ± √ó Œ≤) ‚Üí ‚Ñù} (hf : 0 ‚â§ f) :
    Summable f ‚Üî (‚àÄ x, Summable fun y ‚Ü¶ f (x, y)) ‚àß Summable fun x ‚Ü¶ ‚àë' y, f (x, y) :=
  (Equiv.sigmaEquivProd _ _).summable_iff.symm.trans <| summable_sigma_of_nonneg fun _ ‚Ü¶ hf _

theorem summable_of_sum_le {Œπ : Type*} {f : Œπ ‚Üí ‚Ñù} {c : ‚Ñù} (hf : 0 ‚â§ f)
    (h : ‚àÄ u : Finset Œπ, ‚àë x in u, f x ‚â§ c) : Summable f :=
  ‚ü®‚®Ü u : Finset Œπ, ‚àë x in u, f x,
    tendsto_atTop_ciSup (Finset.sum_mono_set_of_nonneg hf) ‚ü®c, fun _ ‚ü®u, hu‚ü© => hu ‚ñ∏ h u‚ü©‚ü©
#align summable_of_sum_le summable_of_sum_le

theorem summable_of_sum_range_le {f : ‚Ñï ‚Üí ‚Ñù} {c : ‚Ñù} (hf : ‚àÄ n, 0 ‚â§ f n)
    (h : ‚àÄ n, ‚àë i in Finset.range n, f i ‚â§ c) : Summable f := by
  refine (summable_iff_not_tendsto_nat_atTop_of_nonneg hf).2 fun H => ?_
  -- ‚ä¢ False
  rcases exists_lt_of_tendsto_atTop H 0 c with ‚ü®n, -, hn‚ü©
  -- ‚ä¢ False
  exact lt_irrefl _ (hn.trans_le (h n))
  -- üéâ no goals
#align summable_of_sum_range_le summable_of_sum_range_le

theorem Real.tsum_le_of_sum_range_le {f : ‚Ñï ‚Üí ‚Ñù} {c : ‚Ñù} (hf : ‚àÄ n, 0 ‚â§ f n)
    (h : ‚àÄ n, ‚àë i in Finset.range n, f i ‚â§ c) : ‚àë' n, f n ‚â§ c :=
  _root_.tsum_le_of_sum_range_le (summable_of_sum_range_le hf h) h
#align real.tsum_le_of_sum_range_le Real.tsum_le_of_sum_range_le

/-- If a sequence `f` with non-negative terms is dominated by a sequence `g` with summable
series and at least one term of `f` is strictly smaller than the corresponding term in `g`,
then the series of `f` is strictly smaller than the series of `g`. -/
theorem tsum_lt_tsum_of_nonneg {i : ‚Ñï} {f g : ‚Ñï ‚Üí ‚Ñù} (h0 : ‚àÄ b : ‚Ñï, 0 ‚â§ f b)
    (h : ‚àÄ b : ‚Ñï, f b ‚â§ g b) (hi : f i < g i) (hg : Summable g) : ‚àë' n, f n < ‚àë' n, g n :=
  tsum_lt_tsum h hi (summable_of_nonneg_of_le h0 h hg) hg
#align tsum_lt_tsum_of_nonneg tsum_lt_tsum_of_nonneg

section

variable [EMetricSpace Œ≤]

open ENNReal Filter EMetric

/-- In an emetric ball, the distance between points is everywhere finite -/
theorem edist_ne_top_of_mem_ball {a : Œ≤} {r : ‚Ñù‚â•0‚àû} (x y : ball a r) : edist x.1 y.1 ‚â† ‚ä§ :=
  ne_of_lt <|
    calc
      edist x y ‚â§ edist a x + edist a y := edist_triangle_left x.1 y.1 a
      _ < r + r := by rw [edist_comm a x, edist_comm a y]; exact add_lt_add x.2 y.2
                      -- ‚ä¢ edist (‚Üëx) a + edist (‚Üëy) a < r + r
                                                           -- üéâ no goals
      _ ‚â§ ‚ä§ := le_top
#align edist_ne_top_of_mem_ball edist_ne_top_of_mem_ball

/-- Each ball in an extended metric space gives us a metric space, as the edist
is everywhere finite. -/
def metricSpaceEMetricBall (a : Œ≤) (r : ‚Ñù‚â•0‚àû) : MetricSpace (ball a r) :=
  EMetricSpace.toMetricSpace edist_ne_top_of_mem_ball
#align metric_space_emetric_ball metricSpaceEMetricBall

theorem nhds_eq_nhds_emetric_ball (a x : Œ≤) (r : ‚Ñù‚â•0‚àû) (h : x ‚àà ball a r) :
    ùìù x = map ((‚Üë) : ball a r ‚Üí Œ≤) (ùìù ‚ü®x, h‚ü©) :=
  (map_nhds_subtype_coe_eq_nhds _ <| IsOpen.mem_nhds EMetric.isOpen_ball h).symm
#align nhds_eq_nhds_emetric_ball nhds_eq_nhds_emetric_ball

end

section

variable [PseudoEMetricSpace Œ±]

open EMetric

theorem tendsto_iff_edist_tendsto_0 {l : Filter Œ≤} {f : Œ≤ ‚Üí Œ±} {y : Œ±} :
    Tendsto f l (ùìù y) ‚Üî Tendsto (fun x => edist (f x) y) l (ùìù 0) := by
  simp only [EMetric.nhds_basis_eball.tendsto_right_iff, EMetric.mem_ball,
    @tendsto_order ‚Ñù‚â•0‚àû Œ≤ _ _, forall_prop_of_false ENNReal.not_lt_zero, forall_const, true_and_iff]
#align tendsto_iff_edist_tendsto_0 tendsto_iff_edist_tendsto_0

/-- Yet another metric characterization of Cauchy sequences on integers. This one is often the
most efficient. -/
theorem EMetric.cauchySeq_iff_le_tendsto_0 [Nonempty Œ≤] [SemilatticeSup Œ≤] {s : Œ≤ ‚Üí Œ±} :
    CauchySeq s ‚Üî ‚àÉ b : Œ≤ ‚Üí ‚Ñù‚â•0‚àû, (‚àÄ n m N : Œ≤, N ‚â§ n ‚Üí N ‚â§ m ‚Üí edist (s n) (s m) ‚â§ b N) ‚àß
      Tendsto b atTop (ùìù 0) := EMetric.cauchySeq_iff.trans <| by
  constructor
  -- ‚ä¢ (‚àÄ (Œµ : ‚Ñù‚â•0‚àû), Œµ > 0 ‚Üí ‚àÉ N, ‚àÄ (m : Œ≤), N ‚â§ m ‚Üí ‚àÄ (n : Œ≤), N ‚â§ n ‚Üí edist (s m ‚Ä¶
  ¬∑ intro hs
    -- ‚ä¢ ‚àÉ b, (‚àÄ (n m N : Œ≤), N ‚â§ n ‚Üí N ‚â§ m ‚Üí edist (s n) (s m) ‚â§ b N) ‚àß Tendsto b at ‚Ä¶
    /- `s` is Cauchy sequence. Let `b n` be the diameter of the set `s '' Set.Ici n`. -/
    refine ‚ü®fun N => EMetric.diam (s '' Ici N), fun n m N hn hm => ?_, ?_‚ü©
    -- ‚ä¢ edist (s n) (s m) ‚â§ (fun N => diam (s '' Ici N)) N
    -- Prove that it bounds the distances of points in the Cauchy sequence
    ¬∑ exact EMetric.edist_le_diam_of_mem (mem_image_of_mem _ hn) (mem_image_of_mem _ hm)
      -- üéâ no goals
    -- Prove that it tends to `0`, by using the Cauchy property of `s`
    ¬∑ refine ENNReal.tendsto_nhds_zero.2 fun Œµ Œµ0 => ?_
      -- ‚ä¢ ‚àÄ·∂† (x : Œ≤) in atTop, diam (s '' Ici x) ‚â§ Œµ
      rcases hs Œµ Œµ0 with ‚ü®N, hN‚ü©
      -- ‚ä¢ ‚àÄ·∂† (x : Œ≤) in atTop, diam (s '' Ici x) ‚â§ Œµ
      refine (eventually_ge_atTop N).mono fun n hn => EMetric.diam_le ?_
      -- ‚ä¢ ‚àÄ (x : Œ±), x ‚àà s '' Ici n ‚Üí ‚àÄ (y : Œ±), y ‚àà s '' Ici n ‚Üí edist x y ‚â§ Œµ
      rintro _ ‚ü®k, hk, rfl‚ü© _ ‚ü®l, hl, rfl‚ü©
      -- ‚ä¢ edist (s k) (s l) ‚â§ Œµ
      exact (hN _ (hn.trans hk) _ (hn.trans hl)).le
      -- üéâ no goals
  ¬∑ rintro ‚ü®b, ‚ü®b_bound, b_lim‚ü©‚ü© Œµ Œµpos
    -- ‚ä¢ ‚àÉ N, ‚àÄ (m : Œ≤), N ‚â§ m ‚Üí ‚àÄ (n : Œ≤), N ‚â§ n ‚Üí edist (s m) (s n) < Œµ
    have : ‚àÄ·∂† n in atTop, b n < Œµ := b_lim.eventually (gt_mem_nhds Œµpos)
    -- ‚ä¢ ‚àÉ N, ‚àÄ (m : Œ≤), N ‚â§ m ‚Üí ‚àÄ (n : Œ≤), N ‚â§ n ‚Üí edist (s m) (s n) < Œµ
    rcases this.exists with ‚ü®N, hN‚ü©
    -- ‚ä¢ ‚àÉ N, ‚àÄ (m : Œ≤), N ‚â§ m ‚Üí ‚àÄ (n : Œ≤), N ‚â§ n ‚Üí edist (s m) (s n) < Œµ
    refine ‚ü®N, fun m hm n hn => ?_‚ü©
    -- ‚ä¢ edist (s m) (s n) < Œµ
    calc edist (s m) (s n) ‚â§ b N := b_bound m n N hm hn
    _ < Œµ := hN
#align emetric.cauchy_seq_iff_le_tendsto_0 EMetric.cauchySeq_iff_le_tendsto_0

theorem continuous_of_le_add_edist {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (C : ‚Ñù‚â•0‚àû) (hC : C ‚â† ‚ä§)
    (h : ‚àÄ x y, f x ‚â§ f y + C * edist x y) : Continuous f := by
  refine continuous_iff_continuousAt.2 fun x => ENNReal.tendsto_nhds_of_Icc fun Œµ Œµ0 => ?_
  -- ‚ä¢ ‚àÄ·∂† (x_1 : Œ±) in ùìù x, f x_1 ‚àà Icc (f x - Œµ) (f x + Œµ)
  rcases ENNReal.exists_nnreal_pos_mul_lt hC Œµ0.ne' with ‚ü®Œ¥, Œ¥0, hŒ¥‚ü©
  -- ‚ä¢ ‚àÄ·∂† (x_1 : Œ±) in ùìù x, f x_1 ‚àà Icc (f x - Œµ) (f x + Œµ)
  rw [mul_comm] at hŒ¥
  -- ‚ä¢ ‚àÄ·∂† (x_1 : Œ±) in ùìù x, f x_1 ‚àà Icc (f x - Œµ) (f x + Œµ)
  filter_upwards [EMetric.closedBall_mem_nhds x (ENNReal.coe_pos.2 Œ¥0)] with y hy
  -- ‚ä¢ f y ‚àà Icc (f x - Œµ) (f x + Œµ)
  refine ‚ü®tsub_le_iff_right.2 <| (h x y).trans ?_, (h y x).trans ?_‚ü© <;>
  -- ‚ä¢ f y + C * edist x y ‚â§ f y + Œµ
    refine add_le_add_left (le_trans (mul_le_mul_left' ?_ _) hŒ¥.le) _
    -- ‚ä¢ edist x y ‚â§ ‚ÜëŒ¥
    -- ‚ä¢ edist y x ‚â§ ‚ÜëŒ¥
  exacts [EMetric.mem_closedBall'.1 hy, EMetric.mem_closedBall.1 hy]
  -- üéâ no goals
#align continuous_of_le_add_edist continuous_of_le_add_edist

theorem continuous_edist : Continuous fun p : Œ± √ó Œ± => edist p.1 p.2 := by
  apply continuous_of_le_add_edist 2 (by norm_num)
  -- ‚ä¢ ‚àÄ (x y : Œ± √ó Œ±), edist x.fst x.snd ‚â§ edist y.fst y.snd + 2 * edist x y
  rintro ‚ü®x, y‚ü© ‚ü®x', y'‚ü©
  -- ‚ä¢ edist (x, y).fst (x, y).snd ‚â§ edist (x', y').fst (x', y').snd + 2 * edist (x ‚Ä¶
  calc
    edist x y ‚â§ edist x x' + edist x' y' + edist y' y := edist_triangle4 _ _ _ _
    _ = edist x' y' + (edist x x' + edist y y') := by simp only [edist_comm]; ac_rfl
    _ ‚â§ edist x' y' + (edist (x, y) (x', y') + edist (x, y) (x', y')) :=
      (add_le_add_left (add_le_add (le_max_left _ _) (le_max_right _ _)) _)
    _ = edist x' y' + 2 * edist (x, y) (x', y') := by rw [‚Üê mul_two, mul_comm]
#align continuous_edist continuous_edist

@[continuity]
theorem Continuous.edist [TopologicalSpace Œ≤] {f g : Œ≤ ‚Üí Œ±} (hf : Continuous f)
    (hg : Continuous g) : Continuous fun b => edist (f b) (g b) :=
  continuous_edist.comp (hf.prod_mk hg : _)
#align continuous.edist Continuous.edist

theorem Filter.Tendsto.edist {f g : Œ≤ ‚Üí Œ±} {x : Filter Œ≤} {a b : Œ±} (hf : Tendsto f x (ùìù a))
    (hg : Tendsto g x (ùìù b)) : Tendsto (fun x => edist (f x) (g x)) x (ùìù (edist a b)) :=
  (continuous_edist.tendsto (a, b)).comp (hf.prod_mk_nhds hg)
#align filter.tendsto.edist Filter.Tendsto.edist

theorem cauchySeq_of_edist_le_of_tsum_ne_top {f : ‚Ñï ‚Üí Œ±} (d : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû)
    (hf : ‚àÄ n, edist (f n) (f n.succ) ‚â§ d n) (hd : tsum d ‚â† ‚àû) : CauchySeq f := by
  lift d to ‚Ñï ‚Üí NNReal using fun i => ENNReal.ne_top_of_tsum_ne_top hd i
  -- ‚ä¢ CauchySeq f
  rw [ENNReal.tsum_coe_ne_top_iff_summable] at hd
  -- ‚ä¢ CauchySeq f
  exact cauchySeq_of_edist_le_of_summable d hf hd
  -- üéâ no goals
#align cauchy_seq_of_edist_le_of_tsum_ne_top cauchySeq_of_edist_le_of_tsum_ne_top

theorem EMetric.isClosed_ball {a : Œ±} {r : ‚Ñù‚â•0‚àû} : IsClosed (closedBall a r) :=
  isClosed_le (continuous_id.edist continuous_const) continuous_const
#align emetric.is_closed_ball EMetric.isClosed_ball

@[simp]
theorem EMetric.diam_closure (s : Set Œ±) : diam (closure s) = diam s := by
  refine' le_antisymm (diam_le fun x hx y hy => _) (diam_mono subset_closure)
  -- ‚ä¢ edist x y ‚â§ diam s
  have : edist x y ‚àà closure (Iic (diam s)) :=
    map_mem_closure‚ÇÇ continuous_edist hx hy fun x hx y hy => edist_le_diam_of_mem hx hy
  rwa [closure_Iic] at this
  -- üéâ no goals
#align emetric.diam_closure EMetric.diam_closure

@[simp]
theorem Metric.diam_closure {Œ± : Type*} [PseudoMetricSpace Œ±] (s : Set Œ±) :
    Metric.diam (closure s) = diam s := by simp only [Metric.diam, EMetric.diam_closure]
                                           -- üéâ no goals
#align metric.diam_closure Metric.diam_closure

theorem isClosed_setOf_lipschitzOnWith {Œ± Œ≤} [PseudoEMetricSpace Œ±] [PseudoEMetricSpace Œ≤] (K : ‚Ñù‚â•0)
    (s : Set Œ±) : IsClosed { f : Œ± ‚Üí Œ≤ | LipschitzOnWith K f s } := by
  simp only [LipschitzOnWith, setOf_forall]
  -- ‚ä¢ IsClosed (‚ãÇ (i : Œ±) (_ : i ‚àà s) (i_1 : Œ±) (_ : i_1 ‚àà s), {x | edist (x i) (x ‚Ä¶
  refine' isClosed_biInter fun x _ => isClosed_biInter fun y _ => isClosed_le _ _
  -- ‚ä¢ Continuous fun x_1 => edist (x_1 x) (x_1 y)
  exacts [.edist (continuous_apply x) (continuous_apply y), continuous_const]
  -- üéâ no goals
#align is_closed_set_of_lipschitz_on_with isClosed_setOf_lipschitzOnWith

theorem isClosed_setOf_lipschitzWith {Œ± Œ≤} [PseudoEMetricSpace Œ±] [PseudoEMetricSpace Œ≤] (K : ‚Ñù‚â•0) :
    IsClosed { f : Œ± ‚Üí Œ≤ | LipschitzWith K f } := by
  simp only [‚Üê lipschitz_on_univ, isClosed_setOf_lipschitzOnWith]
  -- üéâ no goals
#align is_closed_set_of_lipschitz_with isClosed_setOf_lipschitzWith

namespace Real

/-- For a bounded set `s : Set ‚Ñù`, its `EMetric.diam` is equal to `sSup s - sInf s` reinterpreted as
`‚Ñù‚â•0‚àû`. -/
theorem ediam_eq {s : Set ‚Ñù} (h : Bounded s) :
    EMetric.diam s = ENNReal.ofReal (sSup s - sInf s) := by
  rcases eq_empty_or_nonempty s with (rfl | hne)
  -- ‚ä¢ EMetric.diam ‚àÖ = ENNReal.ofReal (sSup ‚àÖ - sInf ‚àÖ)
  ¬∑ simp
    -- üéâ no goals
  refine' le_antisymm (Metric.ediam_le_of_forall_dist_le fun x hx y hy => _) _
  -- ‚ä¢ dist x y ‚â§ sSup s - sInf s
  ¬∑ have := Real.subset_Icc_sInf_sSup_of_bounded h
    -- ‚ä¢ dist x y ‚â§ sSup s - sInf s
    exact Real.dist_le_of_mem_Icc (this hx) (this hy)
    -- üéâ no goals
  ¬∑ apply ENNReal.ofReal_le_of_le_toReal
    -- ‚ä¢ sSup s - sInf s ‚â§ ENNReal.toReal (EMetric.diam s)
    rw [‚Üê Metric.diam, ‚Üê Metric.diam_closure]
    -- ‚ä¢ sSup s - sInf s ‚â§ Metric.diam (closure s)
    have h' := Real.bounded_iff_bddBelow_bddAbove.1 h
    -- ‚ä¢ sSup s - sInf s ‚â§ Metric.diam (closure s)
    calc sSup s - sInf s ‚â§ dist (sSup s) (sInf s) := le_abs_self _
    _ ‚â§ Metric.diam (closure s) := dist_le_diam_of_mem h.closure (csSup_mem_closure hne h'.2)
        (csInf_mem_closure hne h'.1)
#align real.ediam_eq Real.ediam_eq

/-- For a bounded set `s : Set ‚Ñù`, its `Metric.diam` is equal to `sSup s - sInf s`. -/
theorem diam_eq {s : Set ‚Ñù} (h : Bounded s) : Metric.diam s = sSup s - sInf s := by
  rw [Metric.diam, Real.ediam_eq h, ENNReal.toReal_ofReal]
  -- ‚ä¢ 0 ‚â§ sSup s - sInf s
  rw [Real.bounded_iff_bddBelow_bddAbove] at h
  -- ‚ä¢ 0 ‚â§ sSup s - sInf s
  exact sub_nonneg.2 (Real.sInf_le_sSup s h.1 h.2)
  -- üéâ no goals
#align real.diam_eq Real.diam_eq

@[simp]
theorem ediam_Ioo (a b : ‚Ñù) : EMetric.diam (Ioo a b) = ENNReal.ofReal (b - a) := by
  rcases le_or_lt b a with (h | h)
  -- ‚ä¢ EMetric.diam (Ioo a b) = ENNReal.ofReal (b - a)
  ¬∑ simp [h]
    -- üéâ no goals
  ¬∑ rw [Real.ediam_eq (bounded_Ioo _ _), csSup_Ioo h, csInf_Ioo h]
    -- üéâ no goals
#align real.ediam_Ioo Real.ediam_Ioo

@[simp]
theorem ediam_Icc (a b : ‚Ñù) : EMetric.diam (Icc a b) = ENNReal.ofReal (b - a) := by
  rcases le_or_lt a b with (h | h)
  -- ‚ä¢ EMetric.diam (Icc a b) = ENNReal.ofReal (b - a)
  ¬∑ rw [Real.ediam_eq (bounded_Icc _ _), csSup_Icc h, csInf_Icc h]
    -- üéâ no goals
  ¬∑ simp [h, h.le]
    -- üéâ no goals
#align real.ediam_Icc Real.ediam_Icc

@[simp]
theorem ediam_Ico (a b : ‚Ñù) : EMetric.diam (Ico a b) = ENNReal.ofReal (b - a) :=
  le_antisymm (ediam_Icc a b ‚ñ∏ diam_mono Ico_subset_Icc_self)
    (ediam_Ioo a b ‚ñ∏ diam_mono Ioo_subset_Ico_self)
#align real.ediam_Ico Real.ediam_Ico

@[simp]
theorem ediam_Ioc (a b : ‚Ñù) : EMetric.diam (Ioc a b) = ENNReal.ofReal (b - a) :=
  le_antisymm (ediam_Icc a b ‚ñ∏ diam_mono Ioc_subset_Icc_self)
    (ediam_Ioo a b ‚ñ∏ diam_mono Ioo_subset_Ioc_self)
#align real.ediam_Ioc Real.ediam_Ioc

theorem diam_Icc {a b : ‚Ñù} (h : a ‚â§ b) : Metric.diam (Icc a b) = b - a := by
  simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]
  -- üéâ no goals
#align real.diam_Icc Real.diam_Icc

theorem diam_Ico {a b : ‚Ñù} (h : a ‚â§ b) : Metric.diam (Ico a b) = b - a := by
  simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]
  -- üéâ no goals
#align real.diam_Ico Real.diam_Ico

theorem diam_Ioc {a b : ‚Ñù} (h : a ‚â§ b) : Metric.diam (Ioc a b) = b - a := by
  simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]
  -- üéâ no goals
#align real.diam_Ioc Real.diam_Ioc

theorem diam_Ioo {a b : ‚Ñù} (h : a ‚â§ b) : Metric.diam (Ioo a b) = b - a := by
  simp [Metric.diam, ENNReal.toReal_ofReal (sub_nonneg.2 h)]
  -- üéâ no goals
#align real.diam_Ioo Real.diam_Ioo

end Real

/-- If `edist (f n) (f (n+1))` is bounded above by a function `d : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû`,
then the distance from `f n` to the limit is bounded by `‚àë'_{k=n}^‚àû d k`. -/
theorem edist_le_tsum_of_edist_le_of_tendsto {f : ‚Ñï ‚Üí Œ±} (d : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû)
    (hf : ‚àÄ n, edist (f n) (f n.succ) ‚â§ d n) {a : Œ±} (ha : Tendsto f atTop (ùìù a)) (n : ‚Ñï) :
    edist (f n) a ‚â§ ‚àë' m, d (n + m) := by
  refine' le_of_tendsto (tendsto_const_nhds.edist ha) (mem_atTop_sets.2 ‚ü®n, fun m hnm => _‚ü©)
  -- ‚ä¢ m ‚àà {x | (fun c => edist (f n) (f c) ‚â§ ‚àë' (m : ‚Ñï), d (n + m)) x}
  refine' le_trans (edist_le_Ico_sum_of_edist_le hnm fun _ _ => hf _) _
  -- ‚ä¢ ‚àë i in Finset.Ico n m, d i ‚â§ ‚àë' (m : ‚Ñï), d (n + m)
  rw [Finset.sum_Ico_eq_sum_range]
  -- ‚ä¢ ‚àë k in Finset.range (m - n), d (n + k) ‚â§ ‚àë' (m : ‚Ñï), d (n + m)
  exact sum_le_tsum _ (fun _ _ => zero_le _) ENNReal.summable
  -- üéâ no goals
#align edist_le_tsum_of_edist_le_of_tendsto edist_le_tsum_of_edist_le_of_tendsto

/-- If `edist (f n) (f (n+1))` is bounded above by a function `d : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû`,
then the distance from `f 0` to the limit is bounded by `‚àë'_{k=0}^‚àû d k`. -/
theorem edist_le_tsum_of_edist_le_of_tendsto‚ÇÄ {f : ‚Ñï ‚Üí Œ±} (d : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû)
    (hf : ‚àÄ n, edist (f n) (f n.succ) ‚â§ d n) {a : Œ±} (ha : Tendsto f atTop (ùìù a)) :
    edist (f 0) a ‚â§ ‚àë' m, d m := by simpa using edist_le_tsum_of_edist_le_of_tendsto d hf ha 0
                                    -- üéâ no goals
#align edist_le_tsum_of_edist_le_of_tendsto‚ÇÄ edist_le_tsum_of_edist_le_of_tendsto‚ÇÄ

end

section LimsupLiminf

namespace ENNReal
set_option autoImplicit true

lemma limsup_sub_const (F : Filter Œπ) [NeBot F] (f : Œπ ‚Üí ‚Ñù‚â•0‚àû) (c : ‚Ñù‚â•0‚àû) :
    Filter.limsup (fun i ‚Ü¶ f i - c) F = Filter.limsup f F - c :=
  (Monotone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : ‚Ñù‚â•0‚àû) ‚Ü¶ x - c)
    (fun _ _ h ‚Ü¶ tsub_le_tsub_right h c) (continuous_sub_right c).continuousAt).symm

lemma liminf_sub_const (F : Filter Œπ) [NeBot F] (f : Œπ ‚Üí ‚Ñù‚â•0‚àû) (c : ‚Ñù‚â•0‚àû) :
    Filter.liminf (fun i ‚Ü¶ f i - c) F = Filter.liminf f F - c :=
  (Monotone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : ‚Ñù‚â•0‚àû) ‚Ü¶ x - c)
    (fun _ _ h ‚Ü¶ tsub_le_tsub_right h c) (continuous_sub_right c).continuousAt).symm

lemma limsup_const_sub (F : Filter Œπ) [NeBot F] (f : Œπ ‚Üí ‚Ñù‚â•0‚àû)
    {c : ‚Ñù‚â•0‚àû} (c_ne_top : c ‚â† ‚àû):
    Filter.limsup (fun i ‚Ü¶ c - f i) F = c - Filter.liminf f F :=
  (Antitone.map_limsInf_of_continuousAt (F := F.map f) (f := fun (x : ‚Ñù‚â•0‚àû) ‚Ü¶ c - x)
    (fun _ _ h ‚Ü¶ tsub_le_tsub_left h c) (continuous_sub_left c_ne_top).continuousAt).symm

lemma liminf_const_sub (F : Filter Œπ) [NeBot F] (f : Œπ ‚Üí ‚Ñù‚â•0‚àû)
    {c : ‚Ñù‚â•0‚àû} (c_ne_top : c ‚â† ‚àû):
    Filter.liminf (fun i ‚Ü¶ c - f i) F = c - Filter.limsup f F :=
  (Antitone.map_limsSup_of_continuousAt (F := F.map f) (f := fun (x : ‚Ñù‚â•0‚àû) ‚Ü¶ c - x)
    (fun _ _ h ‚Ü¶ tsub_le_tsub_left h c) (continuous_sub_left c_ne_top).continuousAt).symm

end ENNReal -- namespace

end LimsupLiminf
