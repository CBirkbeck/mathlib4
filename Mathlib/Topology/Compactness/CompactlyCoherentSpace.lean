/-
Copyright (c) 2025 Floris van Doorn and Hannah Scholz. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn, Hannah Scholz
-/

import Mathlib.Topology.Defs.Induced
import Mathlib.Topology.Coherent
import Mathlib.Topology.Compactness.CompactlyGeneratedSpace

/-!
# Compactly coherent spaces and the k-ification

In this file we will define compactly coherent spaces and the compact coherentification and prove
basic properties about them. This is a weaker version of `CompactlyGeneratedSpace`.
These notions agree on Hausdorff spaces. They are both referred to as compactly generated spaces in
the literature while the compact coherentification is often called the compact coherentification.

## Main definitions
* `CompactlyCoherentSpace`: A compactly coherent space is a topological space in which a set `A` is
  open iff for every compact set `B`, the intersection `A ∩ B` is open in `B`.
* `CompactlyCoherentSpace.CompactCoherentification`: For a topological space `X` one can define
  another topology on `X` as follows: `A` is open iff for all compact sets `B`, the intersection
  `A ∩ B` is open in `B`.

## Main results
* `CompactlyCoherentSpace.of_weaklyLocallyCompactSpace`: every weakly locally compact space is a
  compactly coherent space.
* `CompactlyCoherentSpace.of_sequentialSpace`: every sequential space is a compactly coherent space.
* `CompactlyCoherentSpace.of_compactlyGeneratedSpace`: every compactly generated space is a
  compactly coherent space.
* `CompactlyCoherentSpace.isCompact_iff_isCompact_in_compactCoherentification`: The compact sets of
  a topological space and its compact coherentification agree.
* `CompactlyCoherentSpace.CompactCoherentification.instCompactlyCoherentSpace`: The compact
  coherentification makes any space into a compactly coherent space.
* `CompactlyCoherentSpace.compactCoherentification_compactlyCoherentSpace_eq_self`: The compact
  coherentification of a compactly coherent space `X` preserves the topology on `X`.
* `CompactlyCoherentSpace.continuous_compactCoherentification_of_continuousOn_compact`: If a map
  `f : X → Y` is continuous on every compact subset of `X` then it is continuous when viewed as a
  map from `CompactCoherentification X` to `CompactCoherentification Y`.

## References
* [J. Munkres, *Topology*][Munkres2000]
* <https://en.wikipedia.org/wiki/Compactly_generated_space>
-/

noncomputable section

open Set Set.Notation Topology

/-! ### Compactly coherent spaces-/

/-- A space is a compactly coherent space if the topology is generated by the compact sets. -/
class CompactlyCoherentSpace  (X : Type*) [TopologicalSpace X] : Prop where
  /-- A space is a compactly coherent space if the topology is generated by the compact sets.-/
  isCoherentWith : IsCoherentWith (X := X) {K | IsCompact K}

namespace CompactlyCoherentSpace

universe u

variable {X : Type u} [TopologicalSpace X]

/-- A set `A` in a compactly coherent space is open iff for every compact set `K`, the intersection
`K ∩ A` is open in `K`. -/
lemma isOpen_iff [CompactlyCoherentSpace X] (A : Set X) :
    IsOpen A ↔ ∀ K, IsCompact K → IsOpen (K ↓∩ A) :=
  IsCoherentWith.isOpen_iff isCoherentWith

/-- A set `A` in a compactly coherent space is closed iff for every compact set `K`, the
intersection `K ∩ A` is closed in `K`. -/
lemma isClosed_iff [CompactlyCoherentSpace X] (A : Set X) :
    IsClosed A ↔ ∀ K, IsCompact K → IsClosed (K ↓∩ A) :=
  IsCoherentWith.isClosed_iff isCoherentWith

/-- If every set `A` is open if for every compact `K` the intersection `K ∩ A` is open in `K`,
then the space is a compactly coherent space. -/
lemma of_isOpen (h : ∀ (A : Set X), (∀ K, IsCompact K → IsOpen (K ↓∩ A)) → IsOpen A) :
    CompactlyCoherentSpace X where
  isCoherentWith := {isOpen_of_forall_induced := h}

/-- If every set `A` is closed if for every compact `K` the intersection `K ∩ A` is closed in `K`,
then the space is a compactly coherent space. -/
lemma of_isClosed (h : ∀ (A : Set X), (∀ K, IsCompact K → IsClosed (K ↓∩ A)) → IsClosed A) :
    CompactlyCoherentSpace X where
  isCoherentWith := IsCoherentWith.of_isClosed h

/-- Every weakly locally compact space is a compactly coherent space. -/
instance of_weaklyLocallyCompactSpace [WeaklyLocallyCompactSpace X] : CompactlyCoherentSpace X where
  isCoherentWith := IsCoherentWith.isCompact_of_weaklyLocallyCompact

/-- Every sequential space is a compactly coherent space. -/
instance of_sequentialSpace [SequentialSpace X] : CompactlyCoherentSpace X where
  isCoherentWith := IsCoherentWith.isCompact_of_seq

/-- In a compactly coherent space `X`, a set `s` is open when `f ⁻¹' s` is open for every continuous
map from a compact space. -/
lemma preimage_isOpen [CompactlyCoherentSpace X] (s : Set X)
    (hs : (∀ (K : Type u) [TopologicalSpace K],
      [CompactSpace K] → ∀ (f : K → X), Continuous f → IsOpen (f ⁻¹' s))) :
    IsOpen s := by
  rw [isOpen_iff]
  intro K hK
  let _ : CompactSpace (Elem K) := isCompact_iff_compactSpace.mp hK
  exact hs (Elem K) Subtype.val continuous_subtype_val

/-- A topological space `X` is compactly coherent if a set `s` is open when `f ⁻¹' s?` is open for
every continuous map `f : K → X`, where `K` is compact. -/
lemma of_preimage_isOpen (h : ∀ (s : Set X), (∀ (K : Type u) [TopologicalSpace K],
      [CompactSpace K] → ∀ (f : K → X), Continuous f → IsOpen (f ⁻¹' s)) → IsOpen s) :
    CompactlyCoherentSpace X where
  isCoherentWith := {
    isOpen_of_forall_induced := by
      intro s hs
      apply h s
      intro K _ _ f hf
      change IsOpen ((fun x ↦ ⟨f x, mem_image_of_mem f trivial⟩) ⁻¹' ((f '' univ) ↓∩ s))
      apply (hf.subtype_mk fun x ↦ mem_image_of_mem f trivial).isOpen_preimage
      exact hs (f '' univ) (CompactSpace.isCompact_univ.image hf)}

/-- Every compactly generated space is a compactly coherent space. -/
instance of_compactlyGeneratedSpace [CompactlyGeneratedSpace X] : CompactlyCoherentSpace X := by
  apply of_preimage_isOpen
  intro s h
  apply CompactlyGeneratedSpace.isOpen'
  intro K _ _ _ f hf
  exact h K f hf

/-- A compactly coherent space that is Hausdorff is compactly generated. -/
instance compactlyGeneratedSpace_of_kspace_of_t2 [T2Space X] [CompactlyCoherentSpace X] :
    CompactlyGeneratedSpace X := by
  apply compactlyGeneratedSpace_of_isClosed_of_t2
  intro s hs
  rw [isClosed_iff]
  intro K hK
  rw [← Subtype.preimage_coe_inter_self]
  exact (hs K hK).preimage_val

/-- A type synonym used for the compact coherentification of a topological space. -/
def CompactCoherentification (X : Type*) := X

/-- The map taking a space to its compact coherentification. -/
def toCompactlyCoherent (X : Type*) : X ≃ CompactCoherentification X := Equiv.refl _

lemma toCompactlyCoherent_image {X : Type*} (A : Set X) :
    toCompactlyCoherent X '' A = (A : Set (CompactCoherentification X)) := by
  ext
  exact mem_image_iff_of_inverse (congrFun rfl) (congrFun rfl)

lemma toCompactlyCoherent_symm_image {X : Type*} (A : Set X) :
    (toCompactlyCoherent X).symm '' A = A := by
  ext
  exact mem_image_iff_of_inverse (congrFun rfl) (congrFun rfl)

lemma toCompactlyCoherent_preimage {X : Type*} (A : Set X) :
    toCompactlyCoherent X ⁻¹' A = (A : Set (CompactCoherentification X)) := by
  ext
  exact mem_preimage

lemma toCompactlyCoherent_symm_preimage {X : Type*} (A : Set X) :
    (toCompactlyCoherent X).symm ⁻¹' A = A := by
  ext
  exact mem_preimage

/-- For a topological space `X` the compact coherentification is defined as:
`A` is open iff for all compact sets `B`, the intersection `A ∩ B` is open in `B`. -/
instance CompactCoherentification.instTopologicalSpace :
    TopologicalSpace (CompactCoherentification X) where
  IsOpen A := ∀ (K : Set X), IsCompact K → IsOpen (K ↓∩ (toCompactlyCoherent X).symm '' A)
  isOpen_univ := by simp
  isOpen_inter A B hA hB K hK := by
    rw [image_inter (toCompactlyCoherent X).symm.injective]
    exact (hA K hK).inter (hB K hK)
  isOpen_sUnion s hs K hK := by
    rw [image_sUnion]
    rw [preimage_val_sUnion]
    apply isOpen_sUnion
    rintro _ ⟨u, hu, rfl⟩
    rw [mem_image] at hu
    obtain ⟨t, ht⟩ := hu
    exact ht.2 ▸ hs t ht.1 K hK

/-- A set `A` in the compact coherentification is open iff for all compact sets `K`,
the intersection `K ∩ A` is open in `K`. -/
lemma CompactCoherentification.isOpen_iff {A : Set (CompactCoherentification X)} : IsOpen A ↔
    ∀ (K : Set X), IsCompact K → IsOpen (K ↓∩ (toCompactlyCoherent X).symm '' A) := by
  rfl

/-- A set `A` is the compact coherentification is closed iff for all compact sets `K`,
the intersection `K ∩ A` is closed in `K`. -/
lemma CompactCoherentification.isClosed_iff {A : Set (CompactCoherentification X)} :
    IsClosed (X := CompactCoherentification X) A ↔
      ∀ (K : Set X), IsCompact K → IsClosed (K ↓∩ (toCompactlyCoherent X).symm '' A) := by
  rw [← isOpen_compl_iff, isOpen_iff, Equiv.image_compl]
  congrm ∀ (K : Set X), IsCompact K → ?_
  exact isOpen_compl_iff

lemma continuous_toCompactlyCoherent_symm :
    Continuous (toCompactlyCoherent X).symm where
  isOpen_preimage A hA := by
    rw [CompactCoherentification.isOpen_iff, Equiv.image_preimage]
    intros
    exact isOpen_induced hA

lemma isOpenMap_toCompactlyCoherent : IsOpenMap (toCompactlyCoherent X) := by
  intro A hA
  rw [CompactCoherentification.isOpen_iff, Equiv.symm_image_image]
  intro K hK
  exact hA.preimage_val

/-- The compact coherentification is finer than the original topology. -/
lemma CompactCoherentification_le {X : Type*} [t : TopologicalSpace X] :
    (CompactCoherentification.instTopologicalSpace :
    TopologicalSpace X) ≤ (t : TopologicalSpace X) := by
  rw [← continuous_id_iff_le]
  change Continuous (toCompactlyCoherent X).symm
  exact continuous_toCompactlyCoherent_symm

/-- The compact sets of a topological space and its compact coherentification agree. -/
lemma isCompact_iff_isCompact_toCompactlyCoherent_image (K : Set X) :
    IsCompact K ↔ IsCompact (toCompactlyCoherent X '' K) := by
  constructor
  · intro hK
    rw [isCompact_iff_finite_subcover]
    intro ι U hU hKU
    simp_rw [CompactCoherentification.isOpen_iff] at hU
    choose U' hU' using hU
    have hKU' : K ⊆ ⋃ i, U' i K hK := by
      simp_rw [← inter_eq_left, inter_iUnion,
        Subtype.preimage_coe_eq_preimage_coe_iff.mp (hU' _ K hK).2, ← inter_iUnion, inter_eq_left,
        toCompactlyCoherent_symm_image]
      rw [toCompactlyCoherent_image] at hKU
      exact hKU
    rcases (isCompact_iff_finite_subcover.1 hK) (fun i ↦ U' i K hK)
      (fun i ↦ (hU' i K hK).1) hKU' with ⟨ι', hι'⟩
    use ι'
    have := fun i ↦ toCompactlyCoherent_symm_image _ ▸
      Subtype.preimage_coe_eq_preimage_coe_iff.mp (hU' i K hK).2
    simp_rw [toCompactlyCoherent_image, ← inter_eq_left, inter_iUnion,
      ← this, ← inter_iUnion, inter_eq_left]
    exact hι'
  · intro hK
    exact (toCompactlyCoherent X).symm_image_image K ▸ hK.image continuous_toCompactlyCoherent_symm

/-- The compact coherentification makes any space into a compactly coherent space. -/
instance CompactCoherentification.instCompactlyCoherentSpace :
    CompactlyCoherentSpace (CompactCoherentification X) where
  isCoherentWith := {
    isOpen_of_forall_induced := by
      intro A h
      rw [CompactCoherentification.isOpen_iff]
      intro K hK
      obtain ⟨E, hE, hEA⟩ :=
        h (toCompactlyCoherent X '' K) ((isCompact_iff_isCompact_toCompactlyCoherent_image K).1 hK)
      rw [CompactCoherentification.isOpen_iff] at hE
      obtain ⟨F, openF, hF⟩ := hE K hK
      refine ⟨F, openF, ?_⟩
      rw [toCompactlyCoherent_image] at hEA
      simp only [CompactCoherentification] at hEA
      simp_rw [hF, toCompactlyCoherent_symm_image, hEA]}

/-- The compact coherentification preserves the topology of k-spaces. -/
lemma compactCoherentification_compactlyCoherentSpace_eq_self {X : Type*} [t : TopologicalSpace X]
    [CompactlyCoherentSpace X] : t = CompactCoherentification.instTopologicalSpace := by
  rw [TopologicalSpace.ext_iff]
  intro
  rw [CompactCoherentification.isOpen_iff, CompactlyCoherentSpace.isOpen_iff,
    toCompactlyCoherent_symm_image]

variable {Y : Type*} [TopologicalSpace Y]

lemma from_compactCoherentification_continuous_of_continuous (f : X → Y)
    (hf : Continuous f) : Continuous (X := CompactCoherentification X) f := by
  rw [continuous_def] at hf ⊢
  intro s hs
  exact (TopologicalSpace.le_def.1 CompactCoherentification_le) (f ⁻¹' s) (hf s hs)

lemma from_compactCoherentification_continuousOn_of_continuousOn (f : X → Y) (s : Set X)
    (hf : ContinuousOn f s) : ContinuousOn (X := CompactCoherentification X) f s := by
  rw [continuousOn_iff'] at hf ⊢
  intro t ht
  obtain ⟨u, hu, hut⟩ := hf t ht
  exact ⟨u, ⟨(TopologicalSpace.le_def.1 CompactCoherentification_le) u hu, hut⟩⟩

lemma continuous_compact_to_compactCoherentification [CompactSpace X] (f : X → Y)
    (hf : Continuous f) : Continuous ((toCompactlyCoherent Y) ∘ f) := by
  rw [continuous_iff_isClosed]
  intro s hs
  simp_rw [CompactCoherentification.isClosed_iff, isClosed_induced_iff,
    Subtype.preimage_val_eq_preimage_val_iff] at hs
  obtain ⟨t, ht, hst⟩ := hs (range f) (isCompact_range hf)
  suffices IsClosed (f ⁻¹' (range f ∩ s)) by
    simpa only [preimage_inter, preimage_range, univ_inter]
  rw [toCompactlyCoherent_symm_image] at hst
  rw [← hst, Set.preimage_inter, Set.preimage_range, Set.univ_inter]
  exact ht.preimage hf

lemma continuousOn_compact_to_compactCoherentification {A : Set X} (hA : IsCompact A) (f : X → Y)
    (hf : ContinuousOn f A) : ContinuousOn ((toCompactlyCoherent Y) ∘ f) A := by
  rw [continuousOn_iff_continuous_restrict] at hf ⊢
  have _ := isCompact_iff_compactSpace.1 hA
  exact continuous_compact_to_compactCoherentification (A.restrict f) hf

/-- If a map `f : X → Y` is continuous on every compact subset of `X` then it is continuous when
viewed as a map from `CompactCoherentification X` to `CompactCoherentification Y`. -/
lemma continuous_compactCoherentification_of_continuousOn_compact (f : X → Y)
    (hf : ∀ (C : Set X), IsCompact C → ContinuousOn f C) :
    Continuous ((toCompactlyCoherent Y) ∘ f ∘ (toCompactlyCoherent X).symm) := by
  have hf' :  ∀ (C : Set X), IsCompact C → ContinuousOn ((toCompactlyCoherent Y) ∘ f) C :=
    fun C hC ↦ continuousOn_compact_to_compactCoherentification hC f (hf C hC)
  rw [continuous_def]
  intro V hV
  simp only [CompactCoherentification.isOpen_iff]
  intro C hC
  specialize hf' C hC
  rw [continuousOn_iff'] at hf'
  obtain ⟨U, hU, hUV⟩ := hf' V hV
  rw [← Function.comp_assoc, preimage_comp, Equiv.image_preimage]
  suffices IsOpen (C ↓∩ (f ⁻¹' V ∩ C)) by
    rw [preimage_inter, Subtype.coe_preimage_self, inter_univ] at this
    exact this
  simp [preimage_comp, toCompactlyCoherent_preimage] at hUV
  rw [hUV, preimage_inter, Subtype.coe_preimage_self, inter_univ]
  exact isOpen_induced hU

lemma continuous_compactCoherentification_of_continuous (f : X → Y) (hf : Continuous f) :
    Continuous ((toCompactlyCoherent Y) ∘ f ∘ (toCompactlyCoherent X).symm) := by
  apply continuous_compactCoherentification_of_continuousOn_compact
  intros
  exact hf.continuousOn

instance t2space_compactCoherentification_of_t2space [t : T2Space X] :
    T2Space (CompactCoherentification X) :=
  t2Space_antitone CompactCoherentification_le t

end CompactlyCoherentSpace
