/-
Copyright (c) 2021 Yury G. Kudryashov. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury G. Kudryashov
-/
import Mathlib.Analysis.NormedSpace.AddTorsor
import Mathlib.LinearAlgebra.AffineSpace.Ordered
import Mathlib.Topology.ContinuousFunction.Basic

#align_import topology.urysohns_lemma from "leanprover-community/mathlib"@"f2ce6086713c78a7f880485f7917ea547a215982"

/-!
# Urysohn's lemma

In this file we prove Urysohn's lemma `exists_continuous_zero_one_of_closed`: for any two disjoint
closed sets `s` and `t` in a normal topological space `X` there exists a continuous function
`f : X ‚Üí ‚Ñù` such that

* `f` equals zero on `s`;
* `f` equals one on `t`;
* `0 ‚â§ f x ‚â§ 1` for all `x`.

## Implementation notes

Most paper sources prove Urysohn's lemma using a family of open sets indexed by dyadic rational
numbers on `[0, 1]`. There are many technical difficulties with formalizing this proof (e.g., one
needs to formalize the "dyadic induction", then prove that the resulting family of open sets is
monotone). So, we formalize a slightly different proof.

Let `Urysohns.CU` be the type of pairs `(C, U)` of a closed set `C` and an open set `U` such that
`C ‚äÜ U`. Since `X` is a normal topological space, for each `c : CU X` there exists an open set `u`
such that `c.C ‚äÜ u ‚àß closure u ‚äÜ c.U`. We define `c.left` and `c.right` to be `(c.C, u)` and
`(closure u, c.U)`, respectively. Then we define a family of functions
`Urysohns.CU.approx (c : Urysohns.CU X) (n : ‚Ñï) : X ‚Üí ‚Ñù` by recursion on `n`:

* `c.approx 0` is the indicator of `c.U·∂ú`;
* `c.approx (n + 1) x = (c.left.approx n x + c.right.approx n x) / 2`.

For each `x` this is a monotone family of functions that are equal to zero on `c.C` and are equal to
one outside of `c.U`. We also have `c.approx n x ‚àà [0, 1]` for all `c`, `n`, and `x`.

Let `Urysohns.CU.lim c` be the supremum (or equivalently, the limit) of `c.approx n`. Then
properties of `Urysohns.CU.approx` immediately imply that

* `c.lim x ‚àà [0, 1]` for all `x`;
* `c.lim` equals zero on `c.C` and equals one outside of `c.U`;
* `c.lim x = (c.left.lim x + c.right.lim x) / 2`.

In order to prove that `c.lim` is continuous at `x`, we prove by induction on `n : ‚Ñï` that for `y`
in a small neighborhood of `x` we have `|c.lim y - c.lim x| ‚â§ (3 / 4) ^ n`. Induction base follows
from `c.lim x ‚àà [0, 1]`, `c.lim y ‚àà [0, 1]`. For the induction step, consider two cases:

* `x ‚àà c.left.U`; then for `y` in a small neighborhood of `x` we have `y ‚àà c.left.U ‚äÜ c.right.C`
  (hence `c.right.lim x = c.right.lim y = 0`) and `|c.left.lim y - c.left.lim x| ‚â§ (3 / 4) ^ n`.
  Then
  `|c.lim y - c.lim x| = |c.left.lim y - c.left.lim x| / 2 ‚â§ (3 / 4) ^ n / 2 < (3 / 4) ^ (n + 1)`.
* otherwise, `x ‚àâ c.left.right.C`; then for `y` in a small neighborhood of `x` we have
  `y ‚àâ c.left.right.C ‚äá c.left.left.U` (hence `c.left.left.lim x = c.left.left.lim y = 1`),
  `|c.left.right.lim y - c.left.right.lim x| ‚â§ (3 / 4) ^ n`, and
  `|c.right.lim y - c.right.lim x| ‚â§ (3 / 4) ^ n`. Combining these inequalities, the triangle
  inequality, and the recurrence formula for `c.lim`, we get
  `|c.lim x - c.lim y| ‚â§ (3 / 4) ^ (n + 1)`.

The actual formalization uses `midpoint ‚Ñù x y` instead of `(x + y) / 2` because we have more API
lemmas about `midpoint`.

## Tags

Urysohn's lemma, normal topological space
-/


variable {X : Type*} [TopologicalSpace X]

open Set Filter TopologicalSpace Topology Filter

namespace Urysohns

set_option linter.uppercaseLean3 false

/-- An auxiliary type for the proof of Urysohn's lemma: a pair of a closed set `C` and its
open neighborhood `U`. -/
structure CU (X : Type*) [TopologicalSpace X] where
  protected (C U : Set X)
  protected closed_C : IsClosed C
  protected open_U : IsOpen U
  protected subset : C ‚äÜ U
#align urysohns.CU Urysohns.CU

instance : Inhabited (CU X) :=
  ‚ü®‚ü®‚àÖ, univ, isClosed_empty, isOpen_univ, empty_subset _‚ü©‚ü©

variable [NormalSpace X]

namespace CU

/-- Due to `normal_exists_closure_subset`, for each `c : CU X` there exists an open set `u`
such that `c.C ‚äÜ u` and `closure u ‚äÜ c.U`. `c.left` is the pair `(c.C, u)`. -/
@[simps C]
def left (c : CU X) : CU X where
  C := c.C
  U := (normal_exists_closure_subset c.closed_C c.open_U c.subset).choose
  closed_C := c.closed_C
  open_U := (normal_exists_closure_subset c.closed_C c.open_U c.subset).choose_spec.1
  subset := (normal_exists_closure_subset c.closed_C c.open_U c.subset).choose_spec.2.1
#align urysohns.CU.left Urysohns.CU.left

/-- Due to `normal_exists_closure_subset`, for each `c : CU X` there exists an open set `u`
such that `c.C ‚äÜ u` and `closure u ‚äÜ c.U`. `c.right` is the pair `(closure u, c.U)`. -/
@[simps U]
def right (c : CU X) : CU X where
  C := closure (normal_exists_closure_subset c.closed_C c.open_U c.subset).choose
  U := c.U
  closed_C := isClosed_closure
  open_U := c.open_U
  subset := (normal_exists_closure_subset c.closed_C c.open_U c.subset).choose_spec.2.2
#align urysohns.CU.right Urysohns.CU.right

theorem left_U_subset_right_C (c : CU X) : c.left.U ‚äÜ c.right.C :=
  subset_closure
#align urysohns.CU.left_U_subset_right_C Urysohns.CU.left_U_subset_right_C

theorem left_U_subset (c : CU X) : c.left.U ‚äÜ c.U :=
  Subset.trans c.left_U_subset_right_C c.right.subset
#align urysohns.CU.left_U_subset Urysohns.CU.left_U_subset

theorem subset_right_C (c : CU X) : c.C ‚äÜ c.right.C :=
  Subset.trans c.left.subset c.left_U_subset_right_C
#align urysohns.CU.subset_right_C Urysohns.CU.subset_right_C

/-- `n`-th approximation to a continuous function `f : X ‚Üí ‚Ñù` such that `f = 0` on `c.C` and `f = 1`
outside of `c.U`. -/
noncomputable def approx : ‚Ñï ‚Üí CU X ‚Üí X ‚Üí ‚Ñù
  | 0, c, x => indicator c.U·∂ú 1 x
  | n + 1, c, x => midpoint ‚Ñù (approx n c.left x) (approx n c.right x)
#align urysohns.CU.approx Urysohns.CU.approx

theorem approx_of_mem_C (c : CU X) (n : ‚Ñï) {x : X} (hx : x ‚àà c.C) : c.approx n x = 0 := by
  induction' n with n ihn generalizing c
  -- ‚ä¢ approx Nat.zero c x = 0
  ¬∑ exact indicator_of_not_mem (fun (hU : x ‚àà c.U·∂ú) => hU <| c.subset hx) _
    -- üéâ no goals
  ¬∑ simp only [approx]
    -- ‚ä¢ midpoint ‚Ñù (approx n (left c) x) (approx n (right c) x) = 0
    rw [ihn, ihn, midpoint_self]
    -- ‚ä¢ x ‚àà (right c).C
    exacts [c.subset_right_C hx, hx]
    -- üéâ no goals
#align urysohns.CU.approx_of_mem_C Urysohns.CU.approx_of_mem_C

theorem approx_of_nmem_U (c : CU X) (n : ‚Ñï) {x : X} (hx : x ‚àâ c.U) : c.approx n x = 1 := by
  induction' n with n ihn generalizing c
  -- ‚ä¢ approx Nat.zero c x = 1
  ¬∑ rw [‚Üê mem_compl_iff] at hx
    -- ‚ä¢ approx Nat.zero c x = 1
    exact indicator_of_mem hx _
    -- üéâ no goals
  ¬∑ simp only [approx]
    -- ‚ä¢ midpoint ‚Ñù (approx n (left c) x) (approx n (right c) x) = 1
    rw [ihn, ihn, midpoint_self]
    -- ‚ä¢ ¬¨x ‚àà (right c).U
    exacts [hx, fun hU => hx <| c.left_U_subset hU]
    -- üéâ no goals
#align urysohns.CU.approx_of_nmem_U Urysohns.CU.approx_of_nmem_U

theorem approx_nonneg (c : CU X) (n : ‚Ñï) (x : X) : 0 ‚â§ c.approx n x := by
  induction' n with n ihn generalizing c
  -- ‚ä¢ 0 ‚â§ approx Nat.zero c x
  ¬∑ exact indicator_nonneg (fun _ _ => zero_le_one) _
    -- üéâ no goals
  ¬∑ simp only [approx, midpoint_eq_smul_add, invOf_eq_inv]
    -- ‚ä¢ 0 ‚â§ 2‚Åª¬π ‚Ä¢ (approx n (left c) x + approx n (right c) x)
    refine' mul_nonneg (inv_nonneg.2 zero_le_two) (add_nonneg _ _) <;> apply ihn
    -- ‚ä¢ 0 ‚â§ approx n (left c) x
                                                                       -- üéâ no goals
                                                                       -- üéâ no goals
#align urysohns.CU.approx_nonneg Urysohns.CU.approx_nonneg

theorem approx_le_one (c : CU X) (n : ‚Ñï) (x : X) : c.approx n x ‚â§ 1 := by
  induction' n with n ihn generalizing c
  -- ‚ä¢ approx Nat.zero c x ‚â§ 1
  ¬∑ exact indicator_apply_le' (fun _ => le_rfl) fun _ => zero_le_one
    -- üéâ no goals
  ¬∑ simp only [approx, midpoint_eq_smul_add, invOf_eq_inv, smul_eq_mul, ‚Üê div_eq_inv_mul]
    -- ‚ä¢ (approx n (left c) x + approx n (right c) x) / 2 ‚â§ 1
    have := add_le_add (ihn (left c)) (ihn (right c))
    -- ‚ä¢ (approx n (left c) x + approx n (right c) x) / 2 ‚â§ 1
    norm_num at this
    -- ‚ä¢ (approx n (left c) x + approx n (right c) x) / 2 ‚â§ 1
    exact Iff.mpr (div_le_one zero_lt_two) this
    -- üéâ no goals
#align urysohns.CU.approx_le_one Urysohns.CU.approx_le_one

theorem bddAbove_range_approx (c : CU X) (x : X) : BddAbove (range fun n => c.approx n x) :=
  ‚ü®1, fun _ ‚ü®n, hn‚ü© => hn ‚ñ∏ c.approx_le_one n x‚ü©
#align urysohns.CU.bdd_above_range_approx Urysohns.CU.bddAbove_range_approx

theorem approx_le_approx_of_U_sub_C {c‚ÇÅ c‚ÇÇ : CU X} (h : c‚ÇÅ.U ‚äÜ c‚ÇÇ.C) (n‚ÇÅ n‚ÇÇ : ‚Ñï) (x : X) :
    c‚ÇÇ.approx n‚ÇÇ x ‚â§ c‚ÇÅ.approx n‚ÇÅ x := by
  by_cases hx : x ‚àà c‚ÇÅ.U
  -- ‚ä¢ approx n‚ÇÇ c‚ÇÇ x ‚â§ approx n‚ÇÅ c‚ÇÅ x
  ¬∑ calc
      approx n‚ÇÇ c‚ÇÇ x = 0 := approx_of_mem_C _ _ (h hx)
      _ ‚â§ approx n‚ÇÅ c‚ÇÅ x := approx_nonneg _ _ _
  ¬∑ calc
      approx n‚ÇÇ c‚ÇÇ x ‚â§ 1 := approx_le_one _ _ _
      _ = approx n‚ÇÅ c‚ÇÅ x := (approx_of_nmem_U _ _ hx).symm
#align urysohns.CU.approx_le_approx_of_U_sub_C Urysohns.CU.approx_le_approx_of_U_sub_C

theorem approx_mem_Icc_right_left (c : CU X) (n : ‚Ñï) (x : X) :
    c.approx n x ‚àà Icc (c.right.approx n x) (c.left.approx n x) := by
  induction' n with n ihn generalizing c
  -- ‚ä¢ approx Nat.zero c x ‚àà Icc (approx Nat.zero (right c) x) (approx Nat.zero (le ‚Ä¶
  ¬∑ exact ‚ü®le_rfl, indicator_le_indicator_of_subset (compl_subset_compl.2 c.left_U_subset)
      (fun _ => zero_le_one) _‚ü©
  ¬∑ simp only [approx, mem_Icc]
    -- ‚ä¢ midpoint ‚Ñù (approx n (left (right c)) x) (approx n (right (right c)) x) ‚â§ mi ‚Ä¶
    refine' ‚ü®midpoint_le_midpoint _ (ihn _).1, midpoint_le_midpoint (ihn _).2 _‚ü© <;>
    -- ‚ä¢ approx n (left (right c)) x ‚â§ approx n (left c) x
      apply approx_le_approx_of_U_sub_C
      -- ‚ä¢ (left c).U ‚äÜ (left (right c)).C
      -- ‚ä¢ (right (left c)).U ‚äÜ (right c).C
    exacts [subset_closure, subset_closure]
    -- üéâ no goals
#align urysohns.CU.approx_mem_Icc_right_left Urysohns.CU.approx_mem_Icc_right_left

theorem approx_le_succ (c : CU X) (n : ‚Ñï) (x : X) : c.approx n x ‚â§ c.approx (n + 1) x := by
  induction' n with n ihn generalizing c
  -- ‚ä¢ approx Nat.zero c x ‚â§ approx (Nat.zero + 1) c x
  ¬∑ simp only [approx, right_U, right_le_midpoint]
    -- ‚ä¢ indicator c.U·∂ú 1 x ‚â§ indicator (left c).U·∂ú 1 x
    exact (approx_mem_Icc_right_left c 0 x).2
    -- üéâ no goals
  ¬∑ rw [approx, approx]
    -- ‚ä¢ midpoint ‚Ñù (approx n (left c) x) (approx n (right c) x) ‚â§ midpoint ‚Ñù (approx ‚Ä¶
    exact midpoint_le_midpoint (ihn _) (ihn _)
    -- üéâ no goals
#align urysohns.CU.approx_le_succ Urysohns.CU.approx_le_succ

theorem approx_mono (c : CU X) (x : X) : Monotone fun n => c.approx n x :=
  monotone_nat_of_le_succ fun n => c.approx_le_succ n x
#align urysohns.CU.approx_mono Urysohns.CU.approx_mono

/-- A continuous function `f : X ‚Üí ‚Ñù` such that

* `0 ‚â§ f x ‚â§ 1` for all `x`;
* `f` equals zero on `c.C` and equals one outside of `c.U`;
-/
protected noncomputable def lim (c : CU X) (x : X) : ‚Ñù :=
  ‚®Ü n, c.approx n x
#align urysohns.CU.lim Urysohns.CU.lim

theorem tendsto_approx_atTop (c : CU X) (x : X) :
    Tendsto (fun n => c.approx n x) atTop (ùìù <| c.lim x) :=
  tendsto_atTop_ciSup (c.approx_mono x) ‚ü®1, fun _ ‚ü®_, hn‚ü© => hn ‚ñ∏ c.approx_le_one _ _‚ü©
#align urysohns.CU.tendsto_approx_at_top Urysohns.CU.tendsto_approx_atTop

theorem lim_of_mem_C (c : CU X) (x : X) (h : x ‚àà c.C) : c.lim x = 0 := by
  simp only [CU.lim, approx_of_mem_C, h, ciSup_const]
  -- üéâ no goals
#align urysohns.CU.lim_of_mem_C Urysohns.CU.lim_of_mem_C

theorem lim_of_nmem_U (c : CU X) (x : X) (h : x ‚àâ c.U) : c.lim x = 1 := by
  simp only [CU.lim, approx_of_nmem_U c _ h, ciSup_const]
  -- üéâ no goals
#align urysohns.CU.lim_of_nmem_U Urysohns.CU.lim_of_nmem_U

theorem lim_eq_midpoint (c : CU X) (x : X) :
    c.lim x = midpoint ‚Ñù (c.left.lim x) (c.right.lim x) := by
  refine' tendsto_nhds_unique (c.tendsto_approx_atTop x) ((tendsto_add_atTop_iff_nat 1).1 _)
  -- ‚ä¢ Tendsto (fun n => approx (n + 1) c x) atTop (ùìù (midpoint ‚Ñù (CU.lim (left c)  ‚Ä¶
  simp only [approx]
  -- ‚ä¢ Tendsto (fun n => midpoint ‚Ñù (approx (Nat.add n 0) (left c) x) (approx (Nat. ‚Ä¶
  exact (c.left.tendsto_approx_atTop x).midpoint (c.right.tendsto_approx_atTop x)
  -- üéâ no goals
#align urysohns.CU.lim_eq_midpoint Urysohns.CU.lim_eq_midpoint

theorem approx_le_lim (c : CU X) (x : X) (n : ‚Ñï) : c.approx n x ‚â§ c.lim x :=
  le_ciSup (c.bddAbove_range_approx x) _
#align urysohns.CU.approx_le_lim Urysohns.CU.approx_le_lim

theorem lim_nonneg (c : CU X) (x : X) : 0 ‚â§ c.lim x :=
  (c.approx_nonneg 0 x).trans (c.approx_le_lim x 0)
#align urysohns.CU.lim_nonneg Urysohns.CU.lim_nonneg

theorem lim_le_one (c : CU X) (x : X) : c.lim x ‚â§ 1 :=
  ciSup_le fun _ => c.approx_le_one _ _
#align urysohns.CU.lim_le_one Urysohns.CU.lim_le_one

theorem lim_mem_Icc (c : CU X) (x : X) : c.lim x ‚àà Icc (0 : ‚Ñù) 1 :=
  ‚ü®c.lim_nonneg x, c.lim_le_one x‚ü©
#align urysohns.CU.lim_mem_Icc Urysohns.CU.lim_mem_Icc

/-- Continuity of `Urysohns.CU.lim`. See module docstring for a sketch of the proofs. -/
theorem continuous_lim (c : CU X) : Continuous c.lim := by
  obtain ‚ü®h0, h1234, h1‚ü© : 0 < (2‚Åª¬π : ‚Ñù) ‚àß (2‚Åª¬π : ‚Ñù) < 3 / 4 ‚àß (3 / 4 : ‚Ñù) < 1 := by norm_num
  -- ‚ä¢ Continuous (CU.lim c)
  refine'
    continuous_iff_continuousAt.2 fun x =>
      (Metric.nhds_basis_closedBall_pow (h0.trans h1234) h1).tendsto_right_iff.2 fun n _ => _
  simp only [Metric.mem_closedBall]
  -- ‚ä¢ ‚àÄ·∂† (x_1 : X) in ùìù x, dist (CU.lim c x_1) (CU.lim c x) ‚â§ (3 / 4) ^ n
  induction' n with n ihn generalizing c
  -- ‚ä¢ ‚àÄ·∂† (x_1 : X) in ùìù x, dist (CU.lim c x_1) (CU.lim c x) ‚â§ (3 / 4) ^ Nat.zero
  ¬∑ refine' eventually_of_forall fun y => _
    -- ‚ä¢ dist (CU.lim c y) (CU.lim c x) ‚â§ (3 / 4) ^ Nat.zero
    rw [pow_zero]
    -- ‚ä¢ dist (CU.lim c y) (CU.lim c x) ‚â§ 1
    exact Real.dist_le_of_mem_Icc_01 (c.lim_mem_Icc _) (c.lim_mem_Icc _)
    -- üéâ no goals
  ¬∑ by_cases hxl : x ‚àà c.left.U
    -- ‚ä¢ ‚àÄ·∂† (x_1 : X) in ùìù x, dist (CU.lim c x_1) (CU.lim c x) ‚â§ (3 / 4) ^ Nat.succ n
    ¬∑ filter_upwards [IsOpen.mem_nhds c.left.open_U hxl, ihn c.left]with _ hyl hyd
      -- ‚ä¢ dist (CU.lim c a‚úù) (CU.lim c x) ‚â§ (3 / 4) ^ Nat.succ n
      rw [pow_succ, c.lim_eq_midpoint, c.lim_eq_midpoint,
        c.right.lim_of_mem_C _ (c.left_U_subset_right_C hyl),
        c.right.lim_of_mem_C _ (c.left_U_subset_right_C hxl)]
      refine' (dist_midpoint_midpoint_le _ _ _ _).trans _
      -- ‚ä¢ (dist (CU.lim (left c) a‚úù) (CU.lim (left c) x) + dist 0 0) / 2 ‚â§ 3 / 4 * (3  ‚Ä¶
      rw [dist_self, add_zero, div_eq_inv_mul]
      -- ‚ä¢ 2‚Åª¬π * dist (CU.lim (left c) a‚úù) (CU.lim (left c) x) ‚â§ 3 / 4 * (3 / 4) ^ n
      gcongr
      -- üéâ no goals
    ¬∑ replace hxl : x ‚àà c.left.right.C·∂ú
      -- ‚ä¢ x ‚àà (right (left c)).C·∂ú
      exact compl_subset_compl.2 c.left.right.subset hxl
      -- ‚ä¢ ‚àÄ·∂† (x_1 : X) in ùìù x, dist (CU.lim c x_1) (CU.lim c x) ‚â§ (3 / 4) ^ Nat.succ n
      filter_upwards [IsOpen.mem_nhds (isOpen_compl_iff.2 c.left.right.closed_C) hxl,
        ihn c.left.right, ihn c.right]with y hyl hydl hydr
      replace hxl : x ‚àâ c.left.left.U
      -- ‚ä¢ ¬¨x ‚àà (left (left c)).U
      exact compl_subset_compl.2 c.left.left_U_subset_right_C hxl
      -- ‚ä¢ dist (CU.lim c y) (CU.lim c x) ‚â§ (3 / 4) ^ Nat.succ n
      replace hyl : y ‚àâ c.left.left.U
      -- ‚ä¢ ¬¨y ‚àà (left (left c)).U
      exact compl_subset_compl.2 c.left.left_U_subset_right_C hyl
      -- ‚ä¢ dist (CU.lim c y) (CU.lim c x) ‚â§ (3 / 4) ^ Nat.succ n
      simp only [pow_succ, c.lim_eq_midpoint, c.left.lim_eq_midpoint,
        c.left.left.lim_of_nmem_U _ hxl, c.left.left.lim_of_nmem_U _ hyl]
      refine' (dist_midpoint_midpoint_le _ _ _ _).trans _
      -- ‚ä¢ (dist (midpoint ‚Ñù 1 (CU.lim (right (left c)) y)) (midpoint ‚Ñù 1 (CU.lim (righ ‚Ä¶
      refine' (div_le_div_of_le_of_nonneg (add_le_add_right (dist_midpoint_midpoint_le _ _ _ _) _)
        zero_le_two).trans _
      rw [dist_self, zero_add]
      -- ‚ä¢ (dist (CU.lim (right (left c)) y) (CU.lim (right (left c)) x) / 2 + dist (CU ‚Ä¶
      set r := (3 / 4 : ‚Ñù) ^ n
      -- ‚ä¢ (dist (CU.lim (right (left c)) y) (CU.lim (right (left c)) x) / 2 + dist (CU ‚Ä¶
      calc _ ‚â§ (r / 2 + r) / 2 := by gcongr
        _ = _ := by field_simp; ring
#align urysohns.CU.continuous_lim Urysohns.CU.continuous_lim

end CU

end Urysohns

variable [NormalSpace X]

/-- Urysohn's lemma: if `s` and `t` are two disjoint closed sets in a normal topological space `X`,
then there exists a continuous function `f : X ‚Üí ‚Ñù` such that

* `f` equals zero on `s`;
* `f` equals one on `t`;
* `0 ‚â§ f x ‚â§ 1` for all `x`.
-/
theorem exists_continuous_zero_one_of_closed {s t : Set X} (hs : IsClosed s) (ht : IsClosed t)
    (hd : Disjoint s t) : ‚àÉ f : C(X, ‚Ñù), EqOn f 0 s ‚àß EqOn f 1 t ‚àß ‚àÄ x, f x ‚àà Icc (0 : ‚Ñù) 1 := by
  -- The actual proof is in the code above. Here we just repack it into the expected format.
  set c : Urysohns.CU X := ‚ü®s, t·∂ú, hs, ht.isOpen_compl, disjoint_left.1 hd‚ü©
  -- ‚ä¢ ‚àÉ f, EqOn (‚Üëf) 0 s ‚àß EqOn (‚Üëf) 1 t ‚àß ‚àÄ (x : X), ‚Üëf x ‚àà Icc 0 1
  exact ‚ü®‚ü®c.lim, c.continuous_lim‚ü©, c.lim_of_mem_C, fun x hx => c.lim_of_nmem_U _ fun h => h hx,
    c.lim_mem_Icc‚ü©
#align exists_continuous_zero_one_of_closed exists_continuous_zero_one_of_closed
