/-
Copyright (c) 2021 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot
-/
import Mathlib.Order.Filter.Bases
import Mathlib.Topology.Algebra.Module.Basic

/-!
# Group and ring filter bases

A `GroupFilterBasis` is a `FilterBasis` on a group with some properties relating
the basis to the group structure. The main theorem is that a `GroupFilterBasis`
on a group gives a topology on the group which makes it into a topological group
with neighborhoods of the neutral element generated by the given basis.

## Main definitions and results

Given a group `G` and a ring `R`:

* `GroupFilterBasis G`: the type of filter bases that will become neighborhood of `1`
  for a topology on `G` compatible with the group structure
* `GroupFilterBasis.topology`: the associated topology
* `GroupFilterBasis.isTopologicalGroup`: the compatibility between the above topology
  and the group structure
* `RingFilterBasis R`: the type of filter bases that will become neighborhood of `0`
  for a topology on `R` compatible with the ring structure
* `RingFilterBasis.topology`: the associated topology
* `RingFilterBasis.isTopologicalRing`: the compatibility between the above topology
  and the ring structure

## References

* [N. Bourbaki, *General Topology*][bourbaki1966]
-/


open Filter Set TopologicalSpace Function

open Topology Filter Pointwise

universe u

namespace Filter

/-- A `GroupFilterBasis` on a group is a `FilterBasis` satisfying some additional axioms.
  Example : if `G` is a topological group then the neighbourhoods of the identity are a
  `GroupFilterBasis`. Conversely given a `GroupFilterBasis` one can define a topology
  compatible with the group structure on `G`. -/
class IsGroupBasis {G : Type*} {ι : Sort*} [Group G] (p : ι → Prop) (s : ι → Set G)
    extends IsBasis p s where
  one' : ∀ {i}, p i → (1 : G) ∈ s i
  mul' : ∀ {i}, p i → ∃ j, p j ∧ s j * s j ⊆ s i
  inv' : ∀ {i}, p i → ∃ j, p j ∧ s j ⊆ (s i)⁻¹
  conj' : ∀ x₀, ∀ {i}, p i → ∃ j, p j ∧ s j ⊆ (x₀ * · * x₀⁻¹) ⁻¹' (s i)

/-- An `AddGroupFilterBasis` on an additive group is a `FilterBasis` satisfying some additional
  axioms. Example : if `G` is a topological group then the neighbourhoods of the identity are an
  `AddGroupFilterBasis`. Conversely given an `AddGroupFilterBasis` one can define a topology
  compatible with the group structure on `G`. -/
class IsAddGroupBasis {G : Type*} {ι : Sort*} [AddGroup G] (p : ι → Prop) (s : ι → Set G)
    extends IsBasis p s where
  zero' : ∀ {i}, p i → (0 : G) ∈ s i
  add' : ∀ {i}, p i → ∃ j, p j ∧ s j + s j ⊆ s i
  neg' : ∀ {i}, p i → ∃ j, p j ∧ s j ⊆ -(s i)
  conj' : ∀ x₀, ∀ {i}, p i → ∃ j, p j ∧ s j ⊆ (x₀ + · + -x₀) ⁻¹' (s i)

attribute [to_additive existing] IsGroupBasis IsGroupBasis.conj'
  IsGroupBasis.toIsBasis

/-- `GroupFilterBasis` constructor in the commutative group case. -/
@[to_additive "`AddGroupFilterBasis` constructor in the additive commutative group case."]
def IsGroupBasis.mk_of_comm {G : Type*} {ι : Sort*} [CommGroup G] (p : ι → Prop) (s : ι → Set G)
    (toIsBasis : IsBasis p s) (one : ∀ {i}, p i → (1 : G) ∈ s i)
    (mul : ∀ {i}, p i → ∃ j, p j ∧ s j * s j ⊆ s i)
    (inv : ∀ {i}, p i → ∃ j, p j ∧ s j ⊆ (s i)⁻¹) :
    IsGroupBasis p s :=
  { toIsBasis := toIsBasis
    one' := one
    mul' := mul
    inv' := inv
    conj' := fun x U U_in ↦ ⟨U, U_in, by simp only [mul_inv_cancel_comm, preimage_id']; rfl⟩ }

namespace IsGroupBasis

variable {G : Type*} {ι : Sort*} [Group G] {p : ι → Prop} {s : ι → Set G} (hB : IsGroupBasis p s)
include hB

@[to_additive]
theorem one {i} : p i → (1 : G) ∈ s i := hB.one'

@[to_additive]
theorem mul {i} : p i → ∃ j, p j ∧ s j * s j ⊆ s i := hB.mul'

@[to_additive]
theorem inv {i} : p i → ∃ j, p j ∧ s j ⊆ (s i)⁻¹ := hB.inv'

@[to_additive]
theorem conj : ∀ x₀, ∀ {i}, p i → ∃ j, p j ∧ s j ⊆ (x₀ * · * x₀⁻¹) ⁻¹' (s i) :=
  hB.conj'

@[to_additive]
theorem subset_mul_self {i} (h : p i) : s i ⊆ s i * s i :=
  fun x x_in ↦ ⟨1, hB.one h, x, x_in, one_mul x⟩

/-- The neighborhood function of a `GroupFilterBasis`. -/
@[to_additive "The neighborhood function of an `AddGroupFilterBasis`."]
def N : G → Filter G := fun x ↦ x • hB.filter

@[to_additive (attr := simp)]
theorem N_one : hB.N 1 = hB.filter := by
  simp only [N, one_smul]

@[to_additive]
theorem hasBasis_N (x : G) :
    HasBasis (hB.N x) p (fun i ↦ x • (s i)) :=
  hB.hasBasis.map (fun y ↦ x * y)

/-- The topological space structure coming from a group filter basis. -/
@[to_additive "The topological space structure coming from an additive group filter basis."]
def topology : TopologicalSpace G :=
  TopologicalSpace.mkOfNhds hB.N

@[to_additive]
theorem nhds_eq {x₀ : G} : @nhds G hB.topology x₀ = hB.N x₀ := by
  apply TopologicalSpace.nhds_mkOfNhds_of_hasBasis hB.hasBasis_N
  · intro a i hi
    exact ⟨1, hB.one hi, mul_one a⟩
  · intro a i hi
    rcases hB.mul hi with ⟨j, hj, hji⟩
    filter_upwards [hB.hasBasis_N a |>.mem_of_mem hj]
    rintro _ ⟨x, hx, rfl⟩
    calc
      (a * x) • (s j) ∈ hB.N (a * x) := hB.hasBasis_N _ |>.mem_of_mem hj
      _ = a • x • (s j) := smul_smul .. |>.symm
      _ ⊆ a • (s j * s j) := smul_set_mono <| smul_set_subset_smul hx
      _ ⊆ a • (s i) := smul_set_mono hji

@[to_additive]
theorem nhds_one_eq :
    @nhds G hB.topology (1 : G) = hB.filter := by
  rw [hB.nhds_eq, hB.N_one]

@[to_additive]
theorem nhds_hasBasis (x₀ : G) :
    HasBasis (@nhds G hB.topology x₀) p (fun i ↦ x₀ • (s i)) := by
  rw [hB.nhds_eq]
  apply hB.hasBasis_N

@[to_additive]
theorem nhds_one_hasBasis :
    HasBasis (@nhds G hB.topology 1) p s := by
  rw [hB.nhds_one_eq]
  exact hB.hasBasis

@[to_additive]
theorem mem_nhds_one {i} (hi : p i) :
    s i ∈ @nhds G hB.topology 1 :=
  hB.nhds_one_hasBasis.mem_of_mem hi

-- See note [lower instance priority]
/-- If a group is endowed with a topological structure coming from a group filter basis then it's a
topological group. -/
@[to_additive "If a group is endowed with a topological structure coming from a group filter basis
then it's a topological group."]
instance (priority := 100) instTopologicalGroup :
    @TopologicalGroup G hB.topology _ := by
  letI := hB.topology
  have basis := hB.nhds_one_hasBasis
  have basis' := basis.prod_pprod basis
  refine TopologicalGroup.of_nhds_one ?_ ?_ ?_ ?_
  · refine basis'.tendsto_iff basis |>.mpr fun i hi ↦ (hB.mul hi).imp' (fun i ↦ ⟨i, i⟩)
      fun j ⟨hj, hji⟩ ↦ ⟨⟨hj, hj⟩, ?_⟩
    simpa [← image2_mul, forall_mem_comm] using hji
  · exact basis.tendsto_iff basis |>.mpr fun i hi ↦ (hB.inv hi).imp fun j ↦ id
  · intro x₀
    rw [nhds_eq, nhds_one_eq]
    rfl
  · exact fun x₀ ↦ basis.tendsto_iff basis |>.mpr fun i hi ↦ (hB.conj x₀ hi).imp fun j ↦ id

end IsGroupBasis

/-- A `RingFilterBasis` on a ring is a `FilterBasis` satisfying some additional axioms.
  Example : if `R` is a topological ring then the neighbourhoods of the identity are a
  `RingFilterBasis`. Conversely given a `RingFilterBasis` on a ring `R`, one can define a
  topology on `R` which is compatible with the ring structure. -/
class IsRingBasis {R : Type*} {ι : Sort*} [Ring R] (p : ι → Prop) (s : ι → Set R) extends
    IsAddGroupBasis p s where
  mul' : ∀ {i}, p i → ∃ j, p j ∧ s j * s j ⊆ s i
  mul_left' : ∀ (x₀ : R) {i}, p i → ∃ j, p j ∧ s j ⊆ (x₀ * ·) ⁻¹' (s i)
  mul_right' : ∀ (x₀ : R) {i}, p i → ∃ j, p j ∧ s j ⊆ (· * x₀) ⁻¹' (s i)

namespace IsRingBasis

variable {R : Type*} {ι : Sort*} [Ring R] {p : ι → Prop} {s : ι → Set R} (hB : IsRingBasis p s)
include hB

theorem mul {i} (hi : p i) : ∃ j, p j ∧ s j * s j ⊆ s i :=
  hB.mul' hi

theorem mul_left (x₀ : R) {i} (hi : p i) : ∃ j, p j ∧ s j ⊆ (x₀ * ·) ⁻¹' (s i) :=
  hB.mul_left' x₀ hi

theorem mul_right (x₀ : R) {i} (hi : p i) : ∃ j, p j ∧ s j ⊆ (· * x₀) ⁻¹' (s i) :=
  hB.mul_right' x₀ hi

/-- The topology associated to a ring filter basis.
It has the given basis as a basis of neighborhoods of zero. -/
nonrec def topology : TopologicalSpace R := hB.topology

/-- If a ring is endowed with a topological structure coming from
a ring filter basis then it's a topological ring. -/
instance (priority := 100) instTopologicalRing :
    @TopologicalRing R hB.topology _ := by
  letI := hB.topology
  have basis := hB.nhds_zero_hasBasis
  have basis' := basis.prod_pprod basis
  haveI := hB.instTopologicalAddGroup
  apply TopologicalRing.of_addGroup_of_nhds_zero
  · refine basis'.tendsto_iff basis |>.mpr fun i hi ↦ (hB.mul hi).imp' (fun i ↦ ⟨i, i⟩)
      fun j ⟨hj, hji⟩ ↦ ⟨⟨hj, hj⟩, ?_⟩
    simpa [← image2_mul, forall_mem_comm] using hji
  · exact fun x₀ ↦ basis.tendsto_iff basis |>.mpr fun i hi ↦ (hB.mul_left x₀ hi).imp fun j ↦ id
  · exact fun x₀ ↦ basis.tendsto_iff basis |>.mpr fun i hi ↦ (hB.mul_right x₀ hi).imp fun j ↦ id

end IsRingBasis

/-- A `ModuleFilterBasis` on a module is a `FilterBasis` satisfying some additional axioms.
  Example : if `M` is a topological module then the neighbourhoods of zero are a
  `ModuleFilterBasis`. Conversely given a `ModuleFilterBasis` one can define a topology
  compatible with the module structure on `M`. -/
structure IsModuleBasis (R : Type*) {M : Type*} {ι : Sort*} [CommRing R] [TopologicalSpace R]
    [AddCommGroup M] [Module R M] (p : ι → Prop) (s : ι → Set M) extends IsAddGroupBasis p s where
  smul' : ∀ {i}, p i → ∃ V ∈ 𝓝 (0 : R), ∃ j, p j ∧ V • (s j) ⊆ s i
  smul_left' : ∀ (x₀ : R) {i}, p i → ∃ j, p j ∧ s j ⊆ (x₀ • ·) ⁻¹' (s j)
  smul_right' : ∀ (m₀ : M) {i}, p i → ∀ᶠ x in 𝓝 (0 : R), x • m₀ ∈ s i

namespace IsModuleBasis

variable {R M : Type*} {ι : Sort*} [CommRing R] [TopologicalSpace R]
    [AddCommGroup M] [Module R M] {p : ι → Prop} {s : ι → Set M} (hB : IsModuleBasis R p s)
include hB

theorem smul {i} (hi : p i) : ∃ V ∈ 𝓝 (0 : R), ∃ j, p j ∧ V • (s j) ⊆ s i :=
  hB.smul' hi

theorem smul_left (x₀ : R) {i} (hi : p i) : ∃ j, p j ∧ s j ⊆ (x₀ • ·) ⁻¹' (s j) :=
  hB.smul_left' x₀ hi

theorem smul_right (m₀ : M) {i} (hi : p i) : ∀ᶠ x in 𝓝 (0 : R), x • m₀ ∈ s i :=
  hB.smul_right' m₀ hi

/- TODO
/-- If `R` is discrete then the trivial additive group filter basis on any `R`-module is a
module filter basis. -/
instance [DiscreteTopology R] : Inhabited (ModuleFilterBasis R M) :=
  ⟨{
      show AddGroupFilterBasis M from
        default with
      smul' := by
        rintro U (rfl : U ∈ {{(0 : M)}})
        use univ, univ_mem, {0}, rfl
        rintro a ⟨x, -, m, rfl, rfl⟩
        simp only [smul_zero, mem_singleton_iff]
      smul_left' := by
        rintro x₀ U (h : U ∈ {{(0 : M)}})
        rw [mem_singleton_iff] at h
        use {0}, rfl
        simp [h]
      smul_right' := by
        rintro m₀ U (h : U ∈ (0 : Set (Set M)))
        rw [Set.mem_zero] at h
        simp [h, nhds_discrete] }⟩
-/

/-- The topology associated to a module filter basis on a module over a topological ring.
It has the given basis as a basis of neighborhoods of zero. -/
nonrec def topology : TopologicalSpace M := hB.topology

/-- The topology associated to a module filter basis on a module over a topological ring.
It has the given basis as a basis of neighborhoods of zero. This version gets the ring
topology by unification instead of type class inference. -/
def topology' {R M : Type*} {ι : Sort*} [CommRing R] {_ : TopologicalSpace R}
    [AddCommGroup M] [Module R M] {p : ι → Prop} {s : ι → Set M} (hB : IsModuleBasis R p s) :
    TopologicalSpace M :=
  hB.topology

/-- A topological add group with a basis of `𝓝 0` satisfying the axioms of `ModuleFilterBasis`
is a topological module.

This lemma is mathematically useless because one could obtain such a result by applying
`ModuleFilterBasis.continuousSMul` and use the fact that group topologies are characterized
by their neighborhoods of 0 to obtain the `ContinuousSMul` on the pre-existing topology.

But it turns out it's just easier to get it as a byproduct of the proof, so this is just a free
quality-of-life improvement. -/
theorem _root_.ContinuousSMul.of_basis_zero {ι : Type*} [TopologicalRing R] [TopologicalSpace M]
    [TopologicalAddGroup M] {p : ι → Prop} {b : ι → Set M} (h : HasBasis (𝓝 0) p b)
    (hsmul : ∀ {i}, p i → ∃ V ∈ 𝓝 (0 : R), ∃ j, p j ∧ V • b j ⊆ b i)
    (hsmul_left : ∀ (x₀ : R) {i}, p i → ∃ j, p j ∧ MapsTo (x₀ • ·) (b j) (b i))
    (hsmul_right : ∀ (m₀ : M) {i}, p i → ∀ᶠ x in 𝓝 (0 : R), x • m₀ ∈ b i) : ContinuousSMul R M := by
  apply ContinuousSMul.of_nhds_zero
  · rw [h.tendsto_right_iff]
    intro i hi
    rcases hsmul hi with ⟨V, V_in, j, hj, hVj⟩
    apply mem_of_superset (prod_mem_prod V_in <| h.mem_of_mem hj)
    rintro ⟨v, w⟩ ⟨v_in : v ∈ V, w_in : w ∈ b j⟩
    exact hVj (Set.smul_mem_smul v_in w_in)
  · intro m₀
    rw [h.tendsto_right_iff]
    intro i hi
    exact hsmul_right m₀ hi
  · intro x₀
    rw [h.tendsto_right_iff]
    intro i hi
    rcases hsmul_left x₀ hi with ⟨j, hj, hji⟩
    exact mem_of_superset (h.mem_of_mem hj) hji

/-- If a module is endowed with a topological structure coming from
a module filter basis then it's a topological module. -/
instance (priority := 100) continuousSMul [TopologicalRing R] :
    @ContinuousSMul R M _ _ B.topology := by
  let B' := B.toAddGroupFilterBasis
  let _ := B'.topology
  have _ := B'.isTopologicalAddGroup
  exact ContinuousSMul.of_basis_zero B'.nhds_zero_hasBasis
      (fun {_} => by simpa using B.smul)
      (by simpa using B.smul_left) B.smul_right

/-- Build a module filter basis from compatible ring and additive group filter bases. -/
def ofBases {R M : Type*} [CommRing R] [AddCommGroup M] [Module R M] (BR : RingFilterBasis R)
    (BM : AddGroupFilterBasis M) (smul : ∀ {U}, U ∈ BM → ∃ V ∈ BR, ∃ W ∈ BM, V • W ⊆ U)
    (smul_left : ∀ (x₀ : R) {U}, U ∈ BM → ∃ V ∈ BM, V ⊆ (fun x ↦ x₀ • x) ⁻¹' U)
    (smul_right : ∀ (m₀ : M) {U}, U ∈ BM → ∃ V ∈ BR, V ⊆ (fun x ↦ x • m₀) ⁻¹' U) :
    @ModuleFilterBasis R M _ BR.topology _ _ :=
  let _ := BR.topology
  { BM with
    smul' := by
      intro U U_in
      rcases smul U_in with ⟨V, V_in, W, W_in, H⟩
      exact ⟨V, BR.toAddGroupFilterBasis.mem_nhds_zero V_in, W, W_in, H⟩
    smul_left' := smul_left
    smul_right' := by
      intro m₀ U U_in
      rcases smul_right m₀ U_in with ⟨V, V_in, H⟩
      exact mem_of_superset (BR.toAddGroupFilterBasis.mem_nhds_zero V_in) H }

end ModuleFilterBasis
