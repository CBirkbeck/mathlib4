/-
Copyright (c) 2024 Jiedong Jiang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jiedong Jiang
-/

import Mathlib.FieldTheory.Minpoly.IsConjRoot
import Mathlib.FieldTheory.AlgebraicClosure
import Mathlib.RingTheory.Valuation.RankOne
import Mathlib.Topology.Algebra.Valued.NormedValued
import Mathlib.Topology.Algebra.IntermediateField
import Mathlib.Analysis.Normed.Group.Hom
import Mathlib.Analysis.Normed.Field.Lemmas
import Mathlib.Analysis.Normed.Algebra.Norm
import Mathlib.Topology.Algebra.Module.FiniteDimension
import Mathlib.FieldTheory.SeparableDegree
import Mathlib.FieldTheory.IntermediateField.Algebraic
-- import Mathlib.Analysis.Calculus.LHopital
import Mathlib.Analysis.SpecialFunctions.Pow.Asymptotics
import Mathlib.Analysis.Normed.Field.Ultra
import Mathlib.Analysis.Normed.Ring.Ultra
/-!
# Krasner's Lemma

In this file, we prove Krasner's lemma. Instead of state and prove the Krasner's lemma directly,
we define a predicate `IsKrasner K L` for arbitary field extensions `L / K` with a normed/valued
instance on `L` as the abstraction of the conclusion of the Krasner's lemma. Then we prove the
Krasner's lemma holds for `L / K` if `K` is a complete normed/valued field and the norm/valuation
on `L` is compatible with the one on `K`.

## Main definitions

* `IsKrasner K L`

* `IsKrasnerNorm K L`

## Main results

* `of_complete` : If `K` is a complete normed/valued field, such that there exists a
unique norm extension on every algebraic extension `L` of `K`, then `IsKrasner K L` holds for every
algebraic extension `L` over `K`.

## Tags

## TODO
1. The condition `Algebra.IsAlgebraic` can be dropped in `of_complete`. This needs a generalization
of the field `Mathlib.FieldTheory.Extension` to trancendental cases. Almost all theorems in that
file still holds without the assumption of being algebraic.

2. After the definition of `Valued` is fixed, the valued version can be proved under the assumption
`IsValExtension K L`

3. Show that if `IsKrasner K (AlgebraicClosure K)` holds, then the completion of
`(AlgebraicClosure K)` is algebraically closed.

4. After the uniqueness of norm extension of complete normed field is in mathlib, drop the
conditions about `uniqueNormExtension` in `of_complete`.
If `K` is a complete normed/valued field and the norm/valuation on `L` is
compatible with the one on `K`, then `IsKrasnerNorm K L` holds.

5. After 3 and 4 are proved, show that $\mathbb{C}_p$ is algebraically closed.

-/

section test

variable {K L : Type*} [Nm_K : NontriviallyNormedField K] [CompleteSpace K]
[Nm_L : NormedField L] [Algebra K L]
(is_na : IsNonarchimedean (‚Äñ¬∑‚Äñ : K ‚Üí ‚Ñù)) [Algebra.IsAlgebraic K L]
(extd : ‚àÄ x : K, ‚Äñx‚Äñ  = ‚ÄñalgebraMap K L x‚Äñ) (M : IntermediateField K L)
#synth Algebra ‚Ñï K
#synth NormedField M

open Polynomial Filter Topology
#check nhds


theorem Polynomial.tendsto_log_eval_div_zero {p : ‚Ñù[X]} (hp : p.leadingCoeff > 0) : Filter.Tendsto (fun x => Real.log (p.eval x) / x : ‚Ñù ‚Üí ‚Ñù) atTop (ùìù 0) := by
  -- induction' h : p.natDegree
  sorry -- need LHospital infinity case


-- leading coeff char zero
-- Mathlib.Analysis.SpecialFunctions.Polynomials
-- tendsto_rpow_div first generalize to n polynomial.induction polynomial add
theorem Polynomial.tendsto_pow_one_div_atTop {p : ‚Ñù[X]} (hp : p.leadingCoeff > 0) : Filter.Tendsto (fun x => (p.eval x) ^ (1 / x) : ‚Ñù ‚Üí ‚Ñù) atTop (ùìù 1) := by
  sorry

-- theorem IsNonarchimedean.map_le_map_one {f : ‚Ñï ‚Üí ‚Ñù} (h0 : f 0 ‚â§ f 1)
--     (h : IsNonarchimedean f) (n : ‚Ñï) : f n ‚â§ f 1 := by
--   induction n with
--   | zero => exact h0
--   | succ n hn =>
--     apply (h n 1).trans
--     simp only [hn, max_eq_right, le_refl]
theorem IsNonarchimedean.map_le_map_one {Œ± : Type*} [Semiring Œ±] {f : Œ± ‚Üí ‚Ñù} (h0 : f 0 ‚â§ f 1)
    (h : IsNonarchimedean f) (n : ‚Ñï) : f n ‚â§ f 1 := by
  induction n with
  | zero => simpa using h0
  | succ n hn =>
    push_cast
    apply (h n 1).trans
    simp only [hn, max_eq_right, le_refl]
#leansearch "If f : ‚Ñù ‚Üí ‚Ñù tends to F at filter G, then f(n) : ‚Ñï ‚Üí ‚Ñù tends to F as filter pullback of G."
#leansearch "For every c : ‚Ñù, c^(1/n) tends to 1 as n tends to infinity."
#check Filter.tendsto_map'_iff
#check Filter.tendsto_comap'_iff
#check Filter.tendsto_iff_seq_tendsto
theorem IsNonarchimedean.of_algebraMap_nat {R} [NormedDivisionRing R]
  (is_na : IsNonarchimedean (‚ÄñalgebraMap ‚Ñï R ¬∑‚Äñ : ‚Ñï ‚Üí ‚Ñù)) : IsNonarchimedean (‚Äñ¬∑‚Äñ : R ‚Üí ‚Ñù) := by
  -- It suffices to show that for all r : R, ‚Äñr + 1‚Äñ ‚â§ max ‚Äñr‚Äñ 1.
  suffices ‚àÄ r : R, ‚Äñr + 1‚Äñ ‚â§ max ‚Äñr‚Äñ 1 by
    intro x y
    by_cases hy : y = 0
    ¬∑ simp [hy]
    calc
      ‚Äñx + y‚Äñ = ‚Äñx*y‚Åª¬π + 1‚Äñ * ‚Äñy‚Äñ := by simp [‚Üê norm_mul, add_mul, hy]
      _ ‚â§ (max ‚Äñx*y‚Åª¬π‚Äñ 1) * ‚Äñy‚Äñ := mul_le_mul_of_nonneg_right (this _) (norm_nonneg y)
      _ = max ‚Äñx‚Äñ ‚Äñy‚Äñ := by simp [max_mul_of_nonneg _ 1 (norm_nonneg y), hy]
  intro r
  suffices ‚àÄ n : ‚Ñï, ‚Äñr + 1‚Äñ ^ n ‚â§ (n + 1) * max (‚Äñr‚Äñ ^ n) 1 by
    -- Take ^ (1 / n : ‚Ñù) for both side and take limit n ‚Üí ‚àû to prove the goal.
    apply le_of_tendsto_of_tendsto' (f := fun n : ‚Ñï => (‚Äñr + 1‚Äñ ^ n : ‚Ñù) ^ (1 / n : ‚Ñù))
        (g := fun n => (n + 1 : ‚Ñù) ^ (1 / n : ‚Ñù) * max ‚Äñr‚Äñ 1) (b := atTop)
    -- The limit of (‚Äñr + 1‚Äñ ^ n) ^ (1 / ‚Üën) is ‚Äñr + 1‚Äñ
    ¬∑ refine tendsto_atTop_of_eventually_const (i‚ÇÄ := 1) (fun i hi => ?_)
      simp [Real.pow_rpow_inv_natCast (norm_nonneg (r + 1)) (by linarith)]
    -- The limit of (n + 1) ^ (1 / ‚Üën) * max ‚Äñr‚Äñ 1 is max ‚Äñr‚Äñ 1.
    ¬∑ nth_rw 2 [‚Üê one_mul (max ‚Äñr‚Äñ 1)]
      -- It suffices to show the limit of (n + 1) ^ (1 / ‚Üën) is 1.
      apply Filter.Tendsto.mul_const (max ‚Äñr‚Äñ 1)
      -- We use sandwich theorem, n ^ (1 / n) ‚â§ (n + 1) ^ (1 / ‚Üën) ‚â§ (n * n) ^ (1 / n) for n ‚â• 1.
      apply tendsto_of_tendsto_of_tendsto_of_le_of_le'
          (f := (fun k : ‚Ñï ‚Ü¶ ((k : ‚Ñù) + 1) ^ (1 / k : ‚Ñù))) (g := fun n => n ^ (1 / n : ‚Ñù))
          (h := fun n => (n * n) ^ (1 / n : ‚Ñù)) (b := atTop) (a := 1)
      -- n ^ (1 / n) tends to 1.
      ¬∑ exact tendsto_rpow_div.comp tendsto_natCast_atTop_atTop
      -- (n * n) ^ (1 / n) tends to 1.
      ¬∑ have : (fun n : ‚Ñï => (n * n : ‚Ñù) ^ (1 / n : ‚Ñù)) =
            (fun n : ‚Ñï => (n : ‚Ñù) ^ (1 / n : ‚Ñù) * (n : ‚Ñù) ^ (1 / n : ‚Ñù)) := by
          funext x
          rw [Real.mul_rpow (by simp) (by simp)]
        rw [this]
        nth_rw 3 [‚Üê mul_one 1]
        apply Filter.Tendsto.mul <;>
        exact tendsto_rpow_div.comp tendsto_natCast_atTop_atTop
      -- n ^ (1 / n) ‚â§ (n + 1) ^ (1 / ‚Üën)
      ¬∑ simp only [eventually_atTop]
        exact ‚ü®0, fun _ _ => Real.rpow_le_rpow (by linarith)
            (by linarith) (Nat.one_div_cast_nonneg _)‚ü©
      -- (n + 1) ^ (1 / ‚Üën) ‚â§ (n * n) ^ (1 / n).
      ¬∑ simp only [eventually_atTop]
        refine ‚ü®2, fun n hn => Real.rpow_le_rpow (by linarith)
            ?_ (Nat.one_div_cast_nonneg _)‚ü©
        norm_cast
        calc
          n + 1 ‚â§ 2 * n := by linarith
          _ ‚â§ n * n := Nat.mul_le_mul_right n hn
    -- Given ‚àÄ n : ‚Ñï, ‚Äñr + 1‚Äñ ^ n ‚â§ (n + 1) * max (‚Äñr‚Äñ ^ n) 1, we show that
    -- (‚Äñr + 1‚Äñ ^ n) ^ (1 / ‚Üën) < (n + 1) ^ (1 / ‚Üën) * max ‚Äñr‚Äñ 1 holds for all n.
    ¬∑ intro n
      by_cases hn : n = 0
      ¬∑ simp [hn]
      calc
        (‚Äñr + 1‚Äñ ^ n) ^ (1 / n : ‚Ñù) ‚â§  ((n + 1) * max (‚Äñr‚Äñ ^ n) 1) ^ (1 / n : ‚Ñù) := by
          apply Real.rpow_le_rpow (pow_nonneg (norm_nonneg _) _)
              (this n) (Nat.one_div_cast_nonneg n)
        _ =  (n + 1) ^ (1 / n : ‚Ñù) * max (‚Äñr‚Äñ ^ n) 1 ^ (1 / n : ‚Ñù) := by
          rw [Real.mul_rpow (by linarith) (by simp)]
        _ = (n + 1) ^ (1 / n : ‚Ñù) * max ‚Äñr‚Äñ 1 := by
          simp only [Set.mem_Ici, norm_nonneg, pow_nonneg, zero_le_one,
              (Real.monotoneOn_rpow_Ici_of_exponent_nonneg (Nat.one_div_cast_nonneg n)).map_max]
          simp [Real.pow_rpow_inv_natCast (norm_nonneg r) hn]
  -- Finally, we show that ‚Äñr + 1‚Äñ ^ n ‚â§ (n + 1) * max (‚Äñr‚Äñ ^ n) 1 for all n.
  intro n
  calc
    ‚Äñr + 1‚Äñ ^ n = ‚Äñ(r + 1) ^ n‚Äñ := by simp
    _ = ‚Äñ‚àë m ‚àà Finset.range (n + 1), r ^ m * (n.choose m)‚Äñ := by
      simp [(Commute.one_right r).add_pow]
    _ ‚â§ ‚àë m ‚àà Finset.range (n + 1), ‚Äñr ^ m‚Äñ := by
      refine norm_sum_le_of_le _ (fun m hm => (norm_mul_le (r ^ m) (n.choose m)).trans ?_)
      apply mul_le_of_le_one_right (norm_nonneg _)
      simpa using is_na.map_le_map_one (n := n.choose m)
    _ ‚â§ ‚àë m ‚àà Finset.range (n + 1), max ‚Äñr ^ n‚Äñ 1 := by
      refine Finset.sum_le_sum (fun i ha => ?_)
      by_cases hr : ‚Äñr‚Äñ ‚â§ 1 <;>
      simp only [norm_pow, le_max_iff]
      ¬∑ exact Or.inr <| pow_le_one‚ÇÄ (norm_nonneg r) hr
      ¬∑ exact Or.inl <| (pow_le_pow_iff_right (by linarith)).mpr (Finset.mem_range_succ_iff.mp ha)
    _ = (n + 1) * max (‚Äñr‚Äñ ^ n) 1 := by simp

theorem IsUltrametricDist.isNonarchimedean {R} [NormedRing R] [IsUltrametricDist R] :
    IsNonarchimedean (‚Äñ¬∑‚Äñ : R ‚Üí ‚Ñù) := by
  intro x y
  convert dist_triangle_max 0 x (x+y) using 1
  ¬∑ simp
  ¬∑ congr <;> simp

theorem isUltrametricDist_iff_isNonarchimedean {R} [NormedRing R] :
    IsUltrametricDist R ‚Üî IsNonarchimedean (‚Äñ¬∑‚Äñ : R ‚Üí ‚Ñù) := by

#check IsUltrametricDist.isUltrametricDist_of_forall_norm_natCast_le_one

theorem IsUltrametricDist.isUltrametricDist_iff_forall_norm_natCast_le_one {R : Type*}
    [NormedDivisionRing R] : IsUltrametricDist R ‚Üî ‚àÄ n : ‚Ñï, ‚Äñ(n : R)‚Äñ ‚â§ 1 :=
  ‚ü®fun _ => IsUltrametricDist.norm_natCast_le_one R,
      isUltrametricDist_of_forall_norm_natCast_le_one‚ü©

/-- K : field L : division ring-/
theorem IsNonarchimedean.norm_extension (is_na : IsNonarchimedean (‚Äñ¬∑‚Äñ : K ‚Üí ‚Ñù))
    (extd : ‚àÄ x : K, ‚Äñx‚Äñ  = ‚ÄñalgebraMap K L x‚Äñ) : IsNonarchimedean (‚Äñ¬∑‚Äñ : L ‚Üí ‚Ñù) := by
  refine @IsUltrametricDist.isNonarchimedean L _ ?_
  rw [IsUltrametricDist.isUltrametricDist_iff_forall_norm_natCast_le_one]
  
  apply IsNonarchimedean.of_algebraMap_nat
  intro x y
  simp only [IsScalarTower.algebraMap_apply ‚Ñï K L, ‚Üê extd]
  exact map_add ((algebraMap ‚Ñï K)) _ _ ‚ñ∏ is_na _ _

-- this is another PR, showing that fron any divisionring, nonarch is equiv to nonarch
-- pullback to natural numbers

open IntermediateField
theorem IsConjRoot.exists_algEquiv_of_minpoly_split {K L} [Field K] [Field L] [Algebra K L]
    [Algebra.IsAlgebraic K L] {x y: L}
    (h : IsConjRoot K x y) (sp : (minpoly K x).Splits (algebraMap K L)) :
    ‚àÉ œÉ : L ‚âÉ‚Çê[K] L, œÉ y = x := by
  obtain ‚ü®œÉ, hœÉ‚ü© :=
    exists_algHom_of_splits_of_aeval (fun s => ‚ü®sorry, sorry‚ü©)
    --minpoly_add_algebraMap_splits
      (h ‚ñ∏ minpoly.aeval K x)
  exact ‚ü®AlgEquiv.ofBijective œÉ sorry, hœÉ‚ü© -- fin dim vector space inj => bij
-- another PR

end test

def uniqueNormExtension (K L : Type*) [NormedCommRing K] [Field L] [Algebra K L]
    [Algebra.IsAlgebraic K L] :=
  ‚àÉ! (_ : NormedField L), ‚àÄ (x : K), ‚Äñx‚Äñ = ‚ÄñalgebraMap K L x‚Äñ

-- def uniqueNormExtension' (K L : Type*) [NormedCommRing K] [Field L] [Algebra K L]
--     [Algebra.IsAlgebraic K L] :=
--   Singleton (MulAlgebraNorm K L)

-- variable (K L) [NormedField K] [Nm_L : NormedField L]
--     [Algebra K L]
-- #check RingHomClass.toNonUnitalRingHomClass
-- #synth RingEquivClass (L ‚âÉ‚Çê[K] L) L L
-- #synth NonUnitalRingHomClass (L ‚âÉ‚Çê[K] L) L L
theorem IsConjRoot.norm_eq_of_uniqueNormExtension (K L) [NormedField K] [Nm_L : NormedField L]
    [Algebra K L]
    [Algebra.IsAlgebraic K L] (x y: L) (uniq : uniqueNormExtension K L)
    (extd : ‚àÄ x : K, ‚Äñx‚Äñ  = ‚ÄñalgebraMap K L x‚Äñ) (sp : (minpoly K x).Splits (algebraMap K L))
    (h : IsConjRoot K x y) : ‚Äñx‚Äñ = ‚Äñy‚Äñ := by
  obtain ‚ü®œÉ, hœÉ‚ü© := IsConjRoot.exists_algEquiv_of_minpoly_split h sp
  symm
  calc
    ‚Äñy‚Äñ = (NormedField.induced L L œÉ œÉ.injective).norm y := by
      apply congrArg (a‚ÇÅ := Nm_L) (a‚ÇÇ := (NormedField.induced L L œÉ œÉ.injective))
      exact uniq.unique extd fun _ => congrArg Nm_L.norm (œÉ.commutes _).symm ‚ñ∏ extd _
    _ = ‚Äñx‚Äñ := hœÉ ‚ñ∏ rfl

-- #check Algebra.smul_def
-- #synth UniformContinuousConstSMul K L
-- instance uniformContinuousConstSMul:
--   UniformContinuousConstSMul K L:= uniformContinuousConstSMul_of_continuousConstSMul K L

-- #synth UniformContinuousConstSMul K L

-- theorem boundedSMul_of_extd (extd : ‚àÄ x : K, ‚Äñx‚Äñ  = ‚ÄñalgebraMap K L x‚Äñ) : BoundedSMul K L :=
--   BoundedSMul.of_norm_smul_le
--     (fun r x => Algebra.smul_def r x ‚ñ∏ extd r ‚ñ∏ NonUnitalSeminormedRing.norm_mul _ x)

-- def NormedField.mulAlgebraNorm (K L : Type*) [NormedField K] [NormedField L] [Algebra K L]
--     (extd : ‚àÄ x : K, ‚Äñx‚Äñ  = ‚ÄñalgebraMap K L x‚Äñ) : MulAlgebraNorm K L where
--       toFun := (‚Äñ¬∑‚Äñ)
--       map_zero' := norm_zero
--       add_le' := norm_add_le
--       neg' := norm_neg
--       map_one' := norm_one
--       map_mul' := norm_mul
--       eq_zero_of_map_eq_zero' _ := norm_eq_zero.mp
--       smul' := norm_smul

-- theorem IsConjRoot.norm_eq_of_uniqueNormExtension (K L) [NormedField K]
--     [Nm_L : MulAlgebraNorm K L]
--     [Algebra K L]
--     [Algebra.IsAlgebraic K L] (x y: L) (uniq : uniqueNormExtension' K L)
--     (extd : ‚àÄ x : K, ‚Äñx‚Äñ  = ‚ÄñalgebraMap K L x‚Äñ) (sp : (minpoly K x).Splits (algebraMap K L))
--     (h : IsConjRoot K x y) : ‚Äñx‚Äñ = ‚Äñy‚Äñ := by
--   obtain ‚ü®œÉ, hœÉ‚ü© := IsConjRoot.exists_algEquiv_of_minpoly_split h sp
--   symm
--   calc
--     ‚Äñy‚Äñ = (NormedField.induced L L œÉ œÉ.injective).norm y := by
--       apply congrArg (a‚ÇÅ := Nm_L) (a‚ÇÇ := (NormedField.induced L L œÉ œÉ.injective))
--       exact uniq.unique extd fun _ => congrArg Nm_L.norm (œÉ.commutes _).symm ‚ñ∏ extd _
--     _ = ‚Äñx‚Äñ := hœÉ ‚ñ∏ rfl



open IntermediateField Valued

variable (K L : Type*) {ŒìL : Type*} [LinearOrderedCommGroupWithZero ŒìL] [Field K]

section Normed

variable [NormedField L] [Algebra K L]

class IsKrasnerNorm : Prop where
  krasner_norm' : ‚àÄ {x y : L}, IsSeparable K x ‚Üí (minpoly K x).Splits (algebraMap K L) ‚Üí
    IsIntegral K y ‚Üí (‚àÄ x' : L, IsConjRoot K x x' ‚Üí  x ‚â† x' ‚Üí ‚Äñx - y‚Äñ < ‚Äñx - x'‚Äñ) ‚Üí
      x ‚àà K‚üÆy‚üØ

theorem IsKrasnerNorm.krasner_norm [IsKrasnerNorm K L] {x y : L} (hx : (minpoly K x).Separable)
    (sp : (minpoly K x).Splits (algebraMap K L)) (hy : IsIntegral K y)
    (h : (‚àÄ x' : L, IsConjRoot K x x' ‚Üí x ‚â† x' ‚Üí ‚Äñx - y‚Äñ < ‚Äñx - x'‚Äñ)) : x ‚àà K‚üÆy‚üØ :=
  IsKrasnerNorm.krasner_norm' hx sp hy h

theorem of_completeSpace {K L : Type*} [Nm_K : NontriviallyNormedField K] [CompleteSpace K] [Nm_L : NormedField L] [Algebra K L] (is_na : IsNonarchimedean (‚Äñ¬∑‚Äñ : K ‚Üí ‚Ñù)) [Algebra.IsAlgebraic K L] (extd : ‚àÄ x : K, ‚Äñx‚Äñ  = ‚ÄñalgebraMap K L x‚Äñ) (uniq : ‚àÄ M : IntermediateField K L, uniqueNormExtension K M) : IsKrasnerNorm K L := by
  constructor
  intro x y xsep sp yint kr
  let z := x - y
  let M := K‚üÆy‚üØ
  have _ := IntermediateField.adjoin.finiteDimensional yint
  let i_K : NormedAddGroupHom K (‚ä• : IntermediateField K L) :=
    (AddMonoidHomClass.toAddMonoidHom (botEquiv K L).symm).mkNormedAddGroupHom 1 (by simp [extd])
  have _ : ContinuousSMul K M := by
    apply IsInducing.continuousSMul (N := K) (M := (‚ä• : IntermediateField K L)) (X := M) (Y := M)
      (f := (IntermediateField.botEquiv K L).symm) IsInducing.id i_K.continuous
    intros c x
    rw [Algebra.smul_def, @Algebra.smul_def (‚ä• : IntermediateField K L) M _ _ _]
    rfl -- note to reviewers: This is an ugly `rfl`. I'm not sure how to make it better.
  let _ : CompleteSpace M := FiniteDimensional.complete K M
  have hy : y ‚àà K‚üÆy‚üØ := IntermediateField.subset_adjoin K {y} rfl
  have zsep : IsSeparable M z := by
    apply Field.isSeparable_sub (IsSeparable.tower_top M xsep)
    simpa using isSeparable_algebraMap (‚ü®y, hy‚ü© : M)
  suffices z ‚àà K‚üÆy‚üØ by simpa [z] using add_mem this hy
  by_contra hz
  have : z ‚àà K‚üÆy‚üØ ‚Üî z ‚àà (‚ä• : Subalgebra M L) := by simp [Algebra.mem_bot]
  rw [this.not] at hz
  obtain ‚ü®z', hne, h1‚ü© := (not_mem_iff_exists_ne_and_isConjRoot zsep
      (minpoly_sub_algebraMap_splits ‚ü®y, hy‚ü© (IsIntegral.minpoly_splits_tower_top
        xsep.isIntegral sp))).mp hz
  simp only [ne_eq, Subtype.mk.injEq] at hne

  -- have eq_spnM : (norm : M ‚Üí ‚Ñù) = spectralNorm K M :=
  --   funext <| spectralNorm_unique_field_norm_ext
  --     (f := instNormedIntermediateField.toMulRingNorm) extd is_na
  -- have eq_spnL : (norm : L ‚Üí ‚Ñù) = spectralNorm K L :=
  --   funext <| spectralNorm_unique_field_norm_ext (f := NL.toMulRingNorm) extd is_na
  -- have is_naM : IsNonarchimedean (norm : M ‚Üí ‚Ñù) := eq_spnM ‚ñ∏ spectralNorm_isNonarchimedean K M is_na
  -- have is_naL : IsNonarchimedean (norm : L ‚Üí ‚Ñù) := eq_spnL ‚ñ∏ spectralNorm_isNonarchimedean K L is_na

  letI : NontriviallyNormedField M := {
    SubfieldClass.toNormedField M with
    non_trivial := by
      obtain ‚ü®k, hk‚ü© :=  @NontriviallyNormedField.non_trivial K _
      use algebraMap K M k
      change 1 < ‚Äñ(algebraMap K L) k‚Äñ
      simp [(extd k).symm, hk]-- a lemma for extends nontrivial implies nontrivial
    }
  -- have eq_spnML: (norm : L ‚Üí ‚Ñù) = spectralNorm M L := by
  --   apply Eq.trans eq_spnL
  --   apply (_root_.funext <| spectralNorm_unique_field_norm_ext (K := K)
  --     (f := (spectralMulAlgNorm is_naM).toMulRingNorm) _ is_na).symm
  --   apply functionExtends_of_functionExtends_of_functionExtends (fA := (norm : M ‚Üí ‚Ñù))
  --   ¬∑ intro m
  --     exact extd m
  --   ¬∑ exact spectralNorm_extends M L -- a lemma for extends extends
  -- have norm_eq: ‚Äñz‚Äñ = ‚Äñz'‚Äñ := by -- a lemma
  --   simp only [eq_spnML, spectralNorm]
  --   congr 1
    -- spectralNorm K L = spectralnorm M L
  -- IsConjRoot.val_eq M hM (Polynomial.Separable.isIntegral zsep) h1
  -- need rank one -- exist_algEquiv
  have extdM : ‚àÄ x : M, ‚Äñx‚Äñ = ‚ÄñalgebraMap M L x‚Äñ := by
    sorry
  have uniqM : uniqueNormExtension M L := by
    sorry
  have : ‚Äñz - z'‚Äñ < ‚Äñz - z'‚Äñ := by
    calc
      _ ‚â§ max ‚Äñz‚Äñ ‚Äñz'‚Äñ := by
        simpa only [norm_neg, sub_eq_add_neg] using (is_na.norm_extension extd z (- z'))
      _ ‚â§ ‚Äñx - y‚Äñ := by
        rw [h1.norm_eq_of_uniqueNormExtension M L z z' uniqM extdM
              (minpoly_sub_algebraMap_splits ‚ü®y, hy‚ü© (xsep.isIntegral.minpoly_splits_tower_top sp))]
        simp only [max_self, le_refl]
      _ < ‚Äñx - (z' + y)‚Äñ := by
        apply kr (z' + y)
        ¬∑ apply IsConjRoot.of_isScalarTower (L := M) xsep.isIntegral
          simpa only [IntermediateField.algebraMap_apply, sub_add_cancel, z] using
            IsConjRoot.add_algebraMap ‚ü®y, hy‚ü© h1
        ¬∑ simpa [z, sub_eq_iff_eq_add] using hne
      _ = ‚Äñz - z'‚Äñ := by congr 1; ring
  simp only [lt_self_iff_false] at this


theorem of_completeSpace {K L : Type*} [Nm_K : NontriviallyNormedField K] [NormedField L]
    [Algebra K L] (is_na : IsNonarchimedean (‚Äñ¬∑‚Äñ : K ‚Üí ‚Ñù)) [Algebra.IsAlgebraic K L]
    [CompleteSpace K] (extd : ‚àÄ x : K, ‚Äñx‚Äñ  = ‚ÄñalgebraMap K L x‚Äñ) : IsKrasnerNorm K L := by
  constructor
  intro x y xsep sp yint kr
  let z := x - y
  let M := K‚üÆy‚üØ
  have _ := IntermediateField.adjoin.finiteDimensional yint
  let i_K : NormedAddGroupHom K (‚ä• : IntermediateField K L) :=
    (AddMonoidHomClass.toAddMonoidHom (botEquiv K L).symm).mkNormedAddGroupHom 1 (by simp [extd])
  have _ : ContinuousSMul K M := by
    apply Inducing.continuousSMul (N := K) (M := (‚ä• : IntermediateField K L)) (X := M) (Y := M)
      (f := (IntermediateField.botEquiv K L).symm) inducing_id i_K.continuous
    intros c x
    rw [Algebra.smul_def, @Algebra.smul_def (‚ä• : IntermediateField K L) M _ _ _]
    rfl
  let _ : CompleteSpace M := FiniteDimensional.complete K M
  have hy : y ‚àà K‚üÆy‚üØ := IntermediateField.subset_adjoin K {y} rfl
  have zsep : IsSeparable M z := by
    apply Field.isSeparable_sub (IsSeparable.tower_top M xsep)
    simpa using isSeparable_algebraMap (‚ü®y, hy‚ü© : M)
  suffices z ‚àà K‚üÆy‚üØ by simpa [z] using add_mem this hy
  by_contra hz
  have : z ‚àà K‚üÆy‚üØ ‚Üî z ‚àà (‚ä• : Subalgebra M L) := by simp [Algebra.mem_bot]
  rw [this.not] at hz
  -- need + algebra map split and split tower.
  obtain ‚ü®z', hne, h1‚ü© := (not_mem_iff_exists_ne_and_isConjRoot zsep
      (minpoly_sub_algebraMap_splits ‚ü®y, hy‚ü© (IsIntegral.minpoly_splits_tower_top
        xsep.isIntegral sp))).mp hz
  -- this is where the separablity is used.
  simp only [ne_eq, Subtype.mk.injEq] at hne
  have eq_spnM : (norm : M ‚Üí ‚Ñù) = spectralNorm K M :=
    funext <| spectralNorm_unique_field_norm_ext
      (f := instNormedIntermediateField.toMulRingNorm) extd is_na
  have eq_spnL : (norm : L ‚Üí ‚Ñù) = spectralNorm K L :=
    funext <| spectralNorm_unique_field_norm_ext (f := NL.toMulRingNorm) extd is_na
  have is_naM : IsNonarchimedean (norm : M ‚Üí ‚Ñù) := eq_spnM ‚ñ∏ spectralNorm_isNonarchimedean K M is_na
  have is_naL : IsNonarchimedean (norm : L ‚Üí ‚Ñù) := eq_spnL ‚ñ∏ spectralNorm_isNonarchimedean K L is_na
  letI : NontriviallyNormedField M := {
    instNormedIntermediateField with
    non_trivial := by
      obtain ‚ü®k, hk‚ü© :=  @NontriviallyNormedField.non_trivial K _
      use algebraMap K M k
      change 1 < ‚Äñ(algebraMap K L) k‚Äñ
      simp [extd k, hk]-- a lemma for extends nontrivial implies nontrivial
  }
  have eq_spnML: (norm : L ‚Üí ‚Ñù) = spectralNorm M L := by
    apply Eq.trans eq_spnL
    apply (_root_.funext <| spectralNorm_unique_field_norm_ext (K := K)
      (f := (spectralMulAlgNorm is_naM).toMulRingNorm) _ is_na).symm
    apply functionExtends_of_functionExtends_of_functionExtends (fA := (norm : M ‚Üí ‚Ñù))
    ¬∑ intro m
      exact extd m
    ¬∑ exact spectralNorm_extends M L -- a lemma for extends extends
  have norm_eq: ‚Äñz‚Äñ = ‚Äñz'‚Äñ := by -- a lemma
    simp only [eq_spnML, spectralNorm]
    congr 1
    -- spectralNorm K L = spectralnorm M L
  -- IsConjRoot.val_eq M hM (Polynomial.Separable.isIntegral zsep) h1
  -- need rank one -- exist_algEquiv
  have : ‚Äñz - z'‚Äñ < ‚Äñz - z'‚Äñ := by
    calc
      _ ‚â§ max ‚Äñz‚Äñ ‚Äñz'‚Äñ := by
        simpa only [norm_neg, sub_eq_add_neg] using (is_naL z (- z'))
      _ ‚â§ ‚Äñx - y‚Äñ := by
        simp only [‚Üê norm_eq, max_self, le_refl]
      _ < ‚Äñx - (z' + y)‚Äñ := by
        apply kr (z' + y)
        ¬∑ apply IsConjRoot.of_isScalarTower (L := M) xsep.isIntegral
          simpa only [IntermediateField.algebraMap_apply, sub_add_cancel, z] using
            IsConjRoot.add_algebraMap ‚ü®y, hy‚ü© h1
        ¬∑ simpa [z, sub_eq_iff_eq_add] using hne
      _ = ‚Äñz - z'‚Äñ := by congr 1; ring
  simp only [lt_self_iff_false] at this


-- add a requirement that the uniquess is need and
-- TODO: we know this is true and after it is in mathlib we can remove this condition.
theorem of_completeSpace [CompleteSpace K] : IsKrasnerNorm K L := by
  constructor
  intro x y xsep sp yint kr
  let L' := algebraicClosure K L
  let xL : L' := ‚ü®x, IsSeparable.isIntegral xsep‚ü©
  let yL : L' := ‚ü®y, yint‚ü©
  suffices xL ‚àà K‚üÆyL‚üØ by
    rwa [‚Üê IntermediateField.lift_adjoin_simple K L' yL, IntermediateField.mem_lift xL]
  have hL' : IsKrasnerNorm K L' := IsKrasnerNorm.of_completeSpace_aux is_na extd
  apply hL'.krasner_norm
  ¬∑ exact IsSeparable.of_algHom L'.val xsep
  ¬∑ rw [‚Üê (minpoly.algHom_eq L'.val Subtype.val_injective xL)]
    apply minpoly_split_algebraClosure (x := x) xsep.isIntegral sp
  ¬∑ exact (isIntegral_algHom_iff _ L'.val.toRingHom.injective).mp yint
  ¬∑ exact fun x' hx' hne => kr x' ((isConjRoot_algHom_iff L'.val).mpr hx')
      (Subtype.coe_ne_coe.mpr hne)

end Normed

section Valued

variable [Field L] [Algebra K L] [vL : Valued L ŒìL]

class IsKrasner : Prop where
  krasner' : ‚àÄ {x y : L}, IsSeparable K x ‚Üí (minpoly K x).Splits (algebraMap K L) ‚Üí
    IsIntegral K y ‚Üí (‚àÄ x' : L, IsConjRoot K x x' ‚Üí x ‚â† x' ‚Üí v (x - y) < v (x - x')) ‚Üí
      x ‚àà K‚üÆy‚üØ

variable {K L}

theorem IsKrasner.krasner [IsKrasner K L] {x y : L} (hx : IsSeparable K x)
    (sp : (minpoly K x).Splits (algebraMap K L)) (hy : IsIntegral K y)
    (h : (‚àÄ x' : L, IsConjRoot K x x' ‚Üí x ‚â† x' ‚Üí vL.v (x - y) < vL.v (x - x'))) : x ‚àà K‚üÆy‚üØ :=
  IsKrasner.krasner' hx sp hy h

end Valued
