/-
Copyright (c) 2022 Jakob von Raumer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jakob von Raumer
-/
import Mathlib.CategoryTheory.Preadditive.Yoneda.Projective
<<<<<<< HEAD
import Mathlib.Algebra.Homology.ShortComplex.Abelian

#align_import category_theory.abelian.projective from "leanprover-community/mathlib"@"f0c8bf9245297a541f468be517f1bde6195105e9"
=======
import Mathlib.CategoryTheory.Preadditive.Yoneda.Limits
>>>>>>> origin/homology-sequence-computation

/-!
# Projective objects in abelian categories

In an abelian category, an object `P` is projective iff the functor
`preadditiveCoyonedaObj (op P)` preserves finite colimits.

-/

universe v u

namespace CategoryTheory

open Limits Projective Opposite

variable {C : Type u} [Category.{v} C] [Abelian C]

<<<<<<< HEAD
/-- When `C` is abelian, `Projective.d f` and `f` are exact. -/
theorem exact_d_f [EnoughProjectives C] {X Y : C} (f : X ⟶ Y) :
    (ShortComplex.mk (d f) f (by simp)).Exact := by
  let α : ShortComplex.mk (d f) f (by simp) ⟶ ShortComplex.mk (kernel.ι f) f (by simp) :=
    { τ₁ := Projective.π _
      τ₂ := 𝟙 _
      τ₃ := 𝟙 _  }
  have : Epi α.τ₁ := by dsimp; infer_instance
  have : IsIso α.τ₂ := by dsimp; infer_instance
  have : Mono α.τ₃ := by dsimp; infer_instance
  rw [ShortComplex.exact_iff_of_epi_of_isIso_of_mono α]
  apply ShortComplex.exact_of_f_is_kernel
  apply kernelIsKernel

/-- The preadditive Co-Yoneda functor on `P` preserves colimits if `P` is projective. -/
def preservesFiniteColimitsPreadditiveCoyonedaObjOfProjective (P : C) [hP : Projective P] :
=======
/-- The preadditive Co-Yoneda functor on `P` preserves finite colimits if `P` is projective. -/
noncomputable def preservesFiniteColimitsPreadditiveCoyonedaObjOfProjective
    (P : C) [hP : Projective P] :
>>>>>>> origin/homology-sequence-computation
    PreservesFiniteColimits (preadditiveCoyonedaObj (op P)) := by
  haveI := (projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj' P).mp hP
  -- porting note: this next instance wasn't necessary in Lean 3
  haveI := @Functor.preservesEpimorphisms_of_preserves_of_reflects _ _ _ _ _ _ _ _ this _
  apply Functor.preservesFiniteColimitsOfPreservesEpisAndKernels
#align category_theory.preserves_finite_colimits_preadditive_coyoneda_obj_of_projective CategoryTheory.preservesFiniteColimitsPreadditiveCoyonedaObjOfProjective

/-- An object is projective if its preadditive Co-Yoneda functor preserves finite colimits. -/
theorem projective_of_preservesFiniteColimits_preadditiveCoyonedaObj (P : C)
    [hP : PreservesFiniteColimits (preadditiveCoyonedaObj (op P))] : Projective P := by
  rw [projective_iff_preservesEpimorphisms_preadditiveCoyoneda_obj']
  -- porting note: this next line wasn't necessary in Lean 3
  dsimp only [preadditiveCoyoneda]
  infer_instance
#align category_theory.projective_of_preserves_finite_colimits_preadditive_coyoneda_obj CategoryTheory.projective_of_preservesFiniteColimits_preadditiveCoyonedaObj

<<<<<<< HEAD
namespace ProjectiveResolution

/-!
Our goal is to define `ProjectiveResolution.of Z : ProjectiveResolution Z`.
The `0`-th object in this resolution will just be `Projective.over Z`,
i.e. an arbitrarily chosen projective object with a map to `Z`.
After that, we build the `n+1`-st object as `Projective.syzygies`
applied to the previously constructed morphism,
and the map to the `n`-th object as `Projective.d`.
-/


variable [EnoughProjectives C]

-- Porting note: compilation of CategoryTheory.ProjectiveResolution.ofComplex took 4.95s
-- (was much faster in lean 3)
/-- Auxiliary definition for `ProjectiveResolution.of`. -/
@[simps!]
def ofComplex (Z : C) : ChainComplex C ℕ :=
  ChainComplex.mk' (Projective.over Z) (Projective.syzygies (Projective.π Z))
    (Projective.d (Projective.π Z)) fun ⟨_, _, f⟩ =>
    ⟨Projective.syzygies f, Projective.d f, by simp⟩
set_option linter.uppercaseLean3 false in
#align category_theory.ProjectiveResolution.of_complex CategoryTheory.ProjectiveResolution.ofComplex

/- Porting note:

The declarations below are very slow.
They could be given better proofs, which would hopefully also be efficient,
by giving better simp lemmas for `ofComplex`.
The current lemmas generated by `@[simps]` are terrible.

As an example, we would like to be able to say:

```
lemma ofComplex_d_shape (Z : C) {i j : ℕ} (w : i = j + 1) :
    (ofComplex Z).d (i + 1) (j + 1) = Projective.d ((ofComplex Z).d i j) := by
  sorry
```

but sadly this doesn't typecheck.
Even a version with appropriate `eqToHom`s on the RHS would be helpful.
(We might even want a lemma describing `(ofComplex Z).d i j` on the assumptions
`i = k + 2` and `j = k + 1` for some `k`.)

It may even be possible to adjust `ChainComplex.mk` and `ChainComplex.mk'`
to give better definitional equalities.
See the notes where they are defined asking if there should be further lemmas
describing the inductive steps. The problems apparent here clearly indicate that there should be!
-/

-- Porting note: the π in `of` was very, very slow. To assist,
-- implicit arguments were filled in and this particular proof was broken
-- out into a separate result
theorem ofComplex_sq_10_comm (Z : C) :
    0 ≫ HomologicalComplex.d ((ChainComplex.single₀ C).obj Z) 1 0 =
    HomologicalComplex.d (ofComplex Z) 1 0 ≫ Projective.π Z := by
  simp only [ofComplex_d, eqToHom_refl, Category.id_comp,
    zero_comp]
  erw [Category.assoc, kernel.condition, comp_zero]

lemma ofComplex_exactAt_succ (Z : C) (n : ℕ) : (ofComplex Z).ExactAt (n+1) := by
  rw [HomologicalComplex.exactAt_iff' _ (n+1+1) (n+1) n (by simp) (by simp)]
  obtain (_|n) := n
  all_goals
    dsimp [ofComplex, ChainComplex.mk', HomologicalComplex.sc',
      HomologicalComplex.shortComplexFunctor', ChainComplex.mk, ChainComplex.of]
    simp
    apply exact_d_f

/-- In any abelian category with enough projectives,
`ProjectiveResolution.of Z` constructs a projective resolution of the object `Z`.
-/
irreducible_def of (Z : C) : ProjectiveResolution Z :=
  { complex := ofComplex Z
    π := ChainComplex.mkHom (ofComplex Z) ((ChainComplex.single₀ C).obj Z) (Projective.π Z) 0
           (ofComplex_sq_10_comm Z) (fun n _ ↦ ⟨0, by
           -- Porting note: broken ext
            apply HasZeroObject.to_zero_ext ⟩)
    projective := by rintro (_ | _ | _ | n) <;> apply Projective.projective_over
    hπ := ⟨fun n => by
      cases n
      · rw [ChainComplex.quasiIsoAt₀_iff, ShortComplex.quasiIso_iff_of_zeros']
        . exact ⟨Projective.π_epi Z, by simpa using exact_d_f (Projective.π Z)⟩
        all_goals rfl
        --rw [CochainComplex.quasiIsoAt₀_iff,
        --  ShortComplex.quasiIso_iff_of_zeros]
        --· exact ⟨Injective.ι_mono Z, by simpa using exact_f_d (Injective.ι Z)⟩
        --all_goals rfl
      · rw [quasiIsoAt_iff_exactAt']
        apply ofComplex_exactAt_succ
        apply ChainComplex.single₀_exactAt⟩ }
    --exact₀ := by simpa using exact_d_f (Projective.π Z)
    --exact := exact_ofComplex Z
    --epi := Projective.π_epi Z }
set_option linter.uppercaseLean3 false in
#align category_theory.ProjectiveResolution.of CategoryTheory.ProjectiveResolution.of

instance (priority := 100) (Z : C) : HasProjectiveResolution Z where out := ⟨of Z⟩

instance (priority := 100) : HasProjectiveResolutions C where out Z := by infer_instance

end ProjectiveResolution

=======
>>>>>>> origin/homology-sequence-computation
end CategoryTheory
