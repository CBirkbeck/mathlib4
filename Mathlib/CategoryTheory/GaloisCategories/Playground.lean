import Mathlib.CategoryTheory.GaloisCategories.Basic
import Mathlib.Data.Finite.Card
import Mathlib.Data.Finite.Basic
import Mathlib.CategoryTheory.Limits.ConcreteCategory

universe u v w v‚ÇÅ u‚ÇÅ u‚ÇÇ

open CategoryTheory Limits Functor

namespace Galois

variable {C : Type u} [Category.{v, u} C] (F : C ‚•§ FintypeCat.{w}) [PreGaloisCategory C]
  [FibreFunctor F]

theorem hasDecompConnectedComponents (X : C) : ‚àÉ (Œπ : Type) (f : Œπ ‚Üí C)
    (t : ColimitCocone (Discrete.functor f)),
    (‚àÄ i, ConnectedObject (f i)) ‚àß Finite Œπ ‚àß X = t.cocone.pt := by
  revert X
  have hp : ‚àÄ (n : ‚Ñï) (X : C), n = Nat.card (F.obj X) ‚Üí
    ‚àÉ (Œπ : Type) (f : Œπ ‚Üí C) (t : ColimitCocone (Discrete.functor f)),
    (‚àÄ i, ConnectedObject (f i)) ‚àß Finite Œπ ‚àß X = t.cocone.pt
  intro n
  induction' n using Nat.strongRecOn with n hi
  intro X hn
  by_cases ConnectedObject X
  let Œπ : Type := PUnit
  let f : Œπ ‚Üí C := fun _ ‚Ü¶ X
  use Œπ
  use f
  let t : ColimitCocone (Discrete.functor f) := {
    cocone := constantCofan X
    isColimit := constantCofanIsColimit X
  }
  use t
  simp only [and_true, forall_const]
  constructor
  assumption
  constructor
  infer_instance
  rfl
  by_cases h : (IsInitial X ‚Üí False)
  swap
  simp only [not_forall] at h
  obtain ‚ü®hin‚ü© := h
  let Œπ : Type := PEmpty
  let f : Œπ ‚Üí C := fun _ ‚Ü¶ X
  use Œπ
  use f
  let t : ColimitCocone (empty C) := {
      cocone := asEmptyCocone X
      isColimit := hin
  }
  rw [‚Üêempty_ext' (empty C) (Discrete.functor f)]
  use t
  simp
  infer_instance
  have : ¬¨ (‚àÄ (Y : C) (i : Y ‚ü∂ X) [Mono i], (IsInitial Y ‚Üí False) ‚Üí IsIso i) := by
    by_contra a
    have : ConnectedObject X := ‚ü®h, a‚ü©
    contradiction
  simp at this
  choose Y hnotinitial v hvmono hvnoiso using this
  have hn0 : Nat.card (F.obj Y) ‚â† 0 := by
    intro hzero
    have h : Nonempty (IsInitial Y) := by
      rw [(initialIffFibreEmpty Y : Nonempty (IsInitial Y) ‚Üî IsEmpty (F.obj Y))]
      exact Finite.card_eq_zero_iff.mp hzero
    exact Nonempty.elim h hnotinitial
  choose Z u x using PreGaloisCategory.monoInducesIsoOnDirectSummand v
  let c := Classical.choice x
  let t : ColimitCocone (pair Y Z) := { cocone := BinaryCofan.mk v u, isColimit := c }
  have hn1 : Nat.card (F.obj Y) < n := by
    rw [hn]
    exact ltCardFibre_of_mono_of_notIso v hvnoiso
  have i : X ‚âÖ Y ‚®ø Z := (colimit.isoColimitCocone t).symm
  have hnn : Nat.card (F.obj X) = Nat.card (F.obj Y) + Nat.card (F.obj Z) := by
    rw [cardFibre_eq_of_iso i]
    exact cardFibre_eq_sum_of_coprod Y Z
  have hn2 : Nat.card (F.obj Z) < n := by
    rw [hn, hnn]
    simp only [lt_add_iff_pos_left]
    have : Nat.card (F.obj Y) ‚â† 0 := hn0
    exact Nat.pos_of_ne_zero hn0
  let ‚ü®Œπ‚ÇÅ, f‚ÇÅ, t‚ÇÅ, hc‚ÇÅ, hf‚ÇÅ, he‚ÇÅ‚ü© := hi (Nat.card (F.obj Y)) hn1 Y rfl
  let ‚ü®Œπ‚ÇÇ, f‚ÇÇ, t‚ÇÇ, hc‚ÇÇ, hf‚ÇÇ, he‚ÇÇ‚ü© := hi (Nat.card (F.obj Z)) hn2 Z rfl
  use Œπ‚ÇÅ ‚äï Œπ‚ÇÇ
  use Sum.elim f‚ÇÅ f‚ÇÇ
  let heq : pair Y Z ‚âÖ pair t‚ÇÅ.cocone.pt t‚ÇÇ.cocone.pt := by
    apply Discrete.natIso
    intro ‚ü®i‚ü©
    match i with
    | WalkingPair.left =>
        show Y ‚âÖ t‚ÇÅ.cocone.pt
        exact eqToIso he‚ÇÅ
    | WalkingPair.right =>
        show Z ‚âÖ t‚ÇÇ.cocone.pt
        exact eqToIso he‚ÇÇ
  let t' : ColimitCocone (pair t‚ÇÅ.cocone.pt t‚ÇÇ.cocone.pt) := {
    cocone := (Cocones.precompose heq.inv).obj t.cocone
    isColimit := (IsColimit.precomposeInvEquiv heq t.cocone).invFun t.isColimit
  }
  use combCofanPairColimitCocone t'
  simp
  constructor
  constructor
  assumption
  assumption
  constructor
  infer_instance
  rfl
  intro X
  exact hp (Nat.card (F.obj X)) X rfl

lemma mono_coprod_inclusion {Œπ : Type} [Fintype Œπ] {f : Œπ ‚Üí C}
    (t : ColimitCocone (Discrete.functor f)) (i : Œπ) :
    Mono (Cofan.inj t.cocone i) := by
  let s : Cocone (Discrete.functor f ‚ãô F) := F.mapCocone t.cocone
  let s' : IsColimit s := isColimitOfPreserves F t.isColimit
  have h : s.Œπ.app ‚ü®i‚ü© = F.map (Cofan.inj t.cocone i) := by
    simp only [Functor.mapCocone_Œπ_app]
    rfl
  have : Mono (s.Œπ.app ‚ü®i‚ü©) := FintypeCat.mono_of_cofanInj' (Discrete.functor f ‚ãô F) ‚ü®s, s'‚ü© i
  rw [h] at this
  exact mono_of_mono_map F this

lemma fibre_in_connected_component (X : C) (x : F.obj X) : ‚àÉ (Y : C) (i : Y ‚ü∂ X) (y : F.obj Y),
    F.map i y = x ‚àß ConnectedObject Y ‚àß Mono i := by
  obtain ‚ü®Œπ, f, t, hc, hf, he‚ü© := hasDecompConnectedComponents F X
  have : Fintype Œπ := Fintype.ofFinite Œπ
  let s : Cocone (Discrete.functor f ‚ãô F) := F.mapCocone t.cocone
  let s' : IsColimit s := isColimitOfPreserves F t.isColimit
  have : s.pt = F.obj X := by simp only [mapCocone_pt, he]
  let x' : s.pt := (eqToHom this.symm) x
  have : ‚àÉ (j : Discrete Œπ) (z : (Discrete.functor f ‚ãô F).obj j), s.Œπ.app j z = x' :=
    FintypeCat.jointly_surjective _ s s' x'
  obtain ‚ü®‚ü®j‚ü©, z, h‚ü© := this
  let Y : C := f j
  let i : Y ‚ü∂ t.cocone.pt := t.cocone.Œπ.app ‚ü®j‚ü©
  have : Mono i := mono_coprod_inclusion F t j
  use Y
  use (i ‚â´ eqToHom he.symm)
  use z
  refine ‚ü®?_, ?_, ?_‚ü©
  simp only [map_comp, FintypeCat.comp_apply, ‚ÜêFunctor.mapCocone_Œπ_app, h]
  aesop_subst he
  simp only [eqToHom_refl, mapCocone_pt, FintypeCat.id_apply, CategoryTheory.Functor.map_id]
  exact hc j
  exact mono_comp i (eqToHom he.symm)

lemma connected_component_unique {X A B : C} [ConnectedObject A] [ConnectedObject B]
    (a : F.obj A) (b : F.obj B) (i : A ‚ü∂ X)
    (j : B ‚ü∂ X) (h : F.map i a = F.map j b) [Mono i] [Mono j] : ‚àÉ (f : A ‚âÖ B), F.map f.hom a = b := by
  let Y : C := pullback i j
  let u : Y ‚ü∂ A := pullback.fst
  let v : Y ‚ü∂ B := pullback.snd
  let G := F ‚ãô FintypeCat.incl
  let is : G.obj Y ‚âÖ { p : G.obj A √ó G.obj B // G.map i p.1 = G.map j p.2 } :=
    (PreservesPullback.iso G i j) ‚â™‚â´ (Types.pullbackIsoPullback (G.map i) (G.map j))
  let y : F.obj Y := is.inv ‚ü®(a, b), h‚ü©
  have hn : IsInitial Y ‚Üí False := notinitial_of_inhabited y
  have : IsIso u := ConnectedObject.noTrivialComponent Y u hn
  have : IsIso v := ConnectedObject.noTrivialComponent Y v hn
  have hu : F.map u y = a := by
    show G.map u y = a
    rw [‚ÜêPreservesPullback.iso_hom_fst G]
    simp only [comp_obj, FintypeCat.incl_obj, Functor.comp_map, Iso.trans_inv, FintypeCat.incl_map,
      types_comp_apply, inv_hom_id_apply]
    show ((Types.pullbackIsoPullback (FintypeCat.incl.map (F.map i)) (FintypeCat.incl.map (F.map j))).inv
      ‚â´ pullback.fst) { val := (a, b), property := h } = a
    rw [Types.pullbackIsoPullback_inv_fst]
  have hv : F.map v y = b := by
    show G.map v y = b
    rw [‚ÜêPreservesPullback.iso_hom_snd G]
    simp only [comp_obj, FintypeCat.incl_obj, Functor.comp_map, Iso.trans_inv, FintypeCat.incl_map,
      types_comp_apply, inv_hom_id_apply]
    show ((Types.pullbackIsoPullback (FintypeCat.incl.map (F.map i)) (FintypeCat.incl.map (F.map j))).inv
      ‚â´ pullback.snd) { val := (a, b), property := h } = b
    rw [Types.pullbackIsoPullback_inv_snd]
  let œÜ : A ‚âÖ B := (asIso u).symm ‚â™‚â´ asIso v
  use œÜ
  rw [‚Üêhu, ‚Üêhv]
  have : CategoryTheory.inv (F.map u) (F.map u y) = y := by
    show (F.map u ‚â´ CategoryTheory.inv (F.map u)) y = y
    simp only [IsIso.hom_inv_id, FintypeCat.id_apply]
  simp only [Iso.trans_hom, Iso.symm_hom, asIso_inv, asIso_hom, map_comp, Functor.map_inv,
    FintypeCat.comp_apply]
  rw [this]

lemma exists_galois_representative (X : C) :
    ‚àÉ (A : C) (a : F.obj A), GaloisObject F A ‚àß Function.Bijective (evaluation A X a) := by
  let Œπ : FintypeCat.{w} := F.obj X
  let f : Œπ ‚Üí C := fun _ => X
  let Y : C := ‚àè f
  have : Fintype Œπ := inferInstance
  let g : Œπ ‚Üí FintypeCat.{w} := fun x => F.obj (f x)
  let i : F.obj Y ‚âÖ ‚àè g := PreservesProduct.iso F f
  have : HasProduct g := inferInstance
  let z : (‚àè g : FintypeCat.{w}) := FintypeCat.Pi.mk g id
  let y : F.obj Y := i.inv z
  obtain ‚ü®A, u, a, h1, h2, h3‚ü© := fibre_in_connected_component F Y y
  use A
  use a
  let p (x : F.obj X) : A ‚ü∂ X := u ‚â´ Pi.œÄ f x
  have hp (x : F.obj X) : F.map (p x) a = x := by
    simp [h1]
    have : piComparison F f ‚â´ Pi.œÄ g x = F.map (Pi.œÄ f x) := piComparison_comp_œÄ F f x
    rw [‚ÜêcongrFun this]
    simp
    rw [‚ÜêPreservesProduct.iso_hom]
    simp [FintypeCat.Pi.œÄ_mk]
  constructor
  constructor
  assumption
  constructor
  have lrr (a' : F.obj A) : ‚àÉ (fiso : A ‚âÖ A), F.map fiso.hom a' = a := by
    let y' : F.obj Y := F.map u a'
    let œÉ (t : F.obj X) : F.obj X := F.map (u ‚â´ Pi.œÄ f t) a'
    have hsig (t : F.obj X) : œÉ t = F.map (Pi.œÄ f t) y' := by simp only [map_comp, FintypeCat.comp_apply]
    have : Function.Bijective œÉ := by
      apply Finite.injective_iff_bijective.mp
      intro t s (hs : F.map (p t) a' = F.map (p s) a')
      have h : p t = p s := evaluationInjectiveOfConnected A X a' hs
      rw [‚Üêhp t, ‚Üêhp s, h]
    let œÑ : F.obj X ‚âÉ F.obj X := Equiv.ofBijective œÉ this
    let œÜ : Y ‚ü∂ Y := Pi.map' œÑ (fun _ => ùüô X)
    have hphi : œÜ = Pi.lift (fun a => Pi.œÄ _ (œÑ a) ‚â´ ùüô X) := rfl
    let œà : Y ‚ü∂ Y := Pi.map' œÑ.invFun (fun _ => ùüô X)
    have : œÜ ‚â´ œà = ùüô Y := by
      ext x
      rw [Category.assoc]
      show (Pi.map' œÑ (fun _ => ùüô X)) ‚â´ (Pi.map' œÑ.invFun (fun _ => ùüô X) ‚â´ Pi.œÄ f x) = ùüô Y ‚â´ Pi.œÄ f x
      rw [Pi.map'_comp_œÄ, Category.comp_id, Pi.map'_comp_œÄ, Category.comp_id, Category.id_comp]
      simp
    have : œà ‚â´ œÜ = ùüô Y := by
      ext x
      rw [Category.assoc]
      show (Pi.map' œÑ.invFun (fun _ => ùüô X)) ‚â´ (Pi.map' œÑ (fun _ => ùüô X) ‚â´ Pi.œÄ f x) = ùüô Y ‚â´ Pi.œÄ f x
      rw [Pi.map'_comp_œÄ, Category.comp_id, Pi.map'_comp_œÄ, Category.comp_id, Category.id_comp]
      simp
    let is : Y ‚âÖ Y := Iso.mk œÜ œà
    let is1 : A ‚ü∂ Y := u ‚â´ is.hom
    have : IsIso is.hom := IsIso.of_iso is
    have : Mono is.hom := IsIso.mono_of_iso is.hom
    have : Mono is1 := mono_comp _ _
    have : F.map is.hom y = y' := by
      rw [‚ÜêFintypeCat.hom_inv_id_apply i y', ‚ÜêFintypeCat.hom_inv_id_apply i (F.map œÜ y)]
      apply congrArg i.inv
      rw [PreservesProduct.iso_hom]
      have : PreservesLimit (Discrete.functor fun b ‚Ü¶ F.obj (f b)) (FintypeCat.incl) := inferInstance
      apply @Concrete.limit_ext FintypeCat.{w} _ _ _ _ _
        _ _ (piComparison F f (F.map œÜ y)) (piComparison F f y')
      intro ‚ü®(t : F.obj X)‚ü©
      rw [hphi]
      show (F.map (Pi.lift fun a ‚Ü¶ Pi.œÄ f (œÑ a) ‚â´ ùüô X) ‚â´ piComparison F (fun _ ‚Ü¶ X) ‚â´ Pi.œÄ (fun _ ‚Ü¶ F.obj X) t) y =
        (piComparison F (fun _ ‚Ü¶ X) ‚â´ Pi.œÄ (fun _ ‚Ü¶ F.obj X) t) y'
      rw [‚ÜêCategory.assoc, map_lift_piComparison, Pi.lift_œÄ, Category.comp_id, piComparison_comp_œÄ]
      rw [‚Üêhsig, ‚ÜêpiComparison_comp_œÄ, ‚ÜêPreservesProduct.iso_hom, FintypeCat.comp_apply]
      show ((PreservesProduct.iso F f).inv ‚â´ (PreservesProduct.iso F f).hom ‚â´ Pi.œÄ (fun b ‚Ü¶ F.obj (f b)) (œÉ t))
        z = œÉ t
      rw [Iso.inv_hom_id_assoc]
      simp only [map_comp, FintypeCat.comp_apply, FintypeCat.Pi.œÄ_mk, id_eq]
    have hl : F.map u a' = F.map is1 a := by
      show y' = F.map (u ‚â´ is.hom) a
      rw [map_comp, FintypeCat.comp_apply, h1, this]
    exact connected_component_unique F a' a u is1 hl
  intro x y
  obtain ‚ü®fi1, hfi1‚ü© := lrr x
  obtain ‚ü®fi2, hfi2‚ü© := lrr y
  use fi1 ‚â™‚â´ fi2.symm
  show F.map (fi1.hom ‚â´ fi2.inv) x = y
  simp only [map_comp, FintypeCat.comp_apply]
  rw [hfi1, ‚Üêhfi2]
  simp only [FintypeCat.FunctorToFintypeCat.map_inv_map_hom_apply]
  have h1' : Function.Surjective (evaluation A X a) := by
    intro x
    use u ‚â´ Pi.œÄ f x
    exact hp x
  have h2 : Function.Injective (evaluation A X a) := evaluationInjectiveOfConnected A X a
  exact ‚ü®h2, h1'‚ü©

lemma exists_map_from_galois_of_fibre (X : C) (x : F.obj X) :
    ‚àÉ (A : C) (f : A ‚ü∂ X) (a : F.obj A), GaloisObject F A ‚àß F.map f a = x := by
  obtain ‚ü®A, a, h1, h2‚ü© := exists_galois_representative F X
  use A
  obtain ‚ü®f, hf‚ü© := h2.surjective x
  use f
  use a
  exact ‚ü®h1, hf‚ü©

lemma exists_map_from_galois_of_fibre_nonempty (X : C) (h : Nonempty (F.obj X)) :
    ‚àÉ (A : C) (_ : A ‚ü∂ X), GaloisObject F A := by
  obtain ‚ü®x‚ü© := h
  obtain ‚ü®A, a, h1, h2‚ü© := exists_galois_representative F X
  use A
  obtain ‚ü®f, _‚ü© := h2.surjective x
  use f

lemma exists_map_from_galois_of_connected (X : C) [ConnectedObject X] :
    ‚àÉ (A : C) (_ : A ‚ü∂ X), GaloisObject F A := by
  apply exists_map_from_galois_of_fibre_nonempty F X
  exact nonempty_fibre_of_connected X
