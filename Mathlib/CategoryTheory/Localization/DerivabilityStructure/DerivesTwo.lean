/-
Copyright (c) 2025 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.CategoryTheory.Localization.DerivabilityStructure.Derives

/-!
# Deriving bifunctors using a derivability structure


-/

universe v‚ÇÅ‚ÇÄ v‚ÇÇ‚ÇÄ v‚ÇÅ v‚ÇÇ v‚ÇÉ u‚ÇÅ‚ÇÄ u‚ÇÇ‚ÇÄ u‚ÇÅ u‚ÇÇ u‚ÇÉ

namespace CategoryTheory

open Limits Category

-- to be moved
namespace MorphismProperty

variable {C‚ÇÅ C‚ÇÇ D : Type*} [Category C‚ÇÅ] [Category C‚ÇÇ] [Category D]

lemma prod_isInvertedBy_iff (W‚ÇÅ : MorphismProperty C‚ÇÅ)
    (W‚ÇÇ : MorphismProperty C‚ÇÇ) [W‚ÇÅ.ContainsIdentities] [W‚ÇÇ.ContainsIdentities]
    (F : C‚ÇÅ √ó C‚ÇÇ ‚•§ D) :
    (W‚ÇÅ.prod W‚ÇÇ).IsInvertedBy F ‚Üî
      (‚àÄ (X‚ÇÇ : C‚ÇÇ), W‚ÇÅ.IsInvertedBy (Functor.prod' (ùü≠ _) ((Functor.const _).obj X‚ÇÇ) ‚ãô F)) ‚àß
      (‚àÄ (X‚ÇÅ : C‚ÇÅ), W‚ÇÇ.IsInvertedBy (Functor.prod' ((Functor.const _).obj X‚ÇÅ) (ùü≠ _) ‚ãô F)) :=
  ‚ü®fun hF ‚Ü¶ ‚ü®fun X‚ÇÇ _ _ _ hf ‚Ü¶ hF _ ‚ü®hf, by simpa using W‚ÇÇ.id_mem _‚ü©,
      fun X‚ÇÅ _ _ _ hf ‚Ü¶ hF _ ‚ü®by simpa using W‚ÇÅ.id_mem _, hf‚ü©‚ü©,
    fun ‚ü®hF‚ÇÅ, hF‚ÇÇ‚ü© ‚ü®X‚ÇÅ, X‚ÇÇ‚ü© ‚ü®Y‚ÇÅ, Y‚ÇÇ‚ü© ‚ü®f‚ÇÅ, f‚ÇÇ‚ü© ‚ü®hf‚ÇÅ, hf‚ÇÇ‚ü© ‚Ü¶ by
      let Œ± : (X‚ÇÅ, X‚ÇÇ) ‚ü∂ (Y‚ÇÅ, X‚ÇÇ) := (f‚ÇÅ, ùüô X‚ÇÇ)
      let Œ≤ : (Y‚ÇÅ, X‚ÇÇ) ‚ü∂ (Y‚ÇÅ, Y‚ÇÇ) := (ùüô Y‚ÇÅ, f‚ÇÇ)
      have : IsIso (F.map Œ±) := hF‚ÇÅ X‚ÇÇ _ hf‚ÇÅ
      have : IsIso (F.map Œ≤) := hF‚ÇÇ Y‚ÇÅ _ hf‚ÇÇ
      simpa only [‚Üê F.map_comp, prod_comp, comp_id, id_comp, Œ±, Œ≤] using
        inferInstanceAs (IsIso (F.map Œ± ‚â´ F.map Œ≤))‚ü©

end MorphismProperty

variable {C‚ÇÅ‚ÇÄ : Type u‚ÇÅ‚ÇÄ} {C‚ÇÇ‚ÇÄ : Type u‚ÇÇ‚ÇÄ}
  {C‚ÇÅ : Type u‚ÇÅ} {C‚ÇÇ : Type u‚ÇÇ} {H : Type u‚ÇÉ}
  [Category.{v‚ÇÅ‚ÇÄ} C‚ÇÅ‚ÇÄ] [Category.{v‚ÇÇ‚ÇÄ} C‚ÇÇ‚ÇÄ]
  [Category.{v‚ÇÅ} C‚ÇÅ] [Category.{v‚ÇÇ} C‚ÇÇ] [Category.{v‚ÇÉ} H]
  {W‚ÇÅ‚ÇÄ : MorphismProperty C‚ÇÅ‚ÇÄ} {W‚ÇÇ‚ÇÄ : MorphismProperty C‚ÇÇ‚ÇÄ}
  {W‚ÇÅ : MorphismProperty C‚ÇÅ} {W‚ÇÇ : MorphismProperty C‚ÇÇ}

namespace LocalizerMorphism

variable (Œ¶‚ÇÅ : LocalizerMorphism W‚ÇÅ‚ÇÄ W‚ÇÅ) (Œ¶‚ÇÇ : LocalizerMorphism W‚ÇÇ‚ÇÄ W‚ÇÇ)
  (F : C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ H)

abbrev Derives‚ÇÇ : Prop :=
  (W‚ÇÅ‚ÇÄ.prod W‚ÇÇ‚ÇÄ).IsInvertedBy (Œ¶‚ÇÅ.functor.prod Œ¶‚ÇÇ.functor ‚ãô uncurry.obj F)

lemma derives‚ÇÇ_iff [W‚ÇÅ‚ÇÄ.ContainsIdentities] [W‚ÇÇ‚ÇÄ.ContainsIdentities] :
    Derives‚ÇÇ Œ¶‚ÇÅ Œ¶‚ÇÇ F ‚Üî
      (‚àÄ (X‚ÇÇ‚ÇÄ : C‚ÇÇ‚ÇÄ), W‚ÇÅ‚ÇÄ.IsInvertedBy (Œ¶‚ÇÅ.functor ‚ãô F.flip.obj (Œ¶‚ÇÇ.functor.obj X‚ÇÇ‚ÇÄ))) ‚àß
      (‚àÄ (X‚ÇÅ‚ÇÄ : C‚ÇÅ‚ÇÄ), W‚ÇÇ‚ÇÄ.IsInvertedBy (Œ¶‚ÇÇ.functor ‚ãô F.obj (Œ¶‚ÇÅ.functor.obj X‚ÇÅ‚ÇÄ))) := by
  simp only [MorphismProperty.prod_isInvertedBy_iff]
  apply and_congr <;> apply forall_congr' <;> intro <;>
    simp [MorphismProperty.IsInvertedBy]

end LocalizerMorphism

end CategoryTheory
