import Mathlib.CategoryTheory.Localization.Trifunctor
import Mathlib.CategoryTheory.Monoidal.Functor
import Mathlib.Tactic.CategoryTheory.Coherence

namespace CategoryTheory

open Category MonoidalCategory

namespace MonoidalCategory

variable {C : Type*} [Category C] [MonoidalCategoryStruct C]

def Pentagon (Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ Y‚ÇÑ : C) : Prop :=
    (Œ±_ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ).hom ‚ñ∑ Y‚ÇÑ ‚â´ (Œ±_ Y‚ÇÅ (Y‚ÇÇ ‚äó Y‚ÇÉ) Y‚ÇÑ).hom ‚â´ Y‚ÇÅ ‚óÅ (Œ±_ Y‚ÇÇ Y‚ÇÉ Y‚ÇÑ).hom =
      (Œ±_ (Y‚ÇÅ ‚äó Y‚ÇÇ) Y‚ÇÉ Y‚ÇÑ).hom ‚â´ (Œ±_ Y‚ÇÅ Y‚ÇÇ (Y‚ÇÉ ‚äó Y‚ÇÑ)).hom

end MonoidalCategory

variable {C D : Type*} [Category C] [Category D] (L : C ‚•§ D) (W : MorphismProperty C)
  [MonoidalCategory C]

namespace MorphismProperty

class Monoidal extends W.IsMultiplicative : Prop where
  whiskerLeft (X : C) {Y‚ÇÅ Y‚ÇÇ : C} (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) (hg : W g) : W (X ‚óÅ g)
  whiskerRight {X‚ÇÅ X‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (hf : W f) (Y : C) : W (f ‚ñ∑ Y)

variable [W.Monoidal]

lemma whiskerLeft_mem (X : C) {Y‚ÇÅ Y‚ÇÇ : C} (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) (hg : W g) : W (X ‚óÅ g) :=
  Monoidal.whiskerLeft _ _ hg

lemma whiskerRight_mem {X‚ÇÅ X‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (hf : W f) (Y : C) : W (f ‚ñ∑ Y) :=
  Monoidal.whiskerRight _ hf Y

lemma tensorHom_mem {X‚ÇÅ X‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) {Y‚ÇÅ Y‚ÇÇ : C} (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ)
    (hf : W f) (hg : W g) : W (f ‚äó g) := by
  rw [tensorHom_def]
  exact comp_mem _ _ _ (whiskerRight_mem _ _ hf _) (whiskerLeft_mem _ _ _ hg)

end MorphismProperty

@[nolint unusedArguments]
def LocalizedMonoidal (L : C ‚•§ D) (W : MorphismProperty C)
    [W.Monoidal] [L.IsLocalization W] {unit : D}
    (_ : L.obj (ùüô_ C) ‚âÖ unit) := D

variable [W.Monoidal] [L.IsLocalization W] {unit : D} (Œµ : L.obj (ùüô_ C) ‚âÖ unit)

namespace Localization

instance : Category (LocalizedMonoidal L W Œµ) :=
  inferInstanceAs (Category D)

namespace Monoidal

def toMonoidalCategory : C ‚•§ LocalizedMonoidal L W Œµ := L

abbrev Œµ' : (toMonoidalCategory L W Œµ).obj (ùüô_ C) ‚âÖ unit := Œµ

local notation "L'" => toMonoidalCategory L W Œµ

instance : (L').IsLocalization W := inferInstanceAs (L.IsLocalization W)

lemma isInvertedBy‚ÇÇ :
    MorphismProperty.IsInvertedBy‚ÇÇ W W
      ((whiskeringRight‚ÇÇ' _ _ L').obj (curriedTensor C)) := by
  rintro ‚ü®X‚ÇÅ, Y‚ÇÅ‚ü© ‚ü®X‚ÇÇ, Y‚ÇÇ‚ü© ‚ü®f‚ÇÅ, f‚ÇÇ‚ü© ‚ü®hf‚ÇÅ, hf‚ÇÇ‚ü©
  have := Localization.inverts L' W _ (W.whiskerRight_mem f‚ÇÅ hf‚ÇÅ Y‚ÇÅ)
  have := Localization.inverts L' W _ (W.whiskerLeft_mem X‚ÇÇ f‚ÇÇ hf‚ÇÇ)
  dsimp
  infer_instance

noncomputable abbrev tensorBifunctor :
    LocalizedMonoidal L W Œµ ‚•§ LocalizedMonoidal L W Œµ ‚•§ LocalizedMonoidal L W Œµ :=
  Localization.lift‚ÇÇ _ (isInvertedBy‚ÇÇ L W Œµ) L L

noncomputable abbrev tensorBifunctorIso :
    (whiskeringLeft‚ÇÇObjObj L' L' D).obj (tensorBifunctor L W Œµ) ‚âÖ
      (whiskeringRight‚ÇÇ' C C L').obj (curriedTensor C) :=
  Lifting‚ÇÇ.iso L L W W (((whiskeringRight‚ÇÇ' _ _ L').obj (curriedTensor C))) (tensorBifunctor L W Œµ)

noncomputable abbrev tensorLeftFunctor (X : LocalizedMonoidal L W Œµ) :
    LocalizedMonoidal L W Œµ ‚•§ LocalizedMonoidal L W Œµ := (tensorBifunctor L W Œµ).obj X

noncomputable abbrev tensorRightFunctor (Y : LocalizedMonoidal L W Œµ) :
    LocalizedMonoidal L W Œµ ‚•§ LocalizedMonoidal L W Œµ :=
  (tensorBifunctor L W Œµ).flip.obj Y

noncomputable instance (X : C) :
    Lifting L' W (tensorLeft X ‚ãô L') (tensorLeftFunctor L W Œµ ((L').obj X)) :=
  inferInstanceAs (Lifting L W ((((whiskeringRight‚ÇÇ' _ _ L').obj (curriedTensor C))).obj X)
    ((tensorBifunctor L W Œµ).obj (L.obj X)))

noncomputable instance (Y : C) :
    Lifting L' W (tensorRight Y ‚ãô L') (tensorRightFunctor L W Œµ ((L').obj Y)) :=
  inferInstanceAs (Lifting L W ((((whiskeringRight‚ÇÇ' _ _ L').obj (curriedTensor C))).flip.obj Y)
    ((tensorBifunctor L W Œµ).flip.obj (L.obj Y)))

noncomputable def leftUnitor : tensorLeftFunctor L W Œµ unit ‚âÖ ùü≠ _ :=
  (tensorBifunctor L W Œµ).mapIso Œµ.symm ‚â™‚â´
    Localization.liftNatIso L' W (tensorLeft (ùüô_ C) ‚ãô L') L'
      (tensorLeftFunctor L W Œµ ((L').obj (ùüô_ _))) _
        (isoWhiskerRight (leftUnitorNatIso C) _ ‚â™‚â´ L.leftUnitor)

noncomputable def rightUnitor : tensorRightFunctor L W Œµ unit ‚âÖ ùü≠ _ :=
  (tensorBifunctor L W Œµ).flip.mapIso Œµ.symm ‚â™‚â´
    Localization.liftNatIso L' W (tensorRight (ùüô_ C) ‚ãô L') L'
      (tensorRightFunctor L W Œµ ((L').obj (ùüô_ _))) _
        (isoWhiskerRight (rightUnitorNatIso C) _ ‚â™‚â´ L.leftUnitor)

noncomputable def tensorTrifunctorLeft : LocalizedMonoidal L W Œµ ‚•§ LocalizedMonoidal L W Œµ ‚•§
    LocalizedMonoidal L W Œµ ‚•§ LocalizedMonoidal L W Œµ :=
  bifunctorComp‚ÇÅ‚ÇÇ (tensorBifunctor L W Œµ) (tensorBifunctor L W Œµ)
  -- this is `fun X Y Z ‚Ü¶ (X ‚äó Y) ‚äó Z`, see the example below

@[simps!]
def leftAssocTensorAux (C : Type*) [Category C] [MonoidalCategory C] : C √ó C ‚•§ C ‚•§ C :=
  curry.obj (prod.associator _ _ _ ‚ãô leftAssocTensor C)

lemma isInvertedBy‚ÇÇ_leftAssocTensorAux :
    (W.prod W).IsInvertedBy‚ÇÇ W ((whiskeringRight‚ÇÇ' _ _ L').obj (leftAssocTensorAux C)) := by
  rintro ‚ü®‚ü®X‚ÇÅ, Y‚ÇÅ‚ü©, Z‚ÇÅ‚ü© ‚ü®‚ü®X‚ÇÇ, Y‚ÇÇ‚ü©, Z‚ÇÇ‚ü© ‚ü®‚ü®f‚ÇÅ, f‚ÇÇ‚ü©, f‚ÇÉ‚ü© ‚ü®‚ü®hf‚ÇÅ, hf‚ÇÇ‚ü©, hf‚ÇÉ‚ü©
  have := Localization.inverts (L') W _ (W.whiskerRight_mem _ (W.whiskerRight_mem f‚ÇÅ hf‚ÇÅ Y‚ÇÇ) Z‚ÇÅ)
  have := Localization.inverts (L') W _ (W.whiskerRight_mem _ (W.whiskerLeft_mem X‚ÇÅ _ hf‚ÇÇ) Z‚ÇÅ)
  have := Localization.inverts (L') W _ (W.whiskerLeft_mem X‚ÇÇ _ (W.whiskerLeft_mem Y‚ÇÇ _ hf‚ÇÉ))
  simp only [leftAssocTensorAux, uncurry_obj_obj, whiskeringRight‚ÇÇ'_obj_obj_obj, curry_obj_obj_obj,
    Functor.comp_obj, prod.associator_obj, leftAssocTensor_obj, prod_Hom, uncurry_obj_map,
    whiskeringRight‚ÇÇ'_obj_map_app, curry_obj_map_app, Functor.comp_map, prod.associator_map,
    leftAssocTensor_map, tensorHom_id, whiskeringRight‚ÇÇ'_obj_obj_map, curry_obj_obj_map, prod_id,
    id_whiskerRight, id_tensorHom, tensor_whiskerLeft, Functor.map_comp]
  have h : f‚ÇÅ ‚äó f‚ÇÇ = (X‚ÇÅ ‚óÅ f‚ÇÇ) ‚â´ (f‚ÇÅ ‚ñ∑ Y‚ÇÇ) := by
    simp [‚Üê id_tensorHom, ‚Üê tensorHom_id, ‚Üê tensor_comp]
  rw [h, MonoidalCategory.comp_whiskerRight, Functor.map_comp]
  infer_instance

noncomputable def tensorTrifunctorLeftAux : LocalizedMonoidal L W Œµ √ó LocalizedMonoidal L W Œµ ‚•§
    LocalizedMonoidal L W Œµ ‚•§ LocalizedMonoidal L W Œµ :=
  lift‚ÇÇ _ (isInvertedBy‚ÇÇ_leftAssocTensorAux L W Œµ) (L.prod L) L

@[simps!]
def rightAssocTensorAux (C : Type*) [Category C] [MonoidalCategory C] : C √ó C ‚•§ C ‚•§ C :=
  curry.obj (prod.associator _ _ _ ‚ãô rightAssocTensor C)

lemma isInvertedBy‚ÇÇ_rightAssocTensorAux :
    (W.prod W).IsInvertedBy‚ÇÇ W ((whiskeringRight‚ÇÇ' _ _ L').obj (rightAssocTensorAux C)) := by
  rintro ‚ü®‚ü®X‚ÇÅ, Y‚ÇÅ‚ü©, Z‚ÇÅ‚ü© ‚ü®‚ü®X‚ÇÇ, Y‚ÇÇ‚ü©, Z‚ÇÇ‚ü© ‚ü®‚ü®f‚ÇÅ, f‚ÇÇ‚ü©, f‚ÇÉ‚ü© ‚ü®‚ü®hf‚ÇÅ, hf‚ÇÇ‚ü©, hf‚ÇÉ‚ü©
  have := Localization.inverts (L') W _ (W.whiskerRight_mem _ hf‚ÇÅ (Y‚ÇÇ ‚äó Z‚ÇÅ))
  have := Localization.inverts (L') W _ (W.whiskerLeft_mem X‚ÇÅ _ (W.whiskerRight_mem _ hf‚ÇÇ Z‚ÇÅ))
  have := Localization.inverts (L') W _ (W.whiskerLeft_mem X‚ÇÇ _ (W.whiskerLeft_mem Y‚ÇÇ _ hf‚ÇÉ))
  simp only [rightAssocTensorAux, uncurry_obj_obj, whiskeringRight‚ÇÇ'_obj_obj_obj, curry_obj_obj_obj,
    Functor.comp_obj, prod.associator_obj, rightAssocTensor_obj, prod_Hom, uncurry_obj_map,
    whiskeringRight‚ÇÇ'_obj_map_app, curry_obj_map_app, Functor.comp_map, prod.associator_map,
    rightAssocTensor_map, tensorHom_id, whiskeringRight‚ÇÇ'_obj_obj_map, curry_obj_obj_map, prod_id,
    id_tensorHom]
  have h : f‚ÇÅ ‚äó f‚ÇÇ ‚ñ∑ Z‚ÇÅ = (X‚ÇÅ ‚óÅ f‚ÇÇ ‚ñ∑ Z‚ÇÅ) ‚â´ (f‚ÇÅ ‚ñ∑ (Y‚ÇÇ ‚äó Z‚ÇÅ)) := by
    simp [‚Üê id_tensorHom, ‚Üê tensorHom_id, ‚Üê tensor_comp]
  rw [h, Functor.map_comp]
  infer_instance

noncomputable def tensorTrifunctorRightAux : LocalizedMonoidal L W Œµ √ó LocalizedMonoidal L W Œµ ‚•§
    LocalizedMonoidal L W Œµ ‚•§ LocalizedMonoidal L W Œµ :=
  lift‚ÇÇ _ (isInvertedBy‚ÇÇ_rightAssocTensorAux L W Œµ) (L.prod L) L

noncomputable def tensorTrifunctorLeftRightAuxIso :
    tensorTrifunctorLeftAux L W Œµ ‚âÖ tensorTrifunctorRightAux L W Œµ :=
  lift‚ÇÇNatIso (L.prod L) L (isInvertedBy‚ÇÇ_leftAssocTensorAux L W Œµ)
    (isInvertedBy‚ÇÇ_rightAssocTensorAux L W Œµ) (Functor.mapIso _
      (curry.mapIso (isoWhiskerLeft _ (associatorNatIso C))))

lemma associatorLeftHalf_aux {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÇ : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :
    ((tensorBifunctor L W Œµ).map (L.map f‚ÇÅ)).app (L.obj Y‚ÇÅ) ‚â´
      ((tensorBifunctor L W Œµ).obj (L.obj X‚ÇÇ)).map (L.map f‚ÇÇ) =
        (((tensorBifunctorIso L W Œµ).hom.app X‚ÇÅ).app Y‚ÇÅ) ‚â´ (L').map (f‚ÇÅ ‚äó f‚ÇÇ)
          ‚â´ (((tensorBifunctorIso L W Œµ).inv.app X‚ÇÇ).app Y‚ÇÇ) := by
  have h : f‚ÇÅ ‚äó f‚ÇÇ = (X‚ÇÅ ‚óÅ f‚ÇÇ) ‚â´ (f‚ÇÅ ‚ñ∑ Y‚ÇÇ) := by
    simp [‚Üê id_tensorHom, ‚Üê tensorHom_id, ‚Üê tensor_comp]
  have := ((tensorBifunctorIso L W Œµ).hom.app X‚ÇÅ).naturality (f‚ÇÇ)
  simp only [whiskeringLeft‚ÇÇObjObj_obj_obj_obj, whiskeringRight‚ÇÇ'_obj_obj_obj,
    curriedTensor_obj_obj, whiskeringLeft‚ÇÇObjObj_obj_obj_map, whiskeringRight‚ÇÇ'_obj_obj_map,
    curriedTensor_obj_map] at this
  rw [h, Functor.map_comp]
  slice_rhs 0 1 => rw [‚Üê this]
  simp only [whiskeringLeft‚ÇÇObjObj_obj_obj_obj, assoc]
  rw [‚Üê ((tensorBifunctor L W Œµ).map (L.map f‚ÇÅ)).naturality]
  congr 1
  change _ = _ ‚â´ _ ‚â´ (((tensorBifunctorIso L W Œµ).app X‚ÇÇ).app Y‚ÇÇ).inv
  rw [‚Üê assoc, Iso.eq_comp_inv]
  change _ ‚â´ (((tensorBifunctorIso L W Œµ).hom.app X‚ÇÇ).app Y‚ÇÇ) = _
  change ((L ‚ãô tensorBifunctor L W Œµ).map _).app _ ‚â´ _ = _
  rw [‚Üê whiskerLeft_app, ‚Üê NatTrans.comp_app]
  erw [(tensorBifunctorIso L W Œµ).hom.naturality f‚ÇÅ]
  rfl

lemma associatorLeftHalf_aux_naturality {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C} (Z : C) (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÇ : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :
    ((tensorBifunctor L W Œµ).map
      (((tensorBifunctor L W Œµ).map (L.map f‚ÇÅ)).app (L.obj Y‚ÇÅ))).app (L.obj Z) ‚â´
        ((tensorBifunctor L W Œµ).map
          (((tensorBifunctor L W Œµ).obj (L.obj X‚ÇÇ)).map (L.map f‚ÇÇ))).app (L.obj Z) ‚â´
            ((tensorBifunctor L W Œµ).map
              (((tensorBifunctorIso L W Œµ).hom.app X‚ÇÇ).app Y‚ÇÇ)).app (L.obj Z) ‚â´
                ((tensorBifunctorIso L W Œµ).hom.app (X‚ÇÇ ‚äó Y‚ÇÇ)).app Z =
    ((tensorBifunctor L W Œµ).map
      (((tensorBifunctorIso L W Œµ).hom.app X‚ÇÅ).app Y‚ÇÅ)).app (L.obj Z) ‚â´
        ((tensorBifunctorIso L W Œµ).hom.app (X‚ÇÅ ‚äó Y‚ÇÅ)).app Z ‚â´ (L').map ((f‚ÇÅ ‚äó f‚ÇÇ) ‚ñ∑ Z) := by
  simp only [‚Üê NatTrans.comp_app_assoc, ‚Üê Functor.map_comp]
  have h : ((tensorBifunctor L W Œµ).map (L.map f‚ÇÅ)).app (L.obj Y‚ÇÅ) ‚â´
      ((tensorBifunctor L W Œµ).obj (L.obj X‚ÇÇ)).map (L.map f‚ÇÇ) =
        (((tensorBifunctorIso L W Œµ).hom.app X‚ÇÅ).app Y‚ÇÅ) ‚â´ (L').map (f‚ÇÅ ‚äó f‚ÇÇ)
          ‚â´ (((tensorBifunctorIso L W Œµ).inv.app X‚ÇÇ).app Y‚ÇÇ) :=
    associatorLeftHalf_aux L W Œµ f‚ÇÅ f‚ÇÇ
  rw [reassoc_of% h, ‚Üê NatTrans.comp_app, ‚Üê NatTrans.comp_app]
  simp only [whiskeringRight‚ÇÇ'_obj_obj_obj, curriedTensor_obj_obj, Iso.inv_hom_id,
    NatTrans.id_app, comp_id, Functor.map_comp]
  simp only [NatTrans.comp_app, assoc]
  congr 1
  rw [‚Üê whiskerLeft_app, ‚Üê NatTrans.comp_app]
  erw [(tensorBifunctorIso L W Œµ).hom.naturality (f‚ÇÅ ‚äó f‚ÇÇ)]
  simp

noncomputable instance : Lifting‚ÇÇ (L.prod L) L (W.prod W) W
    ((whiskeringRight‚ÇÇ' (C √ó C) C L').obj (leftAssocTensorAux C))
      (uncurry.obj (tensorBifunctor L W Œµ) ‚ãô tensorBifunctor L W Œµ) where
  iso' := by
    refine NatIso.ofComponents (fun ‚ü®X, Y‚ü© ‚Ü¶ NatIso.ofComponents (fun Z ‚Ü¶ ?_) ?_) ?_
    ¬∑ exact ((tensorBifunctor L W Œµ).flip.obj _).mapIso
        (((tensorBifunctorIso L W Œµ).app _).app _) ‚â™‚â´ ((tensorBifunctorIso L W Œµ).app _).app _
    ¬∑ intro Z‚ÇÅ Z‚ÇÇ f
      simp only [whiskeringLeft‚ÇÇObjObj_obj_obj_obj, Functor.prod_obj, Functor.comp_obj,
        uncurry_obj_obj, whiskeringRight‚ÇÇ'_obj_obj_obj, leftAssocTensorAux_obj_obj,
        whiskeringLeft‚ÇÇObjObj_obj_obj_map, curriedTensor_obj_obj, Functor.flip_obj_obj,
        Iso.trans_hom, Functor.mapIso_hom, Iso.app_hom, Functor.flip_obj_map,
        NatTrans.naturality_assoc, whiskeringRight‚ÇÇ'_obj_obj_map, leftAssocTensorAux_obj_map,
        Functor.map_comp, assoc]
      have := ((tensorBifunctorIso L W Œµ).hom.app (X ‚äó Y)).naturality f
      simp only [whiskeringLeft‚ÇÇObjObj_obj_obj_obj, whiskeringRight‚ÇÇ'_obj_obj_obj,
        curriedTensor_obj_obj, whiskeringLeft‚ÇÇObjObj_obj_obj_map,
        whiskeringRight‚ÇÇ'_obj_obj_map, curriedTensor_obj_map, tensor_whiskerLeft,
        Functor.map_comp] at this
      rw [‚Üê this]
      rfl
    ¬∑ intro ‚ü®X‚ÇÅ, Y‚ÇÅ‚ü© ‚ü®X‚ÇÇ, Y‚ÇÇ‚ü© ‚ü®f‚ÇÅ, f‚ÇÇ‚ü©
      ext Z
      simp only [whiskeringLeft‚ÇÇObjObj_obj_obj_obj, Functor.prod_obj, Functor.comp_obj,
        uncurry_obj_obj, whiskeringRight‚ÇÇ'_obj_obj_obj, leftAssocTensorAux_obj_obj,
        curriedTensor_obj_obj, Functor.flip_obj_obj, NatTrans.comp_app,
        whiskeringLeft‚ÇÇObjObj_obj_map_app, Functor.prod_map, Functor.comp_map,
        uncurry_obj_map, Functor.map_comp, NatIso.ofComponents_hom_app, Iso.trans_hom,
        Functor.mapIso_hom, Iso.app_hom, Functor.flip_obj_map, assoc,
        whiskeringRight‚ÇÇ'_obj_map_app, leftAssocTensorAux_map_app]
      exact associatorLeftHalf_aux_naturality L W Œµ Z f‚ÇÅ f‚ÇÇ

noncomputable def associatorLeftHalf :
    curry.obj (tensorTrifunctorLeftAux L W Œµ) ‚âÖ tensorTrifunctorLeft L W Œµ := by
  refine curry.mapIso ?_ ‚â™‚â´ (bifunctorComp‚ÇÅ‚ÇÇIso _ _).symm
  exact lift‚ÇÇNatIso' (W‚ÇÅ := W.prod W) (W‚ÇÇ := W)
    (F‚ÇÅ := ((whiskeringRight‚ÇÇ' (C √ó C) C L').obj (leftAssocTensorAux C)))
    (F‚ÇÇ := ((whiskeringRight‚ÇÇ' (C √ó C) C L').obj (leftAssocTensorAux C)))
    (L.prod L) L
    (lift‚ÇÇ _ (isInvertedBy‚ÇÇ_leftAssocTensorAux L W Œµ) (L.prod L) L)
    (uncurry.obj (tensorBifunctor L W Œµ) ‚ãô tensorBifunctor L W Œµ) (Iso.refl _)

noncomputable def tensorTrifunctorRight : LocalizedMonoidal L W Œµ ‚•§ LocalizedMonoidal L W Œµ ‚•§
    LocalizedMonoidal L W Œµ ‚•§ LocalizedMonoidal L W Œµ :=
  bifunctorComp‚ÇÇ‚ÇÉ (tensorBifunctor L W Œµ) (tensorBifunctor L W Œµ)
   -- this is `fun X Y Z ‚Ü¶ X ‚äó (Y ‚äó Z)`, see the example below

lemma associatorRightHalf_aux_naturality {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : C} (Z : C) (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÇ : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :
    ((tensorBifunctor L W Œµ).map
      (L.map f‚ÇÅ)).app (((tensorBifunctor L W Œµ).obj (L.obj Y‚ÇÅ)).obj (L.obj Z)) ‚â´
        ((tensorBifunctor L W Œµ).obj (L.obj X‚ÇÇ)).map
          (((tensorBifunctor L W Œµ).map (L.map f‚ÇÇ)).app (L.obj Z)) ‚â´
            ((tensorBifunctor L W Œµ).obj (L.obj X‚ÇÇ)).map
              (((tensorBifunctorIso L W Œµ).hom.app Y‚ÇÇ).app Z) ‚â´
                ((tensorBifunctorIso L W Œµ).hom.app X‚ÇÇ).app (Y‚ÇÇ ‚äó Z) =
      ((tensorBifunctor L W Œµ).obj (L.obj X‚ÇÅ)).map
        (((tensorBifunctorIso L W Œµ).hom.app Y‚ÇÅ).app Z) ‚â´
          ((tensorBifunctorIso L W Œµ).hom.app X‚ÇÅ).app (Y‚ÇÅ ‚äó Z) ‚â´ (L').map (f‚ÇÅ ‚äó f‚ÇÇ ‚ñ∑ Z) := by
  rw [‚Üê ((tensorBifunctor L W Œµ).obj (L.obj X‚ÇÇ)).map_comp_assoc]
  slice_lhs 2 2 =>
    rw [‚Üê whiskerLeft_app, ‚Üê NatTrans.comp_app]
    erw [(tensorBifunctorIso L W Œµ).hom.naturality f‚ÇÇ]
  erw [‚Üê ((tensorBifunctor L W Œµ).map (L.map f‚ÇÅ)).naturality_assoc]
  simp only [whiskeringRight‚ÇÇ'_obj_obj_obj, curriedTensor_obj_obj, NatTrans.comp_app,
    Functor.comp_obj, whiskeringRight‚ÇÇ'_obj_map_app, curriedTensor_map_app, Functor.map_comp, assoc,
    whiskeringLeft‚ÇÇObjObj_obj_obj_obj]
  congr 1
  simp only [NatTrans.naturality_assoc]
  erw [((tensorBifunctorIso L W Œµ).hom.app X‚ÇÇ).naturality]
  simp only [whiskeringLeft‚ÇÇObjObj_obj_obj_obj, whiskeringRight‚ÇÇ'_obj_obj_obj,
    curriedTensor_obj_obj, whiskeringRight‚ÇÇ'_obj_obj_map, curriedTensor_obj_map]
  rw [‚Üê whiskerLeft_app, ‚Üê NatTrans.comp_app_assoc]
  erw [(tensorBifunctorIso L W Œµ).hom.naturality f‚ÇÅ]
  simp only [Functor.comp_obj, whiskeringRight‚ÇÇ'_obj_obj_obj, curriedTensor_obj_obj,
    NatTrans.comp_app, whiskeringRight‚ÇÇ'_obj_map_app, curriedTensor_map_app, whiskerRight_tensor,
    Functor.map_comp, assoc]
  simp [‚Üê Functor.map_comp, ‚Üê tensorHom_id, ‚Üê id_tensorHom, ‚Üê tensor_comp]

set_option maxHeartbeats 400000 in
noncomputable instance : Lifting‚ÇÇ (L.prod L) L (W.prod W) W
    ((whiskeringRight‚ÇÇ' (C √ó C) C L').obj (rightAssocTensorAux C))
      (curry.obj (prod.associator _ _ _ ‚ãô uncurry.obj (uncurry.obj
        (tensorBifunctor L W Œµ) ‚ãô (tensorBifunctor L W Œµ).flip).flip)) where
  iso' := by
    refine NatIso.ofComponents (fun ‚ü®X, Y‚ü© ‚Ü¶ NatIso.ofComponents (fun Z ‚Ü¶ ?_) ?_) ?_
    ¬∑ exact ((tensorBifunctor L W Œµ).obj _).mapIso (((tensorBifunctorIso L W Œµ).app _).app _)  ‚â™‚â´
        ((tensorBifunctorIso L W Œµ).app _).app _
    ¬∑ intro Z‚ÇÅ Z‚ÇÇ f
      simp only [whiskeringLeft‚ÇÇObjObj_obj_obj_obj, Functor.prod_obj, curry_obj_obj_obj,
        Functor.comp_obj, prod.associator_obj, uncurry_obj_obj, Functor.flip_obj_obj,
        whiskeringRight‚ÇÇ'_obj_obj_obj, rightAssocTensorAux_obj_obj,
        whiskeringLeft‚ÇÇObjObj_obj_obj_map, curry_obj_obj_map, prod_Hom, prod_id, Functor.comp_map,
        prod.associator_map, uncurry_obj_map, Functor.map_id, NatTrans.id_app, Functor.flip_obj_map,
        id_comp, Functor.flip_map_app, curriedTensor_obj_obj, Iso.trans_hom, Functor.mapIso_hom,
        Iso.app_hom, whiskeringRight‚ÇÇ'_obj_obj_map, rightAssocTensorAux_obj_map, assoc]
      have := ((tensorBifunctorIso L W Œµ).hom.app X).naturality (Y ‚óÅ f)
      simp only [whiskeringLeft‚ÇÇObjObj_obj_obj_obj, whiskeringRight‚ÇÇ'_obj_obj_obj,
        curriedTensor_obj_obj, whiskeringLeft‚ÇÇObjObj_obj_obj_map, whiskeringRight‚ÇÇ'_obj_obj_map,
        curriedTensor_obj_map] at this
      rw [‚Üê this]
      simp only [‚Üê assoc]
      erw [‚Üê ((tensorBifunctor L W Œµ).obj ((L').obj X)).map_comp,
        ‚Üê ((tensorBifunctor L W Œµ).obj ((L').obj X)).map_comp,
        ((tensorBifunctorIso L W Œµ).hom.app Y).naturality]
      rfl
    ¬∑ intro ‚ü®X‚ÇÅ, Y‚ÇÅ‚ü© ‚ü®X‚ÇÇ, Y‚ÇÇ‚ü© ‚ü®f‚ÇÅ, f‚ÇÇ‚ü©
      ext Z
      simp only [whiskeringLeft‚ÇÇObjObj_obj_obj_obj, Functor.prod_obj, curry_obj_obj_obj,
        Functor.comp_obj, prod.associator_obj, uncurry_obj_obj, Functor.flip_obj_obj,
        whiskeringRight‚ÇÇ'_obj_obj_obj, rightAssocTensorAux_obj_obj, curriedTensor_obj_obj,
        NatTrans.comp_app, whiskeringLeft‚ÇÇObjObj_obj_map_app, Functor.prod_map, curry_obj_map_app,
        prod_Hom, Functor.comp_map, prod.associator_map, uncurry_obj_map, Functor.flip_map_app,
        Functor.flip_obj_map, Functor.map_id, comp_id, NatIso.ofComponents_hom_app, Iso.trans_hom,
        Functor.mapIso_hom, Iso.app_hom, assoc, whiskeringRight‚ÇÇ'_obj_map_app,
        rightAssocTensorAux_map_app]
      exact associatorRightHalf_aux_naturality L W Œµ Z f‚ÇÅ f‚ÇÇ

noncomputable def associatorRightHalf :
    curry.obj (tensorTrifunctorRightAux L W Œµ) ‚âÖ tensorTrifunctorRight L W Œµ := by
  refine curry.mapIso ?_ ‚â™‚â´ (bifunctorComp‚ÇÇ‚ÇÉIso _ _).symm
  exact lift‚ÇÇNatIso' (W‚ÇÅ := W.prod W) (W‚ÇÇ := W)
    (F‚ÇÅ := ((whiskeringRight‚ÇÇ' (C √ó C) C L').obj (rightAssocTensorAux C)))
    (F‚ÇÇ := ((whiskeringRight‚ÇÇ' (C √ó C) C L').obj (rightAssocTensorAux C)))
    (L.prod L) L
    (lift‚ÇÇ _ (isInvertedBy‚ÇÇ_rightAssocTensorAux L W Œµ) (L.prod L) L)
    (curry.obj (prod.associator _ _ _ ‚ãô uncurry.obj (uncurry.obj
      (tensorBifunctor L W Œµ) ‚ãô (tensorBifunctor L W Œµ).flip).flip))
    (Iso.refl _)

noncomputable def associator : tensorTrifunctorLeft L W Œµ ‚âÖ tensorTrifunctorRight L W Œµ :=
  (associatorLeftHalf L W Œµ).symm ‚â™‚â´ curry.mapIso (tensorTrifunctorLeftRightAuxIso L W Œµ) ‚â™‚â´
    associatorRightHalf L W Œµ

noncomputable instance monoidalCategoryStruct :
    MonoidalCategoryStruct (LocalizedMonoidal L W Œµ) where
  tensorObj X Y := ((tensorBifunctor L W Œµ).obj X).obj Y
  whiskerLeft X _ _ g := (tensorLeftFunctor L W Œµ X).map g
  whiskerRight f Y := (tensorRightFunctor L W Œµ Y).map f
  tensorUnit := unit
  associator X Y Z := (((associator L W Œµ).app X).app Y).app Z
  leftUnitor Y := (leftUnitor L W Œµ).app Y
  rightUnitor X := (rightUnitor L W Œµ).app X

-- TODO: remove these examples, they are just for remembering what the trifunctors do.
example (X Y Z : LocalizedMonoidal L W Œµ) :
    (((tensorTrifunctorLeft L W Œµ).obj X).obj Y).obj Z = (X ‚äó Y) ‚äó Z := rfl

-- example (X Y Z : LocalizedMonoidal L W Œµ) :
--     ((tensorTrifunctorRightAux L W Œµ).obj (X, Y)).obj Z = (X ‚äó Y) ‚äó Z := rfl

example (X Y Z : LocalizedMonoidal L W Œµ) :
    (((tensorTrifunctorRight L W Œµ).obj X).obj Y).obj Z = X ‚äó Y ‚äó Z := rfl

example (X Y Z Z' : LocalizedMonoidal L W Œµ) (f : Z ‚ü∂ Z') :
    (((tensorTrifunctorLeft L W Œµ).obj X).obj Y).map f = (X ‚äó Y) ‚óÅ f := rfl

example (X Y Z Z' : LocalizedMonoidal L W Œµ) (f : Z ‚ü∂ Z') :
    (((tensorTrifunctorRight L W Œµ).obj X).obj Y).map f = X ‚óÅ (Y ‚óÅ f) := rfl

noncomputable def Œº (X Y : C) : (L').obj X ‚äó (L').obj Y ‚âÖ (L').obj (X ‚äó Y) :=
  ((tensorBifunctorIso L W Œµ).app X).app Y

@[reassoc (attr := simp)]
lemma Œº_natural_left {X‚ÇÅ X‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (Y : C) :
    (L').map f ‚ñ∑ (L').obj Y ‚â´ (Œº L W Œµ X‚ÇÇ Y).hom =
      (Œº L W Œµ X‚ÇÅ Y).hom ‚â´ (L').map (f ‚ñ∑ Y) :=
  NatTrans.naturality_app (tensorBifunctorIso L W Œµ).hom Y f

@[reassoc (attr := simp)]
lemma Œº_inv_natural_left {X‚ÇÅ X‚ÇÇ : C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (Y : C) :
    (Œº L W Œµ X‚ÇÅ Y).inv ‚â´ (L').map f ‚ñ∑ (L').obj Y =
      (L').map (f ‚ñ∑ Y) ‚â´ (Œº L W Œµ X‚ÇÇ Y).inv := by
  simp [Iso.eq_comp_inv]

@[reassoc (attr := simp)]
lemma Œº_natural_right (X : C) {Y‚ÇÅ Y‚ÇÇ : C} (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :
    (L').obj X ‚óÅ (L').map g ‚â´ (Œº L W Œµ X Y‚ÇÇ).hom =
      (Œº L W Œµ X Y‚ÇÅ).hom ‚â´ (L').map (X ‚óÅ g) :=
  ((tensorBifunctorIso L W Œµ).hom.app X).naturality g

@[reassoc (attr := simp)]
lemma Œº_inv_natural_right (X : C) {Y‚ÇÅ Y‚ÇÇ : C} (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :
    (Œº L W Œµ X Y‚ÇÅ).inv ‚â´ (L').obj X ‚óÅ (L').map g =
      (L').map (X ‚óÅ g) ‚â´ (Œº L W Œµ X Y‚ÇÇ).inv := by
  simp [Iso.eq_comp_inv]

lemma leftUnitor_hom_app (Y : C) :
    (Œª_ ((L').obj Y)).hom =
      (Œµ' L W Œµ).inv ‚ñ∑ (L').obj Y ‚â´ (Œº _ _ _ _ _).hom ‚â´ (L').map (Œª_ Y).hom := by
  dsimp [monoidalCategoryStruct, leftUnitor]
  rw [liftNatTrans_app]
  dsimp
  rw [assoc]
  change _ ‚â´ (Œº L W Œµ  _ _).hom ‚â´ _ ‚â´ ùüô _ ‚â´ ùüô _ = _
  simp only [comp_id]

lemma rightUnitor_hom_app (X : C) :
    (œÅ_ ((L').obj X)).hom =
      (L').obj X ‚óÅ (Œµ' L W Œµ).inv ‚â´ (Œº _ _ _ _ _).hom ‚â´
        (L').map (œÅ_ X).hom := by
  dsimp [monoidalCategoryStruct, rightUnitor]
  rw [liftNatTrans_app]
  dsimp
  rw [assoc]
  change _ ‚â´ (Œº L W Œµ  _ _).hom ‚â´ _ ‚â´ ùüô _ ‚â´ ùüô _ = _
  simp only [comp_id]

lemma associator_hom_app (X‚ÇÅ X‚ÇÇ X‚ÇÉ : C) :
    (Œ±_ ((L').obj X‚ÇÅ) ((L').obj X‚ÇÇ) ((L').obj X‚ÇÉ)).hom =
      ((Œº L W Œµ _ _).hom ‚äó ùüô _) ‚â´ (Œº L W Œµ _ _).hom ‚â´ (L').map (Œ±_ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom ‚â´
        (Œº L W Œµ  _ _).inv ‚â´ (ùüô _ ‚äó (Œº L W Œµ  _ _).inv) := by
  simp only [monoidalCategoryStruct, Functor.flip_obj_map, associator, NatIso.trans_app,
    curry_obj_obj_obj, Iso.trans_hom, Iso.app_hom, Iso.symm_hom, Functor.mapIso_hom,
    curry_map_app_app, Functor.map_id, comp_id, NatTrans.id_app, id_comp]
  sorry

lemma id_tensorHom (X : LocalizedMonoidal L W Œµ) {Y‚ÇÅ Y‚ÇÇ : LocalizedMonoidal L W Œµ} (f : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :
    ùüô X ‚äó f = X ‚óÅ f := by
  simp [monoidalCategoryStruct]

lemma tensorHom_id {X‚ÇÅ X‚ÇÇ : LocalizedMonoidal L W Œµ} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (Y : LocalizedMonoidal L W Œµ) :
    f ‚äó ùüô Y = f ‚ñ∑ Y := by
  simp [monoidalCategoryStruct]

@[reassoc]
lemma tensor_comp {X‚ÇÅ Y‚ÇÅ Z‚ÇÅ X‚ÇÇ Y‚ÇÇ Z‚ÇÇ : LocalizedMonoidal L W Œµ}
    (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (g‚ÇÅ : Y‚ÇÅ ‚ü∂ Z‚ÇÅ) (g‚ÇÇ : Y‚ÇÇ ‚ü∂ Z‚ÇÇ) :
    (f‚ÇÅ ‚â´ g‚ÇÅ) ‚äó (f‚ÇÇ ‚â´ g‚ÇÇ) = (f‚ÇÅ ‚äó f‚ÇÇ) ‚â´ (g‚ÇÅ ‚äó g‚ÇÇ) := by
  simp [monoidalCategoryStruct]

lemma tensor_id (X‚ÇÅ X‚ÇÇ : LocalizedMonoidal L W Œµ) : ùüô X‚ÇÅ ‚äó ùüô X‚ÇÇ = ùüô (X‚ÇÅ ‚äó X‚ÇÇ) := by
  simp [monoidalCategoryStruct]

@[reassoc]
theorem whiskerLeft_comp (Q : LocalizedMonoidal L W Œµ) {X Y Z : LocalizedMonoidal L W Œµ}
    (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :
    Q ‚óÅ (f ‚â´ g) = Q ‚óÅ f ‚â´ Q ‚óÅ g := by
  simp only [‚Üê id_tensorHom, ‚Üê tensor_comp, comp_id]

@[reassoc]
theorem whiskerRight_comp (Q : LocalizedMonoidal L W Œµ) {X Y Z : LocalizedMonoidal L W Œµ}
    (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :
    (f ‚â´ g) ‚ñ∑ Q = f ‚ñ∑ Q ‚â´ g ‚ñ∑ Q := by
  simp only [‚Üê tensorHom_id, ‚Üê tensor_comp, comp_id]

lemma whiskerLeft_id (X Y : LocalizedMonoidal L W Œµ) :
    X ‚óÅ (ùüô Y) = ùüô _ := by simp [monoidalCategoryStruct]

lemma whiskerRight_id (X Y : LocalizedMonoidal L W Œµ) :
    (ùüô X) ‚ñ∑ Y = ùüô _ := by simp [monoidalCategoryStruct]

@[reassoc]
lemma whisker_exchange {Q X Y Z : LocalizedMonoidal L W Œµ} (f : Q ‚ü∂ X) (g : Y ‚ü∂ Z) :
    Q ‚óÅ g ‚â´ f ‚ñ∑ Z = f ‚ñ∑ Y ‚â´ X ‚óÅ g := by
  simp only [‚Üê id_tensorHom, ‚Üê tensorHom_id, ‚Üê tensor_comp, id_comp, comp_id]

lemma tensorTrifunctorRight_maps_aux {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : LocalizedMonoidal L W Œµ} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ)
    (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) :
    (((tensorTrifunctorRight L W Œµ).map f‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ
      ‚â´ (((tensorTrifunctorRight L W Œµ).obj Y‚ÇÅ).map f‚ÇÇ).app X‚ÇÉ
        ‚â´ (((tensorTrifunctorRight L W Œµ).obj Y‚ÇÅ).obj Y‚ÇÇ).map f‚ÇÉ =
          f‚ÇÅ ‚ñ∑ (X‚ÇÇ ‚äó X‚ÇÉ) ‚â´ Y‚ÇÅ ‚óÅ (f‚ÇÇ ‚ñ∑ X‚ÇÉ) ‚â´ Y‚ÇÅ ‚óÅ (Y‚ÇÇ ‚óÅ f‚ÇÉ) := rfl

lemma tensorTrifunctorRight_maps_aux‚ÇÇ {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : LocalizedMonoidal L W Œµ} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ)
    (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) : f‚ÇÅ ‚ñ∑ (X‚ÇÇ ‚äó X‚ÇÉ) ‚â´ Y‚ÇÅ ‚óÅ (f‚ÇÇ ‚ñ∑ X‚ÇÉ) ‚â´ Y‚ÇÅ ‚óÅ (Y‚ÇÇ ‚óÅ f‚ÇÉ) =
      f‚ÇÅ ‚äó (f‚ÇÇ ‚äó f‚ÇÉ) := by
  simp only [‚Üê tensorHom_id, ‚Üê id_tensorHom, ‚Üê tensor_comp, comp_id, id_comp]

lemma tensorTrifunctorLeft_maps_aux {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : LocalizedMonoidal L W Œµ} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ)
    (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) :
    (((tensorTrifunctorLeft L W Œµ).map f‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ
      ‚â´ (((tensorTrifunctorLeft L W Œµ).obj Y‚ÇÅ).map f‚ÇÇ).app X‚ÇÉ
        ‚â´ (((tensorTrifunctorLeft L W Œµ).obj Y‚ÇÅ).obj Y‚ÇÇ).map f‚ÇÉ =
          ((f‚ÇÅ ‚ñ∑ X‚ÇÇ) ‚ñ∑ X‚ÇÉ) ‚â´ ((Y‚ÇÅ ‚óÅ f‚ÇÇ) ‚ñ∑ X‚ÇÉ) ‚â´ ((Y‚ÇÅ ‚äó Y‚ÇÇ) ‚óÅ f‚ÇÉ) := rfl

lemma tensorTrifunctorLeft_maps_aux‚ÇÇ {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : LocalizedMonoidal L W Œµ} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ)
    (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) : ((f‚ÇÅ ‚ñ∑ X‚ÇÇ) ‚ñ∑ X‚ÇÉ) ‚â´ ((Y‚ÇÅ ‚óÅ f‚ÇÇ) ‚ñ∑ X‚ÇÉ) ‚â´ ((Y‚ÇÅ ‚äó Y‚ÇÇ) ‚óÅ f‚ÇÉ) =
      (f‚ÇÅ ‚äó f‚ÇÇ) ‚äó f‚ÇÉ := by
  simp only [‚Üê tensorHom_id, ‚Üê id_tensorHom, ‚Üê tensor_comp, comp_id, id_comp]

@[reassoc]
lemma associator_naturality {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : LocalizedMonoidal L W Œµ}
    (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) :
    ((f‚ÇÅ ‚äó f‚ÇÇ) ‚äó f‚ÇÉ) ‚â´ (Œ±_ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ).hom = (Œ±_ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom ‚â´ (f‚ÇÅ ‚äó f‚ÇÇ ‚äó f‚ÇÉ) := by
  rw [‚Üê tensorTrifunctorRight_maps_aux‚ÇÇ, ‚Üê tensorTrifunctorRight_maps_aux]
  rw [‚Üê tensorTrifunctorLeft_maps_aux‚ÇÇ, ‚Üê tensorTrifunctorLeft_maps_aux]
  simp only [assoc]
  erw [(((associator L W Œµ).hom.app Y‚ÇÅ).app Y‚ÇÇ).naturality f‚ÇÉ]
  rw [‚Üê NatTrans.comp_app_assoc, ‚Üê NatTrans.comp_app_assoc]
  simp only [assoc]
  erw [((associator L W Œµ).hom.app Y‚ÇÅ).naturality f‚ÇÇ]
  rw [‚Üê NatTrans.comp_app_assoc]
  erw [(associator L W Œµ).hom.naturality f‚ÇÅ]
  simp
  rfl

lemma associator_naturality‚ÇÅ {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ : LocalizedMonoidal L W Œµ} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) :
    ((f‚ÇÅ ‚ñ∑ X‚ÇÇ) ‚ñ∑ X‚ÇÉ) ‚â´ (Œ±_ Y‚ÇÅ X‚ÇÇ X‚ÇÉ).hom = (Œ±_ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom ‚â´ (f‚ÇÅ ‚ñ∑ (X‚ÇÇ ‚äó X‚ÇÉ)) := by
  simp only [‚Üê tensorHom_id, associator_naturality, Iso.cancel_iso_hom_left, tensor_id]

lemma associator_naturality‚ÇÇ {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÇ : LocalizedMonoidal L W Œµ} (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) :
    ((X‚ÇÅ ‚óÅ f‚ÇÇ) ‚ñ∑ X‚ÇÉ) ‚â´ (Œ±_ X‚ÇÅ Y‚ÇÇ X‚ÇÉ).hom = (Œ±_ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom ‚â´ (X‚ÇÅ ‚óÅ (f‚ÇÇ ‚ñ∑ X‚ÇÉ)) := by
  simp only [‚Üê tensorHom_id, ‚Üê id_tensorHom, associator_naturality]

lemma associator_naturality‚ÇÉ {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÉ : LocalizedMonoidal L W Œµ} (f‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) :
    ((X‚ÇÅ ‚äó X‚ÇÇ) ‚óÅ f‚ÇÉ) ‚â´ (Œ±_ X‚ÇÅ X‚ÇÇ Y‚ÇÉ).hom = (Œ±_ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom ‚â´ (X‚ÇÅ ‚óÅ (X‚ÇÇ ‚óÅ f‚ÇÉ)) := by
  simp only [‚Üê id_tensorHom, ‚Üê tensor_id, associator_naturality]

lemma pentagon_aux‚ÇÅ {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ : LocalizedMonoidal L W Œµ} (i : X‚ÇÅ ‚âÖ Y‚ÇÅ) :
    ((i.hom ‚ñ∑ X‚ÇÇ) ‚ñ∑ X‚ÇÉ) ‚â´ (Œ±_ Y‚ÇÅ X‚ÇÇ X‚ÇÉ).hom  ‚â´ (i.inv ‚ñ∑ (X‚ÇÇ ‚äó X‚ÇÉ)) = (Œ±_ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom := by
  simp only [‚Üê assoc, associator_naturality‚ÇÅ]
  simp [‚Üê whiskerRight_comp, ‚Üê whiskerLeft_comp, whiskerRight_id, whiskerLeft_id]

lemma pentagon_aux‚ÇÇ {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÇ : LocalizedMonoidal L W Œµ} (i : X‚ÇÇ ‚âÖ Y‚ÇÇ) :
    ((X‚ÇÅ ‚óÅ i.hom) ‚ñ∑ X‚ÇÉ) ‚â´ (Œ±_ X‚ÇÅ Y‚ÇÇ X‚ÇÉ).hom  ‚â´ (X‚ÇÅ ‚óÅ (i.inv ‚ñ∑ X‚ÇÉ)) = (Œ±_ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom := by
  simp only [‚Üê assoc, associator_naturality‚ÇÇ]
  simp [‚Üê whiskerRight_comp, ‚Üê whiskerLeft_comp, whiskerRight_id, whiskerLeft_id]

lemma pentagon_aux‚ÇÉ {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÉ : LocalizedMonoidal L W Œµ} (i : X‚ÇÉ ‚âÖ Y‚ÇÉ) :
    ((X‚ÇÅ ‚äó X‚ÇÇ) ‚óÅ i.hom) ‚â´ (Œ±_ X‚ÇÅ X‚ÇÇ Y‚ÇÉ).hom  ‚â´ (X‚ÇÅ ‚óÅ (X‚ÇÇ ‚óÅ i.inv)) = (Œ±_ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom := by
  simp only [‚Üê assoc, associator_naturality‚ÇÉ]
  simp [‚Üê whiskerRight_comp, ‚Üê whiskerLeft_comp, whiskerRight_id, whiskerLeft_id]

variable {L W Œµ} in
lemma pentagon (Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ Y‚ÇÑ : LocalizedMonoidal L W Œµ) :
    Pentagon Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ Y‚ÇÑ := by
  have : (L').EssSurj := Localization.essSurj L' W
  obtain ‚ü®X‚ÇÅ, ‚ü®e‚ÇÅ‚ü©‚ü© : ‚àÉ X‚ÇÅ, Nonempty ((L').obj X‚ÇÅ ‚âÖ Y‚ÇÅ) := ‚ü®_, ‚ü®(L').objObjPreimageIso Y‚ÇÅ‚ü©‚ü©
  obtain ‚ü®X‚ÇÇ, ‚ü®e‚ÇÇ‚ü©‚ü© : ‚àÉ X‚ÇÇ, Nonempty ((L').obj X‚ÇÇ ‚âÖ Y‚ÇÇ) := ‚ü®_, ‚ü®(L').objObjPreimageIso Y‚ÇÇ‚ü©‚ü©
  obtain ‚ü®X‚ÇÉ, ‚ü®e‚ÇÉ‚ü©‚ü© : ‚àÉ X‚ÇÉ, Nonempty ((L').obj X‚ÇÉ ‚âÖ Y‚ÇÉ) := ‚ü®_, ‚ü®(L').objObjPreimageIso Y‚ÇÉ‚ü©‚ü©
  obtain ‚ü®X‚ÇÑ, ‚ü®e‚ÇÑ‚ü©‚ü© : ‚àÉ X‚ÇÑ, Nonempty ((L').obj X‚ÇÑ ‚âÖ Y‚ÇÑ) := ‚ü®_, ‚ü®(L').objObjPreimageIso Y‚ÇÑ‚ü©‚ü©
  suffices Pentagon ((L').obj X‚ÇÅ) ((L').obj X‚ÇÇ) ((L').obj X‚ÇÉ) ((L').obj X‚ÇÑ) by
    dsimp [Pentagon]
    refine Eq.trans ?_ (((((e‚ÇÅ.inv ‚äó e‚ÇÇ.inv) ‚äó e‚ÇÉ.inv) ‚äó e‚ÇÑ.inv) ‚â´= this =‚â´
      (e‚ÇÅ.hom ‚äó e‚ÇÇ.hom ‚äó e‚ÇÉ.hom ‚äó e‚ÇÑ.hom)).trans ?_)
    ¬∑ rw [‚Üê id_tensorHom, ‚Üê id_tensorHom, ‚Üê tensorHom_id, ‚Üê tensorHom_id, assoc, assoc,
        ‚Üê tensor_comp, ‚Üê associator_naturality, id_comp, ‚Üê comp_id e‚ÇÅ.hom,
        tensor_comp, ‚Üê associator_naturality_assoc, ‚Üê comp_id (ùüô ((L').obj X‚ÇÑ)),
        ‚Üê tensor_comp_assoc, associator_naturality, comp_id, comp_id,
        ‚Üê tensor_comp_assoc, assoc, e‚ÇÑ.inv_hom_id, ‚Üê tensor_comp, e‚ÇÅ.inv_hom_id,
        ‚Üê tensor_comp, e‚ÇÇ.inv_hom_id, e‚ÇÉ.inv_hom_id, tensor_id, tensor_id, comp_id]
    ¬∑ rw [assoc, associator_naturality_assoc, associator_naturality_assoc,
        ‚Üê tensor_comp, e‚ÇÅ.inv_hom_id, ‚Üê tensor_comp, e‚ÇÇ.inv_hom_id, ‚Üê tensor_comp,
        e‚ÇÉ.inv_hom_id, e‚ÇÑ.inv_hom_id, tensor_id, tensor_id, tensor_id, comp_id]
  dsimp [Pentagon]
  have : ((L').obj X‚ÇÅ ‚óÅ (Œº L W Œµ X‚ÇÇ X‚ÇÉ).inv) ‚ñ∑ (L').obj X‚ÇÑ ‚â´
      (Œ±_ ((L').obj X‚ÇÅ) ((L').obj X‚ÇÇ ‚äó (L').obj X‚ÇÉ) ((L').obj X‚ÇÑ)).hom ‚â´
        (L').obj X‚ÇÅ ‚óÅ (Œº L W Œµ X‚ÇÇ X‚ÇÉ).hom ‚ñ∑ (L').obj X‚ÇÑ =
          (Œ±_ ((L').obj X‚ÇÅ) ((L').obj (X‚ÇÇ ‚äó X‚ÇÉ)) ((L').obj X‚ÇÑ)).hom :=
    pentagon_aux‚ÇÇ _ _ _ (Œº L W Œµ X‚ÇÇ X‚ÇÉ).symm
  rw [associator_hom_app, tensorHom_id, id_tensorHom, associator_hom_app, tensorHom_id,
    whiskerLeft_comp, whiskerRight_comp,  whiskerRight_comp,  whiskerRight_comp, assoc, assoc,
    assoc, whiskerRight_comp, assoc]
  rw [reassoc_of% this, associator_hom_app, tensorHom_id,
    ‚Üê pentagon_aux‚ÇÅ (X‚ÇÇ := (L').obj X‚ÇÉ) (X‚ÇÉ := (L').obj X‚ÇÑ) (i := Œº L W Œµ X‚ÇÅ X‚ÇÇ),
    ‚Üê pentagon_aux‚ÇÉ (X‚ÇÅ := (L').obj X‚ÇÅ) (X‚ÇÇ := (L').obj X‚ÇÇ) (i := Œº L W Œµ X‚ÇÉ X‚ÇÑ),
    associator_hom_app, associator_hom_app]
  simp only [assoc, ‚Üê whiskerRight_comp_assoc, Iso.inv_hom_id, comp_id, Œº_natural_left_assoc,
    id_tensorHom, ‚Üê whiskerLeft_comp, Iso.inv_hom_id_assoc]
  rw [‚Üê (L').map_comp_assoc, whiskerLeft_comp, Œº_inv_natural_right_assoc, ‚Üê (L').map_comp_assoc]
  simp only [assoc, MonoidalCategory.pentagon, Functor.map_comp]
  simp only [tensorHom_id, id_tensorHom, whiskerLeft_comp, whiskerLeft_comp_assoc,
    whiskerRight_comp, whiskerRight_comp_assoc, assoc]
  congr 3
  simp only [‚Üê assoc]
  congr
  rw [‚Üê comp_id ((L').map (Œ±_ (X‚ÇÅ ‚äó X‚ÇÇ) X‚ÇÉ X‚ÇÑ).hom)]
  simp only [assoc]
  congr
  simp only [id_comp]
  rw [Iso.eq_inv_comp]
  simp only [‚Üê assoc]
  rw [‚Üê Iso.comp_inv_eq]
  simp only [comp_id, Iso.hom_inv_id, assoc]
  rw [whisker_exchange, ‚Üê whiskerRight_comp_assoc]
  simp only [Iso.inv_hom_id, whiskerRight_id, id_comp, ‚Üê whiskerLeft_comp, whiskerLeft_id]

@[reassoc]
lemma triangle_aux {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : LocalizedMonoidal L W Œµ}
    (i‚ÇÅ : X‚ÇÅ ‚âÖ Y‚ÇÅ) (i‚ÇÇ : X‚ÇÇ ‚âÖ Y‚ÇÇ) (i‚ÇÉ : X‚ÇÉ ‚âÖ Y‚ÇÉ) :
    ((i‚ÇÅ.hom ‚äó i‚ÇÇ.hom) ‚äó i‚ÇÉ.hom) ‚â´ (Œ±_ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ).hom ‚â´ (i‚ÇÅ.inv ‚äó i‚ÇÇ.inv ‚äó i‚ÇÉ.inv) =
      (Œ±_ X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom := by
  rw [‚Üê assoc, associator_naturality]
  simp only [assoc, ‚Üê tensor_comp, Iso.hom_inv_id, id_tensorHom, whiskerLeft_id, comp_id]

lemma leftUnitor_naturality {X Y : LocalizedMonoidal L W Œµ} (f : X ‚ü∂ Y) :
    ùüô_ (LocalizedMonoidal L W Œµ) ‚óÅ f ‚â´ (Œª_ Y).hom = (Œª_ X).hom ‚â´ f := by
  simp [monoidalCategoryStruct]

lemma rightUnitor_naturality {X Y : LocalizedMonoidal L W Œµ} (f : X ‚ü∂ Y) :
    f ‚ñ∑ ùüô_ (LocalizedMonoidal L W Œµ) ‚â´ (œÅ_ Y).hom = (œÅ_ X).hom ‚â´ f :=
  (rightUnitor L W Œµ).hom.naturality f

lemma triangle_aux‚ÇÅ {X Y  : LocalizedMonoidal L W Œµ} {X' Y' : C}
    (e‚ÇÅ : (L').obj X' ‚âÖ X) (e‚ÇÇ : (L').obj Y' ‚âÖ Y) :
      e‚ÇÅ.hom ‚äó (Œµ.hom ‚äó e‚ÇÇ.hom) ‚â´ (Œª_ Y).hom =
        (L').obj X' ‚óÅ ((Œµ' L W Œµ).hom ‚ñ∑ (L').obj Y' ‚â´
          ùüô_ _ ‚óÅ e‚ÇÇ.hom ‚â´ (Œª_ Y).hom) ‚â´ e‚ÇÅ.hom ‚ñ∑ Y := by
  simp only [‚Üê tensorHom_id, ‚Üê id_tensorHom, ‚Üê tensor_comp, comp_id, id_comp,
    ‚Üê tensor_comp_assoc, id_comp]
  erw [comp_id]

lemma triangle_aux‚ÇÇ {X Y  : LocalizedMonoidal L W Œµ} {X' Y' : C}
    (e‚ÇÅ : (L').obj X' ‚âÖ X) (e‚ÇÇ : (L').obj Y' ‚âÖ Y) : (œÅ_ X).hom ‚ñ∑ _ =
      ((e‚ÇÅ.inv ‚äó Œµ.inv) ‚äó e‚ÇÇ.inv) ‚â´ _ ‚óÅ e‚ÇÇ.hom ‚â´ ((Œº L W Œµ X' (ùüô_ C)).hom ‚â´
        (L').map (œÅ_ X').hom) ‚ñ∑ Y ‚â´ e‚ÇÅ.hom ‚ñ∑ Y := by
  simp only [‚Üê tensorHom_id, ‚Üê id_tensorHom, ‚Üê tensor_comp, assoc, comp_id, id_comp, Iso.inv_hom_id]
  congr
  rw [‚Üê assoc, ‚Üê assoc, ‚Üê Iso.comp_inv_eq, ‚Üê rightUnitor_naturality, rightUnitor_hom_app]
  simp only [‚Üê tensorHom_id, ‚Üê id_tensorHom, ‚Üê tensor_comp_assoc, comp_id, id_comp, assoc]

variable {L W Œµ} in
lemma triangle (X Y : LocalizedMonoidal L W Œµ) :
    (Œ±_ X (ùüô_ _) Y).hom ‚â´ X ‚óÅ (Œª_ Y).hom = (œÅ_ X).hom ‚ñ∑ Y := by
  have : (L').EssSurj := Localization.essSurj L' W
  obtain ‚ü®X', ‚ü®e‚ÇÅ‚ü©‚ü© : ‚àÉ X‚ÇÅ, Nonempty ((L').obj X‚ÇÅ ‚âÖ X) := ‚ü®_, ‚ü®(L').objObjPreimageIso X‚ü©‚ü©
  obtain ‚ü®Y', ‚ü®e‚ÇÇ‚ü©‚ü© : ‚àÉ X‚ÇÇ, Nonempty ((L').obj X‚ÇÇ ‚âÖ Y) := ‚ü®_, ‚ü®(L').objObjPreimageIso Y‚ü©‚ü©
  have := (((Œº L W Œµ _ _).hom ‚äó ùüô _) ‚â´ (Œº L W Œµ _ _).hom) ‚â´=
    ((L').congr_map (MonoidalCategory.triangle X' Y'))
  have ha := (associator_hom_app L W Œµ X' (ùüô_ _) Y' =‚â´
    (ùüô ((L').obj X') ‚äó (Œº L W Œµ (ùüô_ C) Y').hom))
  simp only [assoc, id_tensorHom, ‚Üê whiskerLeft_comp,
    Iso.inv_hom_id, whiskerLeft_id, comp_id] at ha
  simp only [‚Üê assoc] at ha
  rw [Iso.eq_comp_inv] at ha
  simp only [assoc, Functor.map_comp] at this
  rw [‚Üê reassoc_of% ha] at this
  erw [‚Üê triangle_aux _ _ _ e‚ÇÅ.symm Œµ.symm e‚ÇÇ.symm]
  simp only [Iso.symm_hom, Iso.symm_inv, assoc]
  simp only [‚Üê id_tensorHom, ‚Üê tensor_comp, comp_id]
  rw [‚Üê Œº_natural_left, tensorHom_id, ‚Üê whiskerRight_comp_assoc] at this
  rw [‚Üê Œº_natural_right] at this
  rw [‚Üê Iso.comp_inv_eq] at this
  simp only [assoc, Iso.hom_inv_id, comp_id] at this
  have hl := (Œµ' L W Œµ).hom ‚ñ∑ (L').obj Y' ‚â´= leftUnitor_hom_app L W Œµ Y'
  simp only [‚Üê whiskerRight_comp_assoc, Iso.hom_inv_id, whiskerRight_id, id_comp] at hl
  rw [‚Üê whiskerLeft_comp, ‚Üê hl] at this
  have hh := this =‚â´ (_ ‚óÅ e‚ÇÇ.hom)
  simp only [assoc] at hh
  rw [‚Üê whiskerLeft_comp, assoc, ‚Üê leftUnitor_naturality, ‚Üê whisker_exchange] at hh
  have hhh := ((e‚ÇÅ.inv ‚äó Œµ.inv) ‚äó e‚ÇÇ.inv) ‚â´= hh =‚â´ (e‚ÇÅ.hom ‚ñ∑ _)
  simp only [assoc] at hhh
  convert hhh
  ¬∑ exact triangle_aux‚ÇÅ _ _ _ e‚ÇÅ e‚ÇÇ
  ¬∑ exact triangle_aux‚ÇÇ _ _ _ e‚ÇÅ e‚ÇÇ

noncomputable instance :
    MonoidalCategory (LocalizedMonoidal L W Œµ) where
  tensorHom_def := by intros; simp [monoidalCategoryStruct]
  tensor_id := by intros; simp [monoidalCategoryStruct]
  tensor_comp := by intros; simp [monoidalCategoryStruct]
  whiskerLeft_id := by intros; simp [monoidalCategoryStruct]
  id_whiskerRight := by intros; simp [monoidalCategoryStruct]
  associator_naturality {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ} f‚ÇÅ f‚ÇÇ f‚ÇÉ := by apply associator_naturality
  leftUnitor_naturality := by intros; simp [monoidalCategoryStruct]
  rightUnitor_naturality := fun f ‚Ü¶ (rightUnitor L W Œµ).hom.naturality f
  pentagon := pentagon
  triangle := triangle

end Monoidal

end Localization

open Localization.Monoidal

noncomputable def toLocalizedMonoidal :
    MonoidalFunctor C (LocalizedMonoidal L W Œµ) where
  toFunctor := toMonoidalCategory L W Œµ
  Œµ := Œµ.inv
  Œº X Y := (Œº L W Œµ X Y).hom
  associativity X Y Z := by simp [associator_hom_app L W Œµ X Y Z]
  left_unitality Y := leftUnitor_hom_app L W Œµ Y
  right_unitality X := rightUnitor_hom_app L W Œµ X

end CategoryTheory
