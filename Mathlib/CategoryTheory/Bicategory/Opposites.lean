/-
Copyright (c) 2024 Calle S√∂nne. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Calle S√∂nne
-/

import Mathlib.CategoryTheory.Bicategory.Functor.Pseudofunctor
import Mathlib.CategoryTheory.Opposites
import Mathlib.CategoryTheory.Bicategory.Functor.LocallyDiscrete

/-!
# Opposite bicategories

We construct the 1-cell opposite of a bicategory `B`, called `B·¥Æ·µí·µñ`. It is defined as follows
* The objects of `B·¥Æ·µí·µñ` correspond to objects of `B`.
* The morphisms `X ‚ü∂ Y` in `B·¥Æ·µí·µñ` are the morphisms `Y ‚ü∂ X` in `B`.
* The 2-morphisms `f ‚ü∂ g` in `B·¥Æ·µí·µñ` are the 2-morphisms `f ‚ü∂ g` in `B`. In other words, the
  directions of the 2-morphisms are preserved.


# Remarks
There are multiple notions of opposite categories for bicategories.
- There is 1-cell dual `B·¥Æ·µí·µñ` as defined above.
- There is the 2-cell dual, `C·∂ú·µí` where only the natural transformations are reversed
- There is the bi-dual `C·∂ú·µí·µí·µñ` where the directions of both the morphisms and the natural
  transformations are reversed.

## TODO

Provide various lemmas for going between `LocallyDiscrete C·µí·µñ` and `(LocallyDiscrete C)·µí·µñ`.
Expand API (do after I have started using it)

-/

universe w v u

open CategoryTheory Bicategory Opposite


/-- The type of objects of the 1-cell opposite of a bicategory `B` -/
structure Bicategory.Opposite (B : Type u) where
  /-- The object of `B·¥Æ·µí·µñ` that represents `b : B` -/  bop ::
  /-- The object of `B` that represents `b : B·¥Æ·µí·µñ` -/ unbop : B

namespace Bicategory.Opposite

variable {B : Type u}

@[inherit_doc]
notation:max B "·¥Æ·µí·µñ" => Bicategory.Opposite B

theorem bop_injective : Function.Injective (bop : B ‚Üí B·¥Æ·µí·µñ) := fun _ _ => congr_arg Opposite.unbop

theorem unbop_injective : Function.Injective (unbop : B·¥Æ·µí·µñ ‚Üí B) := fun _ _ h => congrArg bop h

theorem bop_inj_iff (x y : B) : bop x = bop y ‚Üî x = y :=
  bop_injective.eq_iff

@[simp]
theorem unbop_inj_iff (x y : B·¥Æ·µí·µñ) : unbop x = unbop y ‚Üî x = y :=
  unbop_injective.eq_iff

@[simp]
theorem bop_unbop (a : B·¥Æ·µí·µñ) : bop (unbop a) = a :=
  rfl

@[simp]
theorem unbop_bop (a : B) : unbop (bop a) = a :=
  rfl

/-- The type-level equivalence between a type and its opposite. -/
def equivToOpposite : B ‚âÉ B·¥Æ·µí·µñ where
  toFun := bop
  invFun := unbop
  left_inv := unop_op -- todo whyyy is this typo OK??
  right_inv := bop_unbop

theorem bop_surjective : Function.Surjective (bop : B ‚Üí B·¥Æ·µí·µñ) := equivToOpposite.surjective

theorem unbop_surjective : Function.Surjective (unbop : B·¥Æ·µí·µñ ‚Üí B) := equivToOpposite.symm.surjective

@[simp]
theorem equivToBopposite_coe : (equivToOpposite : B ‚Üí B·¥Æ·µí·µñ) = bop :=
  rfl

@[simp]
theorem equivToBopposite_symm_coe : (equivToOpposite.symm : B·¥Æ·µí·µñ ‚Üí B) = unbop :=
  rfl

theorem bop_eq_iff_eq_unbop {x : B} {y} : bop x = y ‚Üî x = unbop y :=
  equivToOpposite.apply_eq_iff_eq_symm_apply

theorem unbop_eq_iff_eq_bop {x} {y : B} : unbop x = y ‚Üî x = bop y :=
  equivToOpposite.symm.apply_eq_iff_eq_symm_apply

end Bicategory.Opposite

open Bicategory.Opposite

variable {B : Type u} [Bicategory.{w, v} B]

section

/-- `B·¥Æ·µí·µñ` reverses the 1-morphisms in `B` -/
instance Hom : Quiver B·¥Æ·µí·µñ where
  Hom := fun a b => (unbop b ‚ü∂ unbop a)·¥Æ·µí·µñ

-- TODO: this should be bop1 w no fancy namespace

namespace Quiver.Hom
/-- The opposite of a 1-morphism in `B`. -/
@[simps]
abbrev bop1 {a b : B} (f : a ‚ü∂ b) : bop b ‚ü∂ bop a := Bicategory.Opposite.bop f

/-- Given a 1-morhpism in `B·¥Æ·µí·µñ`, we can take the "unopposite" back in `B`. -/
abbrev unbop1 {a b : B·¥Æ·µí·µñ} (f : a ‚ü∂ b) : unbop b ‚ü∂ unbop a :=
  Bicategory.Opposite.unbop f

theorem bop_inj {a b : B} : Function.Injective (bop1 (B := B) (a := a) (b := b)) :=
  fun _ _ H => congr_arg Quiver.Hom.unbop1 H

theorem unbop_inj {a b : B·¥Æ·µí·µñ} : Function.Injective (unbop1 (B := B) (a := a) (b := b)) :=
  fun _ _ H => congr_arg Quiver.Hom.bop1 H

@[simp]
theorem unbop_bop {X Y : B} (f : X ‚ü∂ Y) : f.bop1.unbop1 = f :=
  rfl

end Quiver.Hom

end

namespace Bicategory.Opposite

/-- `B·¥Æ·µí·µñ` preserves the direction of all 2-morphisms in `B` -/
@[simps]
instance (a b : B·¥Æ·µí·µñ) : Quiver (a ‚ü∂ b) where
  Hom := fun f g => (f.unbop ‚ü∂ g.unbop)·¥Æ·µí·µñ

/-- The 1-cell opposite of a 2-morphism `Œ∑ : f ‚ü∂ g` in `B`. -/
@[simps]
abbrev bop2 {a b : B} {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : f.bop1 ‚ü∂ g.bop1 :=
  bop Œ∑

/-- The 1-cell opposite of a 2-morphism `Œ∑ : f ‚ü∂ g` in `B·¥Æ·µí·µñ`. -/
abbrev unbop2 {a b : B·¥Æ·µí·µñ} {f g : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) : f.unbop ‚ü∂ g.unbop :=
  unbop Œ∑

-- @[simps] here causes a loop!!!!
instance homCategory {a b : B·¥Æ·µí·µñ} : Category.{w} (a ‚ü∂ b) where
  id := fun f => bop2 (ùüô f.unbop)
  comp := fun Œ∑ Œ∏ => bop2 (unbop2 Œ∑ ‚â´ unbop2 Œ∏)
  id_comp := fun {f g} Œ∑ => by simp only [bop_unbop, Category.id_comp (unbop2 Œ∑)]

@[simp]
theorem bop2_comp {a b : B} {f g h : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) (Œ∏ : g ‚ü∂ h) :
    bop2 (Œ∑ ‚â´ Œ∏) = bop2 Œ∑ ‚â´ bop2 Œ∏ :=
  rfl

@[simp]
theorem bop2_id {a b : B} {f : a ‚ü∂ b} : bop2 (ùüô f) = ùüô f.bop1 :=
  rfl

@[simp]
theorem unbop2_comp {a b : B·¥Æ·µí·µñ} {f g h : a ‚ü∂ b} (Œ∑ : f ‚ü∂ g) (Œ∏ : g ‚ü∂ h) :
    unbop2 (Œ∑ ‚â´ Œ∏) = unbop2 Œ∑ ‚â´ unbop2 Œ∏ :=
  rfl

@[simp]
theorem unbop2_id {a b : B·¥Æ·µí·µñ} {f : a ‚ü∂ b} : unbop2 (ùüô f) = ùüô f.unbop :=
  rfl

-- TODO: following two are already OK by simp, so maybe shouldn't be simp lemmas?
@[simp]
theorem unbop2_id_bop {a b : B} {f : a ‚ü∂ b} : unbop2 (ùüô f.bop1) = ùüô f :=
  rfl

@[simp]
theorem bop2_id_unbop {a b : B·¥Æ·µí·µñ} {f : a ‚ü∂ b} : bop2 (ùüô f.unbop) = ùüô f :=
  rfl

/-- The natural functor from the hom-category `a ‚ü∂ b` in `B` to its bicategorical opposite
`bop b ‚ü∂ bop a`. -/
@[simps]
def bopFunctor (a b : B) : (a ‚ü∂ b) ‚•§ (bop b ‚ü∂ bop a) where
  obj f := f.bop1
  map Œ∑ := bop2 Œ∑

/-- The functor from the hom-category `a ‚ü∂ b` in `B·¥Æ·µí·µñ` to its bicategorical opposite
`unbop b ‚ü∂ unbop a`. -/
@[simps]
def unbopFunctor (a b : B·¥Æ·µí·µñ) : (a ‚ü∂ b) ‚•§ (unbop b ‚ü∂ unbop a) where
  obj f := f.unbop
  map Œ∑ := unbop2 Œ∑

end Bicategory.Opposite

-- TODO: namespace here should include bicategory?
namespace CategoryTheory.Iso

open Bicategory.Opposite

/-- A 2-isomorphism in `B` gives a 2-isomorphism in `B·¥Æ·µí·µñ` -/
@[simps!]
abbrev bop2 {a b : B} {f g : a ‚ü∂ b} (Œ∑ : f ‚âÖ g) : f.bop1 ‚âÖ g.bop1 := (bopFunctor a b).mapIso Œ∑

/-- A 2-isomorphism in `B·¥Æ·µí·µñ` gives a 2-isomorphism in `B·¥Æ` -/
@[simps!]
abbrev unbop2 {a b : B·¥Æ·µí·µñ} {f g : a ‚ü∂ b} (Œ∑ : f ‚âÖ g) : f.unbop ‚âÖ g.unbop :=
  (unbopFunctor a b).mapIso Œ∑

@[simp]
theorem unbop2_bop2 {a b : B·¥Æ·µí·µñ} {f g : a ‚ü∂ b} (Œ∑ : f ‚âÖ g) : Œ∑.unbop2.bop2 = Œ∑ := by ext; rfl

@[simp]
theorem unbop2_bop {a b : B·¥Æ·µí·µñ} {f g : a ‚ü∂ b} (Œ∑ : f ‚âÖ g) : Œ∑.unbop2.bop2 = Œ∑ := by ext; rfl

end CategoryTheory.Iso

namespace Bicategory.Opposite

/-- The 1-cell dual bicategory `B·¥Æ·µí·µñ`.

It is defined as follows.
* The objects of `B·¥Æ·µí·µñ` correspond to objects of `B`.
* The morphisms `X ‚ü∂ Y` in `B·¥Æ·µí·µñ` are the morphisms `Y ‚ü∂ X` in `B`.
* The 2-morphisms `f ‚ü∂ g` in `B·¥Æ·µí·µñ` are the 2-morphisms `f ‚ü∂ g` in `B`. In other words, the
  directions of the 2-morphisms are preserved.
-/
@[simps!]
instance bicategory : Bicategory.{w, v} B·¥Æ·µí·µñ where
  id := fun a => (ùüô a.unbop).bop1
  comp := fun f g => (g.unbop1 ‚â´ f.unbop1).bop1
  whiskerLeft f g h Œ∑ := bop2 ((unbop2 Œ∑) ‚ñ∑ f.unbop)
  whiskerRight Œ∑ h := bop2 (h.unbop ‚óÅ (unbop2 Œ∑))
  associator f g h := (associator h.unbop g.unbop f.unbop).symm.bop2
  leftUnitor f := (rightUnitor f.unbop).bop2
  rightUnitor f := (leftUnitor f.unbop).bop2
  whiskerLeft_id f g := unbop_injective <| id_whiskerRight g.unbop f.unbop
  whiskerLeft_comp f g h i Œ∑ Œ∏ := unbop_injective <| comp_whiskerRight (unbop2 Œ∑) (unbop2 Œ∏) f.unbop
  id_whiskerLeft Œ∑ := unbop_injective <| whiskerRight_id (unbop2 Œ∑)
  comp_whiskerLeft {a b c d} f g {h h'} Œ∑ := unbop_injective <|
    whiskerRight_comp (unbop2 Œ∑) g.unbop f.unbop
  id_whiskerRight f g := unbop_injective <| whiskerLeft_id g.unbop f.unbop
  comp_whiskerRight Œ∑ Œ∏ i := unbop_injective <|
    whiskerLeft_comp i.unbop (unbop2 Œ∑) (unbop2 Œ∏)
  whiskerRight_id Œ∑ := unbop_injective <| id_whiskerLeft (unbop2 Œ∑)
  whiskerRight_comp Œ∑ g h := unbop_injective <| comp_whiskerLeft h.unbop g.unbop (unbop2 Œ∑)
  whisker_assoc f g g' Œ∑ i := by apply unbop_injective; dsimp; simp
  whisker_exchange Œ∑ Œ∏ := by apply unbop_injective; dsimp; simp [(whisker_exchange _ _).symm]
  pentagon f g h i := by apply unbop_injective; dsimp; simp
  triangle f g := by apply unbop_injective; dsimp; simp

-- TODO: initialize simps projections here...

end Bicategory.Opposite
