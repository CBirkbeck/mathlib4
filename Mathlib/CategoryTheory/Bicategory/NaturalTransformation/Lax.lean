/-
Copyright (c) 2025 Robin Carlier. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yuma Mizuno, Calle Sรถnne, Robin Carlier
-/
import Mathlib.CategoryTheory.Bicategory.Functor.Lax

/-!
# Transformations between lax functors

Just as there are natural transformations between functors, there are transformations
between lax functors. The equality in the naturality condition of a natural transformation gets
replaced by a specified 2-morphism. Now, there are three possible types of transformations (between
lax functors):
* Lax natural transformations;
* OpLax natural transformations;
* Strong natural transformations.
These differ in the direction (and invertibility) of the 2-morphisms involved in the naturality
condition.

## Main definitions

* `Lax.LaxTrans F G`: lax transformations between lax functors `F` and `G`. The naturality
  condition is given by a 2-morphism `F.map f โซ app b โถ app a โซ G.map f` for each 1-morphism
  `f : a โถ b`.
* `Lax.StrongTrans F G`: Strong transformations between lax functors `F` and `G`.

Using these, we define two `CategoryStruct` (scoped) instances on `LaxFunctor B C`, one in the
`Lax.LaxTrans` namespace and one in the `Lax.StrongTrans` namespace. The arrows in these
CategoryStruct's are given by lax transformations and strong transformations respectively.

We also provide API for going between lax transformations and strong transformations:
* `Lax.StrongCore F G`: a structure on an lax transformation between lax functors that
promotes it to a strong transformation.
* `Lax.mkOfLax ฮท ฮท'`: given an lax transformation `ฮท` such that each component
  2-morphism is an isomorphism, `mkOfLax` gives the corresponding strong transformation.

# TODO
This file could also include oplax transformations between lax functors.

## References
* [Niles Johnson, Donald Yau, *2-Dimensional Categories*](https://arxiv.org/abs/2002.06055),
section 4.2.

-/

namespace CategoryTheory.Lax

open Category Bicategory

universe wโ wโ vโ vโ uโ uโ

variable {B : Type uโ} [Bicategory.{wโ, vโ} B] {C : Type uโ} [Bicategory.{wโ, vโ} C]

/-- If `ฮท` is an lax transformation between `F` and `G`, we have a 1-morphism
`ฮท.app a : F.obj a โถ G.obj a` for each object `a : B`. We also have a 2-morphism
`ฮท.naturality f : app a โซ G.map f โถ F.map f โซ app b` for each 1-morphism `f : a โถ b`.
These 2-morphisms satisfies the naturality condition, and preserve the identities and
the compositions modulo some adjustments of domains and codomains of 2-morphisms.
-/
structure LaxTrans (F G : LaxFunctor B C) where
  /-- The component 1-morphisms of an lax transformation. -/
  app (a : B) : F.obj a โถ G.obj a
  /-- The 2-morphisms underlying the lax naturality constraint. -/
  naturality {a b : B} (f : a โถ b) : app a โซ G.map f โถ F.map f โซ app b
  /-- Naturality of the lax naturality constraint. -/
  naturality_naturality {a b : B} {f g : a โถ b} (ฮท : f โถ g) :
     naturality f โซ F.mapโ ฮท โท app b = app a โ G.mapโ ฮท โซ naturality g := by
    aesop_cat
  /-- Lax unity. -/
  naturality_id (a : B) :
      app a โ G.mapId a โซ naturality (๐ a) =
        (ฯ_ (app a)).hom โซ (ฮป_ (app a)).inv โซ F.mapId a โท app a := by
    aesop_cat
  /-- Lax functoriality. -/
  naturality_comp {a b c : B} (f : a โถ b) (g : b โถ c) :
      app a โ G.mapComp f g โซ naturality (f โซ g) =
      (ฮฑ_ _ _ _).inv โซ naturality f โท G.map g โซ (ฮฑ_ _ _ _).hom โซ
        F.map f โ naturality g โซ (ฮฑ_ _ _ _).inv โซ F.mapComp f g โท app c := by
    aesop_cat

attribute [reassoc (attr := simp)] LaxTrans.naturality_naturality LaxTrans.naturality_id
  LaxTrans.naturality_comp

namespace LaxTrans

variable {F : LaxFunctor B C} {G H : LaxFunctor B C} (ฮท : LaxTrans F G) (ฮธ : LaxTrans G H)

section

variable {a b c : B} {a' : C}

@[reassoc (attr := simp)]
theorem whiskerLeft_naturality_naturality (f : a' โถ G.obj a) {g h : a โถ b} (ฮฒ : g โถ h) :
    f โ ฮธ.naturality g โซ f โ G.mapโ ฮฒ โท ฮธ.app b =
    f โ ฮธ.app a โ H.mapโ ฮฒ โซ f โ ฮธ.naturality h := by
  simp_rw [โ Bicategory.whiskerLeft_comp, naturality_naturality]

@[reassoc (attr := simp)]
theorem whiskerRight_naturality_naturality {f g : a โถ b} (ฮฒ : f โถ g) (h : G.obj b โถ a') :
    ฮท.naturality f โท h โซ F.mapโ ฮฒ โท ฮท.app b โท h =
    (ฮฑ_ _ _ _).hom โซ ฮท.app a โ G.mapโ ฮฒ โท h  โซ (ฮฑ_ _ _ _).inv โซ ฮท.naturality g โท h := by
  rw [โ comp_whiskerRight, naturality_naturality, comp_whiskerRight, whisker_assoc,
    Category.assoc, Category.assoc]

@[reassoc (attr := simp)]
theorem whiskerLeft_naturality_comp (f : a' โถ G.obj a) (g : a โถ b) (h : b โถ c) :
    f โ ฮธ.app a โ H.mapComp g h โซ f โ ฮธ.naturality (g โซ h) =
    f โ (ฮฑ_ _ _ _).inv โซ f โ ฮธ.naturality g โท H.map h โซ f โ (ฮฑ_ _ _ _).hom โซ
      f โ G.map g โ ฮธ.naturality h โซ f โ (ฮฑ_ _ _ _).inv โซ f โ G.mapComp g h โท ฮธ.app c := by
  simp_rw [โ Bicategory.whiskerLeft_comp, naturality_comp]

@[reassoc (attr := simp)]
theorem whiskerRight_naturality_comp (f : a โถ b) (g : b โถ c) (h : G.obj c โถ a') :
    (ฮฑ_ _ _ _).hom โซ ฮท.app a โ G.mapComp f g โท h โซ (ฮฑ_ _ _ _).inv โซ
      ฮท.naturality (f โซ g) โท h =
    (ฮฑ_ _ _ _).inv โท h โซ
      ฮท.naturality f โท G.map g โท h โซ
      (ฮฑ_ _ _ _).hom โท h โซ (ฮฑ_ _ _ _).hom โซ
      F.map f โ ฮท.naturality g โท h โซ (ฮฑ_ _ _ _).inv โซ
      (ฮฑ_ _ _ _).inv โท h โซ F.mapComp f g โท ฮท.app c โท h := by
  simpa [-naturality_comp] using congr_arg (fun t โฆ t โท h) <| naturality_comp _ _ _

@[reassoc (attr := simp)]
theorem whiskerLeft_naturality_id (f : a' โถ G.obj a) :
    f โ ฮธ.app a โ H.mapId a โซ f โ ฮธ.naturality (๐ a) =
    (ฮฑ_ _ _ _).inv โซ (ฯ_ (f โซ ฮธ.app a)).hom โซ f โ (ฮป_ (ฮธ.app a)).inv โซ
      f โ G.mapId a โท ฮธ.app a := by
  simpa [-naturality_id] using congr_arg (fun t โฆ f โ t) <| naturality_id _ _

@[reassoc (attr := simp)]
theorem whiskerRight_naturality_id (f : G.obj a โถ a') :
    (ฮฑ_ _ _ _).hom โซ ฮท.app a โ G.mapId a โท f โซ (ฮฑ_ _ _ _).inv โซ ฮท.naturality (๐ a) โท f =
    (ฯ_ (ฮท.app a)).hom โท f โซ (ฮป_ (ฮท.app a โซ f)).inv โซ (ฮฑ_ _ _ _).inv โซ F.mapId a โท ฮท.app a โท f := by
  simpa [-naturality_id] using congr_arg (fun t โฆ t โท f) <| naturality_id _ _

end

variable (F) in
/-- The identity lax transformation. -/
def id : LaxTrans F F where
  app a := ๐ (F.obj a)
  naturality {_ _} f := (ฮป_ (F.map f)).hom โซ (ฯ_ (F.map f)).inv

instance : Inhabited (LaxTrans F F) :=
  โจid Fโฉ

/-- Vertical composition of lax transformations. -/
@[simps]
def vcomp : LaxTrans F H where
  app a := ฮท.app a โซ ฮธ.app a
  naturality {a b} f :=
    (ฮฑ_ _ _ _).hom โซ ฮท.app a โ (ฮธ.naturality f) โซ (ฮฑ_ _ _ _).inv โซ
      ฮท.naturality f โท ฮธ.app b โซ (ฮฑ_ _ _ _).hom
  naturality_comp {a b c} f g := by
    calc
      _ = (ฮฑ_ _ _ _).hom โซ _ โ (ฮฑ_ _ _ _).inv  โซ
            ฮท.app a โ ฮธ.naturality f โท H.map g โซ
            _ โ (ฮฑ_ _ _ _).hom โซ (ฮฑ_ _ _ _).inv โซ
            ฮท.naturality f โท (ฮธ.app b โซ H.map g) โซ
            (F.map f โซ ฮท.app b) โ ฮธ.naturality g โซ
            (ฮฑ_ _ _ _).hom โซ F.map f โ (ฮฑ_ _ _ _).inv โซ
            F.map f โ ฮท.naturality g โท ฮธ.app c โซ
            (ฮฑ_ _ _ _).inv โซ (ฮฑ_ _ _ _).inv โท _ โซ
            F.mapComp f g โท ฮท.app c โท ฮธ.app c โซ (ฮฑ_ _ _ _).hom := by
        rw [โ whisker_exchange_assoc]
        simp only [โ whisker_exchange_assoc, comp_whiskerLeft, assoc, Iso.inv_hom_id_assoc,
          whiskerLeft_naturality_comp_assoc, Bicategory.whiskerRight_comp,
          pentagon_hom_hom_inv_hom_hom_assoc, Iso.cancel_iso_hom_left,
          associator_inv_naturality_middle_assoc]
        simp
      _ = _ := by simp
  naturality_id x := by
    simp only [comp_whiskerLeft, assoc, Iso.inv_hom_id_assoc, whiskerLeft_naturality_id_assoc,
      Iso.hom_inv_id_assoc, Bicategory.whiskerRight_comp, Iso.cancel_iso_hom_left,
      associator_inv_naturality_middle_assoc]
    simp

/-- `CategoryStruct` on `LaxFunctor B C` where the (1-)morphisms are given by lax
transformations. -/
@[simps! id_app id_naturality comp_app comp_naturality]
scoped instance : CategoryStruct (LaxFunctor B C) where
  Hom := LaxTrans
  id := LaxTrans.id
  comp := LaxTrans.vcomp

end LaxTrans

/-- A strong natural transformation between lax functors `F` and `G` is a natural transformation
that is "natural up to 2-isomorphisms".

More precisely, it consists of the following:
* a 1-morphism `ฮท.app a : F.obj a โถ G.obj a` for each object `a : B`.
* a 2-isomorphism `ฮท.naturality f : F.map f โซ app b โถ app a โซ G.map f` for each 1-morphism
`f : a โถ b`.
* These 2-isomorphisms satisfy the naturality condition, and preserve the identities and the
  compositions modulo some adjustments of domains and codomains of 2-morphisms.
-/
structure StrongTrans (F G : LaxFunctor B C) where
  app (a : B) : F.obj a โถ G.obj a
  naturality {a b : B} (f : a โถ b) : app a โซ G.map f โ F.map f โซ app b
  naturality_naturality {a b : B} {f g : a โถ b} (ฮท : f โถ g) :
     (naturality f).hom โซ F.mapโ ฮท โท app b = app a โ G.mapโ ฮท โซ (naturality g).hom := by
    aesop_cat
  /-- Lax unity. -/
  naturality_id (a : B) :
      app a โ G.mapId a โซ (naturality (๐ a)).hom =
        (ฯ_ (app a)).hom โซ (ฮป_ (app a)).inv โซ F.mapId a โท app a := by
    aesop_cat
  /-- Lax functoriality. -/
  naturality_comp {a b c : B} (f : a โถ b) (g : b โถ c) :
      app a โ G.mapComp f g โซ (naturality (f โซ g)).hom =
      (ฮฑ_ _ _ _).inv โซ (naturality f).hom โท G.map g โซ (ฮฑ_ _ _ _).hom โซ
        F.map f โ (naturality g).hom โซ (ฮฑ_ _ _ _).inv โซ F.mapComp f g โท app c := by
    aesop_cat

attribute [nolint docBlame] CategoryTheory.Lax.StrongTrans.app
  CategoryTheory.Lax.StrongTrans.naturality

attribute [reassoc (attr := simp)] StrongTrans.naturality_naturality
  StrongTrans.naturality_id StrongTrans.naturality_comp

/-- A structure on an lax transformation that promotes it to a strong transformation.

See `Pseudofunctor.StrongTrans.mkOfLax`. -/
structure LaxTrans.StrongCore {F G : LaxFunctor B C} (ฮท : F โถ G) where
  /-- The underlying 2-isomorphisms of the naturality constraint. -/
  naturality {a b : B} (f : a โถ b) : ฮท.app a โซ G.map f โ F.map f โซ ฮท.app b
  /-- The 2-isomorphisms agree with the underlying 2-morphism of the lax transformation. -/
  naturality_hom {a b : B} (f : a โถ b) : (naturality f).hom = ฮท.naturality f := by aesop_cat

attribute [simp] LaxTrans.StrongCore.naturality_hom

namespace StrongTrans

/-- The underlying lax natural transformation of a strong natural transformation. -/
@[simps]
def toLax {F G : LaxFunctor B C} (ฮท : StrongTrans F G) : LaxTrans F G where
  app := ฮท.app
  naturality f := (ฮท.naturality f).hom

/-- Construct a strong natural transformation from an lax natural transformation whose
naturality 2-morphism is an isomorphism. -/
def mkOfLax {F G : LaxFunctor B C} (ฮท : LaxTrans F G) (ฮท' : LaxTrans.StrongCore ฮท) :
    StrongTrans F G where
  app := ฮท.app
  naturality := ฮท'.naturality

/-- Construct a strong natural transformation from an lax natural transformation whose
naturality 2-morphism is an isomorphism. -/
noncomputable def mkOfLax' {F G : LaxFunctor B C} (ฮท : LaxTrans F G)
    [โ a b (f : a โถ b), IsIso (ฮท.naturality f)] : StrongTrans F G where
  app := ฮท.app
  naturality _ := asIso (ฮท.naturality _)

variable (F : LaxFunctor B C)


/-- The identity strong natural transformation. -/
@[simps!]
def id : StrongTrans F F :=
  mkOfLax (LaxTrans.id F) { naturality := fun f โฆ (ฮป_ (F.map f)) โชโซ (ฯ_ (F.map f)).symm }

@[simp]
lemma id.toLax : (id F).toLax = LaxTrans.id F :=
  rfl

instance : Inhabited (StrongTrans F F) :=
  โจid Fโฉ


variable {F} {G H : LaxFunctor B C} (ฮท : StrongTrans F G) (ฮธ : StrongTrans G H)

/-- Vertical composition of strong natural transformations. -/
@[simps!]
def vcomp : StrongTrans F H :=
  mkOfLax (LaxTrans.vcomp ฮท.toLax ฮธ.toLax)
    { naturality := fun {a b} f โฆ
        (ฮฑ_ _ _ _) โชโซ whiskerLeftIso (ฮท.app a) (ฮธ.naturality f) โชโซ (ฮฑ_ _ _ _).symm โชโซ
        whiskerRightIso (ฮท.naturality f) (ฮธ.app b) โชโซ (ฮฑ_ _ _ _) }

/-- `CategoryStruct` on `LaxFunctor B C` where the (1-)morphisms are given by strong
transformations. -/
@[simps! id_app id_naturality comp_app comp_naturality]
scoped instance LaxFunctor.instCategoryStruct : CategoryStruct (LaxFunctor B C) where
  Hom := StrongTrans
  id := StrongTrans.id
  comp := StrongTrans.vcomp

section

variable {a b c : B} {a' : C}

@[reassoc (attr := simp), to_app]
theorem whiskerLeft_naturality_naturality (f : a' โถ G.obj a) {g h : a โถ b} (ฮฒ : g โถ h) :
    f โ (ฮธ.naturality g).hom โซ f โ G.mapโ ฮฒ โท ฮธ.app b =
    f โ ฮธ.app a โ H.mapโ ฮฒ โซ f โ (ฮธ.naturality h).hom := by
  apply ฮธ.toLax.whiskerLeft_naturality_naturality

@[reassoc (attr := simp), to_app]
theorem whiskerRight_naturality_naturality {f g : a โถ b} (ฮฒ : f โถ g) (h : G.obj b โถ a') :
    (ฮท.naturality f).hom โท h โซ F.mapโ ฮฒ โท ฮท.app b โท h =
    (ฮฑ_ _ _ _).hom โซ ฮท.app a โ G.mapโ ฮฒ โท h  โซ (ฮฑ_ _ _ _).inv โซ (ฮท.naturality g).hom โท h :=
  ฮท.toLax.whiskerRight_naturality_naturality _ _

@[reassoc (attr := simp), to_app]
theorem whiskerLeft_naturality_comp (f : a' โถ G.obj a) (g : a โถ b) (h : b โถ c) :
    f โ ฮธ.app a โ H.mapComp g h โซ f โ (ฮธ.naturality (g โซ h)).hom =
    f โ (ฮฑ_ _ _ _).inv โซ f โ (ฮธ.naturality g).hom โท H.map h โซ f โ (ฮฑ_ _ _ _).hom โซ
      f โ G.map g โ (ฮธ.naturality h).hom โซ f โ (ฮฑ_ _ _ _).inv โซ f โ G.mapComp g h โท ฮธ.app c  :=
  ฮธ.toLax.whiskerLeft_naturality_comp _ _ _

@[reassoc (attr := simp), to_app]
theorem whiskerRight_naturality_comp (f : a โถ b) (g : b โถ c) (h : G.obj c โถ a') :
    (ฮฑ_ _ _ _).hom โซ ฮท.app a โ G.mapComp f g โท h โซ (ฮฑ_ _ _ _).inv โซ
      (ฮท.naturality (f โซ g)).hom โท h =
    (ฮฑ_ _ _ _).inv โท h โซ
      (ฮท.naturality f).hom โท G.map g โท h โซ
      (ฮฑ_ _ _ _).hom โท h โซ (ฮฑ_ _ _ _).hom โซ
      F.map f โ (ฮท.naturality g).hom โท h โซ (ฮฑ_ _ _ _).inv โซ
      (ฮฑ_ _ _ _).inv โท h โซ F.mapComp f g โท ฮท.app c โท h :=
  ฮท.toLax.whiskerRight_naturality_comp _ _ _

@[reassoc (attr := simp), to_app]
theorem whiskerLeft_naturality_id (f : a' โถ G.obj a) :
    f โ ฮธ.app a โ H.mapId a โซ f โ (ฮธ.naturality (๐ a)).hom =
    (ฮฑ_ _ _ _).inv โซ (ฯ_ (f โซ ฮธ.app a)).hom โซ f โ (ฮป_ (ฮธ.app a)).inv โซ
      f โ G.mapId a โท ฮธ.app a :=
  ฮธ.toLax.whiskerLeft_naturality_id _

@[reassoc (attr := simp), to_app]
theorem whiskerRight_naturality_id (f : G.obj a โถ a') :
    (ฮฑ_ _ _ _).hom โซ ฮท.app a โ G.mapId a โท f โซ (ฮฑ_ _ _ _).inv โซ (ฮท.naturality (๐ a)).hom โท f =
    (ฯ_ (ฮท.app a)).hom โท f โซ (ฮป_ (ฮท.app a โซ f)).inv โซ (ฮฑ_ _ _ _).inv โซ F.mapId a โท ฮท.app a โท f :=
  ฮท.toLax.whiskerRight_naturality_id _

end

end StrongTrans

end CategoryTheory.Lax
