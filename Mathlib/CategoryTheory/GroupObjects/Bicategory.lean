import Mathlib.CategoryTheory.GroupObjects.PreservesFiniteProducts
import Mathlib.CategoryTheory.GroupObjects.StupidLemmas
import Mathlib.CategoryTheory.Limits.Preserves.Finite
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts
import Mathlib.CategoryTheory.Bicategory.Functor

open CategoryTheory Limits

noncomputable section

universe v u

namespace FullSubcategory

variable {C : Type u} [Category.{v,u} C] (P : C ‚Üí Prop) {X Y : FullSubcategory P} (f : X.1 ‚âÖ Y.1)

@[simp]
def isoOfAmbientIso : X ‚âÖ Y :=
  {hom := f.hom, inv := f.inv, hom_inv_id := f.hom_inv_id, inv_hom_id := f.inv_hom_id}

end FullSubcategory

namespace CategoryTheory.Bicategory

variable (C : Type*) [Category C] (P : C ‚Üí Prop) (X Y : C) (f : X ‚âÖ Y) (hX : P X) (hY : P Y)

example : (‚ü®X, hX‚ü© : FullSubcategory P) ‚âÖ ‚ü®Y, hY‚ü© := by
  refine {hom := f.hom, inv := f.inv, hom_inv_id := ?_, inv_hom_id := ?_}
  exact f.hom_inv_id
  exact f.inv_hom_id

instance CatBicat : Bicategory Cat.{v,u} where
  whiskerLeft := whiskerLeft
  whiskerRight := whiskerRight
  associator := Functor.associator
  leftUnitor := leftUnitor
  rightUnitor := rightUnitor
  whiskerLeft_id := whiskerLeft_id
  whiskerLeft_comp := whiskerLeft_comp
  id_whiskerLeft := id_whiskerLeft
  comp_whiskerLeft := comp_whiskerLeft
  id_whiskerRight := id_whiskerRight
  comp_whiskerRight := comp_whiskerRight
  whiskerRight_id := whiskerRight_id
  whiskerRight_comp := whiskerRight_comp
  whisker_assoc := by
    intro A B C D F G G' Œ± H
    simp only [whisker_assoc, Strict.associator_eqToIso, eqToIso_refl, Iso.refl_hom, Iso.refl_inv,
      Category.id_comp]
    change (_ : F ‚ãô G ‚ãô H ‚ü∂ (F ‚ãô G') ‚ãô H) = _
    ext
    simp only [Cat.comp_obj]
    rw [NatTrans.comp_app, NatTrans.id_app]; erw [Category.comp_id, whiskerRight_app]
    rw [NatTrans.comp_app, NatTrans.comp_app]; erw [whiskerRight_app];
    rw [Functor.associator_hom_app, Functor.associator_inv_app]
    erw [Category.id_comp, Category.comp_id]
  whisker_exchange := by
    intro C D E F F' G G' Œ± Œ≤
    simp only
    change (_ : F ‚ãô G ‚ü∂ F' ‚ãô G') = _
    ext
    simp only [Functor.comp_obj, NatTrans.comp_app, Cat.comp_obj]
    erw [NatTrans.comp_app, NatTrans.comp_app, whiskerLeft_app, whiskerRight_app,
      whiskerRight_app, whiskerLeft_app F' Œ≤]
    simp only [Functor.comp_obj, Cat.comp_obj, NatTrans.naturality]
  pentagon := Functor.pentagon

  instance CatFiniteProducts : Bicategory {C : Cat.{v,u} // HasFiniteProducts C} where
  Hom C D := FullSubcategory (fun (F : C ‚•§ D) ‚Ü¶ Nonempty (PreservesFiniteProducts F))
  id C := ‚ü®Functor.id C.1, Nonempty.intro inferInstance‚ü©
  comp F G := ‚ü®F.1 ‚ãô G.1, Nonempty.intro (@Limits.compPreservesFiniteProducts _ _ _ _
      _ _ F.1 G.1 (Classical.choice F.2) (Classical.choice G.2))‚ü©
  homCategory C D := FullSubcategory.category (fun F ‚Ü¶ Nonempty (PreservesFiniteProducts F))
  whiskerLeft := by
    intro C D E F G H Œ±
    exact CategoryTheory.whiskerLeft F.1 (Œ± : G.1 ‚ü∂ H.1)
  whiskerRight Œ± H := CategoryTheory.whiskerRight Œ± H.1
  associator F G H := FullSubcategory.isoOfAmbientIso _ (Functor.associator F.1 G.1 H.1)
  leftUnitor F := FullSubcategory.isoOfAmbientIso _ (Functor.leftUnitor F.1)
  rightUnitor F := FullSubcategory.isoOfAmbientIso _ (Functor.rightUnitor F.1)
  whiskerLeft_id := by
    intro C D E F G
    change CategoryTheory.whiskerLeft F.1 (NatTrans.id G.1) = _
    rw [CategoryTheory.whiskerLeft_id F.1 (G := G.1)]
    rfl
  whiskerLeft_comp := by
    intro C D E F G‚ÇÅ G‚ÇÇ G‚ÇÉ Œ± Œ≤
    exact CategoryTheory.whiskerLeft_comp F.1 Œ± Œ≤
  id_whiskerLeft := by
    intro C D F G Œ±
    simp only [FullSubcategory.isoOfAmbientIso]
    change (_ : ùü≠ ‚Üë‚ÜëC ‚ãô F.obj ‚ü∂ ùü≠ ‚Üë‚ÜëC ‚ãô G.obj) = _
    ext
    simp only [Functor.comp_obj, Functor.id_obj, whiskerLeft_app]
    erw [NatTrans.comp_app, NatTrans.comp_app]
    rw [Functor.leftUnitor_hom_app, Functor.leftUnitor_inv_app, Category.comp_id]
    erw [Category.id_comp]
  comp_whiskerLeft := by
    intro A B C D F G H H' Œ±
    simp only [FullSubcategory.isoOfAmbientIso, whiskerLeft_twice]
    change (_ : (F.1 ‚ãô G.1) ‚ãô H.1 ‚ü∂ (F.1 ‚ãô G.1) ‚ãô H'.1) = _
    ext
    simp only [Functor.comp_obj, whiskerLeft_app]
    erw [NatTrans.comp_app, NatTrans.comp_app]
    rw [Functor.associator_hom_app, Functor.associator_inv_app]
    rw [Category.comp_id, Category.id_comp]
    simp only [whiskerLeft_app, Functor.comp_obj]
  id_whiskerRight := by
    intro C D E F G
    exact CategoryTheory.whiskerRight_id' G.1 (G := F.1)
  comp_whiskerRight := by
    intro C D E F G H Œ± Œ≤ Œ≥
    change (_ : F.obj ‚ãô Œ≥.obj ‚ü∂ H.obj ‚ãô Œ≥.obj) = _
    ext
    simp only [Functor.comp_obj, whiskerRight_app]
    erw [NatTrans.comp_app, NatTrans.comp_app]
    rw [whiskerRight_app, whiskerRight_app]
    simp only [Functor.map_comp, Functor.comp_obj]
  whiskerRight_id := by
    intro C D F G Œ±
    simp only [FullSubcategory.isoOfAmbientIso]
    change (_ : F.obj ‚ãô ùü≠ ‚Üë‚ÜëD ‚ü∂ G.obj ‚ãô ùü≠ ‚Üë‚ÜëD) = _
    ext
    simp only [Functor.comp_obj, Functor.id_obj, whiskerRight_app, Functor.id_map]
    erw [NatTrans.comp_app, NatTrans.comp_app]
    rw [Functor.rightUnitor_hom_app, Functor.rightUnitor_inv_app, Category.comp_id]
    erw [Category.id_comp]
  whiskerRight_comp := by
    intro A B C D F F' Œ± G H
    simp only [FullSubcategory.isoOfAmbientIso, whiskerRight_twice]
    change (_ : F.1 ‚ãô G.1 ‚ãô H.1 ‚ü∂ F'.1 ‚ãô G.1 ‚ãô H.1) = _
    ext
    simp only [Functor.comp_obj, whiskerRight_app, Functor.comp_map]
    repeat (erw [NatTrans.comp_app])
    rw [whiskerRight_app, Functor.associator_hom_app, Functor.associator_inv_app]
    rw [Category.comp_id, Category.id_comp]
    simp only [Functor.comp_map]
  whisker_assoc := by
    intro A B C D F G G' Œ± H
    simp only [FullSubcategory.isoOfAmbientIso]
    change (_ : (F.1 ‚ãô G.1) ‚ãô H.1 ‚ü∂ (F.1 ‚ãô G'.1) ‚ãô H.1) = _
    ext
    simp only [Functor.comp_obj, whiskerRight_app, whiskerLeft_app]
    repeat (erw [NatTrans.comp_app])
    rw [Functor.associator_hom_app, Functor.associator_inv_app, Category.comp_id,
      Category.id_comp]
    simp only [whiskerLeft_app, whiskerRight_app]
  whisker_exchange := by
    intro C D E F F' G G' Œ± Œ≤
    change (_ : F.1 ‚ãô G.1 ‚ü∂ F'.1 ‚ãô G'.1) = _
    ext
    simp only [Functor.comp_obj]
    repeat (erw [NatTrans.comp_app])
    rw [whiskerLeft_app, whiskerRight_app, whiskerRight_app, whiskerLeft_app]
    simp only [Functor.comp_obj, NatTrans.naturality]
  pentagon := by
    intro C‚ÇÅ C‚ÇÇ C‚ÇÉ C‚ÇÑ C‚ÇÖ F G H I
    simp only [FullSubcategory.isoOfAmbientIso]
    change (_ : ((F.1 ‚ãô G.1) ‚ãô H.1) ‚ãô I.1 ‚ü∂ F.1 ‚ãô G.1 ‚ãô H.1 ‚ãô I.1) = _
    exact Functor.pentagon F.1 G.1 H.1 I.1
  triangle := by
    intro C D E F G
    simp only [FullSubcategory.isoOfAmbientIso]
    change (_ : (F.1 ‚ãô ùü≠ _) ‚ãô G.1 ‚ü∂ F.1 ‚ãô G.1) = _
    exact Functor.triangle F.1 G.1

end CategoryTheory.Bicategory

namespace CategoryTheory.GroupObject
open Bicategory

@[simp]
def oplaxFunctor_map {C D : {C : Cat.{v, u} // HasFiniteProducts C}} (F : C ‚ü∂ D) :
    Cat.of (@GroupObject C.1 _ C.2) ‚ü∂ Cat.of (@GroupObject D.1 _ D.2) :=
  @Functor.mapGroupObject C.1 _ D.1 _ C.2 D.2 F.1 (Classical.choice F.2)

@[simp]
def opLaxFunctor_mapId (C : {C : Cat.{v, u} // HasFiniteProducts C}) :
    @Functor.mapGroupObject C.1 _ C.1 _ C.2 C.2 (ùüô C : C ‚ü∂ C).1 (Classical.choice (ùüô C : C ‚ü∂ C).2)
    ‚ü∂ CategoryTheory.CategoryStruct.id (Cat.of (@GroupObject C.1 _ C.2)) := by
    have := C.2
    change (_ : GroupObject C.1 ‚•§ GroupObject C.1) ‚ü∂ _
    refine {app := ?_, naturality := ?_}
    ¬∑ intro X
      refine {hom := ùüô X.X, one_hom := ?_, mul_hom := ?_, inv_hom := ?_}
      ¬∑ simp only [Functor.mapGroupObject_obj, Functor.mapGroupObjectObj_X,
        Functor.mapGroupObjectObj_one, PreservesTerminal.iso_inv, Category.assoc,
        IsIso.inv_comp_eq]
        erw [Category.comp_id]
        have : X.one = ùüô _ ‚â´ X.one := by simp only [Category.id_comp]
        change X.one = _ ‚â´ X.one ; rw [this]; congr 1
        exact Subsingleton.elim _ _
      ¬∑ simp only [Functor.mapGroupObject_obj, Functor.mapGroupObjectObj_X,
        Functor.mapGroupObjectObj_mul, PreservesLimitPair.iso_inv, Category.assoc,
        IsIso.inv_comp_eq]
        erw [Category.comp_id]; rw [‚Üê Category.assoc]
        have : X.mul = ùüô _ ‚â´ X.mul := by simp only [Category.id_comp]
        change X.mul = _ ‚â´ X.mul;
        rw [this]; congr 1; erw [‚Üê prodComparison_natural]; rw [Limits.prod.map_id_id]
        erw [Category.id_comp]
        ext
        ¬∑ erw [prodComparison_fst]; rw [Category.id_comp]; rfl
        ¬∑ erw [prodComparison_snd]; rw [Category.id_comp]; rfl
      ¬∑ simp only [Functor.mapGroupObject_obj, Functor.mapGroupObjectObj_X,
        Functor.mapGroupObjectObj_inv]
        erw [Category.comp_id, Category.id_comp]
        rfl
    ¬∑ intro X Y f
      ext
      simp only [Functor.mapGroupObject_obj, Functor.mapGroupObjectObj_X,
        Functor.mapGroupObject_map, GroupObject.comp_hom', Functor.mapGroupObjectMap_hom,
        Cat.id_map]
      erw [Category.comp_id, Category.id_comp]; rfl

@[simp]
def opLaxFunctor_mapComp {C D E : {C : Cat.{v, u} // HasFiniteProducts C}} (F : C ‚ü∂ D)
    (G : D ‚ü∂ E) : oplaxFunctor_map (F ‚â´ G) ‚ü∂ oplaxFunctor_map F ‚â´ oplaxFunctor_map G := by
    have := C.2; have := D.2; have := E.2
    refine {app := ?_, naturality := ?_}
    ¬∑ intro X
      refine {hom := ùüô _, one_hom := ?_, mul_hom := ?_, inv_hom := ?_}
      ¬∑ simp only [oplaxFunctor_map, Cat.comp_obj, Functor.mapGroupObject_obj,
        Functor.mapGroupObjectObj_X, Functor.mapGroupObjectObj_one, PreservesTerminal.iso_inv,
        Category.comp_id, Functor.map_comp, Functor.map_inv]
        rw [‚Üê Category.assoc]; congr 1
        simp only [IsIso.eq_comp_inv, IsIso.inv_comp_eq]
        exact Subsingleton.elim _ _
      ¬∑ simp only [oplaxFunctor_map, Functor.mapGroupObject_obj, Functor.mapGroupObjectObj_X,
        Cat.comp_obj, Functor.mapGroupObjectObj_mul, PreservesLimitPair.iso_inv, Category.comp_id,
        prod.map_id_id, Functor.map_comp, Functor.map_inv, Category.id_comp]
        rw [‚Üê Category.assoc]; congr 1
        simp only [IsIso.eq_comp_inv, IsIso.inv_comp_eq]
        ext
        ¬∑ rw [prodComparison_fst, Category.assoc]; erw [prodComparison_fst]
          rw [‚Üê Functor.map_comp, prodComparison_fst]
          rfl
        ¬∑ rw [prodComparison_snd, Category.assoc]; erw [prodComparison_snd]
          rw [‚Üê Functor.map_comp, prodComparison_snd]
          rfl
      ¬∑ simp only [id_eq, Functor.mapGroupObject_obj, Functor.mapGroupObjectObj_X, Cat.comp_obj,
        Functor.mapGroupObjectObj_inv, Category.comp_id, Category.id_comp]
        rfl
    ¬∑ intro X Y f
      simp only [oplaxFunctor_map, Functor.mapGroupObject_obj, Cat.comp_obj,
        Functor.mapGroupObject_map, Functor.mapGroupObjectObj_X, Cat.comp_map]
      simp only [Functor.mapGroupObjectMap, oplaxFunctor_map, Functor.mapGroupObject_obj,
        Cat.comp_obj, Functor.mapGroupObjectObj_X]
      change GroupObject.comp _ _ = GroupObject.comp _ _
      ext
      simp only [Functor.mapGroupObjectObj_X, oplaxFunctor_map, Functor.mapGroupObject_obj,
        Cat.comp_obj, GroupObject.comp_hom, Category.comp_id, Category.id_comp]
      rfl

@[simp]
def oplaxFunctor_map‚ÇÇ {C D : {C : Cat.{v, u} // HasFiniteProducts C}} {F G : C ‚ü∂ D}
    (Œ± : F ‚ü∂ G) : oplaxFunctor_map F ‚ü∂ oplaxFunctor_map G :=
  @Functor.mapGroupObject_natTrans C.1 _ D.1 _ C.2 D.2 F.1 G.1 (Classical.choice F.2)
      (Classical.choice G.2) Œ±

lemma opLaxFunctor_mapComp_naturality_left {C D E : {C : Cat.{v, u} // HasFiniteProducts C}}
    {F F' : C ‚ü∂ D} (Œ± : F ‚ü∂ F') (G : D ‚ü∂ E) :
    oplaxFunctor_map‚ÇÇ (Bicategory.whiskerRight Œ± G) ‚â´ opLaxFunctor_mapComp F' G =
    opLaxFunctor_mapComp F G ‚â´ Bicategory.whiskerRight (oplaxFunctor_map‚ÇÇ Œ±)
    (oplaxFunctor_map G) := by
  have := E.2
  simp only [oplaxFunctor_map, oplaxFunctor_map‚ÇÇ, opLaxFunctor_mapComp, Functor.mapGroupObject_obj,
    Cat.comp_obj, Functor.mapGroupObjectObj_X]
  simp only [Functor.mapGroupObject, Functor.mapGroupObject_natTrans, id_eq, oplaxFunctor_map,
    Cat.comp_obj]
  change _ = _ ‚â´ CategoryTheory.whiskerRight _ _
  ext
  simp only [Functor.mapGroupObjectObj_X, Cat.comp_obj, oplaxFunctor_map,
    Functor.mapGroupObject_obj, NatTrans.comp_app, Functor.comp_obj, whiskerRight_app,
    GroupObject.comp_hom', Functor.mapGroupObjectMap_hom, Category.id_comp]
  erw [NatTrans.comp_app]; simp only [Cat.comp_obj, oplaxFunctor_map, Functor.mapGroupObject_obj,
    GroupObject.comp_hom', Functor.mapGroupObjectObj_X, Category.comp_id]
  erw [whiskerRight_app]

lemma opLaxFunctor_mapComp_naturality_right {C D E : {C : Cat.{v, u} // HasFiniteProducts C}}
    (F : C ‚ü∂ D) {G G' : D ‚ü∂ E} (Œ± : G ‚ü∂ G') :
    oplaxFunctor_map‚ÇÇ (Bicategory.whiskerLeft F Œ±) ‚â´ opLaxFunctor_mapComp F G' =
    opLaxFunctor_mapComp F G ‚â´ Bicategory.whiskerLeft (oplaxFunctor_map F) (oplaxFunctor_map‚ÇÇ Œ±)
    := by
  have := E.2
  simp only [oplaxFunctor_map, oplaxFunctor_map‚ÇÇ, opLaxFunctor_mapComp, Functor.mapGroupObject_obj,
    Cat.comp_obj, Functor.mapGroupObjectObj_X]
  simp only [Functor.mapGroupObject, Functor.mapGroupObject_natTrans, id_eq, oplaxFunctor_map,
    Cat.comp_obj]
  change _ = _ ‚â´ CategoryTheory.whiskerLeft _ _
  ext
  simp only [Functor.mapGroupObjectObj_X, Cat.comp_obj, oplaxFunctor_map,
    Functor.mapGroupObject_obj, NatTrans.comp_app, Functor.comp_obj, whiskerLeft_app,
    GroupObject.comp_hom', Category.id_comp]
  erw [NatTrans.comp_app]; simp only [Cat.comp_obj, oplaxFunctor_map, Functor.mapGroupObject_obj,
    GroupObject.comp_hom', Functor.mapGroupObjectObj_X, Category.comp_id]
  erw [whiskerLeft_app]

lemma oplaxFunctor_map‚ÇÇ_id {C D : {C : Cat.{v, u} // HasFiniteProducts C}} (F : C ‚ü∂ D) :
    oplaxFunctor_map‚ÇÇ (ùüô F) = ùüô (oplaxFunctor_map F) := by
    simp only [oplaxFunctor_map, Functor.mapGroupObject, oplaxFunctor_map‚ÇÇ,
      Functor.mapGroupObject_natTrans, id_eq]
    change _ = NatTrans.id _
    ext
    simp only [Functor.mapGroupObject_obj, Functor.mapGroupObjectObj_X, NatTrans.id_app',
      GroupObject.id_hom']
    rfl

lemma oplaxFunctor_map‚ÇÇ_comp {C D : {C : Cat.{v, u} // HasFiniteProducts C}} {F G H : C ‚ü∂ D}
    (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) :
    oplaxFunctor_map‚ÇÇ (Œ± ‚â´ Œ≤) = oplaxFunctor_map‚ÇÇ Œ± ‚â´ oplaxFunctor_map‚ÇÇ Œ≤ := by
  have := D.2
  simp only [oplaxFunctor_map, oplaxFunctor_map‚ÇÇ, Functor.mapGroupObject_natTrans,
    Functor.mapGroupObject_obj, id_eq]
  change _ = (_ : NatTrans _ _)
  ext
  simp only [Functor.mapGroupObject_obj, Functor.mapGroupObjectObj_X]
  erw [NatTrans.comp_app, NatTrans.comp_app]; simp only [Functor.mapGroupObject_obj,
    GroupObject.comp_hom', Functor.mapGroupObjectObj_X]

lemma oplaxFunctor_map‚ÇÇ_associator {A B C D : {C : Cat.{v, u} // HasFiniteProducts C}}
    (F : A ‚ü∂ B) (G : B ‚ü∂ C) (H : C ‚ü∂ D) :
    oplaxFunctor_map‚ÇÇ (Bicategory.associator F G H).hom ‚â´ (opLaxFunctor_mapComp F (G ‚â´ H) ‚â´
    Bicategory.whiskerLeft (oplaxFunctor_map F) (opLaxFunctor_mapComp G H)) =
    opLaxFunctor_mapComp (F ‚â´ G) H ‚â´ (Bicategory.whiskerRight (opLaxFunctor_mapComp F G)
    (oplaxFunctor_map H) ‚â´ (Bicategory.associator (oplaxFunctor_map F) (oplaxFunctor_map G)
    (oplaxFunctor_map H)).hom) := by
  simp only [oplaxFunctor_map, oplaxFunctor_map‚ÇÇ, opLaxFunctor_mapComp,
    Functor.mapGroupObject_obj, Cat.comp_obj, Functor.mapGroupObjectObj_X,
    Strict.associator_eqToIso, eqToIso_refl, Iso.refl_hom, Category.comp_id]
  simp only [Functor.mapGroupObject, Functor.mapGroupObject_natTrans, id_eq, oplaxFunctor_map,
    Cat.comp_obj]
  change (_ : NatTrans _ _) = _
  ext
  simp only [Cat.comp_obj, oplaxFunctor_map, Functor.mapGroupObject_obj]
  erw [NatTrans.comp_app, NatTrans.comp_app, NatTrans.comp_app]
  simp only [Cat.comp_obj, oplaxFunctor_map, Functor.mapGroupObject_obj]
  erw [whiskerRight_app, whiskerLeft_app]
  simp only [oplaxFunctor_map, Functor.mapGroupObject_obj, Cat.comp_obj,
    Functor.mapGroupObjectObj_X]
  have := D.2
  change GroupObject.comp _ (GroupObject.comp _ _) = GroupObject.comp _ _
  ext
  simp only [Functor.mapGroupObjectObj_X, oplaxFunctor_map, Functor.mapGroupObject_obj,
    Cat.comp_obj, GroupObject.comp_hom, Category.comp_id, Functor.mapGroupObjectMap_hom,
    Functor.map_id]
  erw [Functor.associator_hom_app]
  rfl

lemma oplaxFunctor_map‚ÇÇ_leftUnitor {C D : {C : Cat.{v, u} // HasFiniteProducts C}} (F : C ‚ü∂ D) :
    oplaxFunctor_map‚ÇÇ (Bicategory.leftUnitor F).hom = opLaxFunctor_mapComp (ùüô C) F ‚â´
    (Bicategory.whiskerRight (opLaxFunctor_mapId C) (oplaxFunctor_map F) ‚â´
    (Bicategory.leftUnitor (oplaxFunctor_map F)).hom) := by
  simp only [oplaxFunctor_map, oplaxFunctor_map‚ÇÇ, opLaxFunctor_mapComp, Functor.mapGroupObject_obj,
    Cat.comp_obj, Functor.mapGroupObjectObj_X, opLaxFunctor_mapId, Strict.leftUnitor_eqToIso,
    eqToIso_refl, Iso.refl_hom, Category.comp_id]
  simp only [Functor.mapGroupObject, Functor.mapGroupObject_natTrans, id_eq, oplaxFunctor_map,
    Cat.comp_obj]
  change (_ : NatTrans _ _) = _
  ext
  simp only [Functor.mapGroupObject_obj, oplaxFunctor_map, Cat.comp_obj]
  erw [NatTrans.comp_app]; simp only [Functor.mapGroupObject_obj, Cat.comp_obj, oplaxFunctor_map]
  erw [whiskerRight_app]; simp only [oplaxFunctor_map, Functor.mapGroupObject_obj, Cat.comp_obj]
  simp only [oplaxFunctor_map, Functor.mapGroupObject_obj, Cat.comp_obj, Functor.mapGroupObjectMap,
    Functor.mapGroupObjectObj_X]
  have := D.2
  change _ = GroupObject.comp _ _
  ext
  simp only [Functor.mapGroupObjectObj_X, oplaxFunctor_map, Functor.mapGroupObject_obj,
    Cat.comp_obj, GroupObject.comp_hom, Category.id_comp]
  erw [Functor.leftUnitor_hom_app, Functor.map_id]
  rfl

lemma oplaxFunctor_map‚ÇÇ_rightUnitor {C D : {C : Cat.{v, u} // HasFiniteProducts C}} (F : C ‚ü∂ D) :
    oplaxFunctor_map‚ÇÇ (Bicategory.rightUnitor F).hom = opLaxFunctor_mapComp F (ùüô D) ‚â´
    (Bicategory.whiskerLeft (oplaxFunctor_map F) (opLaxFunctor_mapId D) ‚â´
    (Bicategory.rightUnitor (oplaxFunctor_map F)).hom) := by
  simp only [oplaxFunctor_map, Functor.mapGroupObject, oplaxFunctor_map‚ÇÇ,
    Functor.mapGroupObject_natTrans, id_eq, opLaxFunctor_mapComp, Cat.comp_obj,
    Functor.mapGroupObjectObj_X, opLaxFunctor_mapId, Strict.rightUnitor_eqToIso, eqToIso_refl,
    Iso.refl_hom, Category.comp_id]
  change (_ : NatTrans _ _) = _
  ext
  simp only [Functor.mapGroupObject_obj, oplaxFunctor_map, Cat.comp_obj]
  erw [NatTrans.comp_app]; simp only [Functor.mapGroupObject_obj, Cat.comp_obj, oplaxFunctor_map]
  erw [whiskerLeft_app]; simp only [oplaxFunctor_map, Functor.mapGroupObject_obj, Cat.comp_obj,
    Functor.mapGroupObjectObj_X]
  have := D.2
  change _ = GroupObject.comp _ _
  ext
  simp only [Functor.mapGroupObjectObj_X, oplaxFunctor_map, Functor.mapGroupObject_obj,
    Cat.comp_obj, GroupObject.comp_hom, Category.id_comp]
  erw [Functor.rightUnitor_hom_app]

@[simp]
def oplaxFunctor : OplaxFunctor {C : Cat.{v, u} // HasFiniteProducts C} Cat.{v, max v u} where
  obj C := Cat.of (@GroupObject C.1 _ C.2)
  map := oplaxFunctor_map
  map‚ÇÇ := oplaxFunctor_map‚ÇÇ
  mapId := opLaxFunctor_mapId
  mapComp := opLaxFunctor_mapComp
  mapComp_naturality_left := opLaxFunctor_mapComp_naturality_left
  mapComp_naturality_right := opLaxFunctor_mapComp_naturality_right
  map‚ÇÇ_id := oplaxFunctor_map‚ÇÇ_id
  map‚ÇÇ_comp := oplaxFunctor_map‚ÇÇ_comp
  map‚ÇÇ_associator := oplaxFunctor_map‚ÇÇ_associator
  map‚ÇÇ_leftUnitor := oplaxFunctor_map‚ÇÇ_leftUnitor
  map‚ÇÇ_rightUnitor := oplaxFunctor_map‚ÇÇ_rightUnitor

def oplaxFunctor_pseudoCore_mapIdIso (C : {C : Cat.{v, u} // HasFiniteProducts C}) :
    oplaxFunctor_map (ùüô C) ‚âÖ ùüô (oplaxFunctor.obj C) := by
  have := C.2
  simp only [oplaxFunctor, oplaxFunctor_map, Functor.mapGroupObject]
  refine NatIso.ofComponents ?_ ?_
  ¬∑ intro X
    refine GroupObject.isoOfIso (Iso.refl _) ?_ ?_ ?_
    ¬∑ simp only [Functor.mapGroupObjectObj_X, Functor.mapGroupObjectObj_one,
      PreservesTerminal.iso_inv, Iso.refl_hom, Category.comp_id, IsIso.inv_comp_eq]
      change X.one = _ ‚â´ X.one
      rw [Subsingleton.elim (terminalComparison (ùüô C : C ‚ü∂ C).1) (ùüô _)]
      erw [Category.id_comp]
    ¬∑ simp only [Functor.mapGroupObjectObj_X, Functor.mapGroupObjectObj_mul,
      PreservesLimitPair.iso_inv, Iso.refl_hom, Category.comp_id, prod.map_id_id,
      Category.id_comp, IsIso.inv_comp_eq]
      change X.mul = _ ‚â´ X.mul
      suffices h : prodComparison (ùüô C : C ‚ü∂ C).1 X.X X.X = ùüô _ by
        rw [h]; erw [Category.id_comp]
      ext
      ¬∑ simp only [prodComparison_fst, Category.id_comp]; rfl
      ¬∑ simp only [prodComparison_snd, Category.id_comp]; rfl
    ¬∑ simp only [Functor.mapGroupObjectObj_X, Functor.mapGroupObjectObj_inv, Iso.refl_hom,
      Category.comp_id, Category.id_comp]; rfl
  ¬∑ intro X Y f
    simp only [Functor.mapGroupObjectMap, Functor.mapGroupObjectObj_X, Cat.id_map]
    simp only [GroupObject.isoOfIso, Functor.mapGroupObjectObj_X, Iso.refl_hom, Iso.refl_inv]
    change GroupObject.comp _ _ = GroupObject.comp _ _
    ext
    simp only [Functor.mapGroupObjectObj_X, GroupObject.comp_hom, Category.comp_id,
    Category.id_comp]
    rfl

def oplaxFunctor_pseudoCore_mapCompIso {C D E : {C : Cat.{v, u} // HasFiniteProducts C}}
    (F : C ‚ü∂ D) (G : D ‚ü∂ E) :
    oplaxFunctor_map (F ‚â´ G) ‚âÖ oplaxFunctor_map F ‚â´ oplaxFunctor_map G := by
  have := E.2
  refine NatIso.ofComponents ?_ ?_
  ¬∑ intro X
    refine GroupObject.isoOfIso (Iso.refl _) ?_ ?_ ?_
    ¬∑ simp only [oplaxFunctor_map, Cat.comp_obj, Functor.mapGroupObject_obj,
      Functor.mapGroupObjectObj, PreservesTerminal.iso_inv, Iso.refl_hom, Category.comp_id,
      Functor.map_comp, Functor.map_inv]
      rw [‚Üê Category.assoc]; congr 1
      simp only [IsIso.eq_comp_inv, IsIso.inv_comp_eq]
      exact Subsingleton.elim _ _
    ¬∑ simp only [oplaxFunctor_map, Functor.mapGroupObject_obj, Functor.mapGroupObjectObj,
      Cat.comp_obj, PreservesLimitPair.iso_inv, Iso.refl_hom, Category.comp_id, prod.map_id_id,
      Functor.map_comp, Functor.map_inv, Category.id_comp]
      rw [‚Üê Category.assoc]; congr 1
      simp only [IsIso.eq_comp_inv, IsIso.inv_comp_eq]
      ext
      ¬∑ simp only [Category.assoc, prodComparison_fst]
        erw [prodComparison_fst]; rw [‚Üê Functor.map_comp, prodComparison_fst]
        rfl
      ¬∑ simp only [Category.assoc, prodComparison_snd]
        erw [prodComparison_snd]; rw [‚Üê Functor.map_comp, prodComparison_snd]
        rfl
    ¬∑ simp only [oplaxFunctor_map, Functor.mapGroupObject_obj, Functor.mapGroupObjectObj,
      Cat.comp_obj, Iso.refl_hom, Category.comp_id, Category.id_comp]
      rfl
  ¬∑ intro X Y f
    simp only [oplaxFunctor_map, Functor.mapGroupObject_obj, Cat.comp_obj,
      Functor.mapGroupObject_map, GroupObject.isoOfIso, Functor.mapGroupObjectObj_X, Iso.refl_hom,
      Iso.refl_inv, Cat.comp_map]
    simp only [Functor.mapGroupObjectMap, oplaxFunctor_map, Functor.mapGroupObject_obj,
      Cat.comp_obj, Functor.mapGroupObjectObj_X]
    change GroupObject.comp _ _ = GroupObject.comp _ _
    ext
    simp only [Functor.mapGroupObjectObj_X, oplaxFunctor_map, Functor.mapGroupObject_obj,
      Cat.comp_obj, GroupObject.comp_hom, Category.comp_id, Category.id_comp]
    rfl

def oplaxFunctor_pseudoCore : OplaxFunctor.PseudoCore oplaxFunctor where
  mapIdIso := oplaxFunctor_pseudoCore_mapIdIso
  mapCompIso := oplaxFunctor_pseudoCore_mapCompIso

def pseudofunctor : Pseudofunctor {C : Cat.{v, u} // HasFiniteProducts C} Cat.{v, max v u} :=
  Pseudofunctor.mkOfOplax oplaxFunctor oplaxFunctor_pseudoCore

end CategoryTheory.GroupObject
