import Mathlib.CategoryTheory.Limits.Preserves.Shapes.BinaryProducts
import Mathlib.Tactic.Widget.CommDiag
import ProofWidgets.Component.Panel.GoalTypePanel
import Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal
import ProofWidgets.Component.Panel.SelectionPanel
import Mathlib.LinearAlgebra.TensorProduct.Basic
import Mathlib.Algebra.Category.Ring.Basic
import Mathlib.CategoryTheory.Limits.Fubini

universe u v u' v' u'' v''

open CategoryTheory Limits ProofWidgets

variable {C : Type u} {D : Type u'} {E : Type u''} [Category.{v, u} C] [Category.{v', u'} D]
  [Category.{v'', u''} E]

variable {X Y Z X' Y' Z' : C} [HasBinaryProduct X X'] [HasBinaryProduct Y X']
  [HasBinaryProduct Z X'] [HasBinaryProduct X Y'] [HasBinaryProduct Y Y']
  [HasBinaryProduct Z Y'] [HasBinaryProduct X Z'] [HasBinaryProduct Y Z']
  [HasBinaryProduct Z Z']

variable {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} {f' : X' ‚ü∂ Y'} {g' : Y' ‚ü∂ Z'}

variable {F : C ‚•§ D} [Limits.PreservesLimit (pair X X') F]
  [Limits.PreservesLimit (pair Y Y') F]

variable [HasBinaryProduct (F.obj X) (F.obj X')] [HasBinaryProduct (F.obj Y) (F.obj X')]
  [HasBinaryProduct (F.obj Z) (F.obj X')] [HasBinaryProduct (F.obj X) (F.obj Y')] [HasBinaryProduct (F.obj Y) (F.obj Y')]
  [HasBinaryProduct (F.obj Z) (F.obj Y')] [HasBinaryProduct (F.obj X) (F.obj Z')] [HasBinaryProduct (F.obj Y) (F.obj Z')]
  [HasBinaryProduct (F.obj Z) (F.obj Z')]

namespace CategoryTheory

namespace Functor

@[simp]
def precomp (F : E ‚•§ C) : (C ‚•§ D) ‚•§ (E ‚•§ D) where
  obj G := F ‚ãô G
  map f := whiskerLeft F f

@[simp]
def postcomp (F : D ‚•§ E) : (C ‚•§ D) ‚•§ (C ‚•§ E) where
  obj G := G ‚ãô F
  map f := whiskerRight f F

end Functor

namespace Limits

lemma prod_map_comp_left_id_right :
    prod.map (f ‚â´ g) (ùüô X') = prod.map f (ùüô X') ‚â´ prod.map g (ùüô X') := by
  simp only [prod.map_map, Category.comp_id]

lemma prod_map_comp_right_id_left :
    prod.map (ùüô X) (f' ‚â´ g') = prod.map (ùüô X) f' ‚â´ prod.map (ùüô X) g' := by
  simp only [prod.map_map, Category.comp_id]

@[simp]
lemma PreservesLimitPair.iso_inv :
    (PreservesLimitPair.iso F X X').inv = inv (prodComparison F X X') := by
  simp_rw [‚Üê PreservesLimitPair.iso_hom]; rw [IsIso.Iso.inv_hom]

variable [HasTerminal C] [HasTerminal D] [PreservesLimit (CategoryTheory.Functor.empty C) F]

@[simp]
lemma PreservesTerminal.iso_inv :
    (PreservesTerminal.iso F).inv = inv (terminalComparison F) := by
  simp_rw [‚Üê PreservesTerminal.iso_hom]; rw [IsIso.Iso.inv_hom]


lemma prod.associator_comp_prodComparison [HasBinaryProducts C] [HasBinaryProducts D] :
    prodComparison F (X ‚®Ø Y) Z ‚â´ prod.map (prodComparison F X Y) (ùüô (F.obj Z))
    ‚â´ (prod.associator _ _ _).hom =
    F.map (prod.associator _ _ _).hom ‚â´ prodComparison F X (Y ‚®Ø Z) ‚â´ prod.map (ùüô (F.obj X))
    (prodComparison F Y Z) := by
  with_panel_widgets [GoalTypePanel]
  ext <;> simp only [prod.associator_hom, prod.comp_lift, prod.map_fst_assoc, prodComparison_fst,
    prodComparison_snd, prod.map_snd, Category.comp_id, prodComparison_fst_assoc, limit.lift_œÄ,
    BinaryFan.mk_pt, BinaryFan.œÄ_app_left, BinaryFan.mk_fst, Category.assoc, prod.map_fst]
  ¬∑ rw [‚Üê Functor.map_comp, ‚Üê Functor.map_comp]
    congr 1
    simp only [limit.lift_œÄ, BinaryFan.mk_pt, BinaryFan.œÄ_app_left, BinaryFan.mk_fst]
  ¬∑ simp only [BinaryFan.œÄ_app_right, BinaryFan.mk_snd, limit.lift_œÄ, BinaryFan.mk_pt,
    BinaryFan.œÄ_app_left, BinaryFan.mk_fst, prodComparison_snd_assoc]
    repeat' rw [‚Üê Functor.map_comp]
    congr 1
    simp only [limit.lift_œÄ_assoc, BinaryFan.mk_pt, pair_obj_right, BinaryFan.œÄ_app_right,
      BinaryFan.mk_snd, limit.lift_œÄ, BinaryFan.œÄ_app_left, BinaryFan.mk_fst]
  ¬∑ simp only [BinaryFan.œÄ_app_right, BinaryFan.mk_snd, limit.lift_œÄ, BinaryFan.mk_pt,
    prodComparison_snd_assoc]
    repeat' rw [‚Üê F.map_comp]
    congr 1
    simp only [limit.lift_œÄ_assoc, BinaryFan.mk_pt, pair_obj_right, BinaryFan.œÄ_app_right,
      BinaryFan.mk_snd, limit.lift_œÄ]

variable (F X Y Z)

lemma PreservesLimitsPair.iso.inv_comp_prod.associator [HasBinaryProducts C] [HasBinaryProducts D]
    [PreservesLimit (pair (X ‚®Ø Y) Z) F] [PreservesLimit (pair X Y) F]
    [PreservesLimit (pair Y Z) F] [PreservesLimit (pair X (Y ‚®Ø Z)) F] :
    prod.map (PreservesLimitPair.iso F X Y).inv (ùüô (F.obj Z)) ‚â´
    (PreservesLimitPair.iso F (X ‚®Ø Y) Z).inv ‚â´ F.map (prod.associator _ _ _).hom =
    (prod.associator _ _ _).hom ‚â´ prod.map (ùüô F.obj X) (PreservesLimitPair.iso F Y Z).inv ‚â´
    (PreservesLimitPair.iso F X (Y ‚®Ø Z)).inv := by
  refine Mono.right_cancellation (f := (PreservesLimitPair.iso F X (Y ‚®Ø Z)).hom) _ _ ?_
  refine Mono.right_cancellation (f := prod.map (ùüô (F.obj X)) (PreservesLimitPair.iso F Y Z).hom)
    _ _ ?_
  conv_lhs => rw [Category.assoc, Category.assoc, Category.assoc]
              erw [‚Üê prod.associator_comp_prodComparison]
              rw [‚Üê PreservesLimitPair.iso_hom, ‚Üê PreservesLimitPair.iso_hom]
  slice_lhs 2 3 => rw [Iso.inv_hom_id]
  rw [Category.id_comp, ‚Üê Category.assoc, ‚Üê prod_map_comp_left_id_right, Iso.inv_hom_id,
    prod.map_id_id, Category.id_comp]
  slice_rhs 3 4 => rw [Iso.inv_hom_id]
  rw [Category.id_comp]; erw [‚Üê prod_map_comp_right_id_left]
  rw [Iso.inv_hom_id, prod.map_id_id, Category.comp_id]

variable {F X Y Z}

variable {h : X ‚ü∂ Z} [HasBinaryProduct Y Z] [HasBinaryProduct X Y]
  [HasBinaryProduct (F.obj Y) (F.obj Z)]

lemma prodComparison_comp_lift :
    F.map (prod.lift f h) ‚â´ prodComparison F Y Z = prod.lift (F.map f) (F.map h) := by
  ext
  ¬∑ simp only [Category.assoc, prodComparison_fst, limit.lift_œÄ, BinaryFan.mk_pt,
    BinaryFan.œÄ_app_left, BinaryFan.mk_fst]
    rw [‚Üê F.map_comp]; congr 1; simp only [limit.lift_œÄ, BinaryFan.mk_pt, BinaryFan.œÄ_app_left,
      BinaryFan.mk_fst]
  ¬∑ simp only [Category.assoc, prodComparison_snd, limit.lift_œÄ, BinaryFan.mk_pt,
    BinaryFan.œÄ_app_right, BinaryFan.mk_snd]
    rw [‚Üê F.map_comp]; congr 1; simp only [limit.lift_œÄ, BinaryFan.mk_pt, BinaryFan.œÄ_app_right,
      BinaryFan.mk_snd]

variable [PreservesLimit (pair Y Z) F]

lemma PreservesLimitPair.iso.inv_comp_lift :
    prod.lift (F.map f) (F.map h) ‚â´ (PreservesLimitPair.iso F Y Z).inv = F.map (prod.lift f h) := by
  refine Mono.right_cancellation (f := (PreservesLimitPair.iso F Y Z).hom) _ _ ?_
  rw [Category.assoc, Iso.inv_hom_id, Category.comp_id, PreservesLimitPair.iso_hom,
    prodComparison_comp_lift]

lemma default_comp_inv_terminalComparison :
    (default : F.obj X ‚ü∂ ‚ä§_ D) ‚â´ inv (terminalComparison F) = F.map default := by
  simp only [IsIso.comp_inv_eq]
  convert Subsingleton.elim _ _
  infer_instance

variable {G : C ‚•§ D}

variable [HasBinaryProduct (G.obj X) (G.obj Y)] [HasBinaryProduct (F.obj X) (F.obj Y)]

lemma prodComparison_natTrans (Œ± : F ‚ü∂ G) :
    prodComparison F X Y ‚â´ prod.map (Œ±.app X) (Œ±.app Y) =
    Œ±.app (X ‚®Ø Y) ‚â´ prodComparison G X Y := by
  ext
  ¬∑ rw [Category.assoc]; simp only [prod.map_fst, prodComparison_fst_assoc, NatTrans.naturality,
    Category.assoc, prodComparison_fst]
  ¬∑ rw [Category.assoc]; simp only [prod.map_snd, prodComparison_snd_assoc, NatTrans.naturality,
    Category.assoc, prodComparison_snd]

lemma inv_prodComparison_natTrans [IsIso (prodComparison F X Y)] [IsIso (prodComparison G X Y)]
    (Œ± : F ‚ü∂ G) : inv (prodComparison F X Y) ‚â´ Œ±.app (X ‚®Ø Y) =
    prod.map (Œ±.app X) (Œ±.app Y) ‚â´ inv (prodComparison G X Y) := by
  rw [IsIso.eq_comp_inv, Category.assoc, IsIso.inv_comp_eq, prodComparison_natTrans]


#exit

variable {J : Type*} [CategoryTheory.SmallCategory J] [HasBinaryProducts C]

example (F G : J ‚•§ C) : Discrete WalkingPair ‚•§ J ‚•§ C := pair F G

example (F G : J ‚•§ C) [HasLimit F] [HasLimit G] [HasLimitsOfShape J C]
    [HasLimitsOfShape (Discrete WalkingPair √ó J) C]
    [HasLimit (pair F G ‚ãô lim)] [HasLimit (uncurry.obj (pair F G))]
    [HasLimitsOfShape (J √ó Discrete WalkingPair) C]
    : HasLimit (pair F G) := by
  have e‚ÇÅ := limitFlipCompLimIsoLimitCompLim (pair F G)
  have e‚ÇÇ := limitUncurryIsoLimitCompLim (pair F G)
  have f := HasLimit.isoOfEquivalence (G := uncurry.obj (pair F G))
    (F := (Prod.braiding _ _).functor ‚ãô uncurry.obj (pair F G)) _ (Iso.refl _)
  have K := curry.obj ((Prod.braiding _ _).functor ‚ãô uncurry.obj (pair F G))
  have g := limitIsoLimitCurryCompLim ((Prod.braiding _ _).functor ‚ãô uncurry.obj (pair F G))
  have e‚ÇÉ := limitUncurryIsoLimitCompLim (pair F G).flip




end Limits

end CategoryTheory

open CategoryTheory CategoryTheory.Limits TensorProduct

namespace CommRingCat

#exit

section Coproduct

variable (A B : CommRingCat.{u})

/-- The explicit cocone with tensor products as the fibered product in `CommRingCat`. -/
def pushoutCocone : Limits.PushoutCocone f g := by
  letI := RingHom.toAlgebra f
  letI := RingHom.toAlgebra g
  fapply Limits.PushoutCocone.mk
  ¬∑ show CommRingCat; exact CommRingCat.of (A ‚äó[R] B)
  ¬∑ show A ‚ü∂ _; exact Algebra.TensorProduct.includeLeftRingHom
  ¬∑ show B ‚ü∂ _; exact Algebra.TensorProduct.includeRight.toRingHom
  ¬∑ ext r
    trans algebraMap R (A ‚äó[R] B) r
    ¬∑ exact Algebra.TensorProduct.includeLeft.commutes (R := R) r
    ¬∑ exact (Algebra.TensorProduct.includeRight.commutes (R := R) r).symm
set_option linter.uppercaseLean3 false in
#align CommRing.pushout_cocone CommRingCat.pushoutCocone

@[simp]
theorem pushoutCocone_inl :
    (pushoutCocone f g).inl = by
      letI := f.toAlgebra
      letI := g.toAlgebra
      exact Algebra.TensorProduct.includeLeftRingHom :=
  rfl
set_option linter.uppercaseLean3 false in
#align CommRing.pushout_cocone_inl CommRingCat.pushoutCocone_inl

@[simp]
theorem pushoutCocone_inr :
    (pushoutCocone f g).inr = by
      letI := f.toAlgebra
      letI := g.toAlgebra
      exact Algebra.TensorProduct.includeRight.toRingHom :=
  rfl
set_option linter.uppercaseLean3 false in
#align CommRing.pushout_cocone_inr CommRingCat.pushoutCocone_inr

@[simp]
theorem pushoutCocone_pt :
    (pushoutCocone f g).pt = by
      letI := f.toAlgebra
      letI := g.toAlgebra
      exact CommRingCat.of (A ‚äó[R] B) :=
  rfl
set_option linter.uppercaseLean3 false in
#align CommRing.pushout_cocone_X CommRingCat.pushoutCocone_pt

/-- Verify that the `pushout_cocone` is indeed the colimit. -/
def pushoutCoconeIsColimit : Limits.IsColimit (pushoutCocone f g) :=
  Limits.PushoutCocone.isColimitAux' _ fun s => by
    letI := RingHom.toAlgebra f
    letI := RingHom.toAlgebra g
    letI := RingHom.toAlgebra (f ‚â´ s.inl)
    let f' : A ‚Üí‚Çê[R] s.pt :=
      { s.inl with
        commutes' := fun r => rfl }
    let g' : B ‚Üí‚Çê[R] s.pt :=
      { s.inr with
        commutes' := fun r => by
          change (g ‚â´ s.inr) r = (f ‚â´ s.inl) r
          congr 1
          exact
            (s.Œπ.naturality Limits.WalkingSpan.Hom.snd).trans
              (s.Œπ.naturality Limits.WalkingSpan.Hom.fst).symm }
    -- Porting note: Lean has forget why `A ‚äó[R] B` makes sense
    letI : Algebra R A := f.toAlgebra
    letI : Algebra R B := g.toAlgebra
    letI : Algebra R (pushoutCocone f g).pt := show Algebra R (A ‚äó[R] B) by infer_instance
    -- The factor map is a ‚äó b ‚Ü¶ f(a) * g(b).
    use AlgHom.toRingHom (Algebra.TensorProduct.productMap f' g')
    simp only [pushoutCocone_inl, pushoutCocone_inr]
    constructor
    ¬∑ ext x
      -- Porting note: Lean can't see through `forget` functor
      letI : Semiring ((forget CommRingCat).obj A) := A.str.toSemiring
      letI : Algebra R ((forget CommRingCat).obj A) := show Algebra R A by infer_instance
      exact Algebra.TensorProduct.productMap_left_apply _ _ x
    constructor
    ¬∑ ext x
      -- Porting note: Lean can't see through `forget` functor
      letI : Semiring ((forget CommRingCat).obj B) := B.str.toSemiring
      letI : Algebra R ((forget CommRingCat).obj B) := show Algebra R B by infer_instance
      exact Algebra.TensorProduct.productMap_right_apply _ _ x
    intro h eq1 eq2
    let h' : A ‚äó[R] B ‚Üí‚Çê[R] s.pt :=
      { h with
        commutes' := fun r => by
          change h (f r ‚äó‚Çú[R] 1) = s.inl (f r)
          rw [‚Üê eq1]
          simp only [pushoutCocone_pt, coe_of, AlgHom.toRingHom_eq_coe]
          rfl }
    suffices h' = Algebra.TensorProduct.productMap f' g' by
      ext x
      change h' x = Algebra.TensorProduct.productMap f' g' x
      rw [this]
    apply Algebra.TensorProduct.ext'
    intro a b
    simp only [f', g', ‚Üê eq1, pushoutCocone_pt, ‚Üê eq2, AlgHom.toRingHom_eq_coe,
      Algebra.TensorProduct.productMap_apply_tmul, AlgHom.coe_mk]
    change _ = h (a ‚äó‚Çú 1) * h (1 ‚äó‚Çú b)
    rw [‚Üê h.map_mul, Algebra.TensorProduct.tmul_mul_tmul, mul_one, one_mul]
    rfl
set_option linter.uppercaseLean3 false in
#align CommRing.pushout_cocone_is_colimit CommRingCat.pushoutCoconeIsColimit

end Pushout
