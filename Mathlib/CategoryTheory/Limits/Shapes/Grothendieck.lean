/-
Copyright (c) 2024 Jakob von Raumer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jakob von Raumer
-/
import Mathlib.CategoryTheory.Grothendieck
import Mathlib.CategoryTheory.Limits.HasLimits

/-!
# (Co)limits on the (strict) Grothendieck Construction

* Shows that colimits of functors on the Grothendieck construction are colimits of
  "fibered colimits", i.e. of applying the colimit to each fiber of the functor.

-/

universe v‚ÇÅ v‚ÇÇ v‚ÇÉ u‚ÇÅ u‚ÇÇ u‚ÇÉ

namespace CategoryTheory

variable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C]
variable {F : C ‚•§ Cat}
variable {H : Type u‚ÇÇ} [Category.{v‚ÇÇ} H]
variable (G : Grothendieck F ‚•§ H)

@[simps]
def Grothendieck.ŒπNatTrans {X Y : C} (f : X ‚ü∂ Y) : Œπ F X ‚ü∂ F.map f ‚ãô Œπ F Y where
  app d := ‚ü®f, ùüô _‚ü©
  naturality _ _ _ := by
    simp only [Œπ, Functor.comp_obj, Functor.comp_map]
    exact Grothendieck.ext _ _ (by simp) (by simp [eqToHom_map])

def Grothendieck.coherence {X Y : Grothendieck F} (hF : X = Y) :
    eqToHom hF = { base := eqToHom (by subst hF; rfl), fiber := eqToHom (by subst hF; simp) } := by
  subst hF
  rfl

namespace Limits

lemma colimit.Œπ_coherence (F : C ‚•§ H) [HasColimit F] {c c' : C} (hc : c = c') :
    colimit.Œπ F c = eqToHom (by subst hc; rfl) ‚â´ colimit.Œπ F c' := by
  subst hc
  simp

noncomputable section

variable [‚àÄ {X Y : C} (f : X ‚ü∂ Y), HasColimit (F.map f ‚ãô Grothendieck.Œπ F Y ‚ãô G)]

local instance : ‚àÄ X, HasColimit (Grothendieck.Œπ F X ‚ãô G) :=
  fun X => hasColimitOfIso (F := F.map (ùüô _) ‚ãô Grothendieck.Œπ F X ‚ãô G) <|
    (Functor.leftUnitor (Grothendieck.Œπ F X ‚ãô G)).symm ‚â™‚â´
    (isoWhiskerRight (eqToIso (F.map_id X).symm) (Grothendieck.Œπ F X ‚ãô G))

/-- A functor taking a colimit on each fiber of a functor `G : Grothendieck F ‚•§ H`. -/
@[simps]
def fiberwiseColimit : C ‚•§ H where
  obj X := colimit (Grothendieck.Œπ F X ‚ãô G)
  map {X Y} f := colimMap (whiskerRight (Grothendieck.ŒπNatTrans f) G ‚â´
    (Functor.associator _ _ _).hom) ‚â´ colimit.pre (Grothendieck.Œπ F Y ‚ãô G) (F.map f)
  map_id X := by
    ext d
    simp only [Functor.comp_obj, Grothendieck.ŒπNatTrans, Grothendieck.Œπ_obj_base,
      Grothendieck.Œπ_obj_fiber, Œπ_colimMap_assoc, NatTrans.comp_app, whiskerRight_app,
      Functor.associator_hom_app, Category.comp_id, colimit.Œπ_pre]
    conv_rhs =>
      rw [colimit.Œπ_coherence (Grothendieck.Œπ F X ‚ãô G) (c' := (F.map (ùüô X)).obj d) (by simp)]
    rw [‚Üê eqToHom_map G (by simp), Grothendieck.coherence]
    rfl
  map_comp {X Y Z} f g := by
    ext d
    simp only [Functor.comp_obj, Grothendieck.ŒπNatTrans, Grothendieck.Œπ_obj_base,
      Grothendieck.Œπ_obj_fiber, Œπ_colimMap_assoc, NatTrans.comp_app, whiskerRight_app,
      Functor.associator_hom_app, Category.comp_id, colimit.Œπ_pre, Category.assoc,
      colimit.Œπ_pre_assoc]
    rw [‚Üê Category.assoc, ‚Üê G.map_comp]
    conv_rhs =>
      rw [colimit.Œπ_coherence (Grothendieck.Œπ F Z ‚ãô G) (c' := (F.map (f ‚â´ g)).obj d) (by simp)]
    rw [‚Üê Category.assoc, ‚Üê eqToHom_map G (by simp), ‚Üê G.map_comp, Grothendieck.coherence]
    congr 2
    fapply Grothendieck.ext
    ¬∑ simp only [Grothendieck.Œπ_obj_base, Cat.comp_obj, eqToHom_refl, Grothendieck.Œπ_obj_fiber,
        Category.assoc, Grothendieck.comp_base, Category.comp_id]
    ¬∑ simp only [Grothendieck.Œπ_obj_base, Cat.comp_obj, eqToHom_refl, Grothendieck.Œπ_obj_fiber,
        Cat.id_obj, Grothendieck.comp_base, Category.comp_id, Grothendieck.comp_fiber,
        Functor.map_id]
      conv_rhs => enter [2, 1]; rw [eqToHom_map (F.map (ùüô Z))]
      conv_rhs => rw [eqToHom_trans, eqToHom_trans]

/-- Every functor `G : Grothendieck F ‚•§ H` induces a natural transformation from `G` to the
composition of the forgetful functor on `Grothendieck F` with the fiberwise colimit on `G`. -/
@[simps]
def natTransIntoForgetCompFiberwiseColimit :
    G ‚ü∂ Grothendieck.forget F ‚ãô fiberwiseColimit G where
  app X := colimit.Œπ (Grothendieck.Œπ F X.base ‚ãô G) X.fiber
  naturality _ _ f := by
    simp only [Functor.comp_obj, Grothendieck.forget_obj, fiberwiseColimit_obj, Functor.comp_map,
      Grothendieck.forget_map, fiberwiseColimit_map, Grothendieck.ŒπNatTrans,
      Grothendieck.Œπ_obj_base, Grothendieck.Œπ_obj_fiber, Œπ_colimMap_assoc, NatTrans.comp_app,
      whiskerRight_app, Functor.associator_hom_app, Category.comp_id, colimit.Œπ_pre]
    rw [‚Üê colimit.w (Grothendieck.Œπ F _ ‚ãô G) f.fiber]
    simp only [‚Üê Category.assoc, Functor.comp_obj, Functor.comp_map, ‚Üê G.map_comp]
    congr 2
    apply Grothendieck.ext <;> simp

variable {G} in
/-- A cocone on a functor `G : Grothendieck F ‚•§ H` induces a cocone on the fiberwise colimit
on `G`. -/
@[simps]
def coconeFiberwiseColimitOfCocone (c : Cocone G) : Cocone (fiberwiseColimit G) where
  pt := c.pt
  Œπ := { app := fun X => colimit.desc _ (c.whisker (Grothendieck.Œπ F X)),
         naturality := fun _ _ f => by dsimp; ext; simp }

variable {G} in
/-- If `c` is a colimit cocone on `G : Grockendieck F ‚•§ H`, then the induced cocone on the
fiberwise colimit on `G` is a colimit cocone, too. -/
def isColimitCoconeFiberwiseColimitOfCocone {c : Cocone G} (hc : IsColimit c) :
    IsColimit (coconeFiberwiseColimitOfCocone c) where
  desc s := hc.desc <| Cocone.mk s.pt <| natTransIntoForgetCompFiberwiseColimit G ‚â´
    whiskerLeft (Grothendieck.forget F) s.Œπ
  fac s c := by dsimp; ext; simp
  uniq s m hm := hc.hom_ext fun X => by
    have := hm X.base
    simp only [Functor.const_obj_obj, IsColimit.fac, NatTrans.comp_app, Functor.comp_obj,
      Grothendieck.forget_obj, fiberwiseColimit_obj, natTransIntoForgetCompFiberwiseColimit_app,
      whiskerLeft_app]
    simp only [fiberwiseColimit_obj, coconeFiberwiseColimitOfCocone_pt, Functor.const_obj_obj,
      coconeFiberwiseColimitOfCocone_Œπ_app] at this
    simp [‚Üê this, Grothendieck.Œπ]

section

variable [HasColimit G]

local instance hasColimitFiberwiseColimit : HasColimit (fiberwiseColimit G) where
  exists_colimit := ‚ü®‚ü®_, isColimitCoconeFiberwiseColimitOfCocone (colimit.isColimit _)‚ü©‚ü©

/-- For every functor `G` on the Grothendieck construction `Grothendieck F`, taking its colimit
is isomorphic to first taking the fiberwise colimit and then the colimit of the resulting fucntor.
-/
def colimitFiberwiseColimitIso [HasColimit G] :
    colimit (fiberwiseColimit G) ‚âÖ colimit G :=
  IsColimit.coconePointUniqueUpToIso (colimit.isColimit (fiberwiseColimit G))
    (isColimitCoconeFiberwiseColimitOfCocone (colimit.isColimit _))

end

section

variable [‚àÄ {X Y : C} (f : X ‚ü∂ Y), HasColimit (F.map f ‚ãô Grothendieck.Œπ F Y ‚ãô G)]

def coconeOfFiberwiseCocone (c : Cocone (fiberwiseColimit G)) : Cocone G where
  pt := c.pt
  Œπ := { app := fun X => colimit.Œπ (Grothendieck.Œπ F X.base ‚ãô G) X.fiber ‚â´ c.Œπ.app X.base
         naturality := fun {X Y} ‚ü®f, g‚ü© => by
          simp only [Functor.const_obj_obj, Functor.const_obj_map, Category.comp_id]
          rw [‚Üê Category.assoc, ‚Üê c.w f, ‚Üê Category.assoc]
          simp only [fiberwiseColimit_obj, fiberwiseColimit_map, Grothendieck.ŒπNatTrans,
            Functor.comp_obj, Grothendieck.Œπ_obj_base, Grothendieck.Œπ_obj_fiber, Œπ_colimMap_assoc,
            NatTrans.comp_app, whiskerRight_app, Functor.associator_hom_app, Category.comp_id,
            colimit.Œπ_pre]
          rw [‚Üê colimit.w _ g, ‚Üê Category.assoc, Functor.comp_map, ‚Üê G.map_comp]
          congr <;> simp }

/-- We can infer that a functor `G : Grothendieck F ‚•§ H`, with `F : C ‚•§ Cat`, has a colimit from
the fact that each of its fibers has a colimit and that these fiberwise colimits, as a functor
`C ‚•§ H` have a colimit. -/
def hasColimitOfHasFiberwiseColimitOfHasBaseColimit
    [‚àÄ {X Y : C} (f : X ‚ü∂ Y), HasColimit (F.map f ‚ãô Grothendieck.Œπ F Y ‚ãô G)]
    [HasColimit (fiberwiseColimit G)] : HasColimit G where
  exists_colimit := ‚ü®‚ü®_, _‚ü©‚ü©

end

end

end Limits

end CategoryTheory
