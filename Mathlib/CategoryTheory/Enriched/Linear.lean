/-
Copyright (c) 2025 Jakob von Raumer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jakob von Raumer
-/
import Mathlib.CategoryTheory.Enriched.Ordinary.Basic
import Mathlib.CategoryTheory.Linear.Basic
import Mathlib.Algebra.Category.ModuleCat.Monoidal.Basic
import Mathlib.Algebra.Equiv.TransferInstance
import Mathlib.Tactic.CategoryTheory.Coherence
/-!
# Linear categories as `ModuleCat R`-enriched categories

-/

universe w v v' u u'

namespace CategoryTheory

open TensorProduct MonoidalCategory

section EnrichedOfLinear

variable {R : Type u} [CommRing R]
variable {C : Type u} [Category.{u} C] [Preadditive C] [Linear R C]

@[simp]
lemma aux1 {X Y : C} {Z W : Type u} [AddCommGroup Z] [Module R Z]
    [AddCommGroup W] [Module R W] (f : Z ‚Üí‚Çó[R] W) :
    (ModuleCat.ofHom f ‚ñ∑ ModuleCat.of R (X ‚ü∂ Y)).hom = f.rTensor (X ‚ü∂ Y) :=
  rfl

@[simp]
lemma aux1' {X Y : C} {Z W : Type u} [AddCommGroup Z] [Module R Z]
    [AddCommGroup W] [Module R W] (f : Z ‚Üí‚Çó[R] W) :
    (ModuleCat.of R (X ‚ü∂ Y) ‚óÅ ModuleCat.ofHom f).hom = f.lTensor (X ‚ü∂ Y) :=
  rfl

lemma aux2 {X : ModuleCat R} (x : X) : (Œª_ X).inv.hom x = (TensorProduct.lid R X).symm x :=
  rfl

lemma aux2' {X : ModuleCat R} (x : X) : (œÅ_ X).inv.hom x = (TensorProduct.rid R X).symm x :=
  rfl

lemma lift_comp_lift_comp_rTensor_eq {W X Y Z : C} (f : ((W ‚ü∂ X) ‚äó[R] (X ‚ü∂ Y)) ‚äó[R] (Y ‚ü∂ Z)) :
    lift (Linear.comp W Y Z) (((lift (Linear.comp W X Y)).rTensor (Y ‚ü∂ Z)) f) =
      lift (Linear.comp W X Z)
        ((lift (Linear.comp X Y Z)).lTensor (W ‚ü∂ X) ((TensorProduct.assoc R _ _ _) f)) :=
  TensorProduct.induction_on f rfl
    (fun fg _ => TensorProduct.induction_on fg (by simp) (by simp)
      (fun _ _ h‚ÇÇ h‚ÇÉ => by simp [add_tmul, LinearEquiv.map_add, ‚Üê h‚ÇÇ, ‚Üê h‚ÇÉ]))
    (fun _ _ h‚ÇÇ h‚ÇÉ => by simp [h‚ÇÇ, h‚ÇÉ, LinearEquiv.map_add])

open ModuleCat Hom

noncomputable instance : EnrichedOrdinaryCategory (ModuleCat R) C where
  Hom X Y := .of R (X ‚ü∂ Y)
  id X := ModuleCat.ofHom <| (LinearMap.ringLmapEquivSelf R R (X ‚ü∂ X)).symm (ùüô X)
  comp X Y Z := ModuleCat.ofHom <| lift (Linear.comp X Y Z)
  id_comp X Y := by
    ext f
    simp only [LinearMap.ringLmapEquivSelf_symm_apply, ModuleCat.hom_comp,
      ModuleCat.MonoidalCategory.carrier_of_tensorObj_of, hom_ofHom,
      LinearMap.coe_comp, Function.comp_apply, ModuleCat.hom_id, LinearMap.id_coe, id_eq] at f ‚ä¢
    rw [aux2]
    simp [ModuleCat.MonoidalCategory.tensorUnit_eq]
  comp_id X Y := by
    ext f
    simp only [LinearMap.ringLmapEquivSelf_symm_apply, ModuleCat.hom_comp,
      ModuleCat.MonoidalCategory.carrier_of_tensorObj_of, hom_ofHom,
      LinearMap.coe_comp, Function.comp_apply, ModuleCat.hom_id, LinearMap.id_coe, id_eq] at f ‚ä¢
    rw [aux2']
    simp [ModuleCat.MonoidalCategory.tensorUnit_eq]
  assoc W X Y Z := by
    ext f
    change _ ‚äó[R] _ ‚äó[R] _ at f
    simp only [ModuleCat.hom_comp, ModuleCat.MonoidalCategory.carrier_of_tensorObj_of, hom_ofHom,
      LinearMap.coe_comp, Function.comp_apply] at f ‚ä¢
    erw [lift_comp_lift_comp_rTensor_eq]
    congr
    exact (TensorProduct.assoc R (W ‚ü∂ X) (X ‚ü∂ Y) (Y ‚ü∂ Z)).right_inv f
  homEquiv {X Y} := (ModuleCat.homEquiv.trans
      (LinearMap.ringLmapEquivSelf R R (X ‚ü∂ Y)).toEquiv).symm
  homEquiv_id X := rfl
  homEquiv_comp {X Y Z} f g := by
    ext
    change (LinearMap.toSpanSingleton R (X ‚ü∂ Z) (f ‚â´ g)) 1 =
      (lift (Linear.comp X Y Z))
        ((ModuleCat.Hom.hom
          (ModuleCat.ofHom (LinearMap.toSpanSingleton R (X ‚ü∂ Y) f) ‚äó
            ModuleCat.ofHom (LinearMap.toSpanSingleton R (Y ‚ü∂ Z) g)))
          (1 ‚äó‚Çú 1))
    simp

end EnrichedOfLinear

noncomputable section LinearOfEnriched

variable {R : Type u} [CommRing R]
variable {C : Type u} [Category.{u} C] [EnrichedOrdinaryCategory (ModuleCat R) C]

variable (R)

abbrev addCommGroupEnrichedModuleCatHom (X Y : C) : AddCommGroup (X ‚ü∂ Y) :=
  (eHomEquiv (V := ModuleCat R)).addCommGroup

instance moduleModuleCatHom {X Y : C} :
    letI : AddCommGroup (X ‚ü∂ Y) := addCommGroupEnrichedModuleCatHom R X Y
    Module R (X ‚ü∂ Y) :=
  EnrichedOrdinaryCategory.homEquiv.module R

abbrev preadditiveEnrichedModuleCat : Preadditive C where
  homGroup X Y := addCommGroupEnrichedModuleCatHom R X Y
  add_comp X Y Z f f' g := by
    apply (eHomEquiv (ModuleCat R)).injective
    simp [Equiv.add_def, eHomEquiv_comp, MonoidalPreadditive.add_tensor]
  comp_add X Y Z f g g' := by
    apply (eHomEquiv (ModuleCat R)).injective
    simp [Equiv.add_def, eHomEquiv_comp, MonoidalPreadditive.tensor_add]

variable {R}

example : MonoidalLinear R (ModuleCat R) := inferInstance

instance linearEnrichedModuleCat :
    letI : Preadditive C := preadditiveEnrichedModuleCat R
    Linear R C :=
  letI : Preadditive C := preadditiveEnrichedModuleCat R
  { smul_comp X Y Z r f g := by
      apply (eHomEquiv (ModuleCat R)).injective
      simp only [Equiv.smul_def]
      rw [eHomEquiv_comp, ‚Üê eHomEquiv, ‚Üê eHomEquiv]
      simp [eHomEquiv_comp]
    comp_smul X Y Z f r g := by
      apply (eHomEquiv (ModuleCat R)).injective
      simp only [Equiv.smul_def]
      rw [eHomEquiv_comp, ‚Üê eHomEquiv, ‚Üê eHomEquiv]
      simp [eHomEquiv_comp] }

end LinearOfEnriched

end CategoryTheory
