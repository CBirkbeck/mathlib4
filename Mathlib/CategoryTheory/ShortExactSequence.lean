import Mathlib.CategoryTheory.Abelian.Exact
import Mathlib.CategoryTheory.Limits.ExactFunctor
import Mathlib.Algebra.Homology.Exact
import Mathlib.CategoryTheory.Functor.Fin

-- modified from LTE with some names that I think more mnemonic

universe u v

open CategoryTheory Category CategoryTheory.Limits ZeroObject

variable (C D : Type u)
variable [Category.{v} C] [Category.{v} D]
variable [HasImages C] [HasZeroMorphisms C] [HasKernels C] [HasZeroObject C]
variable [HasImages D] [HasZeroMorphisms D] [HasKernels D] [HasZeroObject D]

namespace CategoryTheory

@[ext] structure SES :=
(l m r : C)
(lm : l ‚ü∂ m)
(mr : m ‚ü∂ r)
(mono : Mono lm := by aesop_cat)
(exact : Exact lm mr := by aesop_cat)
(epi : Epi mr := by aesop_cat)

attribute [instance] SES.mono SES.epi

@[ext] structure SES.morphism (s t : SES C) :=
(l : s.l ‚ü∂ t.l)
(m : s.m ‚ü∂ t.m)
(r : s.r ‚ü∂ t.r)
(comm1 : s.lm ‚â´ m = l ‚â´ t.lm := by aesop_cat)
(comm2 : s.mr ‚â´ r = m ‚â´ t.mr := by aesop_cat)

attribute [reassoc] SES.morphism.comm1
attribute [reassoc] SES.morphism.comm2

instance SES.instCategory : Category.{v} (SES.{u, v} C) where
  Hom := SES.morphism C
  id s :=
  { l := ùüô _
    m := ùüô _
    r := ùüô _ }
  comp {a b c} m n :=
  { l := m.l ‚â´ n.l
    m := m.m ‚â´ n.m
    r := m.r ‚â´ n.r
    comm1 := by rw [m.comm1_assoc, Category.assoc, ‚Üê n.comm1]
    comm2 := by rw [m.comm2_assoc, Category.assoc, ‚Üê n.comm2] }

namespace SES

@[simps]
def lFunctor : SES C ‚•§ C where
  obj s := s.l
  map f := f.l

@[simps]
def mFunctor : SES C ‚•§ C where
  obj s := s.m
  map f := f.m

@[simps]
def rFunctor : SES C ‚•§ C where
  obj s := s.r
  map f := f.r

@[simps]
def lmNatTrans : NatTrans (lFunctor C) (mFunctor C) where
  app A := A.lm
  naturality _ _ f := f.comm1.symm

@[simps]
def mrNatTrans : NatTrans (mFunctor C) (rFunctor C) where
  app A := A.mr
  naturality _ _ f := f.comm2.symm

instance : HasZeroMorphisms (SES C) where
  Zero A B :=
  { zero :=
    { l := 0
      m := 0
      r := 0 } }
  comp_zero f s := by
    refine SES.morphism.ext _ _ ?_ ?_ ?_ <;>
    ¬∑ change _ ‚â´ 0 = 0
      aesop_cat
  zero_comp := by
    intros
    refine SES.morphism.ext _ _ ?_ ?_ ?_ <;>
    ¬∑ change 0 ‚â´ _ = 0
      aesop_cat

variable {C}

@[simp] lemma zero_l (s t : SES C) : (0 : s ‚ü∂ t).l = 0 := rfl
@[simp] lemma zero_m (s t : SES C) : (0 : s ‚ü∂ t).m = 0 := rfl
@[simp] lemma zero_r (s t : SES C) : (0 : s ‚ü∂ t).r = 0 := rfl

def asFunctor (s : SES C) : Fin 3 ‚•§ C :=
  fin3FunctorMk ![s.l, s.m, s.r] s.lm s.mr

def asFunctorMap {s t : SES C} (f : s ‚ü∂ t) :
  ‚àÄ i, s.asFunctor.obj i ‚ü∂ t.asFunctor.obj i
| ‚ü®0, _‚ü© => f.l
| ‚ü®1, _‚ü© => f.m
| ‚ü®2, _‚ü© => f.r

lemma asFunctorMap_natural {s t : SES C} (f : s ‚ü∂ t) :
  ‚àÄ (i j : Fin 3) (hij : i ‚â§ j),
    asFunctorMap f i ‚â´ t.asFunctor.map hij.hom = s.asFunctor.map hij.hom ‚â´ asFunctorMap f j
| ‚ü®0,_‚ü©, ‚ü®0,_‚ü©, _ => by aesop_cat
| ‚ü®1,_‚ü©, ‚ü®1,_‚ü©, _ => by aesop_cat
| ‚ü®2,hi‚ü©, ‚ü®2,hj‚ü©, _ => by aesop_cat
| ‚ü®0,_‚ü©, ‚ü®1,_‚ü©, _ => f.comm1.symm
| ‚ü®1,_‚ü©, ‚ü®2,_‚ü©, _ => f.comm2.symm
| ‚ü®i+3,hi‚ü©, _, _      => by exfalso; linarith
| _, ‚ü®j+3,hj‚ü©, _      => by exfalso; linarith
| ‚ü®i+1,hi‚ü©, ‚ü®0,hj‚ü©, (H : _ ‚â§ 0) => by exfalso; linarith
| ‚ü®i+2,hi‚ü©, ‚ü®1,hj‚ü©, (H : _ ‚â§ 1) => by exfalso; linarith
| ‚ü®0,hi‚ü©, ‚ü®2,hj‚ü©, hij => by
  have h01 : (0 : Fin 3) ‚ü∂ 1 := homOfLE <| by decide
  have h12 : (1 : Fin 3) ‚ü∂ 2 := homOfLE <| by decide
  calc  asFunctorMap f ‚ü®0, hi‚ü© ‚â´ t.asFunctor.map hij.hom
    _ = asFunctorMap f ‚ü®0, hi‚ü© ‚â´ t.asFunctor.map h01 ‚â´ t.asFunctor.map h12 := ?_
    _ = (asFunctorMap f ‚ü®0, hi‚ü© ‚â´ t.asFunctor.map h01) ‚â´ t.asFunctor.map h12 :=
      by rw [Category.assoc]
    _ = (s.asFunctor.map h01 ‚â´ asFunctorMap f _) ‚â´ t.asFunctor.map h12 := ?_
    _ = s.asFunctor.map h01 ‚â´ asFunctorMap f _ ‚â´ t.asFunctor.map h12 := Category.assoc _ _ _
    _ = s.asFunctor.map h01 ‚â´ s.asFunctor.map h12 ‚â´ asFunctorMap f _ := ?_
    _ = s.asFunctor.map hij.hom ‚â´ asFunctorMap f ‚ü®2, hj‚ü© := ?_
  ¬∑ rw [‚Üê Functor.map_comp]; congr
  ¬∑ congr 1; exact f.comm1.symm
  ¬∑ congr 1; exact f.comm2.symm
  ¬∑ rw [‚Üê Functor.map_comp_assoc]; congr 1

@[simps]
protected def functor : SES C ‚•§ (Fin 3 ‚•§ C) where
  obj := asFunctor
  map f :=
  { app := asFunctorMap f
    naturality := fun _ _ hij => (asFunctorMap_natural f _ _ hij.le).symm }
  map_id _ := by ext i; fin_cases i <;> rfl
  map_comp _ _ := by ext i; fin_cases i <;> rfl

end SES

end CategoryTheory
