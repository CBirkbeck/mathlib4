/-
Copyright (c) 2025 Grothendieck Institute. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Pablo Donato
-/

import Mathlib.CategoryTheory.Subobject.Basic
import Mathlib.CategoryTheory.Limits.Shapes.Pullback.CommSq

/-!
# Subobject classifier

Following Section I.3 of [Sheaves in Geometry and Logic][MM92], we introduce the notion
`CategoryTheory.Subobject.Classifier C` of subobject classifier in a category `C`.

## Main definitions

Let `C` refer to a category with a terminal object, denoted by `‚ä§_ C`.

* `CategoryTheory.Subobject.IsClassifier t` describes what it means for a morphism `t : ‚ä§_ C ‚ü∂ Œ©`
  (called "true" in [MM92]) to be a subobject classifier for `C`.

* `CategoryTheory.Subobject.Classifier C` is the data of such an `Œ©` and `t` together with a proof
  that `t` is a subobject classifier for `C`.

* `CategoryTheory.Subobject.HasClassifier C` is the mere existence of a subobject classifier for
  `C`.

* `CategoryTheory.Subobject.cmap` uses the `IsClassifier` property to send every subobject `x` of
  `X` to its characteristic map `œá_ x : X ‚ü∂ Œ©`.

* `CategoryTheory.Subobject.compr` sends every map `œÜ : X ‚ü∂ Œ©` to the subobject of `X` whose
  characteristic map is `œÜ` by pulling back `t` along `œÜ`. This generalizes the construction of a
  subset "by comprehension" from its characteristic function in set theory.

* `CategoryTheory.Subobject.sub C` is the presheaf that sends every object `X : C` to its category
  of subobjects `Subobject X`, and every morphism `f : X ‚ü∂ Y` to the function
  `Subobject Y ‚Üí Subobject X` that maps every subobject of `Y` to its pullback along `f`.

## Main statements

* `CategoryTheory.Subobject.hasClassifier_isRepresentable_iff` : a category `C` has a subobject
  classifier `Œ©` if and only if the subobjects presheaf `CategoryTheory.Subobject.sub C` is
  representable by `Œ©` (Proposition 1 in Section I.3 of [MM92]).

## Notation

* If `x` is a subobject, `œá_ x` denotes the characteristic map of `x` given by the subobject
  classifier.

## Implementation notes

* **TODO**: add a uniqueness theorem for subobject classifiers (up to isomorphism)
* **TODO**: add comments to explain the different steps in the long proof of the "only if" direction
  of `CategoryTheory.Subobject.hasClassifier_isRepresentable_iff`

## References

* [S. MacLane and I. Moerdijk, *Sheaves in geometry and logic: A first introduction to topos
  theory*][MM92]

## Tags

subobject, subobject classifier, representable functor, presheaf, topos theory
-/

universe u v

/-! ### Some general lemmas -/

lemma unique_eq {Œ± : Type u} (h : Unique Œ±) (x y : Œ±) : x = y := by
  simp [Unique.uniq h x, Unique.uniq h y]

namespace CategoryTheory

open CategoryTheory
open Limits

variable {C : Type u} [Category.{v} C]

namespace IsPullback

lemma of_iso1 {P P' X Y Z : C}
    {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} {fst : P ‚ü∂ X} {snd : P ‚ü∂ Y}
    {fst' : P' ‚ü∂ X} {snd' : P' ‚ü∂ Y}
    (h : IsPullback fst snd f g) (i : P ‚âÖ P')
    (commfst : fst = i.hom ‚â´ fst')
    (commsnd : snd = i.hom ‚â´ snd') :
    IsPullback fst' snd' f g := by
  apply IsPullback.of_iso h i (Iso.refl _) (Iso.refl _) (Iso.refl _) <;> aesop_cat

lemma of_iso3 {P X X' Y Z : C}
    {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} {fst : P ‚ü∂ X} {snd : P ‚ü∂ Y}
    {f' : X' ‚ü∂ Z} {fst' : P ‚ü∂ X'}
    (h : IsPullback fst snd f g) (i : X ‚âÖ X')
    (commfst : fst ‚â´ i.hom = fst')
    (commf : f = i.hom ‚â´ f') :
    IsPullback fst' snd f' g := by
  apply IsPullback.of_iso h (Iso.refl _) i (Iso.refl _) (Iso.refl _) <;> aesop_cat

end IsPullback

namespace Subobject

/-! ### Additional lemmas about pullbacks and subobjects -/

open Subobject

@[simp]
lemma mk_arrow_mk {X : C} (m : MonoOver X) :
    mk m.arrow = ‚ü¶m‚üß :=
  rfl

section Pullback

lemma isPullback_eq {X Y Z : C} {x x' : Subobject X}
    {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} {k : (x : C) ‚ü∂ Y} {k' : (x' : C) ‚ü∂ Y}
    (h : IsPullback k x.arrow g f) (h' : IsPullback k' x'.arrow g f) :
    x = x' := by
  let i := @IsPullback.isoIsPullback _ _ _ _ _ _ _ _ _ _ _ _ _ h h'
  apply eq_of_comm i
  simp [i]

lemma isPullback_mk {X Y Z : C}
    (f : Y ‚ü∂ Z) (g : X ‚ü∂ Z) [HasPullback f g] [Mono f] :
    let œÄ‚ÇÅ := pullback.fst f g;
    let œÄ‚ÇÇ := pullback.snd f g;
    IsPullback ((underlyingIso œÄ‚ÇÇ).hom ‚â´ œÄ‚ÇÅ) (mk œÄ‚ÇÇ).arrow f g := by
  intro œÄ‚ÇÅ œÄ‚ÇÇ
  apply IsPullback.of_iso1 (IsPullback.of_hasPullback f g) (underlyingIso œÄ‚ÇÇ).symm <;> simp [œÄ‚ÇÅ, œÄ‚ÇÇ]

lemma isPullback_eq_mk {X Y Z : C} {x : Subobject X}
    {f : Y ‚ü∂ Z} {g : X ‚ü∂ Z} [HasPullback f g] [Mono f]
    {fst : (x : C) ‚ü∂ Y}
    (h : IsPullback fst x.arrow f g) :
    x = mk (pullback.snd f g) := by
  have h' := isPullback_mk f g
  apply isPullback_eq h h'

variable [HasPullbacks C]

lemma pullback_obj_representative {X Y : C} (f : Y ‚ü∂ X) (x : Subobject X) :
    (pullback f).obj x = mk ((MonoOver.pullback f).obj (representative.obj x)).arrow := by
  induction' x using Quotient.inductionOn' with m
  unfold pullback lower
  rw [mk_arrow_mk]
  dsimp
  apply Quotient.sound
  constructor
  apply Functor.mapIso
  symm
  exact (representativeIso _)

@[simp]
lemma pullback_obj {X Y : C} (f : Y ‚ü∂ X) (x : Subobject X) :
    (pullback f).obj x = mk (pullback.snd x.arrow f) := by
  rw [pullback_obj_representative]
  rfl

end Pullback

/-! ### The notion of subobject classifier -/

section SubobjectClassifier

/-- A monomorphism `f` from the terminal object `‚ä§_ C` is a subobject classifier when it satisfies
    the universal property that every subobject is uniquely a pullback of `f`.
-/
def IsClassifier [HasTerminal C] {Œ© : C} (f : ‚ä§_ C ‚ü∂ Œ©) :=
  Œ† {X : C} (x : Subobject X),
  Unique {œÜ : X ‚ü∂ Œ© // IsPullback (terminal.from (x : C)) x.arrow f œÜ}

variable (C : Type u) [Category.{v} C] [HasTerminal C]

/-- The data for a subobject classifier consists of an object `Œ©` of "truth values", together with a
    morphism `t : ‚ä§_ C ‚ü∂ Œ©` and a proof that `t` is a subobject classifier.
-/
class Classifier where
  /-- The object of "truth values". -/
  Œ© : C
  /-- The subobject classifier, which is a generalized element of `Œ©` denoting the truth value that
      is "always true". -/
  t : ‚ä§_ C ‚ü∂ Œ©
  /-- A proof that `t` satisfies the property of being a subobject classifier. -/
  is_classifier : IsClassifier t

/-- The mere existence of a subobject classifier. -/
class HasClassifier : Prop where
  has_classifier : Nonempty (Classifier C)

open Classifier

variable {C : Type u} [Category.{v} C] [HasTerminal C] [Classifier C]

/-- `truth` is the subobject associated to the subobject classifier `t`. -/
noncomputable def truth : Subobject (C := C) Œ© := Subobject.mk t

/-- `x.cmap` is the unique characteristic map of subobject `x` given by the `IsClassifier` property.
-/
def cmap {X : C} (x : Subobject X) : X ‚ü∂ Œ© :=
  (is_classifier x).default.val

/-- `œá_ x` is short for `x.cmap`. -/
abbrev œá_ {X : C} (x : Subobject X) := x.cmap

variable [HasPullbacks C]

/-- `compr œá` builds the subobject whose characteristic map is `œá` by pulling back `truth` along
    `œá`. This generalizes the construction of a subset "by comprehension" from its characteristic
    function in set theory. -/
noncomputable def compr {X : C} (œá : X ‚ü∂ Œ©) : Subobject X :=
  (pullback œá).obj truth

lemma compr_isPullback {X : C} (œá : X ‚ü∂ Œ©) :
    IsPullback (terminal.from (compr œá : C)) (compr œá).arrow t œá := by
  have h := IsPullback.of_hasPullback t œá
  let i : (compr œá : C) ‚âÖ Limits.pullback t œá := underlyingIso _
  apply IsPullback.of_iso1 h i.symm _ _ <;> try aesop_cat
  have heq : (compr œá).arrow = (mk (pullback.snd t œá)).arrow := by rfl
  simp [heq, i]

lemma compr_cmap {X : C} (x : Subobject X) :
    compr (œá_ x) = x := by
  have h : IsPullback (terminal.from (x : C)) x.arrow t (œá_ x) :=
    (is_classifier x).default.property
  have h' : IsPullback (terminal.from (compr (œá_ x) : C)) (compr (œá_ x)).arrow t (œá_ x) := by
    apply compr_isPullback
  apply isPullback_eq h' h

lemma cmap_compr {X : C} (œÜ : X ‚ü∂ Œ©) :
    œá_ (compr œÜ) = œÜ := by
  have h := compr_isPullback œÜ
  have h' := compr_isPullback (œá_ (compr œÜ))
  rw [compr_cmap] at h'
  have heq := unique_eq (is_classifier (compr œÜ)) ‚ü®œÜ, h‚ü© ‚ü®œá_ (compr œÜ), h'‚ü©
  simp [‚Üê Subtype.mk_eq_mk.1 heq]

end SubobjectClassifier

/-! ### The subobjects presheaf `sub` -/

section SubPresheaf

variable [HasPullbacks C]

/-- `sub` is the presheaf that sends every object `X : C` to its category of subobjects
    `Subobject X`, and every morphism `f : X ‚ü∂ Y` to the function `Subobject Y ‚Üí Subobject X`
    that maps every subobject of `Y` to its pullback along `f`. -/
noncomputable def sub : C·µí·µñ ‚•§ Type (max u v) where
  obj X := (@Subobject C _ X.unop)

  map f := (pullback f.unop).obj

  map_id := by
    simp only
    intro X
    funext
    rw [unop_id, pullback_id]
    simp

  map_comp := by
    simp only
    intro X Y Z f g
    funext
    rw [unop_comp, pullback_comp]
    simp

end SubPresheaf

/-! ### The representability theorem of subobject classifiers -/

open Classifier

variable [HasTerminal C] [HasPullbacks C]

/-- A category has a subobject classifier if and only if the subobjects functor is representable. -/
theorem isRepresentable_hasClassifier_iff : HasClassifier C ‚Üî (@sub C).IsRepresentable := by
  constructor <;> intro h

  ¬∑ obtain ‚ü®‚ü®ùíû‚ü©‚ü© := h
    exists Œ©
    constructor
    exact {
      /- The correspondence `compr` sending each map `œÜ : X ‚ü∂ Œ©` to the corresponding subobject is a
         bijection with `cmap` as inverse. -/
      homEquiv := {
        toFun := compr
        invFun := cmap
        left_inv := cmap_compr
        right_inv := compr_cmap
      }
      /- Furthermore, this bijection is natural by the fact that two pullback squares placed side by
         side yield a pullback rectangle (lemma `Subobject.pullback_comp`). -/
      homEquiv_comp := by
        intro X X' f g
        simp only [sub, Equiv.coe_fn_mk, compr, Quiver.Hom.unop_op, pullback_comp]
    }

  ¬∑ obtain ‚ü®Œ©, ‚ü®‚ü®Œ∏, hŒ∏‚ü©‚ü©‚ü© := h

    let œÜ := fun {X} (x : Subobject X) ‚Ü¶ Œ∏.symm x
    have hœÜ : ‚àÄ {X} (œá : X ‚ü∂ Œ©), œá = œÜ (Œ∏ œá) := by simp [œÜ]

    let Œ©‚ÇÄ : Subobject Œ© := Œ∏ (ùüô _)
    let t‚ÇÄ := Œ©‚ÇÄ.arrow
    have t‚ÇÄ_mono : Mono t‚ÇÄ := inferInstance

    have hx_pullback : ‚àÄ {X} (x : Subobject X), x = (pullback (œÜ x)).obj Œ©‚ÇÄ := by
      intro X x
      have := hŒ∏ (Œ∏.symm x) (ùüô _)
      simp only [Category.comp_id, Equiv.apply_symm_apply] at this
      rw (occs := .pos [1]) [this]
      simp [sub, œÜ, Œ©‚ÇÄ]

    have hx_mk : ‚àÄ {X} (x : Subobject X), x = Subobject.mk (pullback.snd t‚ÇÄ (œÜ x)) := by
      intro X x
      rw (occs := .pos [1]) [hx_pullback x, pullback_obj]

    let Œπ : ‚àÄ {X} (x : Subobject X), (x : C) ‚âÖ Limits.pullback t‚ÇÄ (œÜ x) := by
      intro X x
      rw (occs := .pos [1]) [hx_mk x]
      exact (underlyingIso (pullback.snd t‚ÇÄ (œÜ x)))

    let œÄ‚ÇÅ := fun {X} (x : Subobject X) ‚Ü¶ (Œπ x).hom ‚â´ pullback.fst t‚ÇÄ (œÜ x)

    have isPullback_œÜ : ‚àÄ {X} (x : Subobject X), IsPullback (œÄ‚ÇÅ x) x.arrow t‚ÇÄ (œÜ x) := by
      intro X x
      have h := isPullback_mk t‚ÇÄ (œÜ x)
      have hx := hx_mk x
      dsimp at h
      rw (occs := .pos [1,2,3]) [hx]
      have h1 : ((underlyingIso (pullback.snd t‚ÇÄ (œÜ x))).hom ‚â´ pullback.fst t‚ÇÄ (œÜ x)) =
                (œÄ‚ÇÅ (Subobject.mk (pullback.snd t‚ÇÄ (œÜ x)))) := by
        congr; try exact hx
        dsimp [Œπ]
        set hc := Eq.symm (congrArg (fun _a ‚Ü¶ underlying.obj _a ‚âÖ Limits.pullback t‚ÇÄ
                                              (œÜ (Subobject.mk (pullback.snd t‚ÇÄ (œÜ x)))))
                                    (hx_mk (Subobject.mk (pullback.snd t‚ÇÄ (œÜ x)))))
        have := cast_heq hc ((underlyingIso (pullback.snd t‚ÇÄ
                                             (œÜ (Subobject.mk (pullback.snd t‚ÇÄ (œÜ x)))))))
        symm
        apply HEq.trans this
        symm
        congr
      rw [‚Üê h1]
      exact h

    have isPullback_uniq : ‚àÄ {X} (x : Subobject X) œà œá, IsPullback œà x.arrow t‚ÇÄ œá ‚Üí œá = œÜ x := by
      intro X x œà œá hœá
      rw [hœÜ œá]
      congr
      specialize hŒ∏ œá (ùüô _)
      rw [Category.comp_id] at hŒ∏
      rw [hŒ∏]
      dsimp [sub]
      rw [pullback_obj, isPullback_eq_mk hœá]
      rfl

    let classifier : ‚àÄ {X} (x : Subobject X), Unique {œá // IsPullback (œÄ‚ÇÅ x) x.arrow t‚ÇÄ œá} := by
      intro X x
      refine ‚ü®‚ü®œÜ x, isPullback_œÜ x‚ü©, ?uniq‚ü©
      intro h
      obtain ‚ü®œá, hœá‚ü© := h
      congr
      exact (isPullback_uniq _ _ _ hœá)

    have isTerminal_Œ©‚ÇÄ : IsTerminal (Œ©‚ÇÄ : C) := by
      have : (X : C) ‚Üí Unique (X ‚ü∂ Œ©‚ÇÄ) := by
        intro X
        let s := Subobject.mk (ùüô X)
        let œÜ' := œÄ‚ÇÅ s
        let i : X ‚âÖ s := by dsimp [s]; exact (underlyingIso (ùüô X)).symm
        let œÜX := (i.hom ‚â´ œÜ')
        refine { default := œÜX, uniq := ?_ }
        intro œÜX'
        dsimp [default]
        have hœà : ‚àÄ œà, IsPullback œà (ùüô X) t‚ÇÄ (œà ‚â´ t‚ÇÄ) := by
          intro œà
          constructor
          ¬∑ constructor
            apply PullbackCone.IsLimit.mk (lift := fun c ‚Ü¶ c.snd) <;> intro c
            ¬∑ apply Mono.right_cancellation (f := t‚ÇÄ)
              rw [c.condition]
              simp
            ¬∑ simp
            ¬∑ intro m hm1 hm2
              rw [‚Üê hm2]
              simp
          ¬∑ simp
        have hX := hœà œÜX
        have hX' := hœà œÜX'
        have hœÜX := isPullback_uniq s (œÄ‚ÇÅ s) (œÜX ‚â´ t‚ÇÄ)
        have hœÜX' := isPullback_uniq s (i.inv ‚â´ œÜX') (œÜX' ‚â´ t‚ÇÄ)
        have h : œÜX ‚â´ t‚ÇÄ = œÜX' ‚â´ t‚ÇÄ := by
          rw [hœÜX, hœÜX']
          ¬∑ apply IsPullback.of_iso1 hX' i
            ¬∑ simp
            ¬∑ simp [i, s]
          ¬∑ apply IsPullback.of_iso1 hX i
            ¬∑ simp only [œÜX, œÜ']
            ¬∑ simp [i, s]
        exact Mono.right_cancellation _ _ h.symm
      apply IsTerminal.ofUnique

    have i : ‚ä§_ C ‚âÖ Œ©‚ÇÄ := by
      apply IsTerminal.uniqueUpToIso
      exact terminalIsTerminal
      exact isTerminal_Œ©‚ÇÄ

    constructor; constructor
    exact {
      Œ© := Œ©
      t := i.hom ‚â´ t‚ÇÄ
      is_classifier := by
        intro X x
        refine { default := ‚ü®œÜ x, ?_‚ü©, uniq := ?_ }
        ¬∑ apply IsPullback.of_iso3 (isPullback_œÜ x) i.symm
          ¬∑ apply unique_eq (uniqueToTerminal _)
          ¬∑ simp
        ¬∑ simp only [Subtype.forall, Subtype.mk.injEq]
          intro œá hœá
          apply isPullback_uniq x (terminal.from (x : C) ‚â´ i.hom) œá
          apply IsPullback.of_iso3 hœá i <;> rfl
    }

end Subobject
end CategoryTheory
