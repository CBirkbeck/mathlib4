/-
Copyright (c) 2018 Michael Jendrusch. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Michael Jendrusch, Scott Morrison, Bhavik Mehta, Brendan Murphy
-/
import Mathlib.CategoryTheory.Monoidal.Category
import Mathlib.CategoryTheory.Adjunction.Opposites
import Mathlib.CategoryTheory.Adjunction.Mates

#align_import category_theory.monoidal.functor from "leanprover-community/mathlib"@"3d7987cda72abc473c7cdbbb075170e9ac620042"

/-!
# (Co)Lax and strong monoidal functors

A lax monoidal functor `F` between monoidal categories `C` and `D`
is a functor between the underlying categories equipped with morphisms
* `Œ∑ : ùüô_ D ‚ü∂ F.obj (ùüô_ C)` (called the unit morphism)
* `Œº X Y : (F.obj X) ‚äó (F.obj Y) ‚ü∂ F.obj (X ‚äó Y)` (called the tensorator, or strength).
satisfying various axioms.
It is more common in the literature to use `Œµ` in place of `Œ∑`, but this
is inconsistent with the convention that `Œ∑` is a unit and `Œµ` is a counit for
(co)monoid objects (this is how the symbols are used for monads, comonads and bialgebras).

A colax monoidal functor `F` between monoidal categories `C` and `D`
is a functor between the underlying categories equipped with morphisms
* `Œµ : F.obj (ùüô_ C) ‚ü∂ ùüô_ D` (called the counit morphism)
* `Œ¥ X Y : F.obj (X ‚äó Y) ‚ü∂ (F.obj X) ‚äó (F.obj Y)` (called the cotensorator).
satisfying various axioms.
These are equivalent to lax monoidal functors between `C·µí·µñ` and `D·µí·µñ`.
An alternate name for these is oplax monoidal.

A (strong) monoidal functor is equivalently
* A lax monoidal functor for which `Œ∑` and `Œº` are isomorphisms.
* A colax monoidal functor for which `Œµ` and `Œ¥` are isomorphisms.
* A pair of lax and colax structures on a functor where `Œ∑, Œµ` and `Œº, Œ¥` are inverse pairs.

We show that the composition of ((co)lax) monoidal functors gives a ((co)lax) monoidal functor.

See also `CategoryTheory.Monoidal.Functorial` for a typeclass decorating an object-level
function with the additional data of a monoidal functor.
This is useful when stating that a pre-existing functor is monoidal.

See `CategoryTheory.Monoidal.NaturalTransformation` for monoidal natural transformations.

We show in `CategoryTheory.Monoidal.Mon_` that lax monoidal functors take monoid objects
to monoid objects.

## References

See <https://stacks.math.columbia.edu/tag/0FFL>.
-/


open CategoryTheory
open Quiver.Hom (op_inj unop_inj)

universe v‚ÇÄ u‚ÇÄ v‚ÇÅ v‚ÇÇ v‚ÇÉ u‚ÇÅ u‚ÇÇ u‚ÇÉ

open CategoryTheory.Category

open CategoryTheory.Functor

namespace CategoryTheory

variable {B : Type u‚ÇÄ} [Category.{v‚ÇÄ} B] [MonoidalCategory.{v‚ÇÄ} B]
  (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] [MonoidalCategory.{v‚ÇÅ} C]
  (D : Type u‚ÇÇ) [Category.{v‚ÇÇ} D] [MonoidalCategory.{v‚ÇÇ} D]
  {E : Type u‚ÇÉ} [Category.{v‚ÇÉ} E] [MonoidalCategory.{v‚ÇÉ} E]

open MonoidalCategory

-- The direction of `left_unitality` and `right_unitality` as simp lemmas may look strange:
-- remember the rule of thumb that component indices of natural transformations
-- "weigh more" than structural maps.
-- (However by this argument `associativity` is currently stated backwards!)
/-- A lax monoidal functor is a functor `F : C ‚•§ D` between monoidal categories,
equipped with morphisms `Œ∑ : ùüô _D ‚ü∂ F.obj (ùüô_ C)` and
`Œº X Y : F.obj X ‚äó F.obj Y ‚ü∂ F.obj (X ‚äó Y)`, satisfying the appropriate coherences. -/
structure LaxMonoidalFunctor extends C ‚•§ D where
  /-- unit morphism -/
  Œ∑ : ùüô_ D ‚ü∂ obj (ùüô_ C)
  /-- tensorator -/
  Œº : ‚àÄ X Y : C, obj X ‚äó obj Y ‚ü∂ obj (X ‚äó Y)
  Œº_natural_left :
    ‚àÄ {X Y : C} (f : X ‚ü∂ Y) (X' : C),
      (map f ‚äó ùüô (obj X')) ‚â´ Œº Y X' = Œº X X' ‚â´ map (f ‚äó ùüô X') := by
    aesop_cat
  Œº_natural_right :
    ‚àÄ {X Y : C} (X' : C) (f : X ‚ü∂ Y) ,
      (ùüô (obj X') ‚äó map f) ‚â´ Œº X' Y = Œº X' X ‚â´ map (ùüô X' ‚äó f) := by
    aesop_cat
  /-- associativity of the tensorator -/
  associativity :
    ‚àÄ X Y Z : C,
      (Œº X Y ‚äó ùüô (obj Z)) ‚â´ Œº (X ‚äó Y) Z ‚â´ map (Œ±_ X Y Z).hom =
        (Œ±_ (obj X) (obj Y) (obj Z)).hom ‚â´ (ùüô (obj X) ‚äó Œº Y Z) ‚â´ Œº X (Y ‚äó Z) := by
    aesop_cat
  -- unitality
  left_unitality : ‚àÄ X : C, (Œª_ (obj X)).hom = (Œ∑ ‚äó ùüô (obj X)) ‚â´ Œº (ùüô_ C) X ‚â´ map (Œª_ X).hom :=
    by aesop_cat
  right_unitality : ‚àÄ X : C, (œÅ_ (obj X)).hom = (ùüô (obj X) ‚äó Œ∑) ‚â´ Œº X (ùüô_ C) ‚â´ map (œÅ_ X).hom :=
    by aesop_cat
#align category_theory.lax_monoidal_functor CategoryTheory.LaxMonoidalFunctor

/-- Notation for a lax monoidal functor between monoidal categories. -/
scoped [CategoryTheory] infixr:26 " ‚•§‚äó‚Ñì " => LaxMonoidalFunctor

/-- A colax monoidal functor is a functor `F : C ‚•§ D` between monoidal categories,
equipped with morphisms `Œµ : F.obj (ùüô_ C) ‚ü∂ ùüô _D` and
`Œ¥ X Y : F.obj (X ‚äó Y) ‚ü∂ F.obj X ‚äó F.obj Y`, satisfying the appropriate coherences. -/
structure ColaxMonoidalFunctor extends C ‚•§ D where
  /-- counit morphism -/
  Œµ : obj (ùüô_ C) ‚ü∂ ùüô_ D
  /-- cotensorator -/
  Œ¥ : ‚àÄ X Y : C, obj (X ‚äó Y) ‚ü∂ obj X ‚äó obj Y
  Œ¥_natural_left :
    ‚àÄ {X Y : C} (f : X ‚ü∂ Y) (X' : C),
      map (f ‚äó ùüô X') ‚â´ Œ¥ Y X' = Œ¥ X X' ‚â´ (map f ‚äó ùüô (obj X')) := by
    aesop_cat
  Œ¥_natural_right :
    ‚àÄ {X Y : C} (X' : C) (f : X ‚ü∂ Y) ,
      map (ùüô X' ‚äó f) ‚â´ Œ¥ X' Y = Œ¥ X' X ‚â´ (ùüô (obj X') ‚äó map f) := by
    aesop_cat
  /-- coassociativity of the cotensorator -/
  coassociativity :
    ‚àÄ X Y Z : C,
      map (Œ±_ X Y Z).hom ‚â´ Œ¥ X (Y ‚äó Z) ‚â´ (ùüô (obj X) ‚äó Œ¥ Y Z) =
        Œ¥ (X ‚äó Y) Z ‚â´ (Œ¥ X Y ‚äó ùüô (obj Z)) ‚â´ (Œ±_ (obj X) (obj Y) (obj Z)).hom := by
    aesop_cat
  -- unitality
  left_counitality : ‚àÄ X : C, Œ¥ (ùüô_ C) X ‚â´ (Œµ ‚äó ùüô (obj X)) ‚â´ (Œª_ (obj X)).hom = map (Œª_ X).hom :=
    by aesop_cat
  right_counitality : ‚àÄ X : C, Œ¥ X (ùüô_ C) ‚â´ (ùüô (obj X) ‚äó Œµ) ‚â´ (œÅ_ (obj X)).hom = map (œÅ_ X).hom :=
    by aesop_cat

/-- Notation for a colax monoidal functor between monoidal categories. -/
scoped [CategoryTheory] infixr:26 " ‚•§‚äóc " => ColaxMonoidalFunctor
-- very irritating that unicode doesn't have a subscript c

/--
A monoidal functor is a lax monoidal functor for which the tensorator and unitor are isomorphisms,
equivalently a colax monoidal functor for which the cotensorator and the counitor are isomorphisms,
equivalently a pair of a lax and colax monoidal functors which have the same underlying functor
and where the structure maps are inverses.

See <https://stacks.math.columbia.edu/tag/0FFL>.
-/
structure MonoidalFunctor
    extends LaxMonoidalFunctor.{v‚ÇÅ, v‚ÇÇ} C D, ColaxMonoidalFunctor.{v‚ÇÅ, v‚ÇÇ} C D where
  Œ∑_Œµ_id : Œ∑ ‚â´ Œµ = ùüô (ùüô_ D) := by aesop_cat
  Œµ_Œ∑_id : Œµ ‚â´ Œ∑ = ùüô (obj (ùüô_ C)) := by aesop_cat
  Œº_Œ¥_id : (X Y : C) ‚Üí Œº X Y ‚â´ Œ¥ X Y = ùüô (obj X ‚äó obj Y) := by aesop_cat
  Œ¥_Œº_id : (X Y : C) ‚Üí Œ¥ X Y ‚â´ Œº X Y = ùüô (obj (X ‚äó Y)) := by aesop_cat
#align category_theory.monoidal_functor CategoryTheory.MonoidalFunctor

/-- Notation for a (strong) monoidal functor between monoidal categories. -/
scoped [CategoryTheory] infixr:26 " ‚•§‚äós " => MonoidalFunctor

--Porting note: was `[simp, reassoc.1]`
attribute [reassoc (attr := simp)] LaxMonoidalFunctor.Œº_natural_left
attribute [reassoc (attr := simp)] LaxMonoidalFunctor.Œº_natural_right

attribute [simp] LaxMonoidalFunctor.left_unitality

attribute [simp] LaxMonoidalFunctor.right_unitality

--Porting note: was `[simp, reassoc.1]`
attribute [reassoc (attr := simp)] LaxMonoidalFunctor.associativity

attribute [reassoc (attr := simp)] ColaxMonoidalFunctor.Œ¥_natural_left
attribute [reassoc (attr := simp)] ColaxMonoidalFunctor.Œ¥_natural_right

attribute [simp] ColaxMonoidalFunctor.left_counitality
attribute [simp] ColaxMonoidalFunctor.right_counitality

attribute [reassoc (attr := simp)] ColaxMonoidalFunctor.coassociativity

attribute [reassoc (attr := simp)] MonoidalFunctor.Œ∑_Œµ_id
attribute [reassoc (attr := simp)] MonoidalFunctor.Œµ_Œ∑_id
attribute [reassoc (attr := simp)] MonoidalFunctor.Œº_Œ¥_id
attribute [reassoc (attr := simp)] MonoidalFunctor.Œ¥_Œº_id

initialize_simps_projections ColaxMonoidalFunctor (+toFunctor, -obj, -map)
initialize_simps_projections LaxMonoidalFunctor (+toFunctor, -obj, -map)
initialize_simps_projections MonoidalFunctor (+toFunctor, -obj, -map)

variable {C D}

section bootstrap

namespace LaxMonoidalFunctor

variable (F : C ‚•§‚äó‚Ñì D)

--Porting note: was `[simp, reassoc.1]`
@[reassoc (attr := simp)]
theorem left_unitality_inv (X : C) :
    (Œª_ (F.obj X)).inv ‚â´ (F.Œ∑ ‚äó ùüô (F.obj X)) ‚â´ F.Œº (ùüô_ C) X = F.map (Œª_ X).inv := by
  rw [Iso.inv_comp_eq, F.left_unitality, Category.assoc, Category.assoc, ‚Üê F.map_comp,
    Iso.hom_inv_id, F.map_id, comp_id]
#align category_theory.lax_monoidal_functor.left_unitality_inv CategoryTheory.LaxMonoidalFunctor.left_unitality_inv

--Porting note: was `[simp, reassoc.1]`
@[reassoc (attr := simp)]
theorem right_unitality_inv (X : C) :
    (œÅ_ (F.obj X)).inv ‚â´ (ùüô (F.obj X) ‚äó F.Œ∑) ‚â´ F.Œº X (ùüô_ C) = F.map (œÅ_ X).inv := by
  rw [Iso.inv_comp_eq, F.right_unitality, Category.assoc, Category.assoc, ‚Üê F.map_comp,
    Iso.hom_inv_id, F.map_id, comp_id]
#align category_theory.lax_monoidal_functor.right_unitality_inv CategoryTheory.LaxMonoidalFunctor.right_unitality_inv

--Porting note: was `[simp, reassoc.1]`
@[reassoc (attr := simp)]
theorem associativity_inv (X Y Z : C) :
    (ùüô (F.obj X) ‚äó F.Œº Y Z) ‚â´ F.Œº X (Y ‚äó Z) ‚â´ F.map (Œ±_ X Y Z).inv =
      (Œ±_ (F.obj X) (F.obj Y) (F.obj Z)).inv ‚â´ (F.Œº X Y ‚äó ùüô (F.obj Z)) ‚â´ F.Œº (X ‚äó Y) Z := by
  rw [Iso.eq_inv_comp, ‚Üê F.associativity_assoc, ‚Üê F.map_comp, Iso.hom_inv_id,
    F.map_id, comp_id]
#align category_theory.lax_monoidal_functor.associativity_inv CategoryTheory.LaxMonoidalFunctor.associativity_inv

end LaxMonoidalFunctor

namespace ColaxMonoidalFunctor

variable (F : C ‚•§‚äóc D)

@[reassoc (attr := simp)]
theorem left_counitality_inv (X : C) :
    F.map (Œª_ X).inv ‚â´ F.Œ¥ (ùüô_ C) X ‚â´ (F.Œµ ‚äó ùüô (F.obj X)) = (Œª_ (F.obj X)).inv := by
  rw [‚Üê mapIso_inv, Iso.inv_comp_eq, mapIso_hom, ‚Üê F.left_counitality,
      Category.assoc, Category.assoc, Iso.hom_inv_id, comp_id]

@[reassoc (attr := simp)]
theorem right_counitality_inv (X : C) :
    F.map (œÅ_ X).inv ‚â´ F.Œ¥ X (ùüô_ C) ‚â´ (ùüô (F.obj X) ‚äó F.Œµ) = (œÅ_ (F.obj X)).inv := by
  rw [‚Üê mapIso_inv, Iso.inv_comp_eq, mapIso_hom, ‚Üê F.right_counitality,
      Category.assoc, Category.assoc, Iso.hom_inv_id, comp_id]

@[reassoc (attr := simp)]
theorem coassociativity_inv (X Y Z : C) :
    F.map (Œ±_ X Y Z).inv ‚â´ F.Œ¥ (X ‚äó Y) Z ‚â´ (F.Œ¥ X Y ‚äó ùüô (F.obj Z)) =
      F.Œ¥ X (Y ‚äó Z) ‚â´ (ùüô (F.obj X) ‚äó F.Œ¥ Y Z) ‚â´ (Œ±_ (F.obj X) (F.obj Y) (F.obj Z)).inv := by
  rw [‚Üê mapIso_inv, Iso.inv_comp_eq, mapIso_hom, F.coassociativity_assoc,
      Iso.hom_inv_id, comp_id]

end ColaxMonoidalFunctor

end bootstrap

section opposites

attribute [local ext] unop_inj in
@[simps, pp_dot]
def LaxMonoidalFunctor.op (F : C ‚•§‚äó‚Ñì D) : C·µí·µñ ‚•§‚äóc D·µí·µñ where
  Œµ := F.Œ∑.op
  Œ¥ X Y := (F.Œº X.unop Y.unop).op
  __ := F.toFunctor.op

@[simps, pp_dot]
def LaxMonoidalFunctor.unop (F : C·µí·µñ ‚•§‚äó‚Ñì D·µí·µñ) : C ‚•§‚äóc D where
  Œµ := F.Œ∑.unop
  Œ¥ X Y := (F.Œº (.op X) (.op Y)).unop
  Œ¥_natural_left f X' := op_inj <| by simp
  Œ¥_natural_right X' f := op_inj <| by simp
  coassociativity X Y Z := op_inj <| by simp
  left_counitality X := op_inj <| by simp
  right_counitality X := op_inj <| by simp
  __ := F.toFunctor.unop

attribute [local ext] unop_inj in
@[simps, pp_dot]
def ColaxMonoidalFunctor.op (F : C ‚•§‚äóc D) : C·µí·µñ ‚•§‚äó‚Ñì D·µí·µñ where
  Œ∑ := F.Œµ.op
  Œº X Y := (F.Œ¥ X.unop Y.unop).op
  __ := F.toFunctor.op

@[simps, pp_dot]
def ColaxMonoidalFunctor.unop (F : C·µí·µñ ‚•§‚äóc D·µí·µñ) : C ‚•§‚äó‚Ñì D where
  Œ∑ := F.Œµ.unop
  Œº X Y := (F.Œ¥ (.op X) (.op Y)).unop
  Œº_natural_left f X' := op_inj <| by simp
  Œº_natural_right X' f := op_inj <| by simp
  associativity X Y Z := op_inj <| by simp
  left_unitality X := op_inj <| by simp
  right_unitality X := op_inj <| by simp
  __ := F.toFunctor.unop

attribute [local ext] unop_inj in
@[simps! Œµ Œ∑ Œ¥ Œº toFunctor, pp_dot]
def MonoidalFunctor.op (F : C ‚•§‚äós D) : C·µí·µñ ‚•§‚äós D·µí·µñ where
  __ := F.toLaxMonoidalFunctor.op
  __ := F.toColaxMonoidalFunctor.op

@[simps! Œµ Œ∑ Œ¥ Œº toFunctor, pp_dot]
def MonoidalFunctor.unop (F : C·µí·µñ ‚•§‚äós D·µí·µñ) : C ‚•§‚äós D where
  Œ∑_Œµ_id := op_inj <| by simp
  Œµ_Œ∑_id := op_inj <| by simp
  Œº_Œ¥_id X Y := op_inj <| by simp
  Œ¥_Œº_id X Y := op_inj <| by simp
  __ := F.toLaxMonoidalFunctor.unop
  __ := F.toColaxMonoidalFunctor.unop

end opposites

-- When `rewrite_search` lands, add @[search] attributes to
-- LaxMonoidalFunctor.Œº_natural LaxMonoidalFunctor.left_unitality
-- LaxMonoidalFunctor.right_unitality LaxMonoidalFunctor.associativity
namespace LaxMonoidalFunctor

section

variable (F : C ‚•§‚äó‚Ñì D)

@[reassoc (attr := simp)]
theorem Œº_natural {X Y X' Y' : C} (f : X ‚ü∂ Y) (g : X' ‚ü∂ Y') :
      (F.map f ‚äó F.map g) ‚â´ F.Œº Y Y' = F.Œº X X' ‚â´ F.map (f ‚äó g) := by
  rw [‚Üê id_tensor_comp_tensor_id_assoc, Œº_natural_left, Œº_natural_right_assoc,
      ‚Üê F.map_comp, id_tensor_comp_tensor_id]

/-- The tensorator of a lax monoidal functor as a natural transformation. -/
@[simps, pp_dot]
def ŒºNatTrans : .prod F.toFunctor F.toFunctor ‚ãô tensor D ‚ü∂ tensor C ‚ãô F.toFunctor where
  app XY := F.Œº XY.1 XY.2

@[reassoc (attr := simp)]
theorem associativity' (X Y Z : C) :
    (F.Œº X Y ‚ñ∑ F.obj Z) ‚â´ F.Œº (X ‚äó Y) Z ‚â´ F.map (Œ±_ X Y Z).hom =
        (Œ±_ (F.obj X) (F.obj Y) (F.obj Z)).hom ‚â´ ((F.obj X) ‚óÅ F.Œº Y Z) ‚â´ F.Œº X (Y ‚äó Z) := by
  simp [‚Üê id_tensorHom, ‚Üê tensorHom_id]

@[reassoc]
theorem left_unitality' (X : C) :
    (Œª_ (F.obj X)).hom = (F.Œ∑ ‚ñ∑ F.obj X) ‚â´ F.Œº (ùüô_ C) X ‚â´ F.map (Œª_ X).hom := by
  simp [‚Üê id_tensorHom, ‚Üê tensorHom_id]

@[reassoc]
theorem right_unitality' (X : C) :
    (œÅ_ (F.obj X)).hom = (F.obj X ‚óÅ F.Œ∑) ‚â´ F.Œº X (ùüô_ C) ‚â´ F.map (œÅ_ X).hom := by
  simp [‚Üê id_tensorHom, ‚Üê tensorHom_id]

@[reassoc (attr := simp)]
theorem Œº_natural_left' {X Y : C} (f : X ‚ü∂ Y) (X' : C) :
      F.map f ‚ñ∑ F.obj X' ‚â´ F.Œº Y X' = F.Œº X X' ‚â´ F.map (f ‚ñ∑ X') := by
  simp [‚Üê id_tensorHom, ‚Üê tensorHom_id]

@[reassoc (attr := simp)]
theorem Œº_natural_right' {X Y : C} (X' : C) (f : X ‚ü∂ Y) :
      F.obj X' ‚óÅ F.map f ‚â´ F.Œº X' Y = F.Œº X' X ‚â´ F.map (X' ‚óÅ f) := by
  simp [‚Üê id_tensorHom, ‚Üê tensorHom_id]

@[reassoc (attr := simp)]
theorem left_unitality_inv' (X : C) :
    (Œª_ (F.obj X)).inv ‚â´ (F.Œ∑ ‚ñ∑ F.obj X) ‚â´ F.Œº (ùüô_ C) X = F.map (Œª_ X).inv := by
  simp [‚Üê id_tensorHom, ‚Üê tensorHom_id]

@[reassoc (attr := simp)]
theorem right_unitality_inv' (X : C) :
    (œÅ_ (F.obj X)).inv ‚â´ (F.obj X ‚óÅ F.Œ∑) ‚â´ F.Œº X (ùüô_ C) = F.map (œÅ_ X).inv := by
  simp [‚Üê id_tensorHom, ‚Üê tensorHom_id]

@[reassoc (attr := simp)]
theorem associativity_inv' (X Y Z : C) :
    (F.obj X ‚óÅ F.Œº Y Z) ‚â´ F.Œº X (Y ‚äó Z) ‚â´ F.map (Œ±_ X Y Z).inv =
      (Œ±_ (F.obj X) (F.obj Y) (F.obj Z)).inv ‚â´ (F.Œº X Y ‚ñ∑ F.obj Z) ‚â´ F.Œº (X ‚äó Y) Z := by
  simp [‚Üê id_tensorHom, ‚Üê tensorHom_id]

#check F.associativity

/-
(F.obj X ‚äó F.obj Y) ‚äó F.obj Z ‚ü∂ F.obj (X ‚äó Y ‚äó Z)

F.toFunctor.prod (F.toFunctor.prod F.toFunctor) ‚ãô leftAssocTensor D ‚ü∂
rightAssocTensor C ‚ãô F.toFunctor
-/

/-
(Œº X Y ‚äó ùüô (F.obj Z)) ‚â´
  Œº (X ‚äó Y) Z ‚â´
    map (Œ±_ X Y Z).hom =
(Œ±_ (obj X) (obj Y) (obj Z)).hom ‚â´
  (ùüô (obj X) ‚äó Œº Y Z) ‚â´
    Œº X (Y ‚äó Z)
-/

namespace associativity_nat_trans
-- TODO: make these coherences isos
def coherence1 :=
  (Functor.associator _ _ _).inv ‚â´
    whiskerRight ((transferNatTrans (prod.associativity C C C).symm.toAdjunction
                                    (prod.associativity D D D).symm.toAdjunction).symm
                    (prod.associator_naturality _ _ _).hom)
                  ((tensor D).prod (ùü≠ D) ‚ãô tensor D) ‚â´
      (Functor.associator _ _ _).hom ‚â´
        whiskerLeft (prod.inverseAssociator C C C) ((Functor.associator _ _ _).inv ‚â´
          whiskerRight ((prodCompIso _ _ _ _).inv ‚â´
            .prod (ùüô (F.toFunctor.prod F.toFunctor ‚ãô tensor D))
                  F.toFunctor.rightUnitor.hom) (tensor D))

@[simp]
lemma coherence1_app (X : C √ó C √ó C) :
    (coherence1 F).app X = ùüô ((F.obj X.1 ‚äó F.obj X.2.1) ‚äó F.obj X.2.2) := by
  dsimp [coherence1, Equivalence.symm]
  simp only [map_id, comp_id, tensor_id]

def coherence2 :=
  whiskerLeft (prod.inverseAssociator C C C)
    (whiskerRight (.prod (ùüô _) F.toFunctor.leftUnitor.inv) (tensor D) ‚â´
      whiskerRight (prodCompIso _ _ _ _).hom (tensor D) ‚â´
        (((tensor C).prod (ùü≠ C)).associator (.prod F.toFunctor F.toFunctor) _).hom)

@[simp]
lemma coherence2_app (X : C √ó C √ó C) :
    (coherence2 F).app X = ùüô (F.obj (X.1 ‚äó X.2.1) ‚äó F.obj X.2.2) := by
  dsimp [coherence2]
  simp only [tensor_id, comp_id]

def coherence3 :=
  whiskerLeft (prod.inverseAssociator C C C)
    (Functor.associator ((tensor C).prod (ùü≠ C)) (tensor C) F.toFunctor).inv ‚â´
    (Functor.associator _ _ _).inv

@[simp]
lemma coherence3_app (X : C √ó C √ó C) :
    (coherence3 F).app X = ùüô (F.obj ((X.1 ‚äó X.2.1) ‚äó X.2.2)) := by
  dsimp [coherence3]
  simp only [comp_id]

-- lemma thm :
--     coherence1 F ‚â´ whiskerLeft _ (whiskerRight (.prod F.ŒºNatTrans (ùüô _)) _) ‚â´
--       coherence2 F ‚â´ whiskerLeft _ (whiskerLeft _ F.ŒºNatTrans) ‚â´
--         coherence3 F ‚â´ whiskerRight (associatorNatIso C).hom _ =
--   --   (Œ±_ (obj X) (obj Y) (obj Z)).hom ‚â´
--   -- (ùüô (obj X) ‚äó Œº Y Z) ‚â´
--   --   Œº X (Y ‚äó Z)

--     (by
--       let a := (associatorNatIso C).hom
--       unfold leftAssocTensor at
--       admit) := sorry

end associativity_nat_trans

end

/--
A constructor for lax monoidal functors whose axioms are described by `tensorHom` instead of
`whiskerLeft` and `whiskerRight`.
-/
@[simps]
def ofTensorHom (F : C ‚•§ D)
    /- unit morphism -/
    (Œ∑ : ùüô_ D ‚ü∂ F.obj (ùüô_ C))
    /- tensorator -/
    (Œº : ‚àÄ X Y : C, F.obj X ‚äó F.obj Y ‚ü∂ F.obj (X ‚äó Y))
    (Œº_natural :
      ‚àÄ {X Y X' Y' : C} (f : X ‚ü∂ Y) (g : X' ‚ü∂ Y'),
        (F.map f ‚äó F.map g) ‚â´ Œº Y Y' = Œº X X' ‚â´ F.map (f ‚äó g) := by
      aesop_cat)
    /- associativity of the tensorator -/
    (associativity :
      ‚àÄ X Y Z : C,
        (Œº X Y ‚äó ùüô (F.obj Z)) ‚â´ Œº (X ‚äó Y) Z ‚â´ F.map (Œ±_ X Y Z).hom =
          (Œ±_ (F.obj X) (F.obj Y) (F.obj Z)).hom ‚â´ (ùüô (F.obj X) ‚äó Œº Y Z) ‚â´ Œº X (Y ‚äó Z) :=
        by aesop_cat)
    /- unitality -/
    (left_unitality :
      ‚àÄ X : C, (Œª_ (F.obj X)).hom = (Œ∑ ‚äó ùüô (F.obj X)) ‚â´ Œº (ùüô_ C) X ‚â´ F.map (Œª_ X).hom :=
        by aesop_cat)
    (right_unitality :
      ‚àÄ X : C, (œÅ_ (F.obj X)).hom = (ùüô (F.obj X) ‚äó Œ∑) ‚â´ Œº X (ùüô_ C) ‚â´ F.map (œÅ_ X).hom :=
        by aesop_cat) : C ‚•§‚äó‚Ñì D where
  Œ∑ := Œ∑
  Œº := Œº
  Œº_natural_left := fun f X' => by
    simp_rw [‚Üê F.map_id, Œº_natural]
  Œº_natural_right := fun X' f => by
    simp_rw [‚Üê F.map_id, Œº_natural]
  associativity := associativity
  left_unitality := left_unitality
  right_unitality := right_unitality
  __ := F

end LaxMonoidalFunctor

namespace ColaxMonoidalFunctor

section

variable (F : C ‚•§‚äóc D)

@[reassoc (attr := simp)]
theorem Œ¥_natural {X Y X' Y' : C} (f : X ‚ü∂ Y) (g : X' ‚ü∂ Y') :
    F.map (f ‚äó g) ‚â´ F.Œ¥ Y Y' = F.Œ¥ X X' ‚â´ (F.map f ‚äó F.map g) :=
  op_inj <| Eq.symm <| F.op.Œº_natural f.op g.op

/-- The cotensorator of a colax monoidal functor as a natural transformation. -/
@[simps, pp_dot]
def Œ¥NatTrans : tensor C ‚ãô F.toFunctor ‚ü∂ .prod F.toFunctor F.toFunctor ‚ãô tensor D where
  app XY := F.Œ¥ XY.1 XY.2

@[reassoc (attr := simp)]
theorem coassociativity' (X Y Z : C) :
    F.map (Œ±_ X Y Z).hom ‚â´ F.Œ¥ X (Y ‚äó Z) ‚â´ (F.obj X ‚óÅ F.Œ¥ Y Z) =
      F.Œ¥ (X ‚äó Y) Z ‚â´ (F.Œ¥ X Y ‚ñ∑ F.obj Z) ‚â´ (Œ±_ (F.obj X) (F.obj Y) (F.obj Z)).hom := by
  convert op_inj (F.op.associativity_inv' (.op X) (.op Y) (.op Z)) using 1 <;> simp

@[reassoc]
theorem left_counitality' (X : C) :
    F.Œ¥ (ùüô_ C) X ‚â´ (F.Œµ ‚ñ∑ F.obj X) ‚â´ (Œª_ (F.obj X)).hom = F.map (Œª_ X).hom := by
  convert op_inj (F.op.left_unitality_inv' (.op X)) using 1; simp

@[reassoc]
theorem right_counitality' (X : C) :
    F.Œ¥ X (ùüô_ C) ‚â´ (F.obj X ‚óÅ F.Œµ) ‚â´ (œÅ_ (F.obj X)).hom = F.map (œÅ_ X).hom := by
  convert op_inj (F.op.right_unitality_inv' (.op X)) using 1; simp

@[reassoc (attr := simp)]
theorem Œ¥_natural_left' {X Y : C} (f : X ‚ü∂ Y) (X' : C) :
    F.map (f ‚ñ∑ X') ‚â´ F.Œ¥ Y X' = F.Œ¥ X X' ‚â´ (F.map f ‚ñ∑ F.obj X') :=
  op_inj (F.op.Œº_natural_left' f.op (.op X')).symm

@[reassoc (attr := simp)]
theorem Œº_natural_right' {X Y : C} (X' : C) (f : X ‚ü∂ Y) :
    F.map (X' ‚óÅ f) ‚â´ F.Œ¥ X' Y = F.Œ¥ X' X ‚â´ (F.obj X' ‚óÅ F.map f) :=
  op_inj (F.op.Œº_natural_right' (.op X') f.op).symm

@[reassoc (attr := simp)]
theorem left_counitality_inv' (X : C) :
    F.map (Œª_ X).inv ‚â´ F.Œ¥ (ùüô_ C) X ‚â´ (F.Œµ ‚ñ∑ F.obj X) = (Œª_ (F.obj X)).inv := by
  convert op_inj (F.op.left_unitality' (.op X)).symm using 1; simp

@[reassoc (attr := simp)]
theorem right_unitality_inv' (X : C) :
    F.map (œÅ_ X).inv ‚â´ F.Œ¥ X (ùüô_ C) ‚â´ (F.obj X ‚óÅ F.Œµ) = (œÅ_ (F.obj X)).inv := by
  convert op_inj (F.op.right_unitality' (.op X)).symm using 1; simp

@[reassoc (attr := simp)]
theorem coassociativity_inv' (X Y Z : C) :
    F.map (Œ±_ X Y Z).inv ‚â´ F.Œ¥ (X ‚äó Y) Z ‚â´ (F.Œ¥ X Y ‚ñ∑ F.obj Z) =
      F.Œ¥ X (Y ‚äó Z) ‚â´ (F.obj X ‚óÅ F.Œ¥ Y Z) ‚â´ (Œ±_ (F.obj X) (F.obj Y) (F.obj Z)).inv := by
  convert op_inj (F.op.associativity' (.op X) (.op Y) (.op Z)) using 1 <;> simp

end

/--
A constructor for colax monoidal functors whose axioms are described by `tensorHom` instead of
`whiskerLeft` and `whiskerRight`.
-/
@[simps]
def ofTensorHom (F : C ‚•§ D)
    /- counit morphism -/
    (Œµ : F.obj (ùüô_ C) ‚ü∂ ùüô_ D)
    /- cotensorator -/
    (Œ¥ : ‚àÄ X Y : C, F.obj (X ‚äó Y) ‚ü∂ F.obj X ‚äó F.obj Y)
    (Œ¥_natural :
      ‚àÄ {X Y X' Y' : C} (f : X ‚ü∂ Y) (g : X' ‚ü∂ Y'),
        F.map (f ‚äó g) ‚â´ Œ¥ Y Y' = Œ¥ X X' ‚â´ (F.map f ‚äó F.map g) := by
      aesop_cat)
    /- coassociativity of the cotensorator -/
    (coassociativity :
      ‚àÄ X Y Z : C,
        F.map (Œ±_ X Y Z).hom ‚â´ Œ¥ X (Y ‚äó Z) ‚â´ (ùüô (F.obj X) ‚äó Œ¥ Y Z) =
          Œ¥ (X ‚äó Y) Z ‚â´ (Œ¥ X Y ‚äó ùüô (F.obj Z)) ‚â´ (Œ±_ (F.obj X) (F.obj Y) (F.obj Z)).hom := by
      aesop_cat)
    (left_counitality :
      ‚àÄ X : C, Œ¥ (ùüô_ C) X ‚â´ (Œµ ‚äó ùüô (F.obj X)) ‚â´ (Œª_ (F.obj X)).hom = F.map (Œª_ X).hom :=
        by aesop_cat)
    (right_counitality :
      ‚àÄ X : C, Œ¥ X (ùüô_ C) ‚â´ (ùüô (F.obj X) ‚äó Œµ) ‚â´ (œÅ_ (F.obj X)).hom = F.map (œÅ_ X).hom :=
        by aesop_cat) : C ‚•§‚äóc D where
  Œµ := Œµ
  Œ¥ := Œ¥
  Œ¥_natural_left := fun f X' => by
    simp_rw [‚Üê F.map_id, Œ¥_natural]
  Œ¥_natural_right := fun X' f => by
    simp_rw [‚Üê F.map_id, Œ¥_natural]
  coassociativity := coassociativity
  left_counitality := left_counitality
  right_counitality := right_counitality
  __ := F

end ColaxMonoidalFunctor

namespace MonoidalFunctor

variable (F : C ‚•§‚äós D)

/-- The unit morphism of a (strong) monoidal functor as an isomorphism. -/
@[pp_dot, simps]
def Œ∑Iso : ùüô_ D ‚âÖ F.obj (ùüô_ C) :=
  ‚ü®F.Œ∑, F.Œµ, F.Œ∑_Œµ_id, F.Œµ_Œ∑_id‚ü©
#align category_theory.monoidal_functor.Œµ_iso CategoryTheory.MonoidalFunctor.Œ∑Iso

/-- The counit morphism of a (strong) monoidal functor as an isomorphism. -/
@[pp_dot, simps]
def ŒµIso : F.obj (ùüô_ C) ‚âÖ ùüô_ D :=
  ‚ü®F.Œµ, F.Œ∑, F.Œµ_Œ∑_id, F.Œ∑_Œµ_id‚ü©

@[simp]
lemma Œ∑Iso_trans_ŒµIso : F.Œ∑Iso ‚â™‚â´ F.ŒµIso = Iso.refl _ :=
  F.Œ∑Iso.self_symm_id

@[simp]
lemma ŒµIso_trans_Œ∑Iso : F.ŒµIso ‚â™‚â´ F.Œ∑Iso = Iso.refl _ :=
  F.ŒµIso.self_symm_id

/-- The tensorator of a (strong) monoidal functor as a natural isomorphism. -/
@[pp_dot, simps! hom inv]
def ŒºNatIso : .prod F.toFunctor F.toFunctor ‚ãô tensor D ‚âÖ tensor C ‚ãô F.toFunctor :=
  .mk F.ŒºNatTrans F.toColaxMonoidalFunctor.Œ¥NatTrans
  -- unfortunately we need to spell out ColaxMonoidalFunctor.Œ¥NatTrans, see lean4#3467
#align category_theory.monoidal_functor.Œº_nat_iso CategoryTheory.MonoidalFunctor.ŒºNatIso

/-- The cotensorator of a (strong) monoidal functor as a natural isomorphism. -/
@[pp_dot, simps! hom inv]
def Œ¥NatIso : tensor C ‚ãô F.toFunctor ‚âÖ .prod F.toFunctor F.toFunctor ‚ãô tensor D :=
  .mk F.toColaxMonoidalFunctor.Œ¥NatTrans F.ŒºNatTrans

/-- The tensorator of a (strong) monoidal functor as a pointwise isomorphism. -/
@[pp_dot, simps!]
def ŒºIso (X Y : C) : F.obj X ‚äó F.obj Y ‚âÖ F.obj (X ‚äó Y) :=
  F.ŒºNatIso.app (X, Y)
#align category_theory.monoidal_functor.Œº_iso CategoryTheory.MonoidalFunctor.ŒºIso

/-- The cotensorator of a (strong) monoidal functor as a pointwise isomorphism. -/
@[pp_dot, simps!]
def Œ¥Iso (X Y : C) : F.obj (X ‚äó Y) ‚âÖ F.obj X ‚äó F.obj Y :=
  F.Œ¥NatIso.app (X, Y)

@[simp] lemma ŒºNatIso_symm : F.ŒºNatIso.symm = F.Œ¥NatIso := rfl
@[simp] lemma Œ¥NatIso_symm : F.Œ¥NatIso.symm = F.ŒºNatIso := rfl
@[simp] lemma ŒºNatIso_trans_Œ¥NatIso : F.ŒºNatIso ‚â™‚â´ F.Œ¥NatIso = Iso.refl _ :=
  F.ŒºNatIso.self_symm_id
@[simp] lemma Œ¥NatIso_trans_ŒºNatIso : F.Œ¥NatIso ‚â™‚â´ F.ŒºNatIso = Iso.refl _ :=
  F.Œ¥NatIso.self_symm_id
@[simp] lemma ŒºIso_symm (X Y : C) : (F.ŒºIso X Y).symm = F.Œ¥Iso X Y := rfl
@[simp] lemma Œ¥Iso_symm (X Y : C) : (F.Œ¥Iso X Y).symm = F.ŒºIso X Y := rfl
@[simp] lemma ŒºIso_trans_Œ¥Iso (X Y : C) : F.ŒºIso X Y ‚â™‚â´ F.Œ¥Iso X Y = Iso.refl _ :=
  (F.ŒºIso X Y).self_symm_id
@[simp] lemma Œ¥Iso_trans_ŒºIso (X Y : C) : F.Œ¥Iso X Y ‚â™‚â´ F.ŒºIso X Y = Iso.refl _ :=
  (F.Œ¥Iso X Y).self_symm_id
@[simp] lemma ŒºNatIso_app_eq_ŒºIso (XY : C √ó C) :
    F.ŒºNatIso.app XY = F.ŒºIso XY.1 XY.2 := rfl
@[simp] lemma Œ¥NatIso_app_eq_Œ¥Iso (XY : C √ó C) :
    F.Œ¥NatIso.app XY = F.Œ¥Iso XY.1 XY.2 := rfl

instance : IsIso F.Œ∑ := inferInstanceAs (IsIso F.Œ∑Iso.hom)
instance : IsIso F.Œµ := inferInstanceAs (IsIso F.ŒµIso.hom)
instance (X Y : C) : IsIso (F.Œº X Y) := inferInstanceAs (IsIso (F.ŒºIso X Y).hom)
instance (X Y : C) : IsIso (F.Œ¥ X Y) := inferInstanceAs (IsIso (F.Œ¥Iso X Y).hom)

@[simp] lemma inv_Œ∑ : inv F.Œ∑ = F.Œµ := by aesop_cat
@[simp] lemma inv_Œµ : inv F.Œµ = F.Œ∑ := by aesop_cat
@[simp] lemma inv_Œº (X Y : C) : inv (F.Œº X Y) = F.Œ¥ X Y := by aesop_cat
@[simp] lemma inv_Œ¥ (X Y : C) : inv (F.Œ¥ X Y) = F.Œº X Y := by aesop_cat

@[simp]
theorem associativity_iso (X Y Z : C) :
    (tensorRight (F.obj Z)).mapIso (F.ŒºIso X Y) ‚â™‚â´
        F.ŒºIso (X ‚äó Y) Z ‚â™‚â´ F.mapIso (Œ±_ X Y Z) =
      Œ±_ (F.obj X) (F.obj Y) (F.obj Z) ‚â™‚â´
        (tensorLeft (F.obj X)).mapIso (F.ŒºIso Y Z) ‚â™‚â´ F.ŒºIso X (Y ‚äó Z) :=
  Iso.ext (F.associativity X Y Z)

@[simp]
theorem associativity'_iso (X Y Z : C) :
    whiskerRightIso (F.ŒºIso X Y) (F.obj Z) ‚â™‚â´
        F.ŒºIso (X ‚äó Y) Z ‚â™‚â´ F.mapIso (Œ±_ X Y Z) =
      Œ±_ (F.obj X) (F.obj Y) (F.obj Z) ‚â™‚â´
        whiskerLeftIso (F.obj X) (F.ŒºIso Y Z) ‚â™‚â´ F.ŒºIso X (Y ‚äó Z) :=
  Iso.ext (F.associativity' X Y Z)

@[simp]
theorem associativity_symm_iso (X Y Z : C) :
    (tensorLeft (F.obj X)).mapIso (F.ŒºIso Y Z) ‚â™‚â´ F.ŒºIso X (Y ‚äó Z) ‚â™‚â´
      (F.mapIso (Œ±_ X Y Z)).symm =
    (Œ±_ (F.obj X) (F.obj Y) (F.obj Z)).symm ‚â™‚â´
      (tensorRight (F.obj Z)).mapIso (F.ŒºIso X Y) ‚â™‚â´ F.ŒºIso (X ‚äó Y) Z := by
  exact Iso.ext (F.associativity_inv X Y Z)

@[simp]
theorem associativity_symm'_iso (X Y Z : C) :
    whiskerLeftIso (F.obj X) (F.ŒºIso Y Z) ‚â™‚â´ F.ŒºIso X (Y ‚äó Z) ‚â™‚â´
      (F.mapIso (Œ±_ X Y Z)).symm =
    (Œ±_ (F.obj X) (F.obj Y) (F.obj Z)).symm ‚â™‚â´
      whiskerRightIso (F.ŒºIso X Y) (F.obj Z) ‚â™‚â´ F.ŒºIso (X ‚äó Y) Z := by
  exact Iso.ext (F.associativity_inv' X Y Z)

@[simp]
theorem coassociativity_iso (X Y Z : C) :
    F.mapIso (Œ±_ X Y Z) ‚â™‚â´ F.Œ¥Iso X (Y ‚äó Z) ‚â™‚â´
      (tensorLeft (F.obj X)).mapIso (F.Œ¥Iso Y Z) =
    F.Œ¥Iso (X ‚äó Y) Z ‚â™‚â´ (tensorRight (F.obj Z)).mapIso (F.Œ¥Iso X Y) ‚â™‚â´
      (Œ±_ (F.obj X) (F.obj Y) (F.obj Z)) :=
  Iso.ext (F.coassociativity X Y Z)

@[simp]
theorem coassociativity'_iso (X Y Z : C) :
    F.mapIso (Œ±_ X Y Z) ‚â™‚â´ F.Œ¥Iso X (Y ‚äó Z) ‚â™‚â´
      whiskerLeftIso (F.obj X) (F.Œ¥Iso Y Z) =
    F.Œ¥Iso (X ‚äó Y) Z ‚â™‚â´ whiskerRightIso (F.Œ¥Iso X Y) (F.obj Z) ‚â™‚â´
      (Œ±_ (F.obj X) (F.obj Y) (F.obj Z)) :=
  Iso.ext (F.toColaxMonoidalFunctor.coassociativity' X Y Z)

@[simp]
theorem coassociativity_symm_iso (X Y Z : C) :
    F.mapIso (Œ±_ X Y Z).symm ‚â™‚â´ F.Œ¥Iso (X ‚äó Y) Z ‚â™‚â´
      (tensorRight (F.obj Z)).mapIso (F.Œ¥Iso X Y) =
    F.Œ¥Iso X (Y ‚äó Z) ‚â™‚â´ (tensorLeft (F.obj X)).mapIso (F.Œ¥Iso Y Z) ‚â™‚â´
      (Œ±_ (F.obj X) (F.obj Y) (F.obj Z)).symm :=
  Iso.ext (F.toColaxMonoidalFunctor.coassociativity_inv X Y Z)

@[simp]
theorem coassociativity_symm'_iso (X Y Z : C) :
    F.mapIso (Œ±_ X Y Z).symm ‚â™‚â´ F.Œ¥Iso (X ‚äó Y) Z ‚â™‚â´
      whiskerRightIso (F.Œ¥Iso X Y) (F.obj Z) =
    F.Œ¥Iso X (Y ‚äó Z) ‚â™‚â´ whiskerLeftIso (F.obj X) (F.Œ¥Iso Y Z) ‚â™‚â´
      (Œ±_ (F.obj X) (F.obj Y) (F.obj Z)).symm :=
  Iso.ext (F.toColaxMonoidalFunctor.coassociativity_inv' X Y Z)

@[simp]
theorem left_counitality_iso (X : C) :
    F.Œ¥Iso (ùüô_ C) X ‚â™‚â´ (tensorRight (F.obj X)).mapIso F.ŒµIso ‚â™‚â´ Œª_ (F.obj X) =
      F.mapIso (Œª_ X) := Iso.ext (F.left_counitality X)

@[simp]
theorem right_counitality_iso (X : C) :
    F.Œ¥Iso X (ùüô_ C) ‚â™‚â´ (tensorLeft (F.obj X)).mapIso F.ŒµIso ‚â™‚â´ œÅ_ (F.obj X) =
      F.mapIso (œÅ_ X) := Iso.ext (F.right_counitality X)

@[simp]
theorem left_unitality'_iso (X : C) :
    F.Œ¥Iso (ùüô_ C) X ‚â™‚â´ whiskerRightIso F.ŒµIso (F.obj X) ‚â™‚â´ Œª_ (F.obj X) =
      F.mapIso (Œª_ X) := Iso.ext (F.toColaxMonoidalFunctor.left_counitality' X)

@[simp]
theorem right_unitality'_iso (X : C) :
    F.Œ¥Iso X (ùüô_ C) ‚â™‚â´ whiskerLeftIso (F.obj X) F.ŒµIso ‚â™‚â´ œÅ_ (F.obj X) =
      F.mapIso (œÅ_ X) := Iso.ext (F.toColaxMonoidalFunctor.right_counitality' X)

/-- Make a strong monoidal functor from a lax monoidal functor and inverses to
its unit and tensorator maps. -/
@[simps! Œµ Œ¥]
def mkOfLaxMonoidalFunctor (F : C ‚•§‚äó‚Ñì D)
    (Œµ : F.obj (ùüô_ C) ‚ü∂ ùüô_ D) (Œ¥ : (X Y : C) ‚Üí F.obj (X ‚äó Y) ‚ü∂ F.obj X ‚äó F.obj Y)
    (Œ∑_Œµ_id : F.Œ∑ ‚â´ Œµ = ùüô (ùüô_ D) := by aesop_cat)
    (Œµ_Œ∑_id : Œµ ‚â´ F.Œ∑ = ùüô (F.obj (ùüô_ C)) := by aesop_cat)
    (Œº_Œ¥_id : (X Y : C) ‚Üí F.Œº X Y ‚â´ Œ¥ X Y = ùüô _ := by aesop_cat)
    (Œ¥_Œº_id : (X Y : C) ‚Üí Œ¥ X Y ‚â´ F.Œº X Y = ùüô _ := by aesop_cat) : C ‚•§‚äós D :=
  let Œ∑Iso := Iso.mk F.Œ∑ Œµ Œ∑_Œµ_id Œµ_Œ∑_id
  let ŒºIso X Y := Iso.mk (F.Œº X Y) (Œ¥ X Y) (Œº_Œ¥_id X Y) (Œ¥_Œº_id X Y)
  { F with
    Œµ := Œµ
    Œ¥ := Œ¥
    Œ¥_natural_left := fun {X Y} f X' => by
      rw [(ŒºIso Y X').comp_inv_eq, assoc, F.Œº_natural_left,
          (ŒºIso X X').inv_hom_id_assoc]
    Œ¥_natural_right := fun {X Y} X' f => by
      rw [(ŒºIso X' Y).comp_inv_eq, assoc, F.Œº_natural_right,
          (ŒºIso X' X).inv_hom_id_assoc]
    coassociativity := fun X Y Z => by
      erw [(ŒºIso (X ‚äó Y) Z).eq_inv_comp,
           ((tensorRight (F.obj Z)).mapIso (ŒºIso X Y)).eq_inv_comp,
           F.associativity_assoc X Y Z, (ŒºIso X (Y ‚äó Z)).hom_inv_id_assoc,
           ((tensorLeft (F.obj X)).mapIso (ŒºIso Y Z)).hom_inv_id, comp_id]
    left_counitality := fun X => by
      erw [F.left_unitality,
           ((tensorRight (F.obj X)).mapIso Œ∑Iso).inv_hom_id_assoc,
           (ŒºIso (ùüô_ C) X).inv_hom_id_assoc]
    right_counitality := fun X => by
      erw [F.right_unitality,
          ((tensorLeft (F.obj X)).mapIso Œ∑Iso).inv_hom_id_assoc,
          (ŒºIso X (ùüô_ C)).inv_hom_id_assoc] }

@[simp] lemma mkOfLaxMonoidalFunctor_toFunctor (F : C ‚•§‚äó‚Ñì D) Œµ Œ¥ h1 h2 h3 h4 :
    (mkOfLaxMonoidalFunctor F Œµ Œ¥ h1 h2 h3 h4).toFunctor = F.toFunctor := rfl

@[simp] lemma mkOfLaxMonoidalFunctor_Œ∑ (F : C ‚•§‚äó‚Ñì D) Œµ Œ¥ h1 h2 h3 h4 :
    (mkOfLaxMonoidalFunctor F Œµ Œ¥ h1 h2 h3 h4).Œ∑ = F.Œ∑ := rfl

@[simp] lemma mkOfLaxMonoidalFunctor_Œº (F : C ‚•§‚äó‚Ñì D) Œµ Œ¥ h1 h2 h3 h4 :
    (mkOfLaxMonoidalFunctor F Œµ Œ¥ h1 h2 h3 h4).Œº = F.Œº := rfl

/-- Make a strong monoidal functor from a lax monoidal functor whose unit and
tensorator maps are isomorphisms. -/
@[simps! Œµ Œ¥]
noncomputable def mkOfLaxMonoidalFunctor' (F : C ‚•§‚äó‚Ñì D)
    [IsIso F.Œ∑] [‚àÄ X Y, IsIso (F.Œº X Y)] : MonoidalFunctor C D :=
  mkOfLaxMonoidalFunctor F (inv F.Œ∑) (fun X Y => inv (F.Œº X Y))

@[simp] lemma mkOfLaxMonoidalFunctor'_toFunctor (F : C ‚•§‚äó‚Ñì D)
    [IsIso F.Œ∑] [‚àÄ X Y, IsIso (F.Œº X Y)] :
    (mkOfLaxMonoidalFunctor' F).toFunctor = F.toFunctor := rfl

@[simp] lemma mkOfLaxMonoidalFunctor'_Œ∑ (F : C ‚•§‚äó‚Ñì D)
    [IsIso F.Œ∑] [‚àÄ X Y, IsIso (F.Œº X Y)] :
    (mkOfLaxMonoidalFunctor' F).Œ∑ = F.Œ∑ := rfl

@[simp] lemma mkOfLaxMonoidalFunctor'_Œº (F : C ‚•§‚äó‚Ñì D)
    [IsIso F.Œ∑] [‚àÄ X Y, IsIso (F.Œº X Y)] (X Y : C) :
    (mkOfLaxMonoidalFunctor' F).Œº X Y = F.Œº X Y := rfl

-- should there be a version which takes ŒºIso as a natural isomorphism?
/-- Make a strong monoidal functor from coherent unitor, tensorator isomorphisms. -/
@[simps! Œ∑ Œµ Œº Œ¥ toFunctor]
def mkOfUnitTensoratorIsos (F : C ‚•§ D) (Œ∑Iso : ùüô_ D ‚âÖ F.obj (ùüô_ C))
    (ŒºIso : (X Y : C) ‚Üí F.obj X ‚äó F.obj Y ‚âÖ F.obj (X ‚äó Y))
    (Œº_natural_left : ‚àÄ {X Y} (f : X ‚ü∂ Y) (X' : C),
      (F.map f ‚äó ùüô (F.obj X')) ‚â´ (ŒºIso Y X').hom =
        (ŒºIso X X').hom ‚â´ F.map (f ‚äó ùüô X') := by aesop_cat)
    (Œº_natural_right : ‚àÄ {X Y} (X' : C) (f : X ‚ü∂ Y),
      (ùüô (F.obj X') ‚äó F.map f) ‚â´ (ŒºIso X' Y).hom =
        (ŒºIso X' X).hom ‚â´ F.map (ùüô X' ‚äó f) := by aesop_cat)
    (associativity : ‚àÄ X Y Z,
      ((ŒºIso X Y).hom ‚äó ùüô (F.obj Z)) ‚â´ (ŒºIso (X ‚äó Y) Z).hom ‚â´ F.map (Œ±_ X Y Z).hom =
        (Œ±_ (F.obj X) (F.obj Y) (F.obj Z)).hom ‚â´ (ùüô (F.obj X) ‚äó (ŒºIso Y Z).hom) ‚â´
          (ŒºIso X (Y ‚äó Z)).hom := by aesop_cat)
    (left_unitality : ‚àÄ X, (Œª_ (F.obj X)).hom =
      (Œ∑Iso.hom ‚äó ùüô (F.obj X)) ‚â´ (ŒºIso (ùüô_ C) X).hom ‚â´ F.map (Œª_ X).hom := by aesop_cat)
    (right_unitality : ‚àÄ X, (œÅ_ (F.obj X)).hom =
      (ùüô (F.obj X) ‚äó Œ∑Iso.hom) ‚â´ (ŒºIso X (ùüô_ C)).hom ‚â´ F.map (œÅ_ X).hom := by aesop_cat) :
    MonoidalFunctor C D :=
  mkOfLaxMonoidalFunctor ‚ü®F, Œ∑Iso.hom, fun X Y => (ŒºIso X Y).hom, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫,
    ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü© Œ∑Iso.inv (fun X Y => (ŒºIso X Y).inv)

attribute [local ext] unop_inj in
/-- Make a strong monoidal functor from a colax monoidal functor and inverses to
its counit and cotensorator maps. -/
@[simps! Œ∑ Œº]
def mkOfColaxMonoidalFunctor (F : C ‚•§‚äócD)
    (Œ∑ : ùüô_ D ‚ü∂ F.obj (ùüô_ C)) (Œº : (X Y : C) ‚Üí F.obj X ‚äó F.obj Y ‚ü∂ F.obj (X ‚äó Y))
    (Œ∑_Œµ_id : Œ∑ ‚â´ F.Œµ = ùüô (ùüô_ D) := by aesop_cat)
    (Œµ_Œ∑_id : F.Œµ ‚â´ Œ∑ = ùüô (F.obj (ùüô_ C)) := by aesop_cat)
    (Œº_Œ¥_id : (X Y : C) ‚Üí Œº X Y ‚â´ F.Œ¥ X Y = ùüô _ := by aesop_cat)
    (Œ¥_Œº_id : (X Y : C) ‚Üí F.Œ¥ X Y ‚â´ Œº X Y = ùüô _ := by aesop_cat) :
    MonoidalFunctor C D :=
  .unop <| mkOfLaxMonoidalFunctor F.op Œ∑.op (fun X Y => (Œº X.unop Y.unop).op)

@[simp] lemma mkOfColaxMonoidalFunctor_toFunctor (F : C ‚•§‚äóc D) Œ∑ Œº h1 h2 h3 h4 :
    (mkOfColaxMonoidalFunctor F Œ∑ Œº h1 h2 h3 h4).toFunctor = F.toFunctor := rfl

@[simp] lemma mkOfColaxMonoidalFunctor_Œµ (F : C ‚•§‚äóc D) Œ∑ Œº h1 h2 h3 h4 :
    (mkOfColaxMonoidalFunctor F Œ∑ Œº h1 h2 h3 h4).Œµ = F.Œµ := rfl

@[simp] lemma mkOfColaxMonoidalFunctor_Œ¥ (F : C ‚•§‚äóc D) Œ∑ Œº h1 h2 h3 h4 (X Y : C) :
    (mkOfColaxMonoidalFunctor F Œ∑ Œº h1 h2 h3 h4).Œ¥ X Y = F.Œ¥ X Y := rfl

/-- Make a strong monoidal functor from a colax monoidal functor whose counit and
cotensorator maps are isomorphisms. -/
@[simps! Œ∑ Œº]
noncomputable def mkOfColaxMonoidalFunctor' (F : C ‚•§‚äóc D)
    [IsIso F.Œµ] [‚àÄ X Y, IsIso (F.Œ¥ X Y)] : MonoidalFunctor C D :=
  mkOfColaxMonoidalFunctor F (inv F.Œµ) (fun X Y => inv (F.Œ¥ X Y))

@[simp] lemma mkOfColaxMonoidalFunctor'_toFunctor (F : C ‚•§‚äóc D)
    [IsIso F.Œµ] [‚àÄ X Y, IsIso (F.Œ¥ X Y)] :
    (mkOfColaxMonoidalFunctor' F).toFunctor = F.toFunctor := rfl

@[simp] lemma mkOfColMonoidalFunctor'_Œµ (F : C ‚•§‚äóc D)
    [IsIso F.Œµ] [‚àÄ X Y, IsIso (F.Œ¥ X Y)] :
    (mkOfColaxMonoidalFunctor' F).Œµ = F.Œµ := rfl

@[simp] lemma mkOfColMonoidalFunctor'_Œ¥ (F : C ‚•§‚äóc D)
    [IsIso F.Œµ] [‚àÄ X Y, IsIso (F.Œ¥ X Y)] (X Y : C) :
    (mkOfColaxMonoidalFunctor' F).Œ¥ X Y = F.Œ¥ X Y := rfl

/-- Make a strong monoidal functor from coherent counitor, cotensorator isomorphisms. -/
@[simps! Œ∑ Œµ Œº Œ¥ toFunctor]
def mkOfCounitCotensoratorIsos (F : C ‚•§ D) (ŒµIso : F.obj (ùüô_ C) ‚âÖ ùüô_ D)
    (Œ¥Iso : (X Y : C) ‚Üí F.obj (X ‚äó Y) ‚âÖ F.obj X ‚äó F.obj Y)
    (Œ¥_natural_left : ‚àÄ {X Y : C} (f : X ‚ü∂ Y) (X' : C),
        F.map (f ‚äó ùüô X') ‚â´ (Œ¥Iso Y X').hom =
          (Œ¥Iso X X').hom ‚â´ (F.map f ‚äó ùüô (F.obj X')) := by aesop_cat)
    (Œ¥_natural_right : ‚àÄ {X Y : C} (X' : C) (f : X ‚ü∂ Y),
        F.map (ùüô X' ‚äó f) ‚â´ (Œ¥Iso X' Y).hom =
          (Œ¥Iso X' X).hom ‚â´ (ùüô (F.obj X') ‚äó F.map f) := by aesop_cat)
    (coassociativity : ‚àÄ X Y Z : C,
        F.map (Œ±_ X Y Z).hom ‚â´ (Œ¥Iso X (Y ‚äó Z)).hom ‚â´ (ùüô (F.obj X) ‚äó (Œ¥Iso Y Z).hom) =
          (Œ¥Iso (X ‚äó Y) Z).hom ‚â´ ((Œ¥Iso X Y).hom ‚äó ùüô (F.obj Z)) ‚â´
            (Œ±_ (F.obj X) (F.obj Y) (F.obj Z)).hom := by aesop_cat)
    (left_counitality : ‚àÄ X : C,
      (Œ¥Iso (ùüô_ C) X).hom ‚â´ (ŒµIso.hom ‚äó ùüô (F.obj X)) ‚â´ (Œª_ (F.obj X)).hom =
        F.map (Œª_ X).hom := by aesop_cat)
    (right_counitality : ‚àÄ X : C,
      (Œ¥Iso X (ùüô_ C)).hom ‚â´ (ùüô (F.obj X) ‚äó ŒµIso.hom) ‚â´ (œÅ_ (F.obj X)).hom =
        F.map (œÅ_ X).hom := by aesop_cat) :
    MonoidalFunctor C D :=
  mkOfColaxMonoidalFunctor ‚ü®F, ŒµIso.hom, fun X Y => (Œ¥Iso X Y).hom, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫,
    ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü© ŒµIso.inv (fun X Y => (Œ¥Iso X Y).inv)

variable (F : C ‚•§‚äós D)

@[reassoc]
theorem map_tensor {X Y X' Y' : C} (f : X ‚ü∂ Y) (g : X' ‚ü∂ Y') :
    F.map (f ‚äó g) = F.Œ¥ X X' ‚â´ (F.map f ‚äó F.map g) ‚â´ F.Œº Y Y' := by simp
#align category_theory.monoidal_functor.map_tensor CategoryTheory.MonoidalFunctor.map_tensor

-- Note: `ùüô X ‚äó f` will be replaced by `X ‚óÅ f` in #6307.
@[reassoc]
theorem map_whiskerLeft (X : C) {Y Z : C} (f : Y ‚ü∂ Z) :
    F.map (ùüô X ‚äó f) = F.Œ¥ X Y ‚â´ (ùüô (F.obj X) ‚äó F.map f) ‚â´ F.Œº X Z := by simp

-- Note: `f ‚äó ùüô Z` will be replaced by `f ‚ñ∑ Z` in #6307.
@[reassoc]
theorem map_whiskerRight {X Y : C} (f : X ‚ü∂ Y) (Z : C) :
    F.map (f ‚äó ùüô Z) = F.Œ¥ X Z ‚â´ (F.map f ‚äó ùüô (F.obj Z)) ‚â´ F.Œº Y Z := by simp

theorem mapIso_leftUnitor (X : C) :
    F.mapIso (Œª_ X) = (F.ŒºIso (ùüô_ C) X).symm ‚â™‚â´
      (tensorRight (F.obj X)).mapIso F.ŒµIso ‚â™‚â´ Œª_ (F.obj X) := by simp

@[reassoc]
theorem map_leftUnitor_hom (X : C) :
    F.map (Œª_ X).hom =
      F.Œ¥ (ùüô_ C) X ‚â´ (F.Œµ ‚äó ùüô (F.obj X)) ‚â´ (Œª_ (F.obj X)).hom :=
  (F.toColaxMonoidalFunctor.left_counitality X).symm
#align category_theory.monoidal_functor.map_left_unitor CategoryTheory.MonoidalFunctor.map_leftUnitor_hom

@[reassoc]
theorem map_leftUnitor_inv (X : C) :
    F.map (Œª_ X).inv =
      (Œª_ (F.obj X)).inv ‚â´ (F.Œ∑ ‚äó ùüô (F.obj X)) ‚â´ (F.ŒºIso (ùüô_ C) X).hom := by
  simp

theorem mapIso_rightUnitor (X : C) :
    F.mapIso (œÅ_ X) = (F.ŒºIso X (ùüô_ C)).symm ‚â™‚â´
      (tensorLeft (F.obj X)).mapIso F.ŒµIso ‚â™‚â´ œÅ_ (F.obj X) := by simp

@[reassoc]
theorem map_rightUnitor_hom (X : C) :
    F.map (œÅ_ X).hom =
      (F.ŒºIso X (ùüô_ C)).inv ‚â´ (ùüô (F.obj X) ‚äó F.Œµ) ‚â´ (œÅ_ (F.obj X)).hom :=
  (F.toColaxMonoidalFunctor.right_counitality X).symm
#align category_theory.monoidal_functor.map_right_unitor CategoryTheory.MonoidalFunctor.map_rightUnitor_hom

@[reassoc]
theorem map_rightUnitor_inv (X : C) :
    F.map (œÅ_ X).inv =
      (œÅ_ (F.obj X)).inv ‚â´ (ùüô (F.obj X) ‚äó F.Œ∑) ‚â´ F.Œº X (ùüô_ C) := by
  simp

/-- Monoidal functors commute with left tensoring up to isomorphism -/
@[simps!]
def commTensorLeft (X : C) :
    F.toFunctor ‚ãô tensorLeft (F.obj X) ‚âÖ tensorLeft X ‚ãô F.toFunctor :=
  NatIso.ofComponents (fun Y => F.ŒºIso X Y) fun f => F.Œº_natural_right X f
#align category_theory.monoidal_functor.comm_tensor_left CategoryTheory.MonoidalFunctor.commTensorLeft

/-- Monoidal functors commute with right tensoring up to isomorphism -/
@[simps!]
def commTensorRight (X : C) :
    F.toFunctor ‚ãô tensorRight (F.obj X) ‚âÖ tensorRight X ‚ãô F.toFunctor :=
  NatIso.ofComponents (fun Y => F.ŒºIso Y X) fun f => F.Œº_natural_left f X
#align category_theory.monoidal_functor.comm_tensor_right CategoryTheory.MonoidalFunctor.commTensorRight

variable (C)

/-- The identity monoidal functor. -/
@[simps! Œµ Œ¥ Œ∑ Œº toFunctor]
def id : C ‚•§‚äós C :=
  .mkOfUnitTensoratorIsos (ùü≠ C) (Iso.refl _) (fun _ _ => Iso.refl _)
#align category_theory.monoidal_functor.id CategoryTheory.MonoidalFunctor.id

instance : Inhabited (C ‚•§‚äós C) := ‚ü®id C‚ü©

/-- The diagonal functor as a monoidal functor. -/
@[simps! Œµ Œ¥ Œ∑ Œº toFunctor]
def diag : C ‚•§‚äós (C √ó C) :=
  .mkOfUnitTensoratorIsos (.diag C) (Iso.refl _) (fun _ _ => Iso.refl _)
#align category_theory.monoidal_functor.diag CategoryTheory.MonoidalFunctor.diag

end MonoidalFunctor

namespace LaxMonoidalFunctor

variable (F : C ‚•§‚äó‚Ñì D) (G : D ‚•§‚äó‚Ñì E)

/-- The composition of two lax monoidal functors is again lax monoidal. -/
@[simps! Œ∑ Œº toFunctor]
def comp : C ‚•§‚äó‚Ñì E where
  Œ∑ := G.Œ∑ ‚â´ G.map F.Œ∑
  Œº X Y := G.Œº (F.obj X) (F.obj Y) ‚â´ G.map (F.Œº X Y)
  Œº_natural_left {X Y} f X' := by
    simp [‚Üê G.map_comp, -map_comp]
  Œº_natural_right {X Y} f X' := by
    simp [‚Üê G.map_comp, -map_comp]
  associativity X Y Z := by
    simp [id_tensorHom, tensorHom_id, ‚Üê G.associativity'_assoc,
          ‚Üê G.map_comp, F.associativity', -associativity', -map_comp]
  __ := F.toFunctor ‚ãô G.toFunctor
#align category_theory.lax_monoidal_functor.comp CategoryTheory.LaxMonoidalFunctor.comp

@[inherit_doc]
infixr:80 " ‚äó‚ãô " => comp

protected lemma comp_toFunctor_eq_toFunctor_comp :
    (F ‚äó‚ãô G).toFunctor = (F.toFunctor ‚ãô G.toFunctor) := rfl

/-- The isomorphism witnessing that the functor underlying a composition of
lax monoidal functors is the composition of the underlying functors. -/
@[simps!]
def comp_toFunctor_iso_toFunctor_comp :
    (F ‚äó‚ãô G).toFunctor ‚âÖ (F.toFunctor ‚ãô G.toFunctor) := Iso.refl _

variable (F : B ‚•§‚äó‚Ñì C) (G : D ‚•§‚äó‚Ñì E)

attribute [local simp] Œº_natural associativity left_unitality right_unitality

/-- The cartesian product of two lax monoidal functors is lax monoidal. -/
@[simps! Œ∑ Œº toFunctor]
def prod : B √ó D ‚•§‚äó‚Ñì C √ó E where
  Œ∑ := (F.Œ∑, G.Œ∑)
  Œº := fun X Y => (F.Œº X.1 Y.1, G.Œº X.2 Y.2)
  __ := Functor.prod F.toFunctor G.toFunctor
#align category_theory.lax_monoidal_functor.prod CategoryTheory.LaxMonoidalFunctor.prod

variable (F : C ‚•§‚äó‚Ñì D) (G : C ‚•§‚äó‚Ñì E)

/-- The cartesian product of two lax monoidal functors starting from the same monoidal category `C`
    is lax monoidal. -/
@[simps! Œ∑ Œº toFunctor]
def prod' : C ‚•§‚äó‚Ñì D √ó E :=
  (MonoidalFunctor.diag C).toLaxMonoidalFunctor ‚äó‚ãô F.prod G
#align category_theory.lax_monoidal_functor.prod' CategoryTheory.LaxMonoidalFunctor.prod'
#align category_theory.lax_monoidal_functor.prod'_to_functor CategoryTheory.LaxMonoidalFunctor.prod'_toFunctor

variable (C)

/-- The identity lax monoidal functor. -/
@[simps! Œ∑ Œº toFunctor] -- is this necessary for an `abbrev`?
abbrev id : C ‚•§‚äó‚Ñì C :=
  (MonoidalFunctor.id C).toLaxMonoidalFunctor
#align category_theory.lax_monoidal_functor.id CategoryTheory.LaxMonoidalFunctor.id

instance : Inhabited (C ‚•§‚äó‚Ñì C) := ‚ü®id C‚ü©

@[simp]
lemma id_ŒºNatTrans :
    (id C).ŒºNatTrans =
      whiskerRight (prodIdIso C C).inv (tensor C) ‚â´
        (tensor C).leftUnitor.hom ‚â´ (tensor C).rightUnitor.inv := by
  aesop_cat

end LaxMonoidalFunctor

namespace ColaxMonoidalFunctor

variable (F : C ‚•§‚äóc D) (G : D ‚•§‚äóc E)

/-- The composition of two colax monoidal functors is again colax monoidal. -/
@[simps! Œµ Œ¥ toFunctor]
def comp : C ‚•§‚äóc E := (F.op.comp G.op).unop

@[inherit_doc]
infixr:80 " ‚äó‚ãô " => comp

protected lemma comp_toFunctor_eq_toFunctor_comp :
    (F ‚äó‚ãô G).toFunctor = (F.toFunctor ‚ãô G.toFunctor) := rfl

/-- The isomorphism witnessing that the functor underlying a composition of
colax monoidal functors is the composition of the underlying functors. -/
@[simps!]
def comp_toFunctor_iso_toFunctor_comp :
    (F ‚äó‚ãô G).toFunctor ‚âÖ (F.toFunctor ‚ãô G.toFunctor) := Iso.refl _

variable (F : B ‚•§‚äóc C) (G : D ‚•§‚äóc E)

attribute [local simp] Œ¥_natural coassociativity left_counitality right_counitality

/-- The cartesian product of two colax monoidal functors is colax monoidal. -/
@[simps! Œµ Œ¥ toFunctor]
def prod : B √ó D ‚•§‚äóc C √ó E where
  Œµ := (F.Œµ, G.Œµ)
  Œ¥ := fun X Y => (F.Œ¥ X.1 Y.1, G.Œ¥ X.2 Y.2)
  __ := Functor.prod F.toFunctor G.toFunctor

variable (F : C ‚•§‚äóc D) (G : C ‚•§‚äóc E)

/-- The cartesian product of two colax monoidal functors starting from the same
monoidal category `C` is colax monoidal. -/
@[simps! Œµ Œ¥ toFunctor]
def prod' : C ‚•§‚äóc D √ó E :=
  (MonoidalFunctor.diag C).toColaxMonoidalFunctor ‚äó‚ãô F.prod G

variable (C)

/-- The identity colax monoidal functor. -/
@[simps! Œµ Œ¥ toFunctor] -- is this necessary for an `abbrev`?
abbrev id : C ‚•§‚äóc C :=
  (MonoidalFunctor.id C).toColaxMonoidalFunctor

instance : Inhabited (C ‚•§‚äóc C) := ‚ü®id C‚ü©

@[simp]
lemma id_Œ¥NatTrans :
    (id C).Œ¥NatTrans =
      (tensor C).rightUnitor.hom ‚â´ (tensor C).leftUnitor.inv ‚â´
        whiskerRight (prodIdIso C C).hom (tensor C) := by
  aesop_cat

end ColaxMonoidalFunctor

namespace MonoidalFunctor

variable (F : C ‚•§‚äós D) (G : D ‚•§‚äós E)

/-- The composition of two monoidal functors is again monoidal. -/
@[simps! Œµ Œ¥ Œ∑ Œº toFunctor]
def comp : C ‚•§‚äós E where
  Œ∑_Œµ_id := by simp [‚Üê G.map_comp_assoc]
  Œµ_Œ∑_id := by simp [‚Üê G.map_comp, -map_comp]
  Œº_Œ¥_id := by simp [‚Üê G.map_comp_assoc]
  Œ¥_Œº_id := by simp [‚Üê G.map_comp, -map_comp]
  __ := F.toLaxMonoidalFunctor ‚äó‚ãô G.toLaxMonoidalFunctor
  __ := F.toColaxMonoidalFunctor ‚äó‚ãô G.toColaxMonoidalFunctor
#align category_theory.monoidal_functor.comp CategoryTheory.MonoidalFunctor.comp

@[inherit_doc]
infixr:80
  " ‚äó‚ãô " =>-- We overload notation; potentially dangerous, but it seems to work.
  comp

protected lemma comp_toFunctor_eq_toFunctor_comp :
    (F ‚äó‚ãô G).toLaxMonoidalFunctor =
      (F.toLaxMonoidalFunctor ‚äó‚ãô G.toLaxMonoidalFunctor) := rfl

variable (F : B ‚•§‚äós C) (G : D ‚•§‚äós E)

/-- The cartesian product of two monoidal functors is monoidal. -/
@[simps! Œµ Œ¥ Œ∑ Œº toFunctor]
def prod : B √ó D ‚•§‚äós C √ó E where
  __ := ColaxMonoidalFunctor.prod F.toColaxMonoidalFunctor G.toColaxMonoidalFunctor
  __ := LaxMonoidalFunctor.prod F.toLaxMonoidalFunctor G.toLaxMonoidalFunctor
#align category_theory.monoidal_functor.prod CategoryTheory.MonoidalFunctor.prod

variable (F : C ‚•§‚äós D) (G : C ‚•§‚äós E)

/-- The cartesian product of two monoidal functors starting from the same
monoidal category `C` is monoidal. -/
@[simps! Œµ Œ¥ Œ∑ Œº toFunctor]
def prod' : C ‚•§‚äós D √ó E := diag C ‚äó‚ãô F.prod G
#align category_theory.monoidal_functor.prod' CategoryTheory.MonoidalFunctor.prod'

end MonoidalFunctor

end CategoryTheory
