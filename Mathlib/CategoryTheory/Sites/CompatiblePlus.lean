/-
Copyright (c) 2021 Adam Topaz. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Adam Topaz
-/
import Mathlib.CategoryTheory.Sites.Whiskering
import Mathlib.CategoryTheory.Sites.Plus

#align_import category_theory.sites.compatible_plus from "leanprover-community/mathlib"@"70fd9563a21e7b963887c9360bd29b2393e6225a"

/-!

In this file, we prove that the plus functor is compatible with functors which
preserve the correct limits and colimits.

See `CategoryTheory/Sites/CompatibleSheafification` for the compatibility
of sheafification, which follows easily from the content in this file.

-/

noncomputable section

namespace CategoryTheory.GrothendieckTopology

open CategoryTheory Limits Opposite

universe w‚ÇÅ w‚ÇÇ v u

variable {C : Type u} [Category.{v} C] (J : GrothendieckTopology C)
variable {D : Type w‚ÇÅ} [Category.{max v u} D]
variable {E : Type w‚ÇÇ} [Category.{max v u} E]
variable (F : D ‚•§ E)

variable [‚àÄ (Œ± Œ≤ : Type max v u) (fst snd : Œ≤ ‚Üí Œ±), HasLimitsOfShape (WalkingMulticospan fst snd) D]
variable [‚àÄ (Œ± Œ≤ : Type max v u) (fst snd : Œ≤ ‚Üí Œ±), HasLimitsOfShape (WalkingMulticospan fst snd) E]
variable [‚àÄ (X : C) (W : J.Cover X) (P : C·µí·µñ ‚•§ D), PreservesLimit (W.index P).multicospan F]
variable (P : C·µí·µñ ‚•§ D)

/-- The diagram used to define `P‚Å∫`, composed with `F`, is isomorphic
to the diagram used to define `P ‚ãô F`. -/
def diagramCompIso (X : C) : J.diagram P X ‚ãô F ‚âÖ J.diagram (P ‚ãô F) X :=
  NatIso.ofComponents
    (fun W => by
      refine' _ ‚â™‚â´ HasLimit.isoOfNatIso (W.unop.multicospanComp _ _).symm
      -- ‚ä¢ (diagram J P X ‚ãô F).obj W ‚âÖ limit (MulticospanIndex.multicospan (Cover.index ‚Ä¶
      refine'
        (isLimitOfPreserves F (limit.isLimit _)).conePointUniqueUpToIso (limit.isLimit _))
    (by
      intro A B f
      -- ‚ä¢ (diagram J P X ‚ãô F).map f ‚â´ ((fun W => IsLimit.conePointUniqueUpToIso (isLim ‚Ä¶
      -- porting note: this used to work with `ext`
      -- See https://github.com/leanprover-community/mathlib4/issues/5229
      apply Multiequalizer.hom_ext
      -- ‚ä¢ ‚àÄ (a : (Cover.index B.unop (P ‚ãô F)).L), ((diagram J P X ‚ãô F).map f ‚â´ ((fun W ‚Ä¶
      dsimp
      -- ‚ä¢ ‚àÄ (a : (Cover.index B.unop (P ‚ãô F)).L), (F.map (Multiequalizer.lift (Cover.i ‚Ä¶
      simp only [Functor.mapCone_œÄ_app, Multiequalizer.multifork_œÄ_app_left, Iso.symm_hom,
        Multiequalizer.lift_Œπ, eqToHom_refl, Category.comp_id,
        limit.conePointUniqueUpToIso_hom_comp,
        GrothendieckTopology.Cover.multicospanComp_hom_inv_left, HasLimit.isoOfNatIso_hom_œÄ,
        Category.assoc]
      simp only [‚Üê F.map_comp, limit.lift_œÄ, Multifork.ofŒπ_œÄ_app, implies_true])
      -- üéâ no goals
#align category_theory.grothendieck_topology.diagram_comp_iso CategoryTheory.GrothendieckTopology.diagramCompIso

@[reassoc (attr := simp)]
theorem diagramCompIso_hom_Œπ (X : C) (W : (J.Cover X)·µí·µñ) (i : W.unop.Arrow) :
  (J.diagramCompIso F P X).hom.app W ‚â´ Multiequalizer.Œπ ((unop W).index (P ‚ãô F)) i =
  F.map (Multiequalizer.Œπ _ _) := by
  delta diagramCompIso
  -- ‚ä¢ NatTrans.app (NatIso.ofComponents fun W => IsLimit.conePointUniqueUpToIso (i ‚Ä¶
  dsimp
  -- ‚ä¢ ((IsLimit.conePointUniqueUpToIso (isLimitOfPreserves F (limit.isLimit (Multi ‚Ä¶
  simp
  -- üéâ no goals
#align category_theory.grothendieck_topology.diagram_comp_iso_hom_Œπ CategoryTheory.GrothendieckTopology.diagramCompIso_hom_Œπ

variable [‚àÄ X : C, HasColimitsOfShape (J.Cover X)·µí·µñ D]
variable [‚àÄ X : C, HasColimitsOfShape (J.Cover X)·µí·µñ E]
variable [‚àÄ X : C, PreservesColimitsOfShape (J.Cover X)·µí·µñ F]

/-- The isomorphism between `P‚Å∫ ‚ãô F` and `(P ‚ãô F)‚Å∫`. -/
def plusCompIso : J.plusObj P ‚ãô F ‚âÖ J.plusObj (P ‚ãô F) :=
  NatIso.ofComponents
    (fun X => by
      refine' _ ‚â™‚â´ HasColimit.isoOfNatIso (J.diagramCompIso F P X.unop)
      -- ‚ä¢ (plusObj J P ‚ãô F).obj X ‚âÖ colimit (diagram J P X.unop ‚ãô F)
      refine'
        (isColimitOfPreserves F
              (colimit.isColimit (J.diagram P (unop X)))).coconePointUniqueUpToIso
          (colimit.isColimit _))
    (by
      intro X Y f
      -- ‚ä¢ (plusObj J P ‚ãô F).map f ‚â´ ((fun X => IsColimit.coconePointUniqueUpToIso (isC ‚Ä¶
      apply (isColimitOfPreserves F (colimit.isColimit (J.diagram P X.unop))).hom_ext
      -- ‚ä¢ ‚àÄ (j : (Cover J X.unop)·µí·µñ), NatTrans.app (F.mapCocone (colimit.cocone (diagr ‚Ä¶
      intro W
      -- ‚ä¢ NatTrans.app (F.mapCocone (colimit.cocone (diagram J P X.unop))).Œπ W ‚â´ (plus ‚Ä¶
      dsimp [plusObj, plusMap]
      -- ‚ä¢ F.map (colimit.Œπ (diagram J P X.unop) W) ‚â´ F.map (colimMap (diagramPullback  ‚Ä¶
      simp only [Functor.map_comp, Category.assoc]
      -- ‚ä¢ F.map (colimit.Œπ (diagram J P X.unop) W) ‚â´ F.map (colimMap (diagramPullback  ‚Ä¶
      slice_rhs 1 2 =>
        erw [(isColimitOfPreserves F (colimit.isColimit (J.diagram P X.unop))).fac]
      slice_lhs 1 3 =>
        simp only [‚Üê F.map_comp]
        dsimp [colimMap, IsColimit.map, colimit.pre]
        simp only [colimit.Œπ_desc_assoc, colimit.Œπ_desc]
        dsimp [Cocones.precompose]
        simp only [Category.assoc, colimit.Œπ_desc]
        dsimp [Cocone.whisker]
        rw [F.map_comp]
      simp only [Category.assoc]
      -- ‚ä¢ F.map (Multiequalizer.lift (Cover.index (Cover.pullback W.unop f.unop) P) (m ‚Ä¶
      slice_lhs 2 3 =>
        erw [(isColimitOfPreserves F (colimit.isColimit (J.diagram P Y.unop))).fac]
      dsimp
      -- ‚ä¢ F.map (Multiequalizer.lift (Cover.index (Cover.pullback W.unop f.unop) P) (m ‚Ä¶
      simp only [HasColimit.isoOfNatIso_Œπ_hom_assoc, GrothendieckTopology.diagramPullback_app,
        colimit.Œπ_pre, HasColimit.isoOfNatIso_Œπ_hom, Œπ_colimMap_assoc]
      simp only [‚Üê Category.assoc]
      -- ‚ä¢ (F.map (Multiequalizer.lift (Cover.index (Cover.pullback W.unop f.unop) P) ( ‚Ä¶
      dsimp
      -- ‚ä¢ (F.map (Multiequalizer.lift (Cover.index (Cover.pullback W.unop f.unop) P) ( ‚Ä¶
      congr 1
      -- ‚ä¢ F.map (Multiequalizer.lift (Cover.index (Cover.pullback W.unop f.unop) P) (m ‚Ä¶
      ext
      -- ‚ä¢ (F.map (Multiequalizer.lift (Cover.index (Cover.pullback W.unop f.unop) P) ( ‚Ä¶
      dsimp
      -- ‚ä¢ (F.map (Multiequalizer.lift (Cover.index (Cover.pullback W.unop f.unop) P) ( ‚Ä¶
      simp only [Category.assoc]
      -- ‚ä¢ F.map (Multiequalizer.lift (Cover.index (Cover.pullback W.unop f.unop) P) (m ‚Ä¶
      erw [Multiequalizer.lift_Œπ, diagramCompIso_hom_Œπ, diagramCompIso_hom_Œπ, ‚Üê F.map_comp,
        Multiequalizer.lift_Œπ])
#align category_theory.grothendieck_topology.plus_comp_iso CategoryTheory.GrothendieckTopology.plusCompIso

@[reassoc (attr := simp)]
theorem Œπ_plusCompIso_hom (X) (W) :
    F.map (colimit.Œπ _ W) ‚â´ (J.plusCompIso F P).hom.app X =
      (J.diagramCompIso F P X.unop).hom.app W ‚â´ colimit.Œπ _ W := by
  delta diagramCompIso plusCompIso
  -- ‚ä¢ F.map (colimit.Œπ (diagram J P X.unop) W) ‚â´ NatTrans.app (NatIso.ofComponents ‚Ä¶
  simp only [IsColimit.descCoconeMorphism_Hom, IsColimit.uniqueUpToIso_hom,
    Cocones.forget_map, Iso.trans_hom, NatIso.ofComponents_hom_app, Functor.mapIso_hom, ‚Üê
    Category.assoc]
  erw [(isColimitOfPreserves F (colimit.isColimit (J.diagram P (unop X)))).fac]
  -- ‚ä¢ NatTrans.app (colimit.cocone (diagram J P X.unop ‚ãô F)).Œπ W ‚â´ (HasColimit.iso ‚Ä¶
  simp only [Category.assoc, HasLimit.isoOfNatIso_hom_œÄ, Iso.symm_hom,
    Cover.multicospanComp_hom_inv_left, eqToHom_refl, Category.comp_id,
    limit.conePointUniqueUpToIso_hom_comp, Functor.mapCone_œÄ_app,
    Multiequalizer.multifork_œÄ_app_left, Multiequalizer.lift_Œπ, Functor.map_comp, eq_self_iff_true,
    Category.assoc, Iso.trans_hom, Iso.cancel_iso_hom_left, NatIso.ofComponents_hom_app,
    colimit.cocone_Œπ, Category.assoc, HasColimit.isoOfNatIso_Œπ_hom]
#align category_theory.grothendieck_topology.Œπ_plus_comp_iso_hom CategoryTheory.GrothendieckTopology.Œπ_plusCompIso_hom

@[reassoc (attr := simp)]
theorem plusCompIso_whiskerLeft {F G : D ‚•§ E} (Œ∑ : F ‚ü∂ G) (P : C·µí·µñ ‚•§ D)
    [‚àÄ X : C, PreservesColimitsOfShape (J.Cover X)·µí·µñ F]
    [‚àÄ (X : C) (W : J.Cover X) (P : C·µí·µñ ‚•§ D), PreservesLimit (W.index P).multicospan F]
    [‚àÄ X : C, PreservesColimitsOfShape (J.Cover X)·µí·µñ G]
    [‚àÄ (X : C) (W : J.Cover X) (P : C·µí·µñ ‚•§ D), PreservesLimit (W.index P).multicospan G] :
    whiskerLeft _ Œ∑ ‚â´ (J.plusCompIso G P).hom =
      (J.plusCompIso F P).hom ‚â´ J.plusMap (whiskerLeft _ Œ∑) := by
  ext X
  -- ‚ä¢ NatTrans.app (whiskerLeft (plusObj J P) Œ∑ ‚â´ (plusCompIso J G P).hom) X = Nat ‚Ä¶
  apply (isColimitOfPreserves F (colimit.isColimit (J.diagram P X.unop))).hom_ext
  -- ‚ä¢ ‚àÄ (j : (Cover J X.unop)·µí·µñ), NatTrans.app (F.mapCocone (colimit.cocone (diagr ‚Ä¶
  intro W
  -- ‚ä¢ NatTrans.app (F.mapCocone (colimit.cocone (diagram J P X.unop))).Œπ W ‚â´ NatTr ‚Ä¶
  dsimp [plusObj, plusMap]
  -- ‚ä¢ F.map (colimit.Œπ (diagram J P X.unop) W) ‚â´ NatTrans.app Œ∑ (colimit (diagram  ‚Ä¶
  simp only [Œπ_plusCompIso_hom, Œπ_colimMap, whiskerLeft_app, Œπ_plusCompIso_hom_assoc,
    NatTrans.naturality_assoc, GrothendieckTopology.diagramNatTrans_app]
  simp only [‚Üê Category.assoc]
  -- ‚ä¢ (NatTrans.app Œ∑ (multiequalizer (Cover.index W.unop P)) ‚â´ NatTrans.app (diag ‚Ä¶
  congr 1
  -- ‚ä¢ NatTrans.app Œ∑ (multiequalizer (Cover.index W.unop P)) ‚â´ NatTrans.app (diagr ‚Ä¶
  -- porting note: this used to work with `ext`
  -- See https://github.com/leanprover-community/mathlib4/issues/5229
  apply Multiequalizer.hom_ext
  -- ‚ä¢ ‚àÄ (a : (Cover.index W.unop (P ‚ãô G)).L), (NatTrans.app Œ∑ (multiequalizer (Cov ‚Ä¶
  intro a
  -- ‚ä¢ (NatTrans.app Œ∑ (multiequalizer (Cover.index W.unop P)) ‚â´ NatTrans.app (diag ‚Ä¶
  dsimp
  -- ‚ä¢ (NatTrans.app Œ∑ (multiequalizer (Cover.index W.unop P)) ‚â´ NatTrans.app (diag ‚Ä¶
  simp
  -- ‚ä¢ NatTrans.app Œ∑ (multiequalizer (Cover.index W.unop P)) ‚â´ G.map (Multiequaliz ‚Ä¶
  -- Porting note: in mathlib3 `simp` managed to apply this.
  erw [Œ∑.naturality]
  -- üéâ no goals
#align category_theory.grothendieck_topology.plus_comp_iso_whisker_left CategoryTheory.GrothendieckTopology.plusCompIso_whiskerLeft

/-- The isomorphism between `P‚Å∫ ‚ãô F` and `(P ‚ãô F)‚Å∫`, functorially in `F`. -/
@[simps! hom_app inv_app]
def plusFunctorWhiskerLeftIso (P : C·µí·µñ ‚•§ D)
    [‚àÄ (F : D ‚•§ E) (X : C), PreservesColimitsOfShape (J.Cover X)·µí·µñ F]
    [‚àÄ (F : D ‚•§ E) (X : C) (W : J.Cover X) (P : C·µí·µñ ‚•§ D),
        PreservesLimit (W.index P).multicospan F] :
    (whiskeringLeft _ _ E).obj (J.plusObj P) ‚âÖ (whiskeringLeft _ _ _).obj P ‚ãô J.plusFunctor E :=
  NatIso.ofComponents (fun _ => plusCompIso _ _ _) @fun _ _ _ => plusCompIso_whiskerLeft _ _ _
#align category_theory.grothendieck_topology.plus_functor_whisker_left_iso CategoryTheory.GrothendieckTopology.plusFunctorWhiskerLeftIso

@[reassoc (attr := simp)]
theorem plusCompIso_whiskerRight {P Q : C·µí·µñ ‚•§ D} (Œ∑ : P ‚ü∂ Q) :
    whiskerRight (J.plusMap Œ∑) F ‚â´ (J.plusCompIso F Q).hom =
      (J.plusCompIso F P).hom ‚â´ J.plusMap (whiskerRight Œ∑ F) := by
  ext X
  -- ‚ä¢ NatTrans.app (whiskerRight (plusMap J Œ∑) F ‚â´ (plusCompIso J F Q).hom) X = Na ‚Ä¶
  apply (isColimitOfPreserves F (colimit.isColimit (J.diagram P X.unop))).hom_ext
  -- ‚ä¢ ‚àÄ (j : (Cover J X.unop)·µí·µñ), NatTrans.app (F.mapCocone (colimit.cocone (diagr ‚Ä¶
  intro W
  -- ‚ä¢ NatTrans.app (F.mapCocone (colimit.cocone (diagram J P X.unop))).Œπ W ‚â´ NatTr ‚Ä¶
  dsimp [plusObj, plusMap]
  -- ‚ä¢ F.map (colimit.Œπ (diagram J P X.unop) W) ‚â´ F.map (colimMap (diagramNatTrans  ‚Ä¶
  simp only [Œπ_colimMap, whiskerRight_app, Œπ_plusCompIso_hom_assoc,
    GrothendieckTopology.diagramNatTrans_app]
  simp only [‚Üê Category.assoc, ‚Üê F.map_comp]
  -- ‚ä¢ F.map (colimit.Œπ (diagram J P X.unop) W ‚â´ colimMap (diagramNatTrans J Œ∑ X.un ‚Ä¶
  dsimp [colimMap, IsColimit.map]
  -- ‚ä¢ F.map (colimit.Œπ (diagram J P X.unop) W ‚â´ colimit.desc (diagram J P X.unop)  ‚Ä¶
  simp only [colimit.Œπ_desc]
  -- ‚ä¢ F.map (NatTrans.app ((Cocones.precompose (diagramNatTrans J Œ∑ X.unop)).obj ( ‚Ä¶
  dsimp [Cocones.precompose]
  -- ‚ä¢ F.map (Multiequalizer.lift (Cover.index W.unop Q) (multiequalizer (Cover.ind ‚Ä¶
  simp only [Functor.map_comp, Category.assoc, Œπ_plusCompIso_hom]
  -- ‚ä¢ F.map (Multiequalizer.lift (Cover.index W.unop Q) (multiequalizer (Cover.ind ‚Ä¶
  simp only [‚Üê Category.assoc]
  -- ‚ä¢ (F.map (Multiequalizer.lift (Cover.index W.unop Q) (multiequalizer (Cover.in ‚Ä¶
  congr 1
  -- ‚ä¢ F.map (Multiequalizer.lift (Cover.index W.unop Q) (multiequalizer (Cover.ind ‚Ä¶
  -- porting note: this used to work with `ext`
  -- See https://github.com/leanprover-community/mathlib4/issues/5229
  apply Multiequalizer.hom_ext
  -- ‚ä¢ ‚àÄ (a : (Cover.index W.unop (Q ‚ãô F)).L), (F.map (Multiequalizer.lift (Cover.i ‚Ä¶
  intro a
  -- ‚ä¢ (F.map (Multiequalizer.lift (Cover.index W.unop Q) (multiequalizer (Cover.in ‚Ä¶
  dsimp
  -- ‚ä¢ (F.map (Multiequalizer.lift (Cover.index W.unop Q) (multiequalizer (Cover.in ‚Ä¶
  simp only [diagramCompIso_hom_Œπ_assoc, Multiequalizer.lift_Œπ, diagramCompIso_hom_Œπ,
    Category.assoc]
  simp only [‚Üê F.map_comp, Multiequalizer.lift_Œπ]
  -- üéâ no goals
#align category_theory.grothendieck_topology.plus_comp_iso_whisker_right CategoryTheory.GrothendieckTopology.plusCompIso_whiskerRight

/-- The isomorphism between `P‚Å∫ ‚ãô F` and `(P ‚ãô F)‚Å∫`, functorially in `P`. -/
@[simps! hom_app inv_app]
def plusFunctorWhiskerRightIso :
    J.plusFunctor D ‚ãô (whiskeringRight _ _ _).obj F ‚âÖ
      (whiskeringRight _ _ _).obj F ‚ãô J.plusFunctor E :=
  NatIso.ofComponents (fun _ => J.plusCompIso _ _) @fun _ _ _ => plusCompIso_whiskerRight _ _ _
#align category_theory.grothendieck_topology.plus_functor_whisker_right_iso CategoryTheory.GrothendieckTopology.plusFunctorWhiskerRightIso

@[reassoc (attr := simp)]
theorem whiskerRight_toPlus_comp_plusCompIso_hom :
    whiskerRight (J.toPlus _) _ ‚â´ (J.plusCompIso F P).hom = J.toPlus _ := by
  ext
  -- ‚ä¢ NatTrans.app (whiskerRight (toPlus J P) F ‚â´ (plusCompIso J F P).hom) x‚úù = Na ‚Ä¶
  dsimp [toPlus]
  -- ‚ä¢ F.map (Cover.toMultiequalizer ‚ä§ P ‚â´ colimit.Œπ (diagram J P x‚úù.unop) (op ‚ä§))  ‚Ä¶
  simp only [Œπ_plusCompIso_hom, Functor.map_comp, Category.assoc]
  -- ‚ä¢ F.map (Cover.toMultiequalizer ‚ä§ P) ‚â´ NatTrans.app (diagramCompIso J F P x‚úù.u ‚Ä¶
  simp only [‚Üê Category.assoc]
  -- ‚ä¢ (F.map (Cover.toMultiequalizer ‚ä§ P) ‚â´ NatTrans.app (diagramCompIso J F P x‚úù. ‚Ä¶
  congr 1
  -- ‚ä¢ F.map (Cover.toMultiequalizer ‚ä§ P) ‚â´ NatTrans.app (diagramCompIso J F P x‚úù.u ‚Ä¶
  -- porting note: this used to work with `ext`
  -- See https://github.com/leanprover-community/mathlib4/issues/5229
  apply Multiequalizer.hom_ext
  -- ‚ä¢ ‚àÄ (a : (Cover.index (op ‚ä§).unop (P ‚ãô F)).L), (F.map (Cover.toMultiequalizer  ‚Ä¶
  delta Cover.toMultiequalizer
  -- ‚ä¢ ‚àÄ (a : (Cover.index (op ‚ä§).unop (P ‚ãô F)).L), (F.map (Multiequalizer.lift (Co ‚Ä¶
  simp only [diagramCompIso_hom_Œπ, Category.assoc, ‚Üê F.map_comp]
  -- ‚ä¢ ‚àÄ (a : (Cover.index (op ‚ä§).unop (P ‚ãô F)).L), F.map (Multiequalizer.lift (Cov ‚Ä¶
  simp only [unop_op, limit.lift_œÄ, Multifork.ofŒπ_œÄ_app, Functor.comp_obj, Functor.comp_map,
    implies_true]
#align category_theory.grothendieck_topology.whisker_right_to_plus_comp_plus_comp_iso_hom CategoryTheory.GrothendieckTopology.whiskerRight_toPlus_comp_plusCompIso_hom

@[simp]
theorem toPlus_comp_plusCompIso_inv :
    J.toPlus _ ‚â´ (J.plusCompIso F P).inv = whiskerRight (J.toPlus _) _ := by simp [Iso.comp_inv_eq]
                                                                             -- üéâ no goals
#align category_theory.grothendieck_topology.to_plus_comp_plus_comp_iso_inv CategoryTheory.GrothendieckTopology.toPlus_comp_plusCompIso_inv

theorem plusCompIso_inv_eq_plusLift (hP : Presheaf.IsSheaf J (J.plusObj P ‚ãô F)) :
    (J.plusCompIso F P).inv = J.plusLift (whiskerRight (J.toPlus _) _) hP := by
  apply J.plusLift_unique
  -- ‚ä¢ toPlus J (P ‚ãô F) ‚â´ (plusCompIso J F P).inv = whiskerRight (toPlus J P) F
  simp [Iso.comp_inv_eq]
  -- üéâ no goals
#align category_theory.grothendieck_topology.plus_comp_iso_inv_eq_plus_lift CategoryTheory.GrothendieckTopology.plusCompIso_inv_eq_plusLift

end CategoryTheory.GrothendieckTopology
