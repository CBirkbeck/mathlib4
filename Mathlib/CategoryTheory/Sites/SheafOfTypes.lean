/-
Copyright (c) 2020 Bhavik Mehta. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Bhavik Mehta
-/
import Mathlib.CategoryTheory.Sites.Pretopology
import Mathlib.CategoryTheory.Limits.Shapes.Types

#align_import category_theory.sites.sheaf_of_types from "leanprover-community/mathlib"@"70fd9563a21e7b963887c9360bd29b2393e6225a"

/-!
# Sheaves of types on a Grothendieck topology

Defines the notion of a sheaf of types (usually called a sheaf of sets by mathematicians)
on a category equipped with a Grothendieck topology, as well as a range of equivalent
conditions useful in different situations.

First define what it means for a presheaf `P : C·µí·µñ ‚•§ Type v` to be a sheaf *for* a particular
presieve `R` on `X`:
* A *family of elements* `x` for `P` at `R` is an element `x_f` of `P Y` for every `f : Y ‚ü∂ X` in
  `R`. See `FamilyOfElements`.
* The family `x` is *compatible* if, for any `f‚ÇÅ : Y‚ÇÅ ‚ü∂ X` and `f‚ÇÇ : Y‚ÇÇ ‚ü∂ X` both in `R`,
  and any `g‚ÇÅ : Z ‚ü∂ Y‚ÇÅ` and `g‚ÇÇ : Z ‚ü∂ Y‚ÇÇ` such that `g‚ÇÅ ‚â´ f‚ÇÅ = g‚ÇÇ ‚â´ f‚ÇÇ`, the restriction of
  `x_f‚ÇÅ` along `g‚ÇÅ` agrees with the restriction of `x_f‚ÇÇ` along `g‚ÇÇ`.
  See `FamilyOfElements.Compatible`.
* An *amalgamation* `t` for the family is an element of `P X` such that for every `f : Y ‚ü∂ X` in
  `R`, the restriction of `t` on `f` is `x_f`.
  See `FamilyOfElements.IsAmalgamation`.
We then say `P` is *separated* for `R` if every compatible family has at most one amalgamation,
and it is a *sheaf* for `R` if every compatible family has a unique amalgamation.
See `IsSeparatedFor` and `IsSheafFor`.

In the special case where `R` is a sieve, the compatibility condition can be simplified:
* The family `x` is *compatible* if, for any `f : Y ‚ü∂ X` in `R` and `g : Z ‚ü∂ Y`, the restriction of
  `x_f` along `g` agrees with `x_(g ‚â´ f)` (which is well defined since `g ‚â´ f` is in `R`).
See `FamilyOfElements.SieveCompatible` and `compatible_iff_sieveCompatible`.

In the special case where `C` has pullbacks, the compatibility condition can be simplified:
* The family `x` is *compatible* if, for any `f : Y ‚ü∂ X` and `g : Z ‚ü∂ X` both in `R`,
  the restriction of `x_f` along `œÄ‚ÇÅ : pullback f g ‚ü∂ Y` agrees with the restriction of `x_g`
  along `œÄ‚ÇÇ : pullback f g ‚ü∂ Z`.
See `FamilyOfElements.PullbackCompatible` and `pullbackCompatible_iff`.

Now given a Grothendieck topology `J`, `P` is a sheaf if it is a sheaf for every sieve in the
topology. See `IsSheaf`.

In the case where the topology is generated by a basis, it suffices to check `P` is a sheaf for
every presieve in the pretopology. See `isSheaf_pretopology`.

We also provide equivalent conditions to satisfy alternate definitions given in the literature.

* Stacks: In `Equalizer.Presieve.sheaf_condition`, the sheaf condition at a presieve is shown to be
  equivalent to that of https://stacks.math.columbia.edu/tag/00VM (and combined with
  `isSheaf_pretopology`, this shows the notions of `IsSheaf` are exactly equivalent.)

  The condition of https://stacks.math.columbia.edu/tag/00Z8 is virtually identical to the
  statement of `isSheafFor_iff_yonedaSheafCondition` (since the bijection described there carries
  the same information as the unique existence.)

* Maclane-Moerdijk [MM92]: Using `compatible_iff_sieveCompatible`, the definitions of `IsSheaf`
  are equivalent. There are also alternate definitions given:
  - Yoneda condition: Defined in `yonedaSheafCondition` and equivalence in
    `isSheafFor_iff_yonedaSheafCondition`.
  - Equalizer condition (Equation 3): Defined in the `Equalizer.Sieve` namespace, and equivalence
    in `Equalizer.Sieve.sheaf_condition`.
  - Matching family for presieves with pullback: `pullbackCompatible_iff`.
  - Sheaf for a pretopology (Prop 1): `isSheaf_pretopology` combined with the previous.
  - Sheaf for a pretopology as equalizer (Prop 1, bis): `Equalizer.Presieve.sheaf_condition`
    combined with the previous.

## Implementation

The sheaf condition is given as a proposition, rather than a subsingleton in `Type (max u‚ÇÅ v)`.
This doesn't seem to make a big difference, other than making a couple of definitions noncomputable,
but it means that equivalent conditions can be given as `‚Üî` statements rather than `‚âÉ` statements,
which can be convenient.

## References

* [MM92]: *Sheaves in geometry and logic*, Saunders MacLane, and Ieke Moerdijk:
  Chapter III, Section 4.
* [Elephant]: *Sketches of an Elephant*, P. T. Johnstone: C2.1.
* https://stacks.math.columbia.edu/tag/00VL (sheaves on a pretopology or site)
* https://stacks.math.columbia.edu/tag/00ZB (sheaves on a topology)

-/


universe w v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ

namespace CategoryTheory

open Opposite CategoryTheory Category Limits Sieve

namespace Presieve

variable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C]

variable {P Q U : C·µí·µñ ‚•§ Type w}

variable {X Y : C} {S : Sieve X} {R : Presieve X}

variable (J J‚ÇÇ : GrothendieckTopology C)

/-- A family of elements for a presheaf `P` given a collection of arrows `R` with fixed codomain `X`
consists of an element of `P Y` for every `f : Y ‚ü∂ X` in `R`.
A presheaf is a sheaf (resp, separated) if every *compatible* family of elements has exactly one
(resp, at most one) amalgamation.

This data is referred to as a `family` in [MM92], Chapter III, Section 4. It is also a concrete
version of the elements of the middle object in https://stacks.math.columbia.edu/tag/00VM which is
more useful for direct calculations. It is also used implicitly in Definition C2.1.2 in [Elephant].
-/
def FamilyOfElements (P : C·µí·µñ ‚•§ Type w) (R : Presieve X) :=
  ‚àÄ ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X), R f ‚Üí P.obj (op Y)
#align category_theory.presieve.family_of_elements CategoryTheory.Presieve.FamilyOfElements

instance : Inhabited (FamilyOfElements P (‚ä• : Presieve X)) :=
  ‚ü®fun _ _ => False.elim‚ü©

/-- A family of elements for a presheaf on the presieve `R‚ÇÇ` can be restricted to a smaller presieve
`R‚ÇÅ`.
-/
def FamilyOfElements.restrict {R‚ÇÅ R‚ÇÇ : Presieve X} (h : R‚ÇÅ ‚â§ R‚ÇÇ) :
    FamilyOfElements P R‚ÇÇ ‚Üí FamilyOfElements P R‚ÇÅ := fun x _ f hf => x f (h _ hf)
#align category_theory.presieve.family_of_elements.restrict CategoryTheory.Presieve.FamilyOfElements.restrict

/-- A family of elements for the arrow set `R` is *compatible* if for any `f‚ÇÅ : Y‚ÇÅ ‚ü∂ X` and
`f‚ÇÇ : Y‚ÇÇ ‚ü∂ X` in `R`, and any `g‚ÇÅ : Z ‚ü∂ Y‚ÇÅ` and `g‚ÇÇ : Z ‚ü∂ Y‚ÇÇ`, if the square `g‚ÇÅ ‚â´ f‚ÇÅ = g‚ÇÇ ‚â´ f‚ÇÇ`
commutes then the elements of `P Z` obtained by restricting the element of `P Y‚ÇÅ` along `g‚ÇÅ` and
restricting the element of `P Y‚ÇÇ` along `g‚ÇÇ` are the same.

In special cases, this condition can be simplified, see `pullbackCompatible_iff` and
`compatible_iff_sieveCompatible`.

This is referred to as a "compatible family" in Definition C2.1.2 of [Elephant], and on nlab:
https://ncatlab.org/nlab/show/sheaf#GeneralDefinitionInComponents
-/
def FamilyOfElements.Compatible (x : FamilyOfElements P R) : Prop :=
  ‚àÄ ‚¶ÉY‚ÇÅ Y‚ÇÇ Z‚¶Ñ (g‚ÇÅ : Z ‚ü∂ Y‚ÇÅ) (g‚ÇÇ : Z ‚ü∂ Y‚ÇÇ) ‚¶Éf‚ÇÅ : Y‚ÇÅ ‚ü∂ X‚¶Ñ ‚¶Éf‚ÇÇ : Y‚ÇÇ ‚ü∂ X‚¶Ñ (h‚ÇÅ : R f‚ÇÅ) (h‚ÇÇ : R f‚ÇÇ),
    g‚ÇÅ ‚â´ f‚ÇÅ = g‚ÇÇ ‚â´ f‚ÇÇ ‚Üí P.map g‚ÇÅ.op (x f‚ÇÅ h‚ÇÅ) = P.map g‚ÇÇ.op (x f‚ÇÇ h‚ÇÇ)
#align category_theory.presieve.family_of_elements.compatible CategoryTheory.Presieve.FamilyOfElements.Compatible

/--
If the category `C` has pullbacks, this is an alternative condition for a family of elements to be
compatible: For any `f : Y ‚ü∂ X` and `g : Z ‚ü∂ X` in the presieve `R`, the restriction of the
given elements for `f` and `g` to the pullback agree.
This is equivalent to being compatible (provided `C` has pullbacks), shown in
`pullbackCompatible_iff`.

This is the definition for a "matching" family given in [MM92], Chapter III, Section 4,
Equation (5). Viewing the type `FamilyOfElements` as the middle object of the fork in
https://stacks.math.columbia.edu/tag/00VM, this condition expresses that `pr‚ÇÄ* (x) = pr‚ÇÅ* (x)`,
using the notation defined there.
-/
def FamilyOfElements.PullbackCompatible (x : FamilyOfElements P R) [R.hasPullbacks] : Prop :=
  ‚àÄ ‚¶ÉY‚ÇÅ Y‚ÇÇ‚¶Ñ ‚¶Éf‚ÇÅ : Y‚ÇÅ ‚ü∂ X‚¶Ñ ‚¶Éf‚ÇÇ : Y‚ÇÇ ‚ü∂ X‚¶Ñ (h‚ÇÅ : R f‚ÇÅ) (h‚ÇÇ : R f‚ÇÇ),
    haveI := hasPullbacks.has_pullbacks h‚ÇÅ h‚ÇÇ
    P.map (pullback.fst : Limits.pullback f‚ÇÅ f‚ÇÇ ‚ü∂ _).op (x f‚ÇÅ h‚ÇÅ) = P.map pullback.snd.op (x f‚ÇÇ h‚ÇÇ)
#align category_theory.presieve.family_of_elements.pullback_compatible CategoryTheory.Presieve.FamilyOfElements.PullbackCompatible

theorem pullbackCompatible_iff (x : FamilyOfElements P R) [R.hasPullbacks] :
    x.Compatible ‚Üî x.PullbackCompatible := by
  constructor
  -- ‚ä¢ FamilyOfElements.Compatible x ‚Üí FamilyOfElements.PullbackCompatible x
  ¬∑ intro t Y‚ÇÅ Y‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ
    -- ‚ä¢ P.map pullback.fst.op (x f‚ÇÅ hf‚ÇÅ) = P.map pullback.snd.op (x f‚ÇÇ hf‚ÇÇ)
    apply t
    -- ‚ä¢ pullback.fst ‚â´ f‚ÇÅ = pullback.snd ‚â´ f‚ÇÇ
    haveI := hasPullbacks.has_pullbacks hf‚ÇÅ hf‚ÇÇ
    -- ‚ä¢ pullback.fst ‚â´ f‚ÇÅ = pullback.snd ‚â´ f‚ÇÇ
    apply pullback.condition
    -- üéâ no goals
  ¬∑ intro t Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ comm
    -- ‚ä¢ P.map g‚ÇÅ.op (x f‚ÇÅ hf‚ÇÅ) = P.map g‚ÇÇ.op (x f‚ÇÇ hf‚ÇÇ)
    haveI := hasPullbacks.has_pullbacks  hf‚ÇÅ hf‚ÇÇ
    -- ‚ä¢ P.map g‚ÇÅ.op (x f‚ÇÅ hf‚ÇÅ) = P.map g‚ÇÇ.op (x f‚ÇÇ hf‚ÇÇ)
    rw [‚Üê pullback.lift_fst _ _ comm, op_comp, FunctorToTypes.map_comp_apply, t hf‚ÇÅ hf‚ÇÇ,
      ‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, pullback.lift_snd]
#align category_theory.presieve.pullback_compatible_iff CategoryTheory.Presieve.pullbackCompatible_iff

/-- The restriction of a compatible family is compatible. -/
theorem FamilyOfElements.Compatible.restrict {R‚ÇÅ R‚ÇÇ : Presieve X} (h : R‚ÇÅ ‚â§ R‚ÇÇ)
    {x : FamilyOfElements P R‚ÇÇ} : x.Compatible ‚Üí (x.restrict h).Compatible :=
  fun q _ _ _ g‚ÇÅ g‚ÇÇ _ _ h‚ÇÅ h‚ÇÇ comm => q g‚ÇÅ g‚ÇÇ (h _ h‚ÇÅ) (h _ h‚ÇÇ) comm
#align category_theory.presieve.family_of_elements.compatible.restrict CategoryTheory.Presieve.FamilyOfElements.Compatible.restrict

/-- Extend a family of elements to the sieve generated by an arrow set.
This is the construction described as "easy" in Lemma C2.1.3 of [Elephant].
-/
noncomputable def FamilyOfElements.sieveExtend (x : FamilyOfElements P R) :
    FamilyOfElements P (generate R : Presieve X) := fun _ _ hf =>
  P.map hf.choose_spec.choose.op (x _ hf.choose_spec.choose_spec.choose_spec.1)
#align category_theory.presieve.family_of_elements.sieve_extend CategoryTheory.Presieve.FamilyOfElements.sieveExtend

/-- The extension of a compatible family to the generated sieve is compatible. -/
theorem FamilyOfElements.Compatible.sieveExtend {x : FamilyOfElements P R} (hx : x.Compatible) :
    x.sieveExtend.Compatible := by
  intro _ _ _ _ _ _ _ h‚ÇÅ h‚ÇÇ comm
  -- ‚ä¢ P.map g‚ÇÅ‚úù.op (FamilyOfElements.sieveExtend x f‚ÇÅ‚úù h‚ÇÅ) = P.map g‚ÇÇ‚úù.op (FamilyO ‚Ä¶
  iterate 2 erw [‚Üê FunctorToTypes.map_comp_apply]; rw [‚Üê op_comp]
  -- ‚ä¢ P.map (g‚ÇÅ‚úù ‚â´ Exists.choose (_ : ‚àÉ h g, R g ‚àß h ‚â´ g = f‚ÇÅ‚úù)).op (x (Exists.cho ‚Ä¶
  apply hx
  -- ‚ä¢ (g‚ÇÅ‚úù ‚â´ Exists.choose (_ : ‚àÉ h g, R g ‚àß h ‚â´ g = f‚ÇÅ‚úù)) ‚â´ Exists.choose (_ : ‚àÉ  ‚Ä¶
  simp [comm, h‚ÇÅ.choose_spec.choose_spec.choose_spec.2, h‚ÇÇ.choose_spec.choose_spec.choose_spec.2]
  -- üéâ no goals
#align category_theory.presieve.family_of_elements.compatible.sieve_extend CategoryTheory.Presieve.FamilyOfElements.Compatible.sieveExtend

/-- The extension of a family agrees with the original family. -/
theorem extend_agrees {x : FamilyOfElements P R} (t : x.Compatible) {f : Y ‚ü∂ X} (hf : R f) :
    x.sieveExtend f (le_generate R Y hf) = x f hf := by
  have h := (le_generate R Y hf).choose_spec
  -- ‚ä¢ FamilyOfElements.sieveExtend x f (_ : f ‚àà (generate R).arrows) = x f hf
  unfold FamilyOfElements.sieveExtend
  -- ‚ä¢ P.map (Exists.choose (_ : ‚àÉ h g, R g ‚àß h ‚â´ g = f)).op (x (Exists.choose (_ : ‚Ä¶
  rw [t h.choose (ùüô _) _ hf _]
  -- ‚ä¢ P.map (ùüô Y).op (x f hf) = x f hf
  ¬∑ simp
    -- üéâ no goals
  ¬∑ rw [id_comp]
    -- ‚ä¢ Exists.choose h ‚â´ Exists.choose (_ : ‚àÉ g, R g ‚àß Exists.choose (_ : ‚àÉ h g, R  ‚Ä¶
    exact h.choose_spec.choose_spec.2
    -- üéâ no goals
#align category_theory.presieve.extend_agrees CategoryTheory.Presieve.extend_agrees

/-- The restriction of an extension is the original. -/
@[simp]
theorem restrict_extend {x : FamilyOfElements P R} (t : x.Compatible) :
    x.sieveExtend.restrict (le_generate R) = x := by
  funext Y f hf
  -- ‚ä¢ FamilyOfElements.restrict (_ : R ‚â§ (generate R).arrows) (FamilyOfElements.si ‚Ä¶
  exact extend_agrees t hf
  -- üéâ no goals
#align category_theory.presieve.restrict_extend CategoryTheory.Presieve.restrict_extend

/--
If the arrow set for a family of elements is actually a sieve (i.e. it is downward closed) then the
consistency condition can be simplified.
This is an equivalent condition, see `compatible_iff_sieveCompatible`.

This is the notion of "matching" given for families on sieves given in [MM92], Chapter III,
Section 4, Equation 1, and nlab: https://ncatlab.org/nlab/show/matching+family.
See also the discussion before Lemma C2.1.4 of [Elephant].
-/
def FamilyOfElements.SieveCompatible (x : FamilyOfElements P (S : Presieve X)) : Prop :=
  ‚àÄ ‚¶ÉY Z‚¶Ñ (f : Y ‚ü∂ X) (g : Z ‚ü∂ Y) (hf), x (g ‚â´ f) (S.downward_closed hf g) = P.map g.op (x f hf)
#align category_theory.presieve.family_of_elements.sieve_compatible CategoryTheory.Presieve.FamilyOfElements.SieveCompatible

theorem compatible_iff_sieveCompatible (x : FamilyOfElements P (S : Presieve X)) :
    x.Compatible ‚Üî x.SieveCompatible := by
  constructor
  -- ‚ä¢ FamilyOfElements.Compatible x ‚Üí FamilyOfElements.SieveCompatible x
  ¬∑ intro h Y Z f g hf
    -- ‚ä¢ x (g ‚â´ f) (_ : S.arrows (g ‚â´ f)) = P.map g.op (x f hf)
    simpa using h (ùüô _) g (S.downward_closed hf g) hf (id_comp _)
    -- üéâ no goals
  ¬∑ intro h Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ k
    -- ‚ä¢ P.map g‚ÇÅ.op (x f‚ÇÅ h‚ÇÅ) = P.map g‚ÇÇ.op (x f‚ÇÇ h‚ÇÇ)
    simp_rw [‚Üê h f‚ÇÅ g‚ÇÅ h‚ÇÅ, ‚Üê h f‚ÇÇ g‚ÇÇ h‚ÇÇ]
    -- ‚ä¢ x (g‚ÇÅ ‚â´ f‚ÇÅ) (_ : S.arrows (g‚ÇÅ ‚â´ f‚ÇÅ)) = x (g‚ÇÇ ‚â´ f‚ÇÇ) (_ : S.arrows (g‚ÇÇ ‚â´ f‚ÇÇ))
    congr
    -- üéâ no goals
#align category_theory.presieve.compatible_iff_sieve_compatible CategoryTheory.Presieve.compatible_iff_sieveCompatible

theorem FamilyOfElements.Compatible.to_sieveCompatible {x : FamilyOfElements P (S : Presieve X)}
    (t : x.Compatible) : x.SieveCompatible :=
  (compatible_iff_sieveCompatible x).1 t
#align category_theory.presieve.family_of_elements.compatible.to_sieve_compatible CategoryTheory.Presieve.FamilyOfElements.Compatible.to_sieveCompatible

/--
Given a family of elements `x` for the sieve `S` generated by a presieve `R`, if `x` is restricted
to `R` and then extended back up to `S`, the resulting extension equals `x`.
-/
@[simp]
theorem extend_restrict {x : FamilyOfElements P (generate R)} (t : x.Compatible) :
    (x.restrict (le_generate R)).sieveExtend = x := by
  rw [compatible_iff_sieveCompatible] at t
  -- ‚ä¢ FamilyOfElements.sieveExtend (FamilyOfElements.restrict (_ : R ‚â§ (generate R ‚Ä¶
  funext _ _ h
  -- ‚ä¢ FamilyOfElements.sieveExtend (FamilyOfElements.restrict (_ : R ‚â§ (generate R ‚Ä¶
  apply (t _ _ _).symm.trans
  -- ‚ä¢ x (Exists.choose (_ : ‚àÉ h_1 g, R g ‚àß h_1 ‚â´ g = x‚úù) ‚â´ Exists.choose (_ : ‚àÉ g, ‚Ä¶
  congr
  -- ‚ä¢ Exists.choose (_ : ‚àÉ h_1 g, R g ‚àß h_1 ‚â´ g = x‚úù) ‚â´ Exists.choose (_ : ‚àÉ g, R  ‚Ä¶
  exact h.choose_spec.choose_spec.choose_spec.2
  -- üéâ no goals
#align category_theory.presieve.extend_restrict CategoryTheory.Presieve.extend_restrict

/--
Two compatible families on the sieve generated by a presieve `R` are equal if and only if they are
equal when restricted to `R`.
-/
theorem restrict_inj {x‚ÇÅ x‚ÇÇ : FamilyOfElements P (generate R)} (t‚ÇÅ : x‚ÇÅ.Compatible)
    (t‚ÇÇ : x‚ÇÇ.Compatible) : x‚ÇÅ.restrict (le_generate R) = x‚ÇÇ.restrict (le_generate R) ‚Üí x‚ÇÅ = x‚ÇÇ :=
  fun h => by
  rw [‚Üê extend_restrict t‚ÇÅ, ‚Üê extend_restrict t‚ÇÇ]
  -- ‚ä¢ FamilyOfElements.sieveExtend (FamilyOfElements.restrict (_ : R ‚â§ (generate R ‚Ä¶
  -- porting note: congr fails to make progress
  apply congr_arg
  -- ‚ä¢ FamilyOfElements.restrict (_ : R ‚â§ (generate R).arrows) x‚ÇÅ = FamilyOfElement ‚Ä¶
  exact h
  -- üéâ no goals
#align category_theory.presieve.restrict_inj CategoryTheory.Presieve.restrict_inj

/-- Compatible families of elements for a presheaf of types `P` and a presieve `R`
    are in 1-1 correspondence with compatible families for the same presheaf and
    the sieve generated by `R`, through extension and restriction. -/
@[simps]
noncomputable def compatibleEquivGenerateSieveCompatible :
    { x : FamilyOfElements P R // x.Compatible } ‚âÉ
      { x : FamilyOfElements P (generate R : Presieve X) // x.Compatible } where
  toFun x := ‚ü®x.1.sieveExtend, x.2.sieveExtend‚ü©
  invFun x := ‚ü®x.1.restrict (le_generate R), x.2.restrict _‚ü©
  left_inv x := Subtype.ext (restrict_extend x.2)
  right_inv x := Subtype.ext (extend_restrict x.2)
#align category_theory.presieve.compatible_equiv_generate_sieve_compatible CategoryTheory.Presieve.compatibleEquivGenerateSieveCompatible

theorem FamilyOfElements.comp_of_compatible (S : Sieve X) {x : FamilyOfElements P S}
    (t : x.Compatible) {f : Y ‚ü∂ X} (hf : S f) {Z} (g : Z ‚ü∂ Y) :
    x (g ‚â´ f) (S.downward_closed hf g) = P.map g.op (x f hf) := by
  simpa using t (ùüô _) g (S.downward_closed hf g) hf (id_comp _)
  -- üéâ no goals
#align category_theory.presieve.family_of_elements.comp_of_compatible CategoryTheory.Presieve.FamilyOfElements.comp_of_compatible

section FunctorPullback

variable {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D] (F : D ‚•§ C) {Z : D}

variable {T : Presieve (F.obj Z)} {x : FamilyOfElements P T}

/--
Given a family of elements of a sieve `S` on `F(X)`, we can realize it as a family of elements of
`S.functorPullback F`.
-/
def FamilyOfElements.functorPullback (x : FamilyOfElements P T) :
    FamilyOfElements (F.op ‚ãô P) (T.functorPullback F) := fun _ f hf => x (F.map f) hf
#align category_theory.presieve.family_of_elements.functor_pullback CategoryTheory.Presieve.FamilyOfElements.functorPullback

theorem FamilyOfElements.Compatible.functorPullback (h : x.Compatible) :
    (x.functorPullback F).Compatible := by
  intro Z‚ÇÅ Z‚ÇÇ W g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ eq
  -- ‚ä¢ (F.op ‚ãô P).map g‚ÇÅ.op (FamilyOfElements.functorPullback F x f‚ÇÅ h‚ÇÅ) = (F.op ‚ãô  ‚Ä¶
  exact h (F.map g‚ÇÅ) (F.map g‚ÇÇ) h‚ÇÅ h‚ÇÇ (by simp only [‚Üê F.map_comp, eq])
  -- üéâ no goals
#align category_theory.presieve.family_of_elements.compatible.functor_pullback CategoryTheory.Presieve.FamilyOfElements.Compatible.functorPullback

end FunctorPullback

/-- Given a family of elements of a sieve `S` on `X` whose values factors through `F`, we can
realize it as a family of elements of `S.functorPushforward F`. Since the preimage is obtained by
choice, this is not well-defined generally.
-/
noncomputable def FamilyOfElements.functorPushforward {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D] (F : D ‚•§ C)
    {X : D} {T : Presieve X} (x : FamilyOfElements (F.op ‚ãô P) T) :
    FamilyOfElements P (T.functorPushforward F) := fun Y f h => by
  obtain ‚ü®Z, g, h, h‚ÇÅ, _‚ü© := getFunctorPushforwardStructure h
  -- ‚ä¢ P.obj (op Y)
  exact P.map h.op (x g h‚ÇÅ)
  -- üéâ no goals
#align category_theory.presieve.family_of_elements.functor_pushforward CategoryTheory.Presieve.FamilyOfElements.functorPushforward

section Pullback

/-- Given a family of elements of a sieve `S` on `X`, and a map `Y ‚ü∂ X`, we can obtain a
family of elements of `S.pullback f` by taking the same elements.
-/
def FamilyOfElements.pullback (f : Y ‚ü∂ X) (x : FamilyOfElements P (S : Presieve X)) :
    FamilyOfElements P (S.pullback f : Presieve Y) := fun _ g hg => x (g ‚â´ f) hg
#align category_theory.presieve.family_of_elements.pullback CategoryTheory.Presieve.FamilyOfElements.pullback

theorem FamilyOfElements.Compatible.pullback (f : Y ‚ü∂ X) {x : FamilyOfElements P S}
    (h : x.Compatible) : (x.pullback f).Compatible := by
  simp only [compatible_iff_sieveCompatible] at h ‚ä¢
  -- ‚ä¢ SieveCompatible (FamilyOfElements.pullback f x)
  intro W Z f‚ÇÅ f‚ÇÇ hf
  -- ‚ä¢ FamilyOfElements.pullback f x (f‚ÇÇ ‚â´ f‚ÇÅ) (_ : (Sieve.pullback f S).arrows (f‚ÇÇ ‚Ä¶
  unfold FamilyOfElements.pullback
  -- ‚ä¢ x ((f‚ÇÇ ‚â´ f‚ÇÅ) ‚â´ f) (_ : (Sieve.pullback f S).arrows (f‚ÇÇ ‚â´ f‚ÇÅ)) = P.map f‚ÇÇ.op  ‚Ä¶
  rw [‚Üê h (f‚ÇÅ ‚â´ f) f‚ÇÇ hf]
  -- ‚ä¢ x ((f‚ÇÇ ‚â´ f‚ÇÅ) ‚â´ f) (_ : (Sieve.pullback f S).arrows (f‚ÇÇ ‚â´ f‚ÇÅ)) = x (f‚ÇÇ ‚â´ f‚ÇÅ ‚â´ ‚Ä¶
  congr 1
  -- ‚ä¢ (f‚ÇÇ ‚â´ f‚ÇÅ) ‚â´ f = f‚ÇÇ ‚â´ f‚ÇÅ ‚â´ f
  simp only [assoc]
  -- üéâ no goals
#align category_theory.presieve.family_of_elements.compatible.pullback CategoryTheory.Presieve.FamilyOfElements.Compatible.pullback

end Pullback

/-- Given a morphism of presheaves `f : P ‚ü∂ Q`, we can take a family of elements valued in `P` to a
family of elements valued in `Q` by composing with `f`.
-/
def FamilyOfElements.compPresheafMap (f : P ‚ü∂ Q) (x : FamilyOfElements P R) :
    FamilyOfElements Q R := fun Y g hg => f.app (op Y) (x g hg)
#align category_theory.presieve.family_of_elements.comp_presheaf_map CategoryTheory.Presieve.FamilyOfElements.compPresheafMap

@[simp]
theorem FamilyOfElements.compPresheafMap_id (x : FamilyOfElements P R) :
    x.compPresheafMap (ùüô P) = x :=
  rfl
#align category_theory.presieve.family_of_elements.comp_presheaf_map_id CategoryTheory.Presieve.FamilyOfElements.compPresheafMap_id

@[simp]
theorem FamilyOfElements.compPresheafMap_comp (x : FamilyOfElements P R) (f : P ‚ü∂ Q)
    (g : Q ‚ü∂ U) : (x.compPresheafMap f).compPresheafMap g = x.compPresheafMap (f ‚â´ g) :=
  rfl
#align category_theory.presieve.family_of_elements.comp_prersheaf_map_comp CategoryTheory.Presieve.FamilyOfElements.compPresheafMap_comp

theorem FamilyOfElements.Compatible.compPresheafMap (f : P ‚ü∂ Q) {x : FamilyOfElements P R}
    (h : x.Compatible) : (x.compPresheafMap f).Compatible := by
  intro Z‚ÇÅ Z‚ÇÇ W g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ eq
  -- ‚ä¢ Q.map g‚ÇÅ.op (FamilyOfElements.compPresheafMap f x f‚ÇÅ h‚ÇÅ) = Q.map g‚ÇÇ.op (Fami ‚Ä¶
  unfold FamilyOfElements.compPresheafMap
  -- ‚ä¢ Q.map g‚ÇÅ.op (NatTrans.app f (op Z‚ÇÅ) (x f‚ÇÅ h‚ÇÅ)) = Q.map g‚ÇÇ.op (NatTrans.app f ‚Ä¶
  rwa [‚Üê FunctorToTypes.naturality, ‚Üê FunctorToTypes.naturality, h]
  -- üéâ no goals
#align category_theory.presieve.family_of_elements.compatible.comp_presheaf_map CategoryTheory.Presieve.FamilyOfElements.Compatible.compPresheafMap

/--
The given element `t` of `P.obj (op X)` is an *amalgamation* for the family of elements `x` if every
restriction `P.map f.op t = x_f` for every arrow `f` in the presieve `R`.

This is the definition given in https://ncatlab.org/nlab/show/sheaf#GeneralDefinitionInComponents,
and https://ncatlab.org/nlab/show/matching+family, as well as [MM92], Chapter III, Section 4,
equation (2).
-/
def FamilyOfElements.IsAmalgamation (x : FamilyOfElements P R) (t : P.obj (op X)) : Prop :=
  ‚àÄ ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X) (h : R f), P.map f.op t = x f h
#align category_theory.presieve.family_of_elements.is_amalgamation CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation

theorem FamilyOfElements.IsAmalgamation.compPresheafMap {x : FamilyOfElements P R} {t} (f : P ‚ü∂ Q)
    (h : x.IsAmalgamation t) : (x.compPresheafMap f).IsAmalgamation (f.app (op X) t) := by
  intro Y g hg
  -- ‚ä¢ Q.map g.op (NatTrans.app f (op X) t) = FamilyOfElements.compPresheafMap f x  ‚Ä¶
  dsimp [FamilyOfElements.compPresheafMap]
  -- ‚ä¢ Q.map g.op (NatTrans.app f (op X) t) = NatTrans.app f (op Y) (x g hg)
  change (f.app _ ‚â´ Q.map _) _ = _
  -- ‚ä¢ (NatTrans.app f (op X) ‚â´ Q.map g.op) t = NatTrans.app f (op Y) (x g hg)
  rw [‚Üê f.naturality, types_comp_apply, h g hg]
  -- üéâ no goals
#align category_theory.presieve.family_of_elements.is_amalgamation.comp_presheaf_map CategoryTheory.Presieve.FamilyOfElements.IsAmalgamation.compPresheafMap

theorem is_compatible_of_exists_amalgamation (x : FamilyOfElements P R)
    (h : ‚àÉ t, x.IsAmalgamation t) : x.Compatible := by
  cases' h with t ht
  -- ‚ä¢ FamilyOfElements.Compatible x
  intro Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ h‚ÇÅ h‚ÇÇ comm
  -- ‚ä¢ P.map g‚ÇÅ.op (x f‚ÇÅ h‚ÇÅ) = P.map g‚ÇÇ.op (x f‚ÇÇ h‚ÇÇ)
  rw [‚Üê ht _ h‚ÇÅ, ‚Üê ht _ h‚ÇÇ, ‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, comm]
  -- ‚ä¢ P.map (g‚ÇÇ ‚â´ f‚ÇÇ).op t = P.map g‚ÇÇ.op (P.map f‚ÇÇ.op t)
  simp
  -- üéâ no goals
#align category_theory.presieve.is_compatible_of_exists_amalgamation CategoryTheory.Presieve.is_compatible_of_exists_amalgamation

theorem isAmalgamation_restrict {R‚ÇÅ R‚ÇÇ : Presieve X} (h : R‚ÇÅ ‚â§ R‚ÇÇ) (x : FamilyOfElements P R‚ÇÇ)
    (t : P.obj (op X)) (ht : x.IsAmalgamation t) : (x.restrict h).IsAmalgamation t := fun Y f hf =>
  ht f (h Y hf)
#align category_theory.presieve.is_amalgamation_restrict CategoryTheory.Presieve.isAmalgamation_restrict

theorem isAmalgamation_sieveExtend {R : Presieve X} (x : FamilyOfElements P R) (t : P.obj (op X))
    (ht : x.IsAmalgamation t) : x.sieveExtend.IsAmalgamation t := by
  intro Y f hf
  -- ‚ä¢ P.map f.op t = FamilyOfElements.sieveExtend x f hf
  dsimp [FamilyOfElements.sieveExtend]
  -- ‚ä¢ P.map f.op t = P.map (Exists.choose (_ : ‚àÉ h g, R g ‚àß h ‚â´ g = f)).op (x (Exi ‚Ä¶
  rw [‚Üê ht _, ‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, hf.choose_spec.choose_spec.choose_spec.2]
  -- üéâ no goals
#align category_theory.presieve.is_amalgamation_sieve_extend CategoryTheory.Presieve.isAmalgamation_sieveExtend

/-- A presheaf is separated for a presieve if there is at most one amalgamation. -/
def IsSeparatedFor (P : C·µí·µñ ‚•§ Type w) (R : Presieve X) : Prop :=
  ‚àÄ (x : FamilyOfElements P R) (t‚ÇÅ t‚ÇÇ), x.IsAmalgamation t‚ÇÅ ‚Üí x.IsAmalgamation t‚ÇÇ ‚Üí t‚ÇÅ = t‚ÇÇ
#align category_theory.presieve.is_separated_for CategoryTheory.Presieve.IsSeparatedFor

theorem IsSeparatedFor.ext {R : Presieve X} (hR : IsSeparatedFor P R) {t‚ÇÅ t‚ÇÇ : P.obj (op X)}
    (h : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ (_ : R f), P.map f.op t‚ÇÅ = P.map f.op t‚ÇÇ) : t‚ÇÅ = t‚ÇÇ :=
  hR (fun _ f _ => P.map f.op t‚ÇÇ) t‚ÇÅ t‚ÇÇ (fun _ _ hf => h hf) fun _ _ _ => rfl
#align category_theory.presieve.is_separated_for.ext CategoryTheory.Presieve.IsSeparatedFor.ext

theorem isSeparatedFor_iff_generate :
    IsSeparatedFor P R ‚Üî IsSeparatedFor P (generate R : Presieve X) := by
  constructor
  -- ‚ä¢ IsSeparatedFor P R ‚Üí IsSeparatedFor P (generate R).arrows
  ¬∑ intro h x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ
    -- ‚ä¢ t‚ÇÅ = t‚ÇÇ
    apply h (x.restrict (le_generate R)) t‚ÇÅ t‚ÇÇ _ _
    -- ‚ä¢ FamilyOfElements.IsAmalgamation (FamilyOfElements.restrict (_ : R ‚â§ (generat ‚Ä¶
    ¬∑ exact isAmalgamation_restrict _ x t‚ÇÅ ht‚ÇÅ
      -- üéâ no goals
    ¬∑ exact isAmalgamation_restrict _ x t‚ÇÇ ht‚ÇÇ
      -- üéâ no goals
  ¬∑ intro h x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ
    -- ‚ä¢ t‚ÇÅ = t‚ÇÇ
    apply h x.sieveExtend
    -- ‚ä¢ FamilyOfElements.IsAmalgamation (FamilyOfElements.sieveExtend x) t‚ÇÅ
    ¬∑ exact isAmalgamation_sieveExtend x t‚ÇÅ ht‚ÇÅ
      -- üéâ no goals
    ¬∑ exact isAmalgamation_sieveExtend x t‚ÇÇ ht‚ÇÇ
      -- üéâ no goals
#align category_theory.presieve.is_separated_for_iff_generate CategoryTheory.Presieve.isSeparatedFor_iff_generate

theorem isSeparatedFor_top (P : C·µí·µñ ‚•§ Type w) : IsSeparatedFor P (‚ä§ : Presieve X) :=
  fun x t‚ÇÅ t‚ÇÇ h‚ÇÅ h‚ÇÇ => by
  have q‚ÇÅ := h‚ÇÅ (ùüô X) (by tauto)
  -- ‚ä¢ t‚ÇÅ = t‚ÇÇ
  have q‚ÇÇ := h‚ÇÇ (ùüô X) (by tauto)
  -- ‚ä¢ t‚ÇÅ = t‚ÇÇ
  simp only [op_id, FunctorToTypes.map_id_apply] at q‚ÇÅ q‚ÇÇ
  -- ‚ä¢ t‚ÇÅ = t‚ÇÇ
  rw [q‚ÇÅ, q‚ÇÇ]
  -- üéâ no goals
#align category_theory.presieve.is_separated_for_top CategoryTheory.Presieve.isSeparatedFor_top

/-- We define `P` to be a sheaf for the presieve `R` if every compatible family has a unique
amalgamation.

This is the definition of a sheaf for the given presieve given in C2.1.2 of [Elephant], and
https://ncatlab.org/nlab/show/sheaf#GeneralDefinitionInComponents.
Using `compatible_iff_sieveCompatible`,
this is equivalent to the definition of a sheaf in [MM92], Chapter III, Section 4.
-/
def IsSheafFor (P : C·µí·µñ ‚•§ Type w) (R : Presieve X) : Prop :=
  ‚àÄ x : FamilyOfElements P R, x.Compatible ‚Üí ‚àÉ! t, x.IsAmalgamation t
#align category_theory.presieve.is_sheaf_for CategoryTheory.Presieve.IsSheafFor

/-- This is an equivalent condition to be a sheaf, which is useful for the abstraction to local
operators on elementary toposes. However this definition is defined only for sieves, not presieves.
The equivalence between this and `IsSheafFor` is given in `isSheafFor_iff_yonedaSheafCondition`.
This version is also useful to establish that being a sheaf is preserved under isomorphism of
presheaves.

See the discussion before Equation (3) of [MM92], Chapter III, Section 4. See also C2.1.4 of
[Elephant]. This is also a direct reformulation of <https://stacks.math.columbia.edu/tag/00Z8>.
-/
def YonedaSheafCondition (P : C·µí·µñ ‚•§ Type v‚ÇÅ) (S : Sieve X) : Prop :=
  ‚àÄ f : S.functor ‚ü∂ P, ‚àÉ! g, S.functorInclusion ‚â´ g = f
#align category_theory.presieve.yoneda_sheaf_condition CategoryTheory.Presieve.YonedaSheafCondition

-- TODO: We can generalize the universe parameter v‚ÇÅ above by composing with
-- appropriate `ulift_functor`s.
/-- (Implementation). This is a (primarily internal) equivalence between natural transformations
and compatible families.

Cf the discussion after Lemma 7.47.10 in <https://stacks.math.columbia.edu/tag/00YW>. See also
the proof of C2.1.4 of [Elephant], and the discussion in [MM92], Chapter III, Section 4.
-/
def natTransEquivCompatibleFamily {P : C·µí·µñ ‚•§ Type v‚ÇÅ} :
    (S.functor ‚ü∂ P) ‚âÉ { x : FamilyOfElements P (S : Presieve X) // x.Compatible } where
  toFun Œ± := by
    refine' ‚ü®fun Y f hf => _, _‚ü©
    -- ‚ä¢ P.obj (op Y)
    ¬∑ apply Œ±.app (op Y) ‚ü®_, hf‚ü©
      -- üéâ no goals
    ¬∑ rw [compatible_iff_sieveCompatible]
      -- ‚ä¢ FamilyOfElements.SieveCompatible fun Y f hf => NatTrans.app Œ± (op Y) { val : ‚Ä¶
      intro Y Z f g hf
      -- ‚ä¢ (fun Y f hf => NatTrans.app Œ± (op Y) { val := f, property := hf }) Z (g ‚â´ f) ‚Ä¶
      dsimp
      -- ‚ä¢ NatTrans.app Œ± (op Z) { val := g ‚â´ f, property := (_ : S.arrows (g ‚â´ f)) } = ‚Ä¶
      rw [‚Üê FunctorToTypes.naturality _ _ Œ± g.op]
      -- ‚ä¢ NatTrans.app Œ± (op Z) { val := g ‚â´ f, property := (_ : S.arrows (g ‚â´ f)) } = ‚Ä¶
      rfl
      -- üéâ no goals
  invFun t :=
    { app := fun Y f => t.1 _ f.2
      naturality := fun Y Z g => by
        ext ‚ü®f, hf‚ü©
        -- ‚ä¢ ((functor S).map g ‚â´ (fun Y f => ‚Üët ‚Üëf (_ : S.arrows ‚Üëf)) Z) { val := f, pro ‚Ä¶
        apply t.2.to_sieveCompatible _ }
        -- üéâ no goals
  left_inv Œ± := by
    ext X ‚ü®_, _‚ü©
    -- ‚ä¢ NatTrans.app ((fun t => NatTrans.mk fun Y f => ‚Üët ‚Üëf (_ : S.arrows ‚Üëf)) ((fu ‚Ä¶
    rfl
    -- üéâ no goals
  right_inv := by
    rintro ‚ü®x, hx‚ü©
    -- ‚ä¢ (fun Œ± => { val := fun Y f hf => NatTrans.app Œ± (op Y) { val := f, property  ‚Ä¶
    rfl
    -- üéâ no goals
#align category_theory.presieve.nat_trans_equiv_compatible_family CategoryTheory.Presieve.natTransEquivCompatibleFamily

/-- (Implementation). A lemma useful to prove `isSheafFor_iff_yonedaSheafCondition`. -/
theorem extension_iff_amalgamation {P : C·µí·µñ ‚•§ Type v‚ÇÅ} (x : S.functor ‚ü∂ P) (g : yoneda.obj X ‚ü∂ P) :
    S.functorInclusion ‚â´ g = x ‚Üî
      (natTransEquivCompatibleFamily x).1.IsAmalgamation (yonedaEquiv g) := by
  change _ ‚Üî ‚àÄ ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X) (h : S f), P.map f.op (yonedaEquiv g) = x.app (op Y) ‚ü®f, h‚ü©
  -- ‚ä¢ functorInclusion S ‚â´ g = x ‚Üî ‚àÄ ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X) (h : S.arrows f), P.map f ‚Ä¶
  constructor
  -- ‚ä¢ functorInclusion S ‚â´ g = x ‚Üí ‚àÄ ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X) (h : S.arrows f), P.map f ‚Ä¶
  ¬∑ rintro rfl Y f hf
    -- ‚ä¢ P.map f.op (‚ÜëyonedaEquiv g) = NatTrans.app (functorInclusion S ‚â´ g) (op Y) { ‚Ä¶
    rw [yonedaEquiv_naturality]
    -- ‚ä¢ ‚ÜëyonedaEquiv (yoneda.map f ‚â´ g) = NatTrans.app (functorInclusion S ‚â´ g) (op  ‚Ä¶
    dsimp
    -- ‚ä¢ NatTrans.app g (op Y) (ùüô Y ‚â´ f) = NatTrans.app g (op Y) f
    simp
    -- üéâ no goals
  -- See note [dsimp, simp].
  ¬∑ intro h
    -- ‚ä¢ functorInclusion S ‚â´ g = x
    ext Y ‚ü®f, hf‚ü©
    -- ‚ä¢ NatTrans.app (functorInclusion S ‚â´ g) Y { val := f, property := hf } = NatTr ‚Ä¶
    convert h f hf
    -- ‚ä¢ NatTrans.app (functorInclusion S ‚â´ g) Y { val := f, property := hf } = P.map ‚Ä¶
    rw [yonedaEquiv_naturality]
    -- ‚ä¢ NatTrans.app (functorInclusion S ‚â´ g) Y { val := f, property := hf } = ‚Üëyone ‚Ä¶
    simp [yonedaEquiv]
    -- üéâ no goals
#align category_theory.presieve.extension_iff_amalgamation CategoryTheory.Presieve.extension_iff_amalgamation

/-- The yoneda version of the sheaf condition is equivalent to the sheaf condition.

C2.1.4 of [Elephant].
-/
theorem isSheafFor_iff_yonedaSheafCondition {P : C·µí·µñ ‚•§ Type v‚ÇÅ} :
    IsSheafFor P (S : Presieve X) ‚Üî YonedaSheafCondition P S := by
  rw [IsSheafFor, YonedaSheafCondition]
  -- ‚ä¢ (‚àÄ (x : FamilyOfElements P S.arrows), FamilyOfElements.Compatible x ‚Üí ‚àÉ! t,  ‚Ä¶
  simp_rw [extension_iff_amalgamation]
  -- ‚ä¢ (‚àÄ (x : FamilyOfElements P S.arrows), FamilyOfElements.Compatible x ‚Üí ‚àÉ! t,  ‚Ä¶
  rw [Equiv.forall_congr_left' natTransEquivCompatibleFamily]
  -- ‚ä¢ (‚àÄ (x : FamilyOfElements P S.arrows), FamilyOfElements.Compatible x ‚Üí ‚àÉ! t,  ‚Ä¶
  rw [Subtype.forall]
  -- ‚ä¢ (‚àÄ (x : FamilyOfElements P S.arrows), FamilyOfElements.Compatible x ‚Üí ‚àÉ! t,  ‚Ä¶
  apply ball_congr
  -- ‚ä¢ ‚àÄ (x : FamilyOfElements P S.arrows) (h : FamilyOfElements.Compatible x), (‚àÉ! ‚Ä¶
  intro x hx
  -- ‚ä¢ (‚àÉ! t, FamilyOfElements.IsAmalgamation x t) ‚Üî ‚àÉ! g, FamilyOfElements.IsAmalg ‚Ä¶
  rw [Equiv.exists_unique_congr_left _]
  -- ‚ä¢ (‚àÉ! t, FamilyOfElements.IsAmalgamation x t) ‚Üî ‚àÉ! y, FamilyOfElements.IsAmalg ‚Ä¶
  simp
  -- üéâ no goals
#align category_theory.presieve.is_sheaf_for_iff_yoneda_sheaf_condition CategoryTheory.Presieve.isSheafFor_iff_yonedaSheafCondition

/--
If `P` is a sheaf for the sieve `S` on `X`, a natural transformation from `S` (viewed as a functor)
to `P` can be (uniquely) extended to all of `yoneda.obj X`.

      f
   S  ‚Üí  P
   ‚Üì  ‚Üó
   yX

-/
noncomputable def IsSheafFor.extend {P : C·µí·µñ ‚•§ Type v‚ÇÅ} (h : IsSheafFor P (S : Presieve X))
    (f : S.functor ‚ü∂ P) : yoneda.obj X ‚ü∂ P :=
  (isSheafFor_iff_yonedaSheafCondition.1 h f).exists.choose
#align category_theory.presieve.is_sheaf_for.extend CategoryTheory.Presieve.IsSheafFor.extend

/--
Show that the extension of `f : S.functor ‚ü∂ P` to all of `yoneda.obj X` is in fact an extension, ie
that the triangle below commutes, provided `P` is a sheaf for `S`

      f
   S  ‚Üí  P
   ‚Üì  ‚Üó
   yX

-/
@[reassoc (attr := simp)]
theorem IsSheafFor.functorInclusion_comp_extend {P : C·µí·µñ ‚•§ Type v‚ÇÅ} (h : IsSheafFor P S)
    (f : S.functor ‚ü∂ P) : S.functorInclusion ‚â´ h.extend f = f :=
  (isSheafFor_iff_yonedaSheafCondition.1 h f).exists.choose_spec
#align category_theory.presieve.is_sheaf_for.functor_inclusion_comp_extend CategoryTheory.Presieve.IsSheafFor.functorInclusion_comp_extend

/-- The extension of `f` to `yoneda.obj X` is unique. -/
theorem IsSheafFor.unique_extend {P : C·µí·µñ ‚•§ Type v‚ÇÅ} (h : IsSheafFor P S) {f : S.functor ‚ü∂ P}
    (t : yoneda.obj X ‚ü∂ P) (ht : S.functorInclusion ‚â´ t = f) : t = h.extend f :=
  (isSheafFor_iff_yonedaSheafCondition.1 h f).unique ht (h.functorInclusion_comp_extend f)
#align category_theory.presieve.is_sheaf_for.unique_extend CategoryTheory.Presieve.IsSheafFor.unique_extend

/--
If `P` is a sheaf for the sieve `S` on `X`, then if two natural transformations from `yoneda.obj X`
to `P` agree when restricted to the subfunctor given by `S`, they are equal.
-/
theorem IsSheafFor.hom_ext {P : C·µí·µñ ‚•§ Type v‚ÇÅ} (h : IsSheafFor P (S : Presieve X))
    (t‚ÇÅ t‚ÇÇ : yoneda.obj X ‚ü∂ P) (ht : S.functorInclusion ‚â´ t‚ÇÅ = S.functorInclusion ‚â´ t‚ÇÇ) :
    t‚ÇÅ = t‚ÇÇ :=
  (h.unique_extend t‚ÇÅ ht).trans (h.unique_extend t‚ÇÇ rfl).symm
#align category_theory.presieve.is_sheaf_for.hom_ext CategoryTheory.Presieve.IsSheafFor.hom_ext

/-- `P` is a sheaf for `R` iff it is separated for `R` and there exists an amalgamation. -/
theorem isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor :
    (IsSeparatedFor P R ‚àß ‚àÄ x : FamilyOfElements P R, x.Compatible ‚Üí ‚àÉ t, x.IsAmalgamation t) ‚Üî
      IsSheafFor P R := by
  rw [IsSeparatedFor, ‚Üê forall_and]
  -- ‚ä¢ (‚àÄ (x : FamilyOfElements P R), (‚àÄ (t‚ÇÅ t‚ÇÇ : P.obj (op X)), FamilyOfElements.I ‚Ä¶
  apply forall_congr'
  -- ‚ä¢ ‚àÄ (a : FamilyOfElements P R), (‚àÄ (t‚ÇÅ t‚ÇÇ : P.obj (op X)), FamilyOfElements.Is ‚Ä¶
  intro x
  -- ‚ä¢ (‚àÄ (t‚ÇÅ t‚ÇÇ : P.obj (op X)), FamilyOfElements.IsAmalgamation x t‚ÇÅ ‚Üí FamilyOfEl ‚Ä¶
  constructor
  -- ‚ä¢ (‚àÄ (t‚ÇÅ t‚ÇÇ : P.obj (op X)), FamilyOfElements.IsAmalgamation x t‚ÇÅ ‚Üí FamilyOfEl ‚Ä¶
  ¬∑ intro z hx
    -- ‚ä¢ ‚àÉ! t, FamilyOfElements.IsAmalgamation x t
    exact exists_unique_of_exists_of_unique (z.2 hx) z.1
    -- üéâ no goals
  ¬∑ intro h
    -- ‚ä¢ (‚àÄ (t‚ÇÅ t‚ÇÇ : P.obj (op X)), FamilyOfElements.IsAmalgamation x t‚ÇÅ ‚Üí FamilyOfEl ‚Ä¶
    refine' ‚ü®_, ExistsUnique.exists ‚àò h‚ü©
    -- ‚ä¢ ‚àÄ (t‚ÇÅ t‚ÇÇ : P.obj (op X)), FamilyOfElements.IsAmalgamation x t‚ÇÅ ‚Üí FamilyOfEle ‚Ä¶
    intro t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ
    -- ‚ä¢ t‚ÇÅ = t‚ÇÇ
    apply (h _).unique ht‚ÇÅ ht‚ÇÇ
    -- ‚ä¢ FamilyOfElements.Compatible x
    exact is_compatible_of_exists_amalgamation x ‚ü®_, ht‚ÇÇ‚ü©
    -- üéâ no goals
#align category_theory.presieve.is_separated_for_and_exists_is_amalgamation_iff_sheaf_for CategoryTheory.Presieve.isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor

/-- If `P` is separated for `R` and every family has an amalgamation, then `P` is a sheaf for `R`.
-/
theorem IsSeparatedFor.isSheafFor (t : IsSeparatedFor P R) :
    (‚àÄ x : FamilyOfElements P R, x.Compatible ‚Üí ‚àÉ t, x.IsAmalgamation t) ‚Üí IsSheafFor P R := by
  rw [‚Üê isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  -- ‚ä¢ (‚àÄ (x : FamilyOfElements P R), FamilyOfElements.Compatible x ‚Üí ‚àÉ t, FamilyOf ‚Ä¶
  exact And.intro t
  -- üéâ no goals
#align category_theory.presieve.is_separated_for.is_sheaf_for CategoryTheory.Presieve.IsSeparatedFor.isSheafFor

/-- If `P` is a sheaf for `R`, it is separated for `R`. -/
theorem IsSheafFor.isSeparatedFor : IsSheafFor P R ‚Üí IsSeparatedFor P R := fun q =>
  (isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor.2 q).1
#align category_theory.presieve.is_sheaf_for.is_separated_for CategoryTheory.Presieve.IsSheafFor.isSeparatedFor

/-- Get the amalgamation of the given compatible family, provided we have a sheaf. -/
noncomputable def IsSheafFor.amalgamate (t : IsSheafFor P R) (x : FamilyOfElements P R)
    (hx : x.Compatible) : P.obj (op X) :=
  (t x hx).exists.choose
#align category_theory.presieve.is_sheaf_for.amalgamate CategoryTheory.Presieve.IsSheafFor.amalgamate

theorem IsSheafFor.isAmalgamation (t : IsSheafFor P R) {x : FamilyOfElements P R}
    (hx : x.Compatible) : x.IsAmalgamation (t.amalgamate x hx) :=
  (t x hx).exists.choose_spec
#align category_theory.presieve.is_sheaf_for.is_amalgamation CategoryTheory.Presieve.IsSheafFor.isAmalgamation

@[simp]
theorem IsSheafFor.valid_glue (t : IsSheafFor P R) {x : FamilyOfElements P R} (hx : x.Compatible)
    (f : Y ‚ü∂ X) (Hf : R f) : P.map f.op (t.amalgamate x hx) = x f Hf :=
  t.isAmalgamation hx f Hf
#align category_theory.presieve.is_sheaf_for.valid_glue CategoryTheory.Presieve.IsSheafFor.valid_glue

/-- C2.1.3 in [Elephant] -/
theorem isSheafFor_iff_generate (R : Presieve X) :
    IsSheafFor P R ‚Üî IsSheafFor P (generate R : Presieve X) := by
  rw [‚Üê isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  -- ‚ä¢ (IsSeparatedFor P R ‚àß ‚àÄ (x : FamilyOfElements P R), FamilyOfElements.Compati ‚Ä¶
  rw [‚Üê isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  -- ‚ä¢ (IsSeparatedFor P R ‚àß ‚àÄ (x : FamilyOfElements P R), FamilyOfElements.Compati ‚Ä¶
  rw [‚Üê isSeparatedFor_iff_generate]
  -- ‚ä¢ (IsSeparatedFor P R ‚àß ‚àÄ (x : FamilyOfElements P R), FamilyOfElements.Compati ‚Ä¶
  apply and_congr (Iff.refl _)
  -- ‚ä¢ (‚àÄ (x : FamilyOfElements P R), FamilyOfElements.Compatible x ‚Üí ‚àÉ t, FamilyOf ‚Ä¶
  constructor
  -- ‚ä¢ (‚àÄ (x : FamilyOfElements P R), FamilyOfElements.Compatible x ‚Üí ‚àÉ t, FamilyOf ‚Ä¶
  ¬∑ intro q x hx
    -- ‚ä¢ ‚àÉ t, FamilyOfElements.IsAmalgamation x t
    apply Exists.imp _ (q _ (hx.restrict (le_generate R)))
    -- ‚ä¢ ‚àÄ (a : P.obj (op X)), FamilyOfElements.IsAmalgamation (FamilyOfElements.rest ‚Ä¶
    intro t ht
    -- ‚ä¢ FamilyOfElements.IsAmalgamation x t
    simpa [hx] using isAmalgamation_sieveExtend _ _ ht
    -- üéâ no goals
  ¬∑ intro q x hx
    -- ‚ä¢ ‚àÉ t, FamilyOfElements.IsAmalgamation x t
    apply Exists.imp _ (q _ hx.sieveExtend)
    -- ‚ä¢ ‚àÄ (a : P.obj (op X)), FamilyOfElements.IsAmalgamation (FamilyOfElements.siev ‚Ä¶
    intro t ht
    -- ‚ä¢ FamilyOfElements.IsAmalgamation x t
    simpa [hx] using isAmalgamation_restrict (le_generate R) _ _ ht
    -- üéâ no goals
#align category_theory.presieve.is_sheaf_for_iff_generate CategoryTheory.Presieve.isSheafFor_iff_generate

/-- Every presheaf is a sheaf for the family {ùüô X}.

[Elephant] C2.1.5(i)
-/
theorem isSheafFor_singleton_iso (P : C·µí·µñ ‚•§ Type w) : IsSheafFor P (Presieve.singleton (ùüô X)) := by
  intro x _
  -- ‚ä¢ ‚àÉ! t, FamilyOfElements.IsAmalgamation x t
  refine' ‚ü®x _ (Presieve.singleton_self _), _, _‚ü©
  -- ‚ä¢ (fun t => FamilyOfElements.IsAmalgamation x t) (x (ùüô X) (_ : singleton (ùüô X) ‚Ä¶
  ¬∑ rintro _ _ ‚ü®rfl, rfl‚ü©
    -- ‚ä¢ P.map (ùüô X).op (x (ùüô X) (_ : singleton (ùüô X) (ùüô X))) = x (ùüô X) (_ : singleto ‚Ä¶
    simp
    -- üéâ no goals
  ¬∑ intro t ht
    -- ‚ä¢ t = x (ùüô X) (_ : singleton (ùüô X) (ùüô X))
    simpa using ht _ (Presieve.singleton_self _)
    -- üéâ no goals
#align category_theory.presieve.is_sheaf_for_singleton_iso CategoryTheory.Presieve.isSheafFor_singleton‚Çì_iso

/-- Every presheaf is a sheaf for the maximal sieve.

[Elephant] C2.1.5(ii)
-/
theorem isSheafFor_top_sieve (P : C·µí·µñ ‚•§ Type w) : IsSheafFor P ((‚ä§ : Sieve X) : Presieve X) := by
  rw [‚Üê generate_of_singleton_isSplitEpi (ùüô X)]
  -- ‚ä¢ IsSheafFor P (generate (singleton (ùüô X))).arrows
  rw [‚Üê isSheafFor_iff_generate]
  -- ‚ä¢ IsSheafFor P (singleton (ùüô X))
  apply isSheafFor_singleton_iso
  -- üéâ no goals
#align category_theory.presieve.is_sheaf_for_top_sieve CategoryTheory.Presieve.isSheafFor_top_sieve

/-- If `P` is a sheaf for `S`, and it is iso to `P'`, then `P'` is a sheaf for `S`. This shows that
"being a sheaf for a presieve" is a mathematical or hygienic property.
-/
theorem isSheafFor_iso {P' : C·µí·µñ ‚•§ Type w} (i : P ‚âÖ P') : IsSheafFor P R ‚Üí IsSheafFor P' R := by
  intro h x hx
  -- ‚ä¢ ‚àÉ! t, FamilyOfElements.IsAmalgamation x t
  let x' := x.compPresheafMap i.inv
  -- ‚ä¢ ‚àÉ! t, FamilyOfElements.IsAmalgamation x t
  have : x'.Compatible := FamilyOfElements.Compatible.compPresheafMap i.inv hx
  -- ‚ä¢ ‚àÉ! t, FamilyOfElements.IsAmalgamation x t
  obtain ‚ü®t, ht1, ht2‚ü© := h x' this
  -- ‚ä¢ ‚àÉ! t, FamilyOfElements.IsAmalgamation x t
  use i.hom.app _ t
  -- ‚ä¢ (fun t => FamilyOfElements.IsAmalgamation x t) (NatTrans.app i.hom (op X) t) ‚Ä¶
  fconstructor
  -- ‚ä¢ (fun t => FamilyOfElements.IsAmalgamation x t) (NatTrans.app i.hom (op X) t)
  ¬∑ convert FamilyOfElements.IsAmalgamation.compPresheafMap i.hom ht1
    -- ‚ä¢ x = FamilyOfElements.compPresheafMap i.hom x'
    simp
    -- üéâ no goals
  ¬∑ intro y hy
    -- ‚ä¢ y = NatTrans.app i.hom (op X) t
    rw [show y = (i.inv.app (op X) ‚â´ i.hom.app (op X)) y by simp]
    -- ‚ä¢ (NatTrans.app i.inv (op X) ‚â´ NatTrans.app i.hom (op X)) y = NatTrans.app i.h ‚Ä¶
    simp [ht2 (i.inv.app _ y) (FamilyOfElements.IsAmalgamation.compPresheafMap i.inv hy)]
    -- üéâ no goals
#align category_theory.presieve.is_sheaf_for_iso CategoryTheory.Presieve.isSheafFor_iso

/-- If a presieve `R` on `X` has a subsieve `S` such that:

* `P` is a sheaf for `S`.
* For every `f` in `R`, `P` is separated for the pullback of `S` along `f`,

then `P` is a sheaf for `R`.

This is closely related to [Elephant] C2.1.6(i).
-/
theorem isSheafFor_subsieve_aux (P : C·µí·µñ ‚•§ Type w) {S : Sieve X} {R : Presieve X}
    (h : (S : Presieve X) ‚â§ R) (hS : IsSheafFor P (S : Presieve X))
    (trans : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, R f ‚Üí IsSeparatedFor P (S.pullback f : Presieve Y)) :
    IsSheafFor P R := by
  rw [‚Üê isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor]
  -- ‚ä¢ IsSeparatedFor P R ‚àß ‚àÄ (x : FamilyOfElements P R), FamilyOfElements.Compatib ‚Ä¶
  constructor
  -- ‚ä¢ IsSeparatedFor P R
  ¬∑ intro x t‚ÇÅ t‚ÇÇ ht‚ÇÅ ht‚ÇÇ
    -- ‚ä¢ t‚ÇÅ = t‚ÇÇ
    exact
      hS.isSeparatedFor _ _ _ (isAmalgamation_restrict h x t‚ÇÅ ht‚ÇÅ)
        (isAmalgamation_restrict h x t‚ÇÇ ht‚ÇÇ)
  ¬∑ intro x hx
    -- ‚ä¢ ‚àÉ t, FamilyOfElements.IsAmalgamation x t
    use hS.amalgamate _ (hx.restrict h)
    -- ‚ä¢ FamilyOfElements.IsAmalgamation x (IsSheafFor.amalgamate hS (FamilyOfElement ‚Ä¶
    intro W j hj
    -- ‚ä¢ P.map j.op (IsSheafFor.amalgamate hS (FamilyOfElements.restrict h x) (_ : Fa ‚Ä¶
    apply (trans hj).ext
    -- ‚ä¢ ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ W‚¶Ñ, (Sieve.pullback j S).arrows f ‚Üí P.map f.op (P.map j.o ‚Ä¶
    intro Y f hf
    -- ‚ä¢ P.map f.op (P.map j.op (IsSheafFor.amalgamate hS (FamilyOfElements.restrict  ‚Ä¶
    rw [‚Üê FunctorToTypes.map_comp_apply, ‚Üê op_comp, hS.valid_glue (hx.restrict h) _ hf,
      FamilyOfElements.restrict, ‚Üê hx (ùüô _) f (h _ hf) _ (id_comp _)]
    simp
    -- üéâ no goals
#align category_theory.presieve.is_sheaf_for_subsieve_aux CategoryTheory.Presieve.isSheafFor_subsieve_aux

/--
If `P` is a sheaf for every pullback of the sieve `S`, then `P` is a sheaf for any presieve which
contains `S`.
This is closely related to [Elephant] C2.1.6.
-/
theorem isSheafFor_subsieve (P : C·µí·µñ ‚•§ Type w) {S : Sieve X} {R : Presieve X}
    (h : (S : Presieve X) ‚â§ R) (trans : ‚àÄ ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X),
      IsSheafFor P (S.pullback f : Presieve Y)) :
    IsSheafFor P R :=
  isSheafFor_subsieve_aux P h (by simpa using trans (ùüô _)) fun Y f _ => (trans f).isSeparatedFor
                                  -- üéâ no goals
#align category_theory.presieve.is_sheaf_for_subsieve CategoryTheory.Presieve.isSheafFor_subsieve

/-- A presheaf is separated for a topology if it is separated for every sieve in the topology. -/
def IsSeparated (P : C·µí·µñ ‚•§ Type w) : Prop :=
  ‚àÄ {X} (S : Sieve X), S ‚àà J X ‚Üí IsSeparatedFor P (S : Presieve X)
#align category_theory.presieve.is_separated CategoryTheory.Presieve.IsSeparated

/-- A presheaf is a sheaf for a topology if it is a sheaf for every sieve in the topology.

If the given topology is given by a pretopology, `isSheaf_pretopology` shows it suffices to
check the sheaf condition at presieves in the pretopology.
-/
def IsSheaf (P : C·µí·µñ ‚•§ Type w) : Prop :=
  ‚àÄ ‚¶ÉX‚¶Ñ (S : Sieve X), S ‚àà J X ‚Üí IsSheafFor P (S : Presieve X)
#align category_theory.presieve.is_sheaf CategoryTheory.Presieve.IsSheaf

theorem IsSheaf.isSheafFor {P : C·µí·µñ ‚•§ Type w} (hp : IsSheaf J P) (R : Presieve X)
    (hr : generate R ‚àà J X) : IsSheafFor P R :=
  (isSheafFor_iff_generate R).2 <| hp _ hr
#align category_theory.presieve.is_sheaf.is_sheaf_for CategoryTheory.Presieve.IsSheaf.isSheafFor

theorem isSheaf_of_le (P : C·µí·µñ ‚•§ Type w) {J‚ÇÅ J‚ÇÇ : GrothendieckTopology C} :
    J‚ÇÅ ‚â§ J‚ÇÇ ‚Üí IsSheaf J‚ÇÇ P ‚Üí IsSheaf J‚ÇÅ P := fun h t _ S hS => t S (h _ hS)
#align category_theory.presieve.is_sheaf_of_le CategoryTheory.Presieve.isSheaf_of_le

theorem isSeparated_of_isSheaf (P : C·µí·µñ ‚•§ Type w) (h : IsSheaf J P) : IsSeparated J P :=
  fun S hS => (h S hS).isSeparatedFor
#align category_theory.presieve.is_separated_of_is_sheaf CategoryTheory.Presieve.isSeparated_of_isSheaf

/-- The property of being a sheaf is preserved by isomorphism. -/
theorem isSheaf_iso {P' : C·µí·µñ ‚•§ Type w} (i : P ‚âÖ P') (h : IsSheaf J P) : IsSheaf J P' :=
  fun _ S hS => isSheafFor_iso i (h S hS)
#align category_theory.presieve.is_sheaf_iso CategoryTheory.Presieve.isSheaf_iso

theorem isSheaf_of_yoneda {P : C·µí·µñ ‚•§ Type v‚ÇÅ}
    (h : ‚àÄ {X} (S : Sieve X), S ‚àà J X ‚Üí YonedaSheafCondition P S) : IsSheaf J P := fun _ _ hS =>
  isSheafFor_iff_yonedaSheafCondition.2 (h _ hS)
#align category_theory.presieve.is_sheaf_of_yoneda CategoryTheory.Presieve.isSheaf_of_yoneda

/-- For a topology generated by a basis, it suffices to check the sheaf condition on the basis
presieves only.
-/
theorem isSheaf_pretopology [HasPullbacks C] (K : Pretopology C) :
    IsSheaf (K.toGrothendieck C) P ‚Üî ‚àÄ {X : C} (R : Presieve X), R ‚àà K X ‚Üí IsSheafFor P R := by
  constructor
  -- ‚ä¢ IsSheaf (Pretopology.toGrothendieck C K) P ‚Üí ‚àÄ {X : C} (R : Presieve X), R ‚àà ‚Ä¶
  ¬∑ intro PJ X R hR
    -- ‚ä¢ IsSheafFor P R
    rw [isSheafFor_iff_generate]
    -- ‚ä¢ IsSheafFor P (generate R).arrows
    apply PJ (Sieve.generate R) ‚ü®_, hR, le_generate R‚ü©
    -- üéâ no goals
  ¬∑ rintro PK X S ‚ü®R, hR, RS‚ü©
    -- ‚ä¢ IsSheafFor P S.arrows
    have gRS : ‚áë(generate R) ‚â§ S := by
      apply giGenerate.gc.monotone_u
      rwa [sets_iff_generate]
    apply isSheafFor_subsieve P gRS _
    -- ‚ä¢ ‚àÄ ‚¶ÉY : C‚¶Ñ (f : Y ‚ü∂ X), IsSheafFor P (Sieve.pullback f (generate R)).arrows
    intro Y f
    -- ‚ä¢ IsSheafFor P (Sieve.pullback f (generate R)).arrows
    rw [‚Üê pullbackArrows_comm, ‚Üê isSheafFor_iff_generate]
    -- ‚ä¢ IsSheafFor P (pullbackArrows f R)
    exact PK (pullbackArrows f R) (K.pullbacks f R hR)
    -- üéâ no goals
#align category_theory.presieve.is_sheaf_pretopology CategoryTheory.Presieve.isSheaf_pretopology

/-- Any presheaf is a sheaf for the bottom (trivial) grothendieck topology. -/
theorem isSheaf_bot : IsSheaf (‚ä• : GrothendieckTopology C) P := fun X => by
  simp [isSheafFor_top_sieve]
  -- üéâ no goals
#align category_theory.presieve.is_sheaf_bot CategoryTheory.Presieve.isSheaf_bot

/--
For a presheaf of the form `yoneda.obj W`, a compatible family of elements on a sieve
is the same as a co-cone over the sieve. Constructing a co-cone from a compatible family works for
any presieve, as does constructing a family of elements from a co-cone. Showing compatibility of the
family needs the sieve condition.
Note: This is related to `CategoryTheory.Presheaf.conesEquivSieveCompatibleFamily`
 -/

def compatibleYonedaFamily_toCocone (R : Presieve X) (W : C) (x : FamilyOfElements (yoneda.obj W) R)
    (hx : FamilyOfElements.Compatible x) :
    Cocone (R.diagram) where
  pt := W
  Œπ :=
    { app := fun f => x f.obj.hom f.property
      naturality := by
        intro g‚ÇÅ g‚ÇÇ F
        -- ‚ä¢ (diagram R).map F ‚â´ (fun f => x f.obj.hom (_ : R f.obj.hom)) g‚ÇÇ = (fun f =>  ‚Ä¶
        simp only [Functor.id_obj, Functor.comp_obj, fullSubcategoryInclusion.obj, Over.forget_obj,
          Functor.const_obj_obj, Functor.comp_map, fullSubcategoryInclusion.map, Over.forget_map,
          Functor.const_obj_map, Category.comp_id]
        rw [‚Üê Category.id_comp (x g‚ÇÅ.obj.hom g‚ÇÅ.property)]
        -- ‚ä¢ F.left ‚â´ x g‚ÇÇ.obj.hom (_ : R g‚ÇÇ.obj.hom) = ùüô (op ((ùü≠ C).obj g‚ÇÅ.obj.left)).un ‚Ä¶
        apply hx
        -- ‚ä¢ F.1 ‚â´ g‚ÇÇ.obj.hom = ùüô (op ((ùü≠ C).obj g‚ÇÅ.obj.left)).unop ‚â´ g‚ÇÅ.obj.hom
        simp only [Functor.id_obj, Over.w, Opposite.unop_op, Category.id_comp] }
        -- üéâ no goals

def yonedaFamilyOfElements_fromCocone (R : Presieve X) (s : Cocone (diagram R)) :
    FamilyOfElements (yoneda.obj s.pt) R :=
  fun _ f hf => s.Œπ.app ‚ü®Over.mk f, hf‚ü©

end Presieve

namespace Sieve
open Presieve

variable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C]

variable {X : C}

theorem yonedaFamily_fromCocone_compatible (S : Sieve X) (s : Cocone (diagram S.arrows)) :
    FamilyOfElements.Compatible <| yonedaFamilyOfElements_fromCocone S.arrows s := by
  intro Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ hgf
  -- ‚ä¢ (yoneda.obj s.pt).map g‚ÇÅ.op (yonedaFamilyOfElements_fromCocone S.arrows s f‚ÇÅ ‚Ä¶
  have Hs := s.Œπ.naturality
  -- ‚ä¢ (yoneda.obj s.pt).map g‚ÇÅ.op (yonedaFamilyOfElements_fromCocone S.arrows s f‚ÇÅ ‚Ä¶
  simp only [Functor.id_obj, yoneda_obj_obj, Opposite.unop_op, yoneda_obj_map, Quiver.Hom.unop_op]
  -- ‚ä¢ g‚ÇÅ ‚â´ yonedaFamilyOfElements_fromCocone S.arrows s f‚ÇÅ hf‚ÇÅ = g‚ÇÇ ‚â´ yonedaFamily ‚Ä¶
  dsimp [yonedaFamilyOfElements_fromCocone]
  -- ‚ä¢ g‚ÇÅ ‚â´ NatTrans.app s.Œπ { obj := Over.mk f‚ÇÅ, property := hf‚ÇÅ } = g‚ÇÇ ‚â´ NatTrans ‚Ä¶
  have hgf‚ÇÅ : S.arrows (g‚ÇÅ ‚â´ f‚ÇÅ) := by exact Sieve.downward_closed S hf‚ÇÅ g‚ÇÅ
  -- ‚ä¢ g‚ÇÅ ‚â´ NatTrans.app s.Œπ { obj := Over.mk f‚ÇÅ, property := hf‚ÇÅ } = g‚ÇÇ ‚â´ NatTrans ‚Ä¶
  have hgf‚ÇÇ : S.arrows (g‚ÇÇ ‚â´ f‚ÇÇ) := by exact Sieve.downward_closed S hf‚ÇÇ g‚ÇÇ
  -- ‚ä¢ g‚ÇÅ ‚â´ NatTrans.app s.Œπ { obj := Over.mk f‚ÇÅ, property := hf‚ÇÅ } = g‚ÇÇ ‚â´ NatTrans ‚Ä¶
  let F : (Over.mk (g‚ÇÅ ‚â´ f‚ÇÅ) : Over X) ‚ü∂ (Over.mk (g‚ÇÇ ‚â´ f‚ÇÇ) : Over X) := (Over.homMk (ùüô Z) )
  -- ‚ä¢ g‚ÇÅ ‚â´ NatTrans.app s.Œπ { obj := Over.mk f‚ÇÅ, property := hf‚ÇÅ } = g‚ÇÇ ‚â´ NatTrans ‚Ä¶
  let F‚ÇÅ : (Over.mk (g‚ÇÅ ‚â´ f‚ÇÅ) : Over X) ‚ü∂ (Over.mk f‚ÇÅ : Over X) := (Over.homMk g‚ÇÅ)
  -- ‚ä¢ g‚ÇÅ ‚â´ NatTrans.app s.Œπ { obj := Over.mk f‚ÇÅ, property := hf‚ÇÅ } = g‚ÇÇ ‚â´ NatTrans ‚Ä¶
  let F‚ÇÇ : (Over.mk (g‚ÇÇ ‚â´ f‚ÇÇ) : Over X) ‚ü∂ (Over.mk f‚ÇÇ : Over X) := (Over.homMk g‚ÇÇ)
  -- ‚ä¢ g‚ÇÅ ‚â´ NatTrans.app s.Œπ { obj := Over.mk f‚ÇÅ, property := hf‚ÇÅ } = g‚ÇÇ ‚â´ NatTrans ‚Ä¶
  have hF := @Hs ‚ü®Over.mk (g‚ÇÅ ‚â´ f‚ÇÅ), hgf‚ÇÅ‚ü© ‚ü®Over.mk (g‚ÇÇ ‚â´ f‚ÇÇ), hgf‚ÇÇ‚ü© F
  -- ‚ä¢ g‚ÇÅ ‚â´ NatTrans.app s.Œπ { obj := Over.mk f‚ÇÅ, property := hf‚ÇÅ } = g‚ÇÇ ‚â´ NatTrans ‚Ä¶
  have hF‚ÇÅ := @Hs ‚ü®Over.mk (g‚ÇÅ ‚â´ f‚ÇÅ), hgf‚ÇÅ‚ü© ‚ü®Over.mk f‚ÇÅ, hf‚ÇÅ‚ü© F‚ÇÅ
  -- ‚ä¢ g‚ÇÅ ‚â´ NatTrans.app s.Œπ { obj := Over.mk f‚ÇÅ, property := hf‚ÇÅ } = g‚ÇÇ ‚â´ NatTrans ‚Ä¶
  have hF‚ÇÇ := @Hs ‚ü®Over.mk (g‚ÇÇ ‚â´ f‚ÇÇ), hgf‚ÇÇ‚ü© ‚ü®Over.mk f‚ÇÇ, hf‚ÇÇ‚ü© F‚ÇÇ
  -- ‚ä¢ g‚ÇÅ ‚â´ NatTrans.app s.Œπ { obj := Over.mk f‚ÇÅ, property := hf‚ÇÅ } = g‚ÇÇ ‚â´ NatTrans ‚Ä¶
  aesop_cat
  -- üéâ no goals

/--
The base of a sieve `S` is a colimit of `S` iff all Yoneda-presheaves satisfy
the sheaf condition for `S`.
-/
theorem forallYonedaIsSheaf_iff_colimit (S : Sieve X) :
    (‚àÄ W : C, Presieve.IsSheafFor (yoneda.obj W) (S : Presieve X)) ‚Üî
      Nonempty (IsColimit S.arrows.cocone) := by
  constructor
  -- ‚ä¢ (‚àÄ (W : C), IsSheafFor (yoneda.obj W) S.arrows) ‚Üí Nonempty (IsColimit (cocon ‚Ä¶
  ¬∑ intro H
    -- ‚ä¢ Nonempty (IsColimit (cocone S.arrows))
    refine Nonempty.intro ?_
    -- ‚ä¢ IsColimit (cocone S.arrows)
    exact
    { desc := fun s => H s.pt (yonedaFamilyOfElements_fromCocone S.arrows s)
        (yonedaFamily_fromCocone_compatible S s) |>.choose
      fac := by
        intro s f
        replace H := H s.pt (yonedaFamilyOfElements_fromCocone S.arrows s)
          (yonedaFamily_fromCocone_compatible S s)
        have ht := H.choose_spec.1 f.obj.hom f.property
        aesop_cat
      uniq := by
        intro s Fs HFs
        replace H := H s.pt (yonedaFamilyOfElements_fromCocone S.arrows s)
          (yonedaFamily_fromCocone_compatible S s)
        apply H.choose_spec.2 Fs
        exact fun _ f hf => HFs ‚ü®Over.mk f, hf‚ü© }
  ¬∑ intro H W x hx
    -- ‚ä¢ ‚àÉ! t, FamilyOfElements.IsAmalgamation x t
    replace H := Classical.choice H
    -- ‚ä¢ ‚àÉ! t, FamilyOfElements.IsAmalgamation x t
    let s := compatibleYonedaFamily_toCocone S W x hx
    -- ‚ä¢ ‚àÉ! t, FamilyOfElements.IsAmalgamation x t
    use H.desc s
    -- ‚ä¢ (fun t => FamilyOfElements.IsAmalgamation x t) (IsColimit.desc H s) ‚àß ‚àÄ (y : ‚Ä¶
    constructor
    -- ‚ä¢ (fun t => FamilyOfElements.IsAmalgamation x t) (IsColimit.desc H s)
    ¬∑ exact fun _ f hf => (H.fac s) ‚ü®Over.mk f, hf‚ü©
      -- üéâ no goals
    ¬∑ exact fun g hg => H.uniq s g (fun ‚ü®‚ü®f, _, hom‚ü©, hf‚ü© => hg hom hf)
      -- üéâ no goals

end Sieve

namespace Equalizer

variable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] (P : C·µí·µñ ‚•§ Type max v‚ÇÅ u‚ÇÅ) {X : C} (R : Presieve X)
  (S : Sieve X)

noncomputable section

/--
The middle object of the fork diagram given in Equation (3) of [MM92], as well as the fork diagram
of <https://stacks.math.columbia.edu/tag/00VM>.
-/
def FirstObj : Type max v‚ÇÅ u‚ÇÅ :=
  ‚àè fun f : Œ£Y, { f : Y ‚ü∂ X // R f } => P.obj (op f.1)
#align category_theory.equalizer.first_obj CategoryTheory.Equalizer.FirstObj

variable {P R}

-- porting note: added to ease automation
@[ext]
lemma FirstObj.ext (z‚ÇÅ z‚ÇÇ : FirstObj P R) (h : ‚àÄ (Y : C) (f : Y ‚ü∂ X)
    (hf : R f), (Pi.œÄ _ ‚ü®Y, f, hf‚ü© : FirstObj P R ‚ü∂ _) z‚ÇÅ =
      (Pi.œÄ _ ‚ü®Y, f, hf‚ü© : FirstObj P R ‚ü∂ _) z‚ÇÇ) : z‚ÇÅ = z‚ÇÇ := by
  apply Limits.Types.limit_ext
  -- ‚ä¢ ‚àÄ (j : Discrete ((Y : C) √ó { f // R f })), limit.œÄ (Discrete.functor fun f = ‚Ä¶
  rintro ‚ü®‚ü®Y, f, hf‚ü©‚ü©
  -- ‚ä¢ limit.œÄ (Discrete.functor fun f => P.obj (op f.fst)) { as := { fst := Y, snd ‚Ä¶
  exact h Y f hf
  -- üéâ no goals

variable (P R)

/-- Show that `FirstObj` is isomorphic to `FamilyOfElements`. -/
@[simps]
def firstObjEqFamily : FirstObj P R ‚âÖ R.FamilyOfElements P where
  hom t Y f hf := Pi.œÄ (fun f : Œ£Y, { f : Y ‚ü∂ X // R f } => P.obj (op f.1)) ‚ü®_, _, hf‚ü© t
  inv := Pi.lift fun f x => x _ f.2.2
#align category_theory.equalizer.first_obj_eq_family CategoryTheory.Equalizer.firstObjEqFamily

instance : Inhabited (FirstObj P (‚ä• : Presieve X)) :=
  (firstObjEqFamily P _).toEquiv.inhabited

-- porting note: was not needed in mathlib
instance : Inhabited (FirstObj P ((‚ä• : Sieve X) : Presieve X)) :=
  (inferInstance : Inhabited (FirstObj P (‚ä• : Presieve X)))

/--
The left morphism of the fork diagram given in Equation (3) of [MM92], as well as the fork diagram
of <https://stacks.math.columbia.edu/tag/00VM>.
-/
def forkMap : P.obj (op X) ‚ü∂ FirstObj P R :=
  Pi.lift fun f => P.map f.2.1.op
#align category_theory.equalizer.fork_map CategoryTheory.Equalizer.forkMap

/-!
This section establishes the equivalence between the sheaf condition of Equation (3) [MM92] and
the definition of `IsSheafFor`.
-/


namespace Sieve

/-- The rightmost object of the fork diagram of Equation (3) [MM92], which contains the data used
to check a family is compatible.
-/
def SecondObj : Type max v‚ÇÅ u‚ÇÅ :=
  ‚àè fun f : Œ£(Y Z : _) (_ : Z ‚ü∂ Y), { f' : Y ‚ü∂ X // S f' } => P.obj (op f.2.1)
#align category_theory.equalizer.sieve.second_obj CategoryTheory.Equalizer.Sieve.SecondObj

variable {P S}

-- porting note: added to ease automation
@[ext]
lemma SecondObj.ext (z‚ÇÅ z‚ÇÇ : SecondObj P S) (h : ‚àÄ (Y Z : C) (g : Z ‚ü∂ Y) (f : Y ‚ü∂ X)
    (hf : S.arrows f), (Pi.œÄ _ ‚ü®Y, Z, g, f, hf‚ü© : SecondObj P S ‚ü∂ _) z‚ÇÅ =
      (Pi.œÄ _ ‚ü®Y, Z, g, f, hf‚ü© : SecondObj P S ‚ü∂ _) z‚ÇÇ) : z‚ÇÅ = z‚ÇÇ := by
  apply Limits.Types.limit_ext
  -- ‚ä¢ ‚àÄ (j : Discrete ((Y : C) √ó (Z : C) √ó (_ : Z ‚ü∂ Y) √ó { f' // S.arrows f' })),  ‚Ä¶
  rintro ‚ü®‚ü®Y, Z, g, f, hf‚ü©‚ü©
  -- ‚ä¢ limit.œÄ (Discrete.functor fun f => P.obj (op f.snd.fst)) { as := { fst := Y, ‚Ä¶
  apply h
  -- üéâ no goals

variable (P S)

/-- The map `p` of Equations (3,4) [MM92]. -/
def firstMap : FirstObj P (S : Presieve X) ‚ü∂ SecondObj P S :=
  Pi.lift fun fg =>
    Pi.œÄ _ (‚ü®_, _, S.downward_closed fg.2.2.2.2 fg.2.2.1‚ü© : Œ£Y, { f : Y ‚ü∂ X // S f })
#align category_theory.equalizer.sieve.first_map CategoryTheory.Equalizer.Sieve.firstMap

instance : Inhabited (SecondObj P (‚ä• : Sieve X)) :=
  ‚ü®firstMap _ _ default‚ü©

/-- The map `a` of Equations (3,4) [MM92]. -/
def secondMap : FirstObj P (S : Presieve X) ‚ü∂ SecondObj P S :=
  Pi.lift fun fg => Pi.œÄ _ ‚ü®_, fg.2.2.2‚ü© ‚â´ P.map fg.2.2.1.op
#align category_theory.equalizer.sieve.second_map CategoryTheory.Equalizer.Sieve.secondMap

theorem w : forkMap P (S : Presieve X) ‚â´ firstMap P S = forkMap P S ‚â´ secondMap P S := by
  ext
  -- ‚ä¢ Pi.œÄ (fun f => P.obj (op f.snd.fst)) { fst := Y‚úù, snd := { fst := Z‚úù, snd := ‚Ä¶
  simp [firstMap, secondMap, forkMap]
  -- üéâ no goals
#align category_theory.equalizer.sieve.w CategoryTheory.Equalizer.Sieve.w

/--
The family of elements given by `x : FirstObj P S` is compatible iff `firstMap` and `secondMap`
map it to the same point.
-/
theorem compatible_iff (x : FirstObj P S) :
    ((firstObjEqFamily P S).hom x).Compatible ‚Üî firstMap P S x = secondMap P S x := by
  rw [Presieve.compatible_iff_sieveCompatible]
  -- ‚ä¢ Presieve.FamilyOfElements.SieveCompatible ((firstObjEqFamily P S.arrows).hom ‚Ä¶
  constructor
  -- ‚ä¢ Presieve.FamilyOfElements.SieveCompatible ((firstObjEqFamily P S.arrows).hom ‚Ä¶
  ¬∑ intro t
    -- ‚ä¢ firstMap P S x = secondMap P S x
    apply SecondObj.ext
    -- ‚ä¢ ‚àÄ (Y Z : C) (g : Z ‚ü∂ Y) (f : Y ‚ü∂ X) (hf : S.arrows f), Pi.œÄ (fun f => P.obj  ‚Ä¶
    intros Y Z g f hf
    -- ‚ä¢ Pi.œÄ (fun f => P.obj (op f.snd.fst)) { fst := Y, snd := { fst := Z, snd := { ‚Ä¶
    simpa [firstMap, secondMap] using t _ g hf
    -- üéâ no goals
  ¬∑ intro t Y Z f g hf
    -- ‚ä¢ (firstObjEqFamily P S.arrows).hom x (g ‚â´ f) (_ : S.arrows (g ‚â´ f)) = P.map g ‚Ä¶
    rw [Types.limit_ext_iff'] at t
    -- ‚ä¢ (firstObjEqFamily P S.arrows).hom x (g ‚â´ f) (_ : S.arrows (g ‚â´ f)) = P.map g ‚Ä¶
    simpa [firstMap, secondMap] using t ‚ü®‚ü®Y, Z, g, f, hf‚ü©‚ü©
    -- üéâ no goals
#align category_theory.equalizer.sieve.compatible_iff CategoryTheory.Equalizer.Sieve.compatible_iff

/-- `P` is a sheaf for `S`, iff the fork given by `w` is an equalizer. -/
theorem equalizer_sheaf_condition :
    Presieve.IsSheafFor P (S : Presieve X) ‚Üî Nonempty (IsLimit (Fork.ofŒπ _ (w P S))) := by
  rw [Types.type_equalizer_iff_unique,
    ‚Üê Equiv.forall_congr_left (firstObjEqFamily P (S : Presieve X)).toEquiv.symm]
  simp_rw [‚Üê compatible_iff]
  -- ‚ä¢ Presieve.IsSheafFor P S.arrows ‚Üî ‚àÄ (x : Presieve.FamilyOfElements P S.arrows ‚Ä¶
  simp only [inv_hom_id_apply, Iso.toEquiv_symm_fun]
  -- ‚ä¢ Presieve.IsSheafFor P S.arrows ‚Üî ‚àÄ (x : Presieve.FamilyOfElements P S.arrows ‚Ä¶
  apply ball_congr
  -- ‚ä¢ ‚àÄ (x : Presieve.FamilyOfElements P S.arrows), Presieve.FamilyOfElements.Comp ‚Ä¶
  intro x _
  -- ‚ä¢ (‚àÉ! t, Presieve.FamilyOfElements.IsAmalgamation x t) ‚Üî ‚àÉ! x_1, forkMap P S.a ‚Ä¶
  apply exists_unique_congr
  -- ‚ä¢ ‚àÄ (a : P.obj (op X)), Presieve.FamilyOfElements.IsAmalgamation x a ‚Üî forkMap ‚Ä¶
  intro t
  -- ‚ä¢ Presieve.FamilyOfElements.IsAmalgamation x t ‚Üî forkMap P S.arrows t = (first ‚Ä¶
  rw [‚Üê Iso.toEquiv_symm_fun]
  -- ‚ä¢ Presieve.FamilyOfElements.IsAmalgamation x t ‚Üî forkMap P S.arrows t = ‚Üë(firs ‚Ä¶
  rw [Equiv.eq_symm_apply]
  -- ‚ä¢ Presieve.FamilyOfElements.IsAmalgamation x t ‚Üî ‚Üë(firstObjEqFamily P S.arrows ‚Ä¶
  constructor
  -- ‚ä¢ Presieve.FamilyOfElements.IsAmalgamation x t ‚Üí ‚Üë(firstObjEqFamily P S.arrows ‚Ä¶
  ¬∑ intro q
    -- ‚ä¢ ‚Üë(firstObjEqFamily P S.arrows).toEquiv (forkMap P S.arrows t) = x
    funext Y f hf
    -- ‚ä¢ ‚Üë(firstObjEqFamily P S.arrows).toEquiv (forkMap P S.arrows t) f hf = x f hf
    simpa [firstObjEqFamily, forkMap] using q _ _
    -- üéâ no goals
  ¬∑ intro q Y f hf
    -- ‚ä¢ P.map f.op t = x f hf
    rw [‚Üê q]
    -- ‚ä¢ P.map f.op t = ‚Üë(firstObjEqFamily P S.arrows).toEquiv (forkMap P S.arrows t) ‚Ä¶
    simp [firstObjEqFamily, forkMap]
    -- üéâ no goals
#align category_theory.equalizer.sieve.equalizer_sheaf_condition CategoryTheory.Equalizer.Sieve.equalizer_sheaf_condition

end Sieve

/-!
This section establishes the equivalence between the sheaf condition of
https://stacks.math.columbia.edu/tag/00VM and the definition of `isSheafFor`.
-/


namespace Presieve

variable [R.hasPullbacks]

/-- The rightmost object of the fork diagram of https://stacks.math.columbia.edu/tag/00VM, which
contains the data used to check a family of elements for a presieve is compatible.
-/
@[simp] def SecondObj : Type max v‚ÇÅ u‚ÇÅ :=
  ‚àè fun fg : (Œ£Y, { f : Y ‚ü∂ X // R f }) √ó Œ£Z, { g : Z ‚ü∂ X // R g } =>
    haveI := Presieve.hasPullbacks.has_pullbacks fg.1.2.2 fg.2.2.2
    P.obj (op (pullback fg.1.2.1 fg.2.2.1))
#align category_theory.equalizer.presieve.second_obj CategoryTheory.Equalizer.Presieve.SecondObj

/-- The map `pr‚ÇÄ*` of <https://stacks.math.columbia.edu/tag/00VL>. -/
def firstMap : FirstObj P R ‚ü∂ SecondObj P R :=
  Pi.lift fun fg =>
    haveI := Presieve.hasPullbacks.has_pullbacks fg.1.2.2 fg.2.2.2
    Pi.œÄ _ _ ‚â´ P.map pullback.fst.op
#align category_theory.equalizer.presieve.first_map CategoryTheory.Equalizer.Presieve.firstMap

instance [HasPullbacks C] : Inhabited (SecondObj P (‚ä• : Presieve X)) :=
  ‚ü®firstMap _ _ default‚ü©

/-- The map `pr‚ÇÅ*` of <https://stacks.math.columbia.edu/tag/00VL>. -/
def secondMap : FirstObj P R ‚ü∂ SecondObj P R :=
  Pi.lift fun fg =>
    haveI := Presieve.hasPullbacks.has_pullbacks fg.1.2.2 fg.2.2.2
    Pi.œÄ _ _ ‚â´ P.map pullback.snd.op
#align category_theory.equalizer.presieve.second_map CategoryTheory.Equalizer.Presieve.secondMap

theorem w : forkMap P R ‚â´ firstMap P R = forkMap P R ‚â´ secondMap P R := by
  dsimp
  -- ‚ä¢ forkMap P R ‚â´ firstMap P R = forkMap P R ‚â´ secondMap P R
  ext fg
  -- ‚ä¢ ((forkMap P R ‚â´ firstMap P R) ‚â´ Pi.œÄ (fun fg => P.obj (op (Limits.pullback ‚Üë ‚Ä¶
  simp only [firstMap, secondMap, forkMap]
  -- ‚ä¢ (((Pi.lift fun f => P.map (‚Üëf.snd).op) ‚â´ Pi.lift fun fg => Pi.œÄ (fun f => P. ‚Ä¶
  simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, assoc, Fan.mk_œÄ_app]
  -- ‚ä¢ (P.map (‚Üëfg.fst.snd).op ‚â´ P.map pullback.fst.op) a‚úù = (P.map (‚Üëfg.snd.snd).o ‚Ä¶
  haveI := Presieve.hasPullbacks.has_pullbacks fg.1.2.2 fg.2.2.2
  -- ‚ä¢ (P.map (‚Üëfg.fst.snd).op ‚â´ P.map pullback.fst.op) a‚úù = (P.map (‚Üëfg.snd.snd).o ‚Ä¶
  rw [‚Üê P.map_comp, ‚Üê op_comp, pullback.condition]
  -- ‚ä¢ P.map (pullback.snd ‚â´ ‚Üëfg.snd.snd).op a‚úù = (P.map (‚Üëfg.snd.snd).op ‚â´ P.map p ‚Ä¶
  simp
  -- üéâ no goals
#align category_theory.equalizer.presieve.w CategoryTheory.Equalizer.Presieve.w

/--
The family of elements given by `x : FirstObj P S` is compatible iff `firstMap` and `secondMap`
map it to the same point.
-/
theorem compatible_iff (x : FirstObj P R) :
    ((firstObjEqFamily P R).hom x).Compatible ‚Üî firstMap P R x = secondMap P R x := by
  rw [Presieve.pullbackCompatible_iff]
  -- ‚ä¢ Presieve.FamilyOfElements.PullbackCompatible ((firstObjEqFamily P R).hom x)  ‚Ä¶
  constructor
  -- ‚ä¢ Presieve.FamilyOfElements.PullbackCompatible ((firstObjEqFamily P R).hom x)  ‚Ä¶
  ¬∑ intro t
    -- ‚ä¢ firstMap P R x = secondMap P R x
    apply Limits.Types.limit_ext
    -- ‚ä¢ ‚àÄ (j : Discrete (((Y : C) √ó { f // R f }) √ó (Z : C) √ó { g // R g })), limit. ‚Ä¶
    rintro ‚ü®‚ü®Y, f, hf‚ü©, Z, g, hg‚ü©
    -- ‚ä¢ limit.œÄ (Discrete.functor fun fg => P.obj (op (Limits.pullback ‚Üëfg.fst.snd ‚Üë ‚Ä¶
    simpa [firstMap, secondMap] using t hf hg
    -- üéâ no goals
  ¬∑ intro t Y Z f g hf hg
    -- ‚ä¢ P.map pullback.fst.op ((firstObjEqFamily P R).hom x f hf) = P.map pullback.s ‚Ä¶
    rw [Types.limit_ext_iff'] at t
    -- ‚ä¢ P.map pullback.fst.op ((firstObjEqFamily P R).hom x f hf) = P.map pullback.s ‚Ä¶
    simpa [firstMap, secondMap] using t ‚ü®‚ü®‚ü®Y, f, hf‚ü©, Z, g, hg‚ü©‚ü©
    -- üéâ no goals
#align category_theory.equalizer.presieve.compatible_iff CategoryTheory.Equalizer.Presieve.compatible_iff

/-- `P` is a sheaf for `R`, iff the fork given by `w` is an equalizer.
See <https://stacks.math.columbia.edu/tag/00VM>.
-/
theorem sheaf_condition : R.IsSheafFor P ‚Üî Nonempty (IsLimit (Fork.ofŒπ _ (w P R))) := by
  rw [Types.type_equalizer_iff_unique]
  -- ‚ä¢ Presieve.IsSheafFor P R ‚Üî ‚àÄ (y : FirstObj P R), firstMap P R y = secondMap P ‚Ä¶
  erw [‚Üê Equiv.forall_congr_left (firstObjEqFamily P R).toEquiv.symm]
  -- ‚ä¢ Presieve.IsSheafFor P R ‚Üî ‚àÄ (x : Presieve.FamilyOfElements P R), firstMap P  ‚Ä¶
  simp_rw [‚Üê compatible_iff, ‚Üê Iso.toEquiv_fun, Equiv.apply_symm_apply]
  -- ‚ä¢ Presieve.IsSheafFor P R ‚Üî ‚àÄ (x : Presieve.FamilyOfElements P R), Presieve.Fa ‚Ä¶
  apply ball_congr
  -- ‚ä¢ ‚àÄ (x : Presieve.FamilyOfElements P R), Presieve.FamilyOfElements.Compatible  ‚Ä¶
  intro x _
  -- ‚ä¢ (‚àÉ! t, Presieve.FamilyOfElements.IsAmalgamation x t) ‚Üî ‚àÉ! x_1, forkMap P R x ‚Ä¶
  apply exists_unique_congr
  -- ‚ä¢ ‚àÄ (a : P.obj (op X)), Presieve.FamilyOfElements.IsAmalgamation x a ‚Üî forkMap ‚Ä¶
  intro t
  -- ‚ä¢ Presieve.FamilyOfElements.IsAmalgamation x t ‚Üî forkMap P R t = ‚Üë(firstObjEqF ‚Ä¶
  rw [Equiv.eq_symm_apply]
  -- ‚ä¢ Presieve.FamilyOfElements.IsAmalgamation x t ‚Üî ‚Üë(firstObjEqFamily P R).toEqu ‚Ä¶
  constructor
  -- ‚ä¢ Presieve.FamilyOfElements.IsAmalgamation x t ‚Üí ‚Üë(firstObjEqFamily P R).toEqu ‚Ä¶
  ¬∑ intro q
    -- ‚ä¢ ‚Üë(firstObjEqFamily P R).toEquiv (forkMap P R t) = x
    funext Y f hf
    -- ‚ä¢ ‚Üë(firstObjEqFamily P R).toEquiv (forkMap P R t) f hf = x f hf
    simpa [forkMap] using q _ _
    -- üéâ no goals
  ¬∑ intro q Y f hf
    -- ‚ä¢ P.map f.op t = x f hf
    rw [‚Üê q]
    -- ‚ä¢ P.map f.op t = ‚Üë(firstObjEqFamily P R).toEquiv (forkMap P R t) f hf
    simp [forkMap]
    -- üéâ no goals
#align category_theory.equalizer.presieve.sheaf_condition CategoryTheory.Equalizer.Presieve.sheaf_condition

end Presieve

end

end Equalizer

variable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C]

variable (J : GrothendieckTopology C)

/-- The category of sheaves on a grothendieck topology. -/
structure SheafOfTypes (J : GrothendieckTopology C) : Type max u‚ÇÅ v‚ÇÅ (w + 1) where
  /-- the underlying presheaf -/
  val : C·µí·µñ ‚•§ Type w
  /-- the condition that the presheaf is a sheaf -/
  cond : Presieve.IsSheaf J val
set_option linter.uppercaseLean3 false in
#align category_theory.SheafOfTypes CategoryTheory.SheafOfTypes

namespace SheafOfTypes

variable {J}

/-- Morphisms between sheaves of types are just morphisms between the underlying presheaves. -/
@[ext]
structure Hom (X Y : SheafOfTypes J) where
  /-- a morphism between the underlying presheaves -/
  val : X.val ‚ü∂ Y.val
set_option linter.uppercaseLean3 false in
#align category_theory.SheafOfTypes.hom CategoryTheory.SheafOfTypes.Hom

@[simps]
instance : Category (SheafOfTypes J) where
  Hom := Hom
  id _ := ‚ü®ùüô _‚ü©
  comp f g := ‚ü®f.val ‚â´ g.val‚ü©
  id_comp _ := Hom.ext _ _ <| id_comp _
  comp_id _ := Hom.ext _ _ <| comp_id _
  assoc _ _ _ := Hom.ext _ _ <| assoc _ _ _

-- Porting note: we need to restate the ext lemma in terms of the categorical morphism
-- not just the underlying structure.
-- It would be nice if this boilerplate weren't necessary.
@[ext]
theorem Hom.ext' {X Y : SheafOfTypes J} (f g : X ‚ü∂ Y) (w : f.val = g.val) : f = g :=
  Hom.ext f g w

-- Let's make the inhabited linter happy...
instance (X : SheafOfTypes J) : Inhabited (Hom X X) :=
  ‚ü®ùüô X‚ü©

end SheafOfTypes

/-- The inclusion functor from sheaves to presheaves. -/
@[simps]
def sheafOfTypesToPresheaf : SheafOfTypes J ‚•§ C·µí·µñ ‚•§ Type w where
  obj := SheafOfTypes.val
  map f := f.val
  map_id _ := rfl
  map_comp _ _ := rfl
set_option linter.uppercaseLean3 false in
#align category_theory.SheafOfTypes_to_presheaf CategoryTheory.sheafOfTypesToPresheaf

instance : Full (sheafOfTypesToPresheaf J) where preimage f := ‚ü®f‚ü©

instance : Faithful (sheafOfTypesToPresheaf J) where

/--
The category of sheaves on the bottom (trivial) grothendieck topology is equivalent to the category
of presheaves.
-/
@[simps]
def sheafOfTypesBotEquiv : SheafOfTypes (‚ä• : GrothendieckTopology C) ‚âå C·µí·µñ ‚•§ Type w where
  functor := sheafOfTypesToPresheaf _
  inverse :=
    { obj := fun P => ‚ü®P, Presieve.isSheaf_bot‚ü©
      map := fun f => (sheafOfTypesToPresheaf _).preimage f }
  unitIso :=
    { hom := { app := fun _ => ‚ü®ùüô _‚ü© }
      inv := { app := fun _ => ‚ü®ùüô _‚ü© } }
  counitIso := Iso.refl _
set_option linter.uppercaseLean3 false in
#align category_theory.SheafOfTypes_bot_equiv CategoryTheory.sheafOfTypesBotEquiv

instance : Inhabited (SheafOfTypes (‚ä• : GrothendieckTopology C)) :=
  ‚ü®sheafOfTypesBotEquiv.inverse.obj ((Functor.const _).obj PUnit)‚ü©

end CategoryTheory
