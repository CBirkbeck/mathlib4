/-
Copyright (c) 2024 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathlib.CategoryTheory.Sites.ConcreteSheafification
import Mathlib.CategoryTheory.Sites.Sheafification
import Mathlib.CategoryTheory.Sites.Whiskering
import Mathlib.CategoryTheory.Sites.LeftExact
/-!
# Locally injective and locally surjective morphisms of presheaves


-/

universe w v' v u' u

namespace CategoryTheory

open Opposite Limits

variable {C : Type u} [Category.{v} C]
  {D : Type u'} [Category.{v'} D] [ConcreteCategory.{w} D]
  (J : GrothendieckTopology C)

attribute [local instance] ConcreteCategory.hasCoeToSort ConcreteCategory.instFunLike

@[simp]
lemma NatTrans.naturality_apply {F G : C ‚•§ D} (œÜ : F ‚ü∂ G) {X Y : C}
    (f : X ‚ü∂ Y) (x : F.obj X) :
    œÜ.app Y (F.map f x) = G.map f (œÜ.app X x) := by
  simpa only [Functor.map_comp] using congr_fun ((forget D).congr_map (œÜ.naturality f)) x

namespace Presheaf

variable {F‚ÇÅ F‚ÇÇ F‚ÇÉ : C·µí·µñ ‚•§ D} (œÜ : F‚ÇÅ ‚ü∂ F‚ÇÇ) (œà : F‚ÇÇ ‚ü∂ F‚ÇÉ)

class LocallyInjective : Prop where
  locally_injective {X : C·µí·µñ} (x y : F‚ÇÅ.obj X) (h : œÜ.app X x = œÜ.app X y) :
    ‚àÉ (S : Sieve X.unop) (_ : S ‚àà J X.unop),
      ‚àÄ {Y : C} (f : Y ‚ü∂ X.unop) (_ : S f), F‚ÇÅ.map f.op x = F‚ÇÅ.map f.op y

lemma locallyInjective_of_injective (hœÜ : ‚àÄ (X : C·µí·µñ), Function.Injective (œÜ.app X)) :
    LocallyInjective J œÜ where
  locally_injective {X} x y h := ‚ü®‚ä§, J.top_mem _, fun f _ => hœÜ _ (by simp [h])‚ü©

instance [IsIso œÜ] :
    LocallyInjective J œÜ := locallyInjective_of_injective J œÜ (fun X => by
  apply Function.Bijective.injective
  rw [‚Üê isIso_iff_bijective]
  change IsIso ((forget D).map (œÜ.app X))
  infer_instance)

section

variable [hœÜ : LocallyInjective J œÜ]
  {X : C·µí·µñ} (x y : F‚ÇÅ.obj X) (h : œÜ.app X x = œÜ.app X y)

noncomputable def sieveOfLocallyInjective : Sieve X.unop :=
  (hœÜ.locally_injective x y h).choose

lemma sieveOfLocallyInjective_mem :
    sieveOfLocallyInjective J œÜ x y h ‚àà J X.unop :=
  (hœÜ.locally_injective x y h).choose_spec.choose

lemma map_apply_eq_of_locallyInjective
    {Y : C} (f : Y ‚ü∂ X.unop) (hf : sieveOfLocallyInjective J œÜ x y h f) :
    F‚ÇÅ.map f.op x = F‚ÇÅ.map f.op y :=
  (hœÜ.locally_injective x y h).choose_spec.choose_spec f hf

end

class LocallySurjective : Prop where
  locally_surjective {X : C·µí·µñ} (x : F‚ÇÇ.obj X) :
    ‚àÉ (S : Sieve X.unop) (_ : S ‚àà J X.unop),
      ‚àÄ {Y : C} (f : Y ‚ü∂ X.unop) (_ : S f), ‚àÉ (y : F‚ÇÅ.obj (op Y)),
        œÜ.app (op Y) y = F‚ÇÇ.map f.op x

lemma locallySurjective_of_surjective (hœÜ : ‚àÄ (X : C·µí·µñ), Function.Surjective (œÜ.app X)) :
    LocallySurjective J œÜ where
  locally_surjective _ := ‚ü®‚ä§, J.top_mem _, fun _ _ => hœÜ _ _‚ü©

instance [IsIso œÜ] : LocallySurjective J œÜ := locallySurjective_of_surjective J œÜ (fun X => by
  apply Function.Bijective.surjective
  rw [‚Üê isIso_iff_bijective]
  change IsIso ((forget D).map (œÜ.app X))
  infer_instance)

section

variable [hœÜ : LocallySurjective J œÜ]
  {X : C·µí·µñ} (x : F‚ÇÇ.obj X)

noncomputable def sieveOfLocallySurjective : Sieve X.unop :=
  (hœÜ.locally_surjective x).choose

lemma sieveOfLocallySurjective_mem : sieveOfLocallySurjective J œÜ x ‚àà J X.unop :=
  (hœÜ.locally_surjective x).choose_spec.choose

variable {Y : C} (f : Y ‚ü∂ X.unop) (hf : sieveOfLocallySurjective J œÜ x f)

noncomputable def localPreimage : F‚ÇÅ.obj (op Y) :=
  ((hœÜ.locally_surjective x).choose_spec.choose_spec f hf).choose

@[simp]
lemma app_apply_localPreimage :
    œÜ.app _ (localPreimage J œÜ x f hf) = F‚ÇÇ.map f.op x :=
  ((hœÜ.locally_surjective x).choose_spec.choose_spec f hf).choose_spec

end

instance locallyInjective_forget [LocallyInjective J œÜ] :
    LocallyInjective J (whiskerRight œÜ (forget D)) where
  locally_injective x y h :=
    ‚ü®_, sieveOfLocallyInjective_mem J œÜ x y h, map_apply_eq_of_locallyInjective J œÜ x y h‚ü©

instance locallySurjective_forget [LocallySurjective J œÜ] :
    LocallySurjective J (whiskerRight œÜ (forget D)) where
  locally_surjective x :=
    ‚ü®_, sieveOfLocallySurjective_mem J œÜ x,
      fun f hf => ‚ü®localPreimage J œÜ x f hf, app_apply_localPreimage J œÜ x f hf‚ü©‚ü©

instance locallyInjective_comp [LocallyInjective J œÜ] [LocallyInjective J œà] :
    LocallyInjective J (œÜ ‚â´ œà) where
  locally_injective {X} x y h := by
    let S := sieveOfLocallyInjective J œà (œÜ.app _ x) (œÜ.app _ y) (by simpa using h)
    have hS : S ‚àà J X.unop := sieveOfLocallyInjective_mem J œà (œÜ.app _ x) (œÜ.app _ y) (by simpa using h)
    have hS' : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X.unop‚¶Ñ (_ : S f),
      œÜ.app _ (F‚ÇÅ.map f.op x) = œÜ.app _ (F‚ÇÅ.map f.op y) := fun Y f hf => by
        simpa using map_apply_eq_of_locallyInjective J œà (œÜ.app _ x) (œÜ.app _ y) _ f hf
    let T : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X.unop‚¶Ñ (_ : S f), Sieve Y := fun Y f hf =>
      sieveOfLocallyInjective J œÜ (F‚ÇÅ.map f.op x) (F‚ÇÅ.map f.op y) (hS' hf)
    refine ‚ü®_, J.transitive hS (Sieve.bind S.1 T) ?_, ?_‚ü©
    ¬∑ intro Y f hf
      exact J.superset_covering (Sieve.le_pullback_bind S.1 T _ hf)
        (sieveOfLocallyInjective_mem J œÜ (F‚ÇÅ.map f.op x) (F‚ÇÅ.map f.op y) (hS' hf))
    ¬∑ intro Y f hf
      obtain ‚ü®Z, a, g, hg, ha, rfl‚ü© := hf
      simpa using map_apply_eq_of_locallyInjective J œÜ _ _ (hS' hg) _ ha

lemma locallyInjective_of_locallyInjective [LocallyInjective J (œÜ ‚â´ œà)] :
    LocallyInjective J œÜ where
  locally_injective {X} x y h :=
      ‚ü®_, sieveOfLocallyInjective_mem J (œÜ ‚â´ œà) x y
        (by simpa using congr_arg (œà.app X) h),
        map_apply_eq_of_locallyInjective J (œÜ ‚â´ œà) x y _‚ü©

variable {œÜ œà}

lemma locallyInjective_of_locallyInjective_fac {œÜœà : F‚ÇÅ ‚ü∂ F‚ÇÉ} (fac : œÜ ‚â´ œà = œÜœà)
    [LocallyInjective J œÜœà] : LocallyInjective J œÜ := by
  subst fac
  exact locallyInjective_of_locallyInjective J œÜ œà

lemma locallyInjective_iff_fac {œÜœà : F‚ÇÅ ‚ü∂ F‚ÇÉ} (fac : œÜ ‚â´ œà = œÜœà) [LocallyInjective J œà] :
    LocallyInjective J œÜœà ‚Üî LocallyInjective J œÜ := by
  constructor
  ¬∑ intro
    exact locallyInjective_of_locallyInjective_fac J fac
  ¬∑ intro
    rw [‚Üê fac]
    infer_instance

variable (œÜ œà)

lemma locallyInjective_comp_iff [LocallyInjective J œà] :
    LocallyInjective J (œÜ ‚â´ œà) ‚Üî LocallyInjective J œÜ :=
  locallyInjective_iff_fac J rfl

instance locallySurjective_comp [LocallySurjective J œÜ] [LocallySurjective J œà] :
    LocallySurjective J (œÜ ‚â´ œà) where
  locally_surjective {X} x := by
    let S := sieveOfLocallySurjective J œà x
    let hS : S ‚àà J X.unop := sieveOfLocallySurjective_mem J œà x
    let T : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X.unop‚¶Ñ (_ : S f), Sieve Y :=
      fun Y f hf => sieveOfLocallySurjective J œÜ (localPreimage J œà x f hf)
    refine ‚ü®_, J.transitive hS (Sieve.bind S.1 T) ?_, ?_‚ü©
    ¬∑ intro Y f hf
      exact J.superset_covering (Sieve.le_pullback_bind _ _ _ hf)
        (by apply sieveOfLocallySurjective_mem)
    ¬∑ intro Y f hf
      obtain ‚ü®Z, a, g, hg, ha, rfl‚ü© := hf
      exact ‚ü®localPreimage J œÜ (localPreimage J œà x g hg) a ha, by simp‚ü©

lemma locallySurjective_of_locallySurjective [LocallySurjective J (œÜ ‚â´ œà)] :
    LocallySurjective J œà where
  locally_surjective {X} x :=
    ‚ü®_, sieveOfLocallySurjective_mem J (œÜ ‚â´ œà) x, fun f hf =>
      ‚ü®œÜ.app _ (localPreimage J (œÜ ‚â´ œà) x f hf),
        by simpa using app_apply_localPreimage J (œÜ ‚â´ œà) x f hf‚ü©‚ü©

variable {œÜ œà}

lemma locallySurjective_of_locallySurjective_fac {œÜœà : F‚ÇÅ ‚ü∂ F‚ÇÉ} (fac : œÜ ‚â´ œà = œÜœà)
    [LocallySurjective J œÜœà] : LocallySurjective J œà := by
  subst fac
  exact locallySurjective_of_locallySurjective J œÜ œà

lemma locallySurjective_iff_fac {œÜœà : F‚ÇÅ ‚ü∂ F‚ÇÉ} (fac : œÜ ‚â´ œà = œÜœà) [LocallySurjective J œÜ] :
    LocallySurjective J œÜœà ‚Üî LocallySurjective J œà := by
  constructor
  ¬∑ intro
    exact locallySurjective_of_locallySurjective_fac J fac
  ¬∑ intro
    rw [‚Üê fac]
    infer_instance

variable (œÜ œà)

lemma locallySurjective_comp_iff [LocallySurjective J œÜ] :
    LocallySurjective J (œÜ ‚â´ œà) ‚Üî LocallySurjective J œà :=
  locallySurjective_iff_fac J rfl

section

variable {E : Type u'} [Category.{max u v} E] [ConcreteCategory E]
  [PreservesLimits (forget E)]
  [‚àÄ (P : C·µí·µñ ‚•§ E) (X : C) (S : J.Cover X),
    HasMultiequalizer (GrothendieckTopology.Cover.index S P)]
  [‚àÄ (X : C), HasColimitsOfShape (GrothendieckTopology.Cover J X)·µí·µñ E]
  [‚àÄ X : C, PreservesColimitsOfShape (J.Cover X)·µí·µñ (forget E)] [ReflectsIsomorphisms (forget E)]

variable (P : C·µí·µñ ‚•§ E)

section

open GrothendieckTopology Plus

instance locallyInjective_toPlus : LocallyInjective J (J.toPlus P) where
  locally_injective {X} x y h := by
    erw [toPlus_eq_mk, toPlus_eq_mk, eq_mk_iff_exists] at h
    obtain ‚ü®W, h‚ÇÅ, h‚ÇÇ, eq‚ü© := h
    exact ‚ü®W.1, W.2, fun {Y} f hf => congr_fun (congr_arg Subtype.val eq) ‚ü®Y, f, hf‚ü©‚ü©

instance locallySurjective_toPlus : LocallySurjective J (J.toPlus P) where
  locally_surjective {X} x := by
    obtain ‚ü®S, x, rfl‚ü© := exists_rep x
    refine' ‚ü®S.1, S.2, fun {Y} f hf => ‚ü®x.1 ‚ü®Y, f, hf‚ü©, _‚ü©‚ü©
    dsimp
    erw [toPlus_eq_mk, res_mk_eq_mk_pullback, eq_mk_iff_exists]
    refine' ‚ü®S.pullback f, homOfLE le_top, ùüô _, _‚ü©
    ext ‚ü®Z, g, hg‚ü©
    simpa using x.2 (Cover.Relation.mk _ _ _ g (ùüô Z) f (g ‚â´ f) hf
      (S.1.downward_closed hf g) (by simp))

end

instance locallyInjective_toSheafify : LocallyInjective J (J.toSheafify P) := by
  dsimp [GrothendieckTopology.toSheafify]
  rw [GrothendieckTopology.plusMap_toPlus]
  infer_instance

instance locallySurjective_toSheafify : LocallySurjective J (J.toSheafify P) := by
  dsimp [GrothendieckTopology.toSheafify]
  rw [GrothendieckTopology.plusMap_toPlus]
  infer_instance

@[reassoc (attr := simp)]
lemma toSheafify_plusPlusIsoSheafify_hom :
    J.toSheafify P ‚â´ (plusPlusIsoSheafify J E P).hom = toSheafify J P := by
  convert Adjunction.unit_leftAdjointUniq_hom_app
    (plusPlusAdjunction J E) (sheafificationAdjunction J E) P
  ext1 P
  dsimp [GrothendieckTopology.toSheafify, plusPlusAdjunction]
  rw [Category.comp_id]

instance locallyInjective_toSheafify' : LocallyInjective J (toSheafify J P) := by
  rw [‚Üê toSheafify_plusPlusIsoSheafify_hom]
  infer_instance

instance locallySurjective_toSheafify' : LocallySurjective J (toSheafify J P) := by
  rw [‚Üê toSheafify_plusPlusIsoSheafify_hom]
  infer_instance

end

end Presheaf

namespace Sheaf

variable {J}
variable {F‚ÇÅ F‚ÇÇ F‚ÇÉ : Sheaf J D} (œÜ : F‚ÇÅ ‚ü∂ F‚ÇÇ) (œà : F‚ÇÇ ‚ü∂ F‚ÇÉ)

abbrev LocallyInjective := Presheaf.LocallyInjective J œÜ.1

abbrev LocallySurjective := Presheaf.LocallySurjective J œÜ.1

instance locallyInjective_comp [LocallyInjective œÜ] [LocallyInjective œà] :
    LocallyInjective (œÜ ‚â´ œà) :=
  Presheaf.locallyInjective_comp J œÜ.1 œà.1

instance locallySurjective_comp [LocallySurjective œÜ] [LocallySurjective œà] :
    LocallySurjective (œÜ ‚â´ œà) :=
  Presheaf.locallySurjective_comp J œÜ.1 œà.1

lemma locallyInjective_of_locallyInjective [LocallyInjective (œÜ ‚â´ œà)] :
    LocallyInjective œÜ :=
  Presheaf.locallyInjective_of_locallyInjective J œÜ.1 œà.1

lemma locallySurjective_of_locallySurjective [LocallySurjective (œÜ ‚â´ œà)] :
    LocallySurjective œà :=
  Presheaf.locallySurjective_of_locallySurjective J œÜ.1 œà.1

variable {œÜ œà}

lemma locallyInjective_of_locallyInjective_fac {œÜœà : F‚ÇÅ ‚ü∂ F‚ÇÉ} (fac : œÜ ‚â´ œà = œÜœà)
    [LocallyInjective œÜœà] : LocallyInjective œÜ := by
  subst fac
  exact locallyInjective_of_locallyInjective œÜ œà

lemma locallySurjective_of_locallySurjective_fac {œÜœà : F‚ÇÅ ‚ü∂ F‚ÇÉ} (fac : œÜ ‚â´ œà = œÜœà)
    [LocallySurjective œÜœà] : LocallySurjective œà := by
  subst fac
  exact locallySurjective_of_locallySurjective œÜ œà

section

variable (œÜ)
variable [J.HasSheafCompose (forget D)]

instance locallyInjective_forget [LocallyInjective œÜ] :
    LocallyInjective ((sheafCompose J (forget D)).map œÜ) :=
  Presheaf.locallyInjective_forget J œÜ.1

instance locallySurjective_forget [LocallySurjective œÜ] :
    LocallySurjective ((sheafCompose J (forget D)).map œÜ) :=
  Presheaf.locallySurjective_forget J œÜ.1

lemma mono_of_locallyInjective' {F G : Sheaf J (Type w)} (œÜ : F ‚ü∂ G) [LocallyInjective œÜ] :
    Mono œÜ where
  right_cancellation {Z} f‚ÇÅ f‚ÇÇ h := by
    ext X x
    apply ((Presieve.isSeparated_of_isSheaf _ _ ((isSheaf_iff_isSheaf_of_type _ _).1 F.2)) _
      (Presheaf.sieveOfLocallyInjective_mem J œÜ.1 (f‚ÇÅ.1.app _ x) (f‚ÇÇ.1.app _ x)
      (congr_fun (congr_app (congr_arg Sheaf.Hom.val h) X) x))).ext
    intro Y f hf
    exact Presheaf.map_apply_eq_of_locallyInjective J œÜ.1 _ _ _ f hf

lemma epi_of_locallySurjective' {F G : Sheaf J (Type w)} (œÜ : F ‚ü∂ G) [LocallySurjective œÜ] :
    Epi œÜ where
  left_cancellation := by
    intro H f‚ÇÅ f‚ÇÇ h‚ÇÅ‚ÇÇ
    ext X x
    apply ((Presieve.isSeparated_of_isSheaf _ _ ((isSheaf_iff_isSheaf_of_type _ _).1 H.2)) _
      (Presheaf.sieveOfLocallySurjective_mem J œÜ.1 x)).ext
    intro Y f hf
    have h‚ÇÅ := congr_fun (f‚ÇÅ.1.naturality f.op) x
    have h‚ÇÇ := congr_fun (f‚ÇÇ.1.naturality f.op) x
    dsimp at h‚ÇÅ h‚ÇÇ
    simp only [‚Üê h‚ÇÅ, ‚Üê h‚ÇÇ]
    erw [congr_arg (f‚ÇÅ.val.app (op Y)) (Presheaf.app_apply_localPreimage J œÜ.1 x f hf).symm,
      congr_arg (f‚ÇÇ.val.app (op Y)) (Presheaf.app_apply_localPreimage J œÜ.1 x f hf).symm]
    exact congr_fun (congr_app (congr_arg Sheaf.Hom.val h‚ÇÅ‚ÇÇ) (op Y)) _

instance : Faithful (sheafCompose J (forget D)) where
  map_injective {F G f‚ÇÅ f‚ÇÇ} h := by
    ext X x
    exact congr_fun (congr_app ((sheafToPresheaf _ _).congr_map h) X) x

lemma mono_of_locallySurjective [LocallyInjective œÜ] : Mono œÜ :=
  (sheafCompose J (forget D)).mono_of_mono_map (mono_of_locallyInjective' _)

lemma epi_of_locallySurjective [LocallySurjective œÜ] : Epi œÜ :=
  (sheafCompose J (forget D)).epi_of_epi_map (epi_of_locallySurjective' _)

end

end Sheaf

namespace Presheaf

variable [HasWeakSheafify J D]
  [‚àÄ (P : C·µí·µñ ‚•§ D), Presheaf.LocallyInjective J (toSheafify J P)]
  [‚àÄ (P : C·µí·µñ ‚•§ D), Presheaf.LocallySurjective J (toSheafify J P)]
  {F G : C·µí·µñ ‚•§ D} (œÜ : F ‚ü∂ G)

/-lemma sheafifyMap_locallyInjective_iff :
    LocallyInjective J (sheafifyMap J œÜ) ‚Üî
      LocallyInjective J œÜ := by
  rw [‚Üê locallyInjective_comp_iff J _ (toSheafify J G), toSheafify_naturality J œÜ]
  constructor
  ¬∑ intro
    infer_instance
  ¬∑ sorry

lemma presheafToSheaf_map_locallyInjective_iff :
    Sheaf.LocallyInjective ((presheafToSheaf J D).map œÜ) ‚Üî
      LocallyInjective J œÜ :=
  sheafifyMap_locallyInjective_iff J œÜ-/

end Presheaf

end CategoryTheory
