/-
Copyright (c) 2022 R√©mi Bottinelli. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: R√©mi Bottinelli
-/
import Mathlib.CategoryTheory.Category.Basic
import Mathlib.CategoryTheory.Functor.Basic
import Mathlib.CategoryTheory.Groupoid
import Mathlib.Tactic.NthRewrite
import Mathlib.CategoryTheory.PathCategory
import Mathlib.CategoryTheory.Quotient
import Mathlib.Combinatorics.Quiver.Symmetric

#align_import category_theory.groupoid.free_groupoid from "leanprover-community/mathlib"@"706d88f2b8fdfeb0b22796433d7a6c1a010af9f2"

/-!
# Free groupoid on a quiver

This file defines the free groupoid on a quiver, the lifting of a prefunctor to its unique
extension as a functor from the free groupoid, and proves uniqueness of this extension.

## Main results

Given the type `V` and a quiver instance on `V`:

- `FreeGroupoid V`: a type synonym for `V`.
- `FreeGroupoid.instGroupoid`: the `Groupoid` instance on `FreeGroupoid V`.
- `lift`: the lifting of a prefunctor from `V` to `V'` where `V'` is a groupoid, to a functor.
  `FreeGroupoid V ‚•§ V'`.
- `lift_spec` and `lift_unique`: the proofs that, respectively, `lift` indeed is a lifting
  and is the unique one.

## Implementation notes

The free groupoid is first defined by symmetrifying the quiver, taking the induced path category
and finally quotienting by the reducibility relation.

-/


open Set Classical Function

attribute [local instance] propDecidable

namespace CategoryTheory

namespace Groupoid

namespace Free

universe u v u' v' u'' v''

variable {V : Type u} [Quiver.{v + 1} V]

/-- Shorthand for the "forward" arrow corresponding to `f` in `paths $ symmetrify V` -/
abbrev _root_.Quiver.Hom.toPosPath {X Y : V} (f : X ‚ü∂ Y) :
    (CategoryTheory.Paths.categoryPaths <| Quiver.Symmetrify V).Hom X Y :=
  f.toPos.toPath
#align category_theory.groupoid.free.quiver.hom.to_pos_path Quiver.Hom.toPosPath

/-- Shorthand for the "forward" arrow corresponding to `f` in `paths $ symmetrify V` -/
abbrev _root_.Quiver.Hom.toNegPath {X Y : V} (f : X ‚ü∂ Y) :
    (CategoryTheory.Paths.categoryPaths <| Quiver.Symmetrify V).Hom Y X :=
  f.toNeg.toPath
#align category_theory.groupoid.free.quiver.hom.to_neg_path Quiver.Hom.toNegPath

/-- The "reduction" relation -/
inductive redStep : HomRel (Paths (Quiver.Symmetrify V))
  | step (X Z : Quiver.Symmetrify V) (f : X ‚ü∂ Z) :
    redStep (ùüô (Paths.of.obj X)) (f.toPath ‚â´ (Quiver.reverse f).toPath)
#align category_theory.groupoid.free.red_step CategoryTheory.Groupoid.Free.redStep

/-- The underlying vertices of the free groupoid -/
def _root_.CategoryTheory.FreeGroupoid (V) [Q : Quiver V] :=
  Quotient (@redStep V Q)
#align category_theory.free_groupoid CategoryTheory.FreeGroupoid

instance {V} [Quiver V] [Nonempty V] : Nonempty (FreeGroupoid V) := by
  inhabit V; exact ‚ü®‚ü®@default V _‚ü©‚ü©
  -- ‚ä¢ Nonempty (FreeGroupoid V)
             -- üéâ no goals

theorem congr_reverse {X Y : Paths <| Quiver.Symmetrify V} (p q : X ‚ü∂ Y) :
    Quotient.CompClosure redStep p q ‚Üí Quotient.CompClosure redStep p.reverse q.reverse := by
  rintro ‚ü®XW, pp, qq, WY, _, Z, f‚ü©
  -- ‚ä¢ Quotient.CompClosure redStep (Quiver.Path.reverse (XW ‚â´ ùüô (Paths.of.obj X‚úù)  ‚Ä¶
  have : Quotient.CompClosure redStep (WY.reverse ‚â´ ùüô _ ‚â´ XW.reverse)
      (WY.reverse ‚â´ (f.toPath ‚â´ (Quiver.reverse f).toPath) ‚â´ XW.reverse) := by
    constructor
    constructor
  simpa only [CategoryStruct.comp, CategoryStruct.id, Quiver.Path.reverse, Quiver.Path.nil_comp,
    Quiver.Path.reverse_comp, Quiver.reverse_reverse, Quiver.Path.reverse_toPath,
    Quiver.Path.comp_assoc] using this
#align category_theory.groupoid.free.congr_reverse CategoryTheory.Groupoid.Free.congr_reverse

theorem congr_comp_reverse {X Y : Paths <| Quiver.Symmetrify V} (p : X ‚ü∂ Y) :
    Quot.mk (@Quotient.CompClosure _ _ redStep _ _) (p ‚â´ p.reverse) =
      Quot.mk (@Quotient.CompClosure _ _ redStep _ _) (ùüô X) := by
  apply Quot.EqvGen_sound
  -- ‚ä¢ EqvGen (Quotient.CompClosure redStep) (p ‚â´ Quiver.Path.reverse p) (ùüô X)
  induction' p with a b q f ih
  -- ‚ä¢ EqvGen (Quotient.CompClosure redStep) (Quiver.Path.nil ‚â´ Quiver.Path.reverse ‚Ä¶
  ¬∑ apply EqvGen.refl
    -- üéâ no goals
  ¬∑ simp only [Quiver.Path.reverse]
    -- ‚ä¢ EqvGen (Quotient.CompClosure redStep) (Quiver.Path.cons q f ‚â´ Quiver.Path.co ‚Ä¶
    fapply EqvGen.trans
    -- Porting note : `Quiver.Path.*` and `Quiver.Hom.*` notation not working
    ¬∑ exact q ‚â´ Quiver.Path.reverse q
      -- üéâ no goals
    ¬∑ apply EqvGen.symm
      -- ‚ä¢ EqvGen (Quotient.CompClosure redStep) (q ‚â´ Quiver.Path.reverse q) (Quiver.Pa ‚Ä¶
      apply EqvGen.rel
      -- ‚ä¢ Quotient.CompClosure redStep (q ‚â´ Quiver.Path.reverse q) (Quiver.Path.cons q ‚Ä¶
      have : Quotient.CompClosure redStep (q ‚â´ ùüô _ ‚â´ Quiver.Path.reverse q)
          (q ‚â´ (Quiver.Hom.toPath f ‚â´ Quiver.Hom.toPath (Quiver.reverse f)) ‚â´
            Quiver.Path.reverse q) := by
        apply Quotient.CompClosure.intro
        apply redStep.step
      simp only [Category.assoc, Category.id_comp] at this ‚ä¢
      -- ‚ä¢ Quotient.CompClosure redStep (q ‚â´ Quiver.Path.reverse q) (Quiver.Path.cons q ‚Ä¶
      -- Porting note : `simp` cannot see how `Quiver.Path.comp_assoc` is relevant, so change to
      -- category notation
      change Quotient.CompClosure redStep (q ‚â´ Quiver.Path.reverse q)
        (Quiver.Path.cons q f ‚â´ (Quiver.Hom.toPath (Quiver.reverse f)) ‚â´ (Quiver.Path.reverse q))
      simp only [‚ÜêCategory.assoc] at this ‚ä¢
      -- ‚ä¢ Quotient.CompClosure redStep (q ‚â´ Quiver.Path.reverse q) ((Quiver.Path.cons  ‚Ä¶
      exact this
      -- üéâ no goals
    ¬∑ exact ih
      -- üéâ no goals
#align category_theory.groupoid.free.congr_comp_reverse CategoryTheory.Groupoid.Free.congr_comp_reverse

theorem congr_reverse_comp {X Y : Paths <| Quiver.Symmetrify V} (p : X ‚ü∂ Y) :
    Quot.mk (@Quotient.CompClosure _ _ redStep _ _) (p.reverse ‚â´ p) =
      Quot.mk (@Quotient.CompClosure _ _ redStep _ _) (ùüô Y) := by
  nth_rw 2 [‚Üê Quiver.Path.reverse_reverse p]
  -- ‚ä¢ Quot.mk (Quotient.CompClosure redStep) (Quiver.Path.reverse p ‚â´ Quiver.Path. ‚Ä¶
  apply congr_comp_reverse
  -- üéâ no goals
#align category_theory.groupoid.free.congr_reverse_comp CategoryTheory.Groupoid.Free.congr_reverse_comp

instance : Category (FreeGroupoid V) :=
  Quotient.category redStep

/-- The inverse of an arrow in the free groupoid -/
def quotInv {X Y : FreeGroupoid V} (f : X ‚ü∂ Y) : Y ‚ü∂ X :=
  Quot.liftOn f (fun pp => Quot.mk _ <| pp.reverse) fun pp qq con =>
    Quot.sound <| congr_reverse pp qq con
#align category_theory.groupoid.free.quot_inv CategoryTheory.Groupoid.Free.quotInv

instance _root_.CategoryTheory.FreeGroupoid.instGroupoid : Groupoid (FreeGroupoid V) where
  inv := quotInv
  inv_comp p := Quot.inductionOn p fun pp => congr_reverse_comp pp
  comp_inv p := Quot.inductionOn p fun pp => congr_comp_reverse pp
#align category_theory.groupoid.free.category_theory.free_groupoid.category_theory.groupoid CategoryTheory.FreeGroupoid.instGroupoid

/-- The inclusion of the quiver on `V` to the underlying quiver on `FreeGroupoid V`-/
def of (V) [Quiver V] : V ‚•§q FreeGroupoid V where
  obj X := ‚ü®X‚ü©
  map f := Quot.mk _ f.toPosPath
#align category_theory.groupoid.free.of CategoryTheory.Groupoid.Free.of

theorem of_eq :
    of V = (Quiver.Symmetrify.of ‚ãôq Paths.of).comp
      (Quotient.functor <| @redStep V _).toPrefunctor := rfl
#align category_theory.groupoid.free.of_eq CategoryTheory.Groupoid.Free.of_eq

section UniversalProperty

variable {V' : Type u'} [Groupoid V'] (œÜ : V ‚•§q V')

/-- The lift of a prefunctor to a groupoid, to a functor from `FreeGroupoid V` -/
def lift (œÜ : V ‚•§q V') : FreeGroupoid V ‚•§ V' :=
  Quotient.lift _ (Paths.lift <| Quiver.Symmetrify.lift œÜ) <| by
    rintro _ _ _ _ ‚ü®X, Y, f‚ü©
    -- ‚ä¢ (Paths.lift (Quiver.Symmetrify.lift œÜ)).map (ùüô (Paths.of.obj X)) = (Paths.li ‚Ä¶
    -- Porting note: `simp` does not work, so manually `rewrite`
    erw [Paths.lift_nil, Paths.lift_cons, Quiver.Path.comp_nil, Paths.lift_toPath,
      Quiver.Symmetrify.lift_reverse]
    symm
    -- ‚ä¢ (Quiver.Symmetrify.lift œÜ).map f ‚â´ Quiver.reverse ((Quiver.Symmetrify.lift œÜ ‚Ä¶
    apply Groupoid.comp_inv
    -- üéâ no goals
#align category_theory.groupoid.free.lift CategoryTheory.Groupoid.Free.lift

theorem lift_spec (œÜ : V ‚•§q V') : of V ‚ãôq (lift œÜ).toPrefunctor = œÜ := by
  rw [of_eq, Prefunctor.comp_assoc, Prefunctor.comp_assoc, Functor.toPrefunctor_comp]
  -- ‚ä¢ Quiver.Symmetrify.of ‚ãôq (Paths.of ‚ãôq (Quotient.functor redStep ‚ãô lift œÜ).toP ‚Ä¶
  dsimp [lift]
  -- ‚ä¢ Quiver.Symmetrify.of ‚ãôq (Paths.of ‚ãôq (Quotient.functor redStep ‚ãô Quotient.li ‚Ä¶
  rw [Quotient.lift_spec, Paths.lift_spec, Quiver.Symmetrify.lift_spec]
  -- üéâ no goals
#align category_theory.groupoid.free.lift_spec CategoryTheory.Groupoid.Free.lift_spec

theorem lift_unique (œÜ : V ‚•§q V') (Œ¶ : FreeGroupoid V ‚•§ V') (hŒ¶ : of V ‚ãôq Œ¶.toPrefunctor = œÜ) :
    Œ¶ = lift œÜ := by
  apply Quotient.lift_unique
  -- ‚ä¢ Quotient.functor redStep ‚ãô Œ¶ = Paths.lift (Quiver.Symmetrify.lift œÜ)
  apply Paths.lift_unique
  -- ‚ä¢ Paths.of ‚ãôq (Quotient.functor redStep ‚ãô Œ¶).toPrefunctor = Quiver.Symmetrify. ‚Ä¶
  fapply @Quiver.Symmetrify.lift_unique _ _ _ _ _ _ _ _ _
  -- ‚ä¢ Quiver.Symmetrify.of ‚ãôq (Paths.of ‚ãôq (Quotient.functor redStep ‚ãô Œ¶).toPrefun ‚Ä¶
  ¬∑ rw [‚Üê Functor.toPrefunctor_comp]
    -- ‚ä¢ Quiver.Symmetrify.of ‚ãôq (Paths.of ‚ãôq ((Quotient.functor redStep).toPrefuncto ‚Ä¶
    exact hŒ¶
    -- üéâ no goals
  ¬∑ rintro X Y f
    -- ‚ä¢ (Paths.of ‚ãôq (Quotient.functor redStep ‚ãô Œ¶).toPrefunctor).map (Quiver.revers ‚Ä¶
    simp only [‚Üê Functor.toPrefunctor_comp, Prefunctor.comp_map, Paths.of_map, inv_eq_inv]
    -- ‚ä¢ Œ¶.map ((Quotient.functor redStep).map (Quiver.Hom.toPath (Quiver.reverse f)) ‚Ä¶
    change Œ¶.map (inv ((Quotient.functor redStep).toPrefunctor.map f.toPath)) =
      inv (Œ¶.map ((Quotient.functor redStep).toPrefunctor.map f.toPath))
    have := Functor.map_inv Œ¶ ((Quotient.functor redStep).toPrefunctor.map f.toPath)
    -- ‚ä¢ Œ¶.map (inv ((Quotient.functor redStep).map (Quiver.Hom.toPath f))) = inv (Œ¶. ‚Ä¶
    convert this <;> simp only [inv_eq_inv]
    -- ‚ä¢ inv ((Quotient.functor redStep).map (Quiver.Hom.toPath f)) = CategoryTheory. ‚Ä¶
                     -- üéâ no goals
                     -- üéâ no goals
#align category_theory.groupoid.free.lift_unique CategoryTheory.Groupoid.Free.lift_unique

end UniversalProperty

section Functoriality

variable {V' : Type u'} [Quiver.{v' + 1} V'] {V'' : Type u''} [Quiver.{v'' + 1} V'']

/-- The functor of free groupoid induced by a prefunctor of quivers -/
def _root_.CategoryTheory.freeGroupoidFunctor (œÜ : V ‚•§q V') : FreeGroupoid V ‚•§ FreeGroupoid V' :=
  lift (œÜ ‚ãôq of V')
#align category_theory.free_groupoid_functor CategoryTheory.freeGroupoidFunctor

theorem freeGroupoidFunctor_id :
    freeGroupoidFunctor (Prefunctor.id V) = Functor.id (FreeGroupoid V) := by
  dsimp only [freeGroupoidFunctor]; symm
  -- ‚ä¢ lift (ùü≠q V ‚ãôq of V) = ùü≠ (FreeGroupoid V)
                                    -- ‚ä¢ ùü≠ (FreeGroupoid V) = lift (ùü≠q V ‚ãôq of V)
  apply lift_unique; rfl
  -- ‚ä¢ of V ‚ãôq (ùü≠ (FreeGroupoid V)).toPrefunctor = ùü≠q V ‚ãôq of V
                     -- üéâ no goals
#align category_theory.groupoid.free.free_groupoid_functor_id CategoryTheory.Groupoid.Free.freeGroupoidFunctor_id

theorem freeGroupoidFunctor_comp (œÜ : V ‚•§q V') (œÜ' : V' ‚•§q V'') :
    freeGroupoidFunctor (œÜ ‚ãôq œÜ') = freeGroupoidFunctor œÜ ‚ãô freeGroupoidFunctor œÜ' := by
  dsimp only [freeGroupoidFunctor]; symm
  -- ‚ä¢ lift (œÜ ‚ãôq œÜ' ‚ãôq of V'') = lift (œÜ ‚ãôq of V') ‚ãô lift (œÜ' ‚ãôq of V'')
                                    -- ‚ä¢ lift (œÜ ‚ãôq of V') ‚ãô lift (œÜ' ‚ãôq of V'') = lift (œÜ ‚ãôq œÜ' ‚ãôq of V'')
  apply lift_unique; rfl
  -- ‚ä¢ of V ‚ãôq (lift (œÜ ‚ãôq of V') ‚ãô lift (œÜ' ‚ãôq of V'')).toPrefunctor = œÜ ‚ãôq œÜ' ‚ãôq  ‚Ä¶
                     -- üéâ no goals
#align category_theory.groupoid.free.free_groupoid_functor_comp CategoryTheory.Groupoid.Free.freeGroupoidFunctor_comp

end Functoriality

end Free

end Groupoid

end CategoryTheory
