/-
Copyright (c) 2021 Aaron Anderson, Ya√´l Dillies. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Aaron Anderson, Kevin Buzzard, Ya√´l Dillies, Eric Wieser
-/
import Mathlib.Data.Finset.Sigma
import Mathlib.Data.Finset.Pairwise
import Mathlib.Data.Finset.Powerset
import Mathlib.Data.Fintype.Basic

#align_import order.sup_indep from "leanprover-community/mathlib"@"c4c2ed622f43768eff32608d4a0f8a6cec1c047d"

/-!
# Supremum independence

In this file, we define supremum independence of indexed sets. An indexed family `f : Œπ ‚Üí Œ±` is
sup-independent if, for all `a`, `f a` and the supremum of the rest are disjoint.

## Main definitions

* `Finset.SupIndep s f`: a family of elements `f` are supremum independent on the finite set `s`.
* `CompleteLattice.SetIndependent s`: a set of elements are supremum independent.
* `CompleteLattice.Independent f`: a family of elements are supremum independent.

## Main statements

* In a distributive lattice, supremum independence is equivalent to pairwise disjointness:
  * `Finset.supIndep_iff_pairwiseDisjoint`
  * `CompleteLattice.setIndependent_iff_pairwiseDisjoint`
  * `CompleteLattice.independent_iff_pairwiseDisjoint`
* Otherwise, supremum independence is stronger than pairwise disjointness:
  * `Finset.SupIndep.pairwiseDisjoint`
  * `CompleteLattice.SetIndependent.pairwiseDisjoint`
  * `CompleteLattice.Independent.pairwiseDisjoint`

## Implementation notes

For the finite version, we avoid the "obvious" definition
`‚àÄ i ‚àà s, Disjoint (f i) ((s.erase i).sup f)` because `erase` would require decidable equality on
`Œπ`.
-/


variable {Œ± Œ≤ Œπ Œπ' : Type*}

/-! ### On lattices with a bottom element, via `Finset.sup` -/


namespace Finset

section Lattice

variable [Lattice Œ±] [OrderBot Œ±]

/-- Supremum independence of finite sets. We avoid the "obvious" definition using `s.erase i`
because `erase` would require decidable equality on `Œπ`. -/
def SupIndep (s : Finset Œπ) (f : Œπ ‚Üí Œ±) : Prop :=
  ‚àÄ ‚¶Ét‚¶Ñ, t ‚äÜ s ‚Üí ‚àÄ ‚¶Éi‚¶Ñ, i ‚àà s ‚Üí i ‚àâ t ‚Üí Disjoint (f i) (t.sup f)
#align finset.sup_indep Finset.SupIndep

variable {s t : Finset Œπ} {f : Œπ ‚Üí Œ±} {i : Œπ}

instance [DecidableEq Œπ] [DecidableEq Œ±] : Decidable (SupIndep s f) := by
  refine @Finset.decidableForallOfDecidableSubsets _ _ _ (?_)
  -- ‚ä¢ (t : Finset Œπ) ‚Üí t ‚äÜ s ‚Üí Decidable (‚àÄ ‚¶Éi : Œπ‚¶Ñ, i ‚àà s ‚Üí ¬¨i ‚àà t ‚Üí Disjoint (f  ‚Ä¶
  rintro t -
  -- ‚ä¢ Decidable (‚àÄ ‚¶Éi : Œπ‚¶Ñ, i ‚àà s ‚Üí ¬¨i ‚àà t ‚Üí Disjoint (f i) (sup t f))
  refine @Finset.decidableDforallFinset _ _ _ (?_)
  -- ‚ä¢ (a : Œπ) ‚Üí a ‚àà s ‚Üí Decidable (¬¨a ‚àà t ‚Üí Disjoint (f a) (sup t f))
  rintro i -
  -- ‚ä¢ Decidable (¬¨i ‚àà t ‚Üí Disjoint (f i) (sup t f))
  have : Decidable (Disjoint (f i) (sup t f)) := decidable_of_iff' (_ = ‚ä•) disjoint_iff
  -- ‚ä¢ Decidable (¬¨i ‚àà t ‚Üí Disjoint (f i) (sup t f))
  infer_instance
  -- üéâ no goals

theorem SupIndep.subset (ht : t.SupIndep f) (h : s ‚äÜ t) : s.SupIndep f := fun _ hu _ hi =>
  ht (hu.trans h) (h hi)
#align finset.sup_indep.subset Finset.SupIndep.subset

theorem supIndep_empty (f : Œπ ‚Üí Œ±) : (‚àÖ : Finset Œπ).SupIndep f := fun _ _ a ha =>
  (not_mem_empty a ha).elim
#align finset.sup_indep_empty Finset.supIndep_empty

theorem supIndep_singleton (i : Œπ) (f : Œπ ‚Üí Œ±) : ({i} : Finset Œπ).SupIndep f :=
  fun s hs j hji hj => by
    rw [eq_empty_of_ssubset_singleton ‚ü®hs, fun h => hj (h hji)‚ü©, sup_empty]
    -- ‚ä¢ Disjoint (f j) ‚ä•
    exact disjoint_bot_right
    -- üéâ no goals
#align finset.sup_indep_singleton Finset.supIndep_singleton

theorem SupIndep.pairwiseDisjoint (hs : s.SupIndep f) : (s : Set Œπ).PairwiseDisjoint f :=
  fun _ ha _ hb hab =>
    sup_singleton.subst <| hs (singleton_subset_iff.2 hb) ha <| not_mem_singleton.2 hab
#align finset.sup_indep.pairwise_disjoint Finset.SupIndep.pairwiseDisjoint

theorem SupIndep.le_sup_iff (hs : s.SupIndep f) (hts : t ‚äÜ s) (hi : i ‚àà s) (hf : ‚àÄ i, f i ‚â† ‚ä•) :
    f i ‚â§ t.sup f ‚Üî i ‚àà t := by
  refine' ‚ü®fun h => _, le_sup‚ü©
  -- ‚ä¢ i ‚àà t
  by_contra hit
  -- ‚ä¢ False
  exact hf i (disjoint_self.1 <| (hs hts hi hit).mono_right h)
  -- üéâ no goals
#align finset.sup_indep.le_sup_iff Finset.SupIndep.le_sup_iff

/-- The RHS looks like the definition of `CompleteLattice.Independent`. -/
theorem supIndep_iff_disjoint_erase [DecidableEq Œπ] :
    s.SupIndep f ‚Üî ‚àÄ i ‚àà s, Disjoint (f i) ((s.erase i).sup f) :=
  ‚ü®fun hs _ hi => hs (erase_subset _ _) hi (not_mem_erase _ _), fun hs _ ht i hi hit =>
    (hs i hi).mono_right (sup_mono fun _ hj => mem_erase.2 ‚ü®ne_of_mem_of_not_mem hj hit, ht hj‚ü©)‚ü©
#align finset.sup_indep_iff_disjoint_erase Finset.supIndep_iff_disjoint_erase

theorem SupIndep.image [DecidableEq Œπ] {s : Finset Œπ'} {g : Œπ' ‚Üí Œπ} (hs : s.SupIndep (f ‚àò g)) :
    (s.image g).SupIndep f := by
  intro t ht i hi hit
  -- ‚ä¢ Disjoint (f i) (sup t f)
  rw [mem_image] at hi
  -- ‚ä¢ Disjoint (f i) (sup t f)
  obtain ‚ü®i, hi, rfl‚ü© := hi
  -- ‚ä¢ Disjoint (f (g i)) (sup t f)
  haveI : DecidableEq Œπ' := Classical.decEq _
  -- ‚ä¢ Disjoint (f (g i)) (sup t f)
  suffices hts : t ‚äÜ (s.erase i).image g
  -- ‚ä¢ Disjoint (f (g i)) (sup t f)
  ¬∑ refine' (supIndep_iff_disjoint_erase.1 hs i hi).mono_right ((sup_mono hts).trans _)
    -- ‚ä¢ sup (Finset.image g (erase s i)) f ‚â§ sup (erase s i) (f ‚àò g)
    rw [sup_image]
    -- üéâ no goals
  rintro j hjt
  -- ‚ä¢ j ‚àà Finset.image g (erase s i)
  obtain ‚ü®j, hj, rfl‚ü© := mem_image.1 (ht hjt)
  -- ‚ä¢ g j ‚àà Finset.image g (erase s i)
  exact mem_image_of_mem _ (mem_erase.2 ‚ü®ne_of_apply_ne g (ne_of_mem_of_not_mem hjt hit), hj‚ü©)
  -- üéâ no goals
#align finset.sup_indep.image Finset.SupIndep.image

theorem supIndep_map {s : Finset Œπ'} {g : Œπ' ‚Ü™ Œπ} : (s.map g).SupIndep f ‚Üî s.SupIndep (f ‚àò g) := by
  refine' ‚ü®fun hs t ht i hi hit => _, fun hs => _‚ü©
  -- ‚ä¢ Disjoint ((f ‚àò ‚Üëg) i) (sup t (f ‚àò ‚Üëg))
  ¬∑ rw [‚Üê sup_map]
    -- ‚ä¢ Disjoint ((f ‚àò ‚Üëg) i) (sup (map g t) f)
    exact hs (map_subset_map.2 ht) ((mem_map' _).2 hi) (by rwa [mem_map'])
    -- üéâ no goals
  ¬∑ classical
    rw [map_eq_image]
    exact hs.image
#align finset.sup_indep_map Finset.supIndep_map

@[simp]
theorem supIndep_pair [DecidableEq Œπ] {i j : Œπ} (hij : i ‚â† j) :
    ({i, j} : Finset Œπ).SupIndep f ‚Üî Disjoint (f i) (f j) :=
  ‚ü®fun h => h.pairwiseDisjoint (by simp) (by simp) hij,
                                   -- üéâ no goals
                                             -- üéâ no goals
   fun h => by
    rw [supIndep_iff_disjoint_erase]
    -- ‚ä¢ ‚àÄ (i_1 : Œπ), i_1 ‚àà {i, j} ‚Üí Disjoint (f i_1) (sup (erase {i, j} i_1) f)
    intro k hk
    -- ‚ä¢ Disjoint (f k) (sup (erase {i, j} k) f)
    rw [Finset.mem_insert, Finset.mem_singleton] at hk
    -- ‚ä¢ Disjoint (f k) (sup (erase {i, j} k) f)
    obtain rfl | rfl := hk
    -- ‚ä¢ Disjoint (f k) (sup (erase {k, j} k) f)
    ¬∑ convert h using 1
      -- ‚ä¢ sup (erase {k, j} k) f = f j
      rw [Finset.erase_insert, Finset.sup_singleton]
      -- ‚ä¢ ¬¨k ‚àà {j}
      simpa using hij
      -- üéâ no goals
    ¬∑ convert h.symm using 1
      -- ‚ä¢ sup (erase {i, k} k) f = f i
      have : ({i, k} : Finset Œπ).erase k = {i} := by
        ext
        rw [mem_erase, mem_insert, mem_singleton, mem_singleton, and_or_left, Ne.def,
          not_and_self_iff, or_false_iff, and_iff_right_of_imp]
        rintro rfl
        exact hij
      rw [this, Finset.sup_singleton]‚ü©
      -- üéâ no goals
#align finset.sup_indep_pair Finset.supIndep_pair

theorem supIndep_univ_bool (f : Bool ‚Üí Œ±) :
    (Finset.univ : Finset Bool).SupIndep f ‚Üî Disjoint (f false) (f true) :=
  haveI : true ‚â† false := by simp only [Ne.def, not_false_iff]
                             -- üéâ no goals
  (supIndep_pair this).trans disjoint_comm
#align finset.sup_indep_univ_bool Finset.supIndep_univ_bool

@[simp]
theorem supIndep_univ_fin_two (f : Fin 2 ‚Üí Œ±) :
    (Finset.univ : Finset (Fin 2)).SupIndep f ‚Üî Disjoint (f 0) (f 1) :=
  haveI : (0 : Fin 2) ‚â† 1 := by simp
                                -- üéâ no goals
  supIndep_pair this
#align finset.sup_indep_univ_fin_two Finset.supIndep_univ_fin_two

theorem SupIndep.attach (hs : s.SupIndep f) : s.attach.SupIndep fun a => f a := by
  intro t _ i _ hi
  -- ‚ä¢ Disjoint ((fun a => f ‚Üëa) i) (sup t fun a => f ‚Üëa)
  classical
    have : (fun (a : { x // x ‚àà s }) => f ‚Üëa) = f ‚àò (fun a : { x // x ‚àà s } => ‚Üëa) := rfl
    rw [this, ‚Üê Finset.sup_image]
    refine' hs (image_subset_iff.2 fun (j : { x // x ‚àà s }) _ => j.2) i.2 fun hi' => hi _
    rw [mem_image] at hi'
    obtain ‚ü®j, hj, hji‚ü© := hi'
    rwa [Subtype.ext hji] at hj
#align finset.sup_indep.attach Finset.SupIndep.attach

/-
Porting note: simpNF linter returns

"Left-hand side does not simplify, when using the simp lemma on itself."

However, simp does indeed solve the following. leanprover/std4#71 is related.

example {Œ± Œπ} [Lattice Œ±] [OrderBot Œ±] (s : Finset Œπ) (f : Œπ ‚Üí Œ±) :
  (s.attach.SupIndep fun a => f a) ‚Üî s.SupIndep f := by simp
-/
@[simp, nolint simpNF]
theorem supIndep_attach : (s.attach.SupIndep fun a => f a) ‚Üî s.SupIndep f := by
  refine' ‚ü®fun h t ht i his hit => _, SupIndep.attach‚ü©
  -- ‚ä¢ Disjoint (f i) (sup t f)
  classical
  convert h (filter_subset (fun (i : { x // x ‚àà s }) => (i : Œπ) ‚àà t) _) (mem_attach _ ‚ü®i, ‚Äπ_‚Ä∫‚ü©)
    fun hi => hit <| by simpa using hi using 1
  refine' eq_of_forall_ge_iff _
  simp only [Finset.sup_le_iff, mem_filter, mem_attach, true_and_iff, Function.comp_apply,
    Subtype.forall, Subtype.coe_mk]
  exact fun a => forall_congr' fun j => ‚ü®fun h _ => h, fun h hj => h (ht hj) hj‚ü©
#align finset.sup_indep_attach Finset.supIndep_attach

end Lattice

section DistribLattice

variable [DistribLattice Œ±] [OrderBot Œ±] {s : Finset Œπ} {f : Œπ ‚Üí Œ±}

theorem supIndep_iff_pairwiseDisjoint : s.SupIndep f ‚Üî (s : Set Œπ).PairwiseDisjoint f :=
  ‚ü®SupIndep.pairwiseDisjoint, fun hs _ ht _ hi hit =>
    Finset.disjoint_sup_right.2 fun _ hj => hs hi (ht hj) (ne_of_mem_of_not_mem hj hit).symm‚ü©
#align finset.sup_indep_iff_pairwise_disjoint Finset.supIndep_iff_pairwiseDisjoint

alias ‚ü®sup_indep.pairwise_disjoint, _root_.Set.PairwiseDisjoint.supIndep‚ü© :=
  supIndep_iff_pairwiseDisjoint
#align set.pairwise_disjoint.sup_indep Set.PairwiseDisjoint.supIndep

/-- Bind operation for `SupIndep`. -/
theorem SupIndep.sup [DecidableEq Œπ] {s : Finset Œπ'} {g : Œπ' ‚Üí Finset Œπ} {f : Œπ ‚Üí Œ±}
    (hs : s.SupIndep fun i => (g i).sup f) (hg : ‚àÄ i' ‚àà s, (g i').SupIndep f) :
    (s.sup g).SupIndep f := by
  simp_rw [supIndep_iff_pairwiseDisjoint] at hs hg ‚ä¢
  -- ‚ä¢ Set.PairwiseDisjoint (‚Üë(Finset.sup s g)) f
  rw [sup_eq_biUnion, coe_biUnion]
  -- ‚ä¢ Set.PairwiseDisjoint (‚ãÉ (x : Œπ') (_ : x ‚àà ‚Üës), ‚Üë(g x)) f
  exact hs.biUnion_finset hg
  -- üéâ no goals
#align finset.sup_indep.sup Finset.SupIndep.sup

/-- Bind operation for `SupIndep`. -/
theorem SupIndep.biUnion [DecidableEq Œπ] {s : Finset Œπ'} {g : Œπ' ‚Üí Finset Œπ} {f : Œπ ‚Üí Œ±}
    (hs : s.SupIndep fun i => (g i).sup f) (hg : ‚àÄ i' ‚àà s, (g i').SupIndep f) :
    (s.biUnion g).SupIndep f := by
  rw [‚Üê sup_eq_biUnion]
  -- ‚ä¢ SupIndep (Finset.sup s g) f
  exact hs.sup hg
  -- üéâ no goals
#align finset.sup_indep.bUnion Finset.SupIndep.biUnion

/-- Bind operation for `SupIndep`. -/
theorem SupIndep.sigma {Œ≤ : Œπ ‚Üí Type*} {s : Finset Œπ} {g : ‚àÄ i, Finset (Œ≤ i)} {f : Sigma Œ≤ ‚Üí Œ±}
    (hs : s.SupIndep fun i => (g i).sup fun b => f ‚ü®i, b‚ü©)
    (hg : ‚àÄ i ‚àà s, (g i).SupIndep fun b => f ‚ü®i, b‚ü©) : (s.sigma g).SupIndep f := by
  rintro t ht ‚ü®i, b‚ü© hi hit
  -- ‚ä¢ Disjoint (f { fst := i, snd := b }) (Finset.sup t f)
  rw [Finset.disjoint_sup_right]
  -- ‚ä¢ ‚àÄ ‚¶Éi_1 : (i : Œπ) √ó Œ≤ i‚¶Ñ, i_1 ‚àà t ‚Üí Disjoint (f { fst := i, snd := b }) (f i_1)
  rintro ‚ü®j, c‚ü© hj
  -- ‚ä¢ Disjoint (f { fst := i, snd := b }) (f { fst := j, snd := c })
  have hbc := (ne_of_mem_of_not_mem hj hit).symm
  -- ‚ä¢ Disjoint (f { fst := i, snd := b }) (f { fst := j, snd := c })
  replace hj := ht hj
  -- ‚ä¢ Disjoint (f { fst := i, snd := b }) (f { fst := j, snd := c })
  rw [mem_sigma] at hi hj
  -- ‚ä¢ Disjoint (f { fst := i, snd := b }) (f { fst := j, snd := c })
  obtain rfl | hij := eq_or_ne i j
  -- ‚ä¢ Disjoint (f { fst := i, snd := b }) (f { fst := i, snd := c })
  ¬∑ exact (hg _ hj.1).pairwiseDisjoint hi.2 hj.2 (sigma_mk_injective.ne_iff.1 hbc)
    -- üéâ no goals
  ¬∑ refine' (hs.pairwiseDisjoint hi.1 hj.1 hij).mono _ _
    -- ‚ä¢ f { fst := i, snd := b } ‚â§ (fun i => Finset.sup (g i) fun b => f { fst := i, ‚Ä¶
    ¬∑ convert le_sup (Œ± := Œ±) hi.2; simp
      -- ‚ä¢ f { fst := i, snd := b } = f { fst := { fst := i, snd := b }.fst, snd := { f ‚Ä¶
                                    -- üéâ no goals
    ¬∑ convert le_sup (Œ± := Œ±) hj.2; simp
      -- ‚ä¢ f { fst := j, snd := c } = f { fst := { fst := j, snd := c }.fst, snd := { f ‚Ä¶
                                    -- üéâ no goals
#align finset.sup_indep.sigma Finset.SupIndep.sigma

theorem SupIndep.product {s : Finset Œπ} {t : Finset Œπ'} {f : Œπ √ó Œπ' ‚Üí Œ±}
    (hs : s.SupIndep fun i => t.sup fun i' => f (i, i'))
    (ht : t.SupIndep fun i' => s.sup fun i => f (i, i')) : (s √óÀ¢ t).SupIndep f := by
  rintro u hu ‚ü®i, i'‚ü© hi hiu
  -- ‚ä¢ Disjoint (f (i, i')) (Finset.sup u f)
  rw [Finset.disjoint_sup_right]
  -- ‚ä¢ ‚àÄ ‚¶Éi_1 : Œπ √ó Œπ'‚¶Ñ, i_1 ‚àà u ‚Üí Disjoint (f (i, i')) (f i_1)
  rintro ‚ü®j, j'‚ü© hj
  -- ‚ä¢ Disjoint (f (i, i')) (f (j, j'))
  have hij := (ne_of_mem_of_not_mem hj hiu).symm
  -- ‚ä¢ Disjoint (f (i, i')) (f (j, j'))
  replace hj := hu hj
  -- ‚ä¢ Disjoint (f (i, i')) (f (j, j'))
  rw [mem_product] at hi hj
  -- ‚ä¢ Disjoint (f (i, i')) (f (j, j'))
  obtain rfl | hij := eq_or_ne i j
  -- ‚ä¢ Disjoint (f (i, i')) (f (i, j'))
  ¬∑ refine' (ht.pairwiseDisjoint hi.2 hj.2 <| (Prod.mk.inj_left _).ne_iff.1 hij).mono _ _
    -- ‚ä¢ f (i, i') ‚â§ (fun i' => Finset.sup s fun i => f (i, i')) (i, i').snd
    ¬∑ convert le_sup (Œ± := Œ±) hi.1; simp
      -- ‚ä¢ f (i, i') = f ((i, i').fst, (i, i').snd)
                                    -- üéâ no goals
    ¬∑ convert le_sup (Œ± := Œ±) hj.1; simp
      -- ‚ä¢ f (i, j') = f ((i, j').fst, (i, j').snd)
                                    -- üéâ no goals
  ¬∑ refine' (hs.pairwiseDisjoint hi.1 hj.1 hij).mono _ _
    -- ‚ä¢ f (i, i') ‚â§ (fun i => Finset.sup t fun i' => f (i, i')) (i, i').fst
    ¬∑ convert le_sup (Œ± := Œ±) hi.2; simp
      -- ‚ä¢ f (i, i') = f ((i, i').fst, (i, i').snd)
                                    -- üéâ no goals
    ¬∑ convert le_sup (Œ± := Œ±) hj.2; simp
      -- ‚ä¢ f (j, j') = f ((j, j').fst, (j, j').snd)
                                    -- üéâ no goals
#align finset.sup_indep.product Finset.SupIndep.product

theorem supIndep_product_iff {s : Finset Œπ} {t : Finset Œπ'} {f : Œπ √ó Œπ' ‚Üí Œ±} :
    (s.product t).SupIndep f ‚Üî (s.SupIndep fun i => t.sup fun i' => f (i, i'))
      ‚àß t.SupIndep fun i' => s.sup fun i => f (i, i') := by
  refine' ‚ü®_, fun h => h.1.product h.2‚ü©
  -- ‚ä¢ SupIndep (Finset.product s t) f ‚Üí (SupIndep s fun i => sup t fun i' => f (i, ‚Ä¶
  simp_rw [supIndep_iff_pairwiseDisjoint]
  -- ‚ä¢ Set.PairwiseDisjoint (‚Üë(Finset.product s t)) f ‚Üí (Set.PairwiseDisjoint ‚Üës fu ‚Ä¶
  refine' fun h => ‚ü®fun i hi j hj hij => _, fun i hi j hj hij => _‚ü© <;>
  -- ‚ä¢ (Disjoint on fun i => sup t fun i' => f (i, i')) i j
      simp_rw [Function.onFun, Finset.disjoint_sup_left, Finset.disjoint_sup_right] <;>
      -- ‚ä¢ ‚àÄ ‚¶Éi_1 : Œπ'‚¶Ñ, i_1 ‚àà t ‚Üí ‚àÄ ‚¶Éi_2 : Œπ'‚¶Ñ, i_2 ‚àà t ‚Üí Disjoint (f (i, i_1)) (f (j, ‚Ä¶
      -- ‚ä¢ ‚àÄ ‚¶Éi_1 : Œπ‚¶Ñ, i_1 ‚àà s ‚Üí ‚àÄ ‚¶Éi_2 : Œπ‚¶Ñ, i_2 ‚àà s ‚Üí Disjoint (f (i_1, i)) (f (i_2, ‚Ä¶
    intro i' hi' j' hj'
    -- ‚ä¢ Disjoint (f (i, i')) (f (j, j'))
    -- ‚ä¢ Disjoint (f (i', i)) (f (j', j))
  ¬∑ exact h (mk_mem_product hi hi') (mk_mem_product hj hj') (ne_of_apply_ne Prod.fst hij)
    -- üéâ no goals
  ¬∑ exact h (mk_mem_product hi' hi) (mk_mem_product hj' hj) (ne_of_apply_ne Prod.snd hij)
    -- üéâ no goals
#align finset.sup_indep_product_iff Finset.supIndep_product_iff

end DistribLattice

end Finset

/-! ### On complete lattices via `sSup` -/


namespace CompleteLattice

variable [CompleteLattice Œ±]

open Set Function

/-- An independent set of elements in a complete lattice is one in which every element is disjoint
  from the `Sup` of the rest. -/
def SetIndependent (s : Set Œ±) : Prop :=
  ‚àÄ ‚¶Éa‚¶Ñ, a ‚àà s ‚Üí Disjoint a (sSup (s \ {a}))
#align complete_lattice.set_independent CompleteLattice.SetIndependent

variable {s : Set Œ±} (hs : SetIndependent s)

@[simp]
theorem setIndependent_empty : SetIndependent (‚àÖ : Set Œ±) := fun x hx =>
  (Set.not_mem_empty x hx).elim
#align complete_lattice.set_independent_empty CompleteLattice.setIndependent_empty

theorem SetIndependent.mono {t : Set Œ±} (hst : t ‚äÜ s) : SetIndependent t := fun _ ha =>
  (hs (hst ha)).mono_right (sSup_le_sSup (diff_subset_diff_left hst))
#align complete_lattice.set_independent.mono CompleteLattice.SetIndependent.mono

/-- If the elements of a set are independent, then any pair within that set is disjoint. -/
theorem SetIndependent.pairwiseDisjoint : s.PairwiseDisjoint id := fun _ hx y hy h =>
  disjoint_sSup_right (hs hx) ((mem_diff y).mpr ‚ü®hy, h.symm‚ü©)
#align complete_lattice.set_independent.pairwise_disjoint CompleteLattice.SetIndependent.pairwiseDisjoint

theorem setIndependent_pair {a b : Œ±} (hab : a ‚â† b) :
    SetIndependent ({a, b} : Set Œ±) ‚Üî Disjoint a b := by
  constructor
  -- ‚ä¢ SetIndependent {a, b} ‚Üí Disjoint a b
  ¬∑ intro h
    -- ‚ä¢ Disjoint a b
    exact h.pairwiseDisjoint (mem_insert _ _) (mem_insert_of_mem _ (mem_singleton _)) hab
    -- üéâ no goals
  ¬∑ rintro h c ((rfl : c = a) | (rfl : c = b))
    -- ‚ä¢ Disjoint c (sSup ({c, b} \ {c}))
    ¬∑ convert h using 1
      -- ‚ä¢ sSup ({c, b} \ {c}) = b
      simp [hab, sSup_singleton]
      -- üéâ no goals
    ¬∑ convert h.symm using 1
      -- ‚ä¢ sSup ({a, c} \ {c}) = a
      simp [hab, sSup_singleton]
      -- üéâ no goals
#align complete_lattice.set_independent_pair CompleteLattice.setIndependent_pair

/-- If the elements of a set are independent, then any element is disjoint from the `sSup` of some
subset of the rest. -/
theorem SetIndependent.disjoint_sSup {x : Œ±} {y : Set Œ±} (hx : x ‚àà s) (hy : y ‚äÜ s) (hxy : x ‚àâ y) :
    Disjoint x (sSup y) := by
  have := (hs.mono <| insert_subset_iff.mpr ‚ü®hx, hy‚ü©) (mem_insert x _)
  -- ‚ä¢ Disjoint x (sSup y)
  rw [insert_diff_of_mem _ (mem_singleton _), diff_singleton_eq_self hxy] at this
  -- ‚ä¢ Disjoint x (sSup y)
  exact this
  -- üéâ no goals
#align complete_lattice.set_independent.disjoint_Sup CompleteLattice.SetIndependent.disjoint_sSup

/-- An independent indexed family of elements in a complete lattice is one in which every element
  is disjoint from the `iSup` of the rest.

  Example: an indexed family of non-zero elements in a
  vector space is linearly independent iff the indexed family of subspaces they generate is
  independent in this sense.

  Example: an indexed family of submodules of a module is independent in this sense if
  and only the natural map from the direct sum of the submodules to the module is injective. -/
-- Porting note: needed to use `_H`
def Independent {Œπ : Sort*} {Œ± : Type*} [CompleteLattice Œ±] (t : Œπ ‚Üí Œ±) : Prop :=
  ‚àÄ i : Œπ, Disjoint (t i) (‚®Ü (j) (_ : j ‚â† i), t j)
#align complete_lattice.independent CompleteLattice.Independent

theorem setIndependent_iff {Œ± : Type*} [CompleteLattice Œ±] (s : Set Œ±) :
    SetIndependent s ‚Üî Independent ((‚Üë) : s ‚Üí Œ±) := by
  simp_rw [Independent, SetIndependent, SetCoe.forall, sSup_eq_iSup]
  -- ‚ä¢ (‚àÄ ‚¶Éa : Œ±‚¶Ñ, a ‚àà s ‚Üí Disjoint a (‚®Ü (a_2 : Œ±) (_ : a_2 ‚àà s \ {a}), a_2)) ‚Üî ‚àÄ ( ‚Ä¶
  refine' forall‚ÇÇ_congr fun a ha => _
  -- ‚ä¢ Disjoint a (‚®Ü (a_1 : Œ±) (_ : a_1 ‚àà s \ {a}), a_1) ‚Üî Disjoint a (‚®Ü (j : { x / ‚Ä¶
  simp [iSup_subtype, iSup_and]
  -- üéâ no goals
#align complete_lattice.set_independent_iff CompleteLattice.setIndependent_iff

variable {t : Œπ ‚Üí Œ±} (ht : Independent t)

theorem independent_def : Independent t ‚Üî ‚àÄ i : Œπ, Disjoint (t i) (‚®Ü (j) (_ : j ‚â† i), t j) :=
  Iff.rfl
#align complete_lattice.independent_def CompleteLattice.independent_def

theorem independent_def' : Independent t ‚Üî ‚àÄ i, Disjoint (t i) (sSup (t '' { j | j ‚â† i })) := by
  simp_rw [sSup_image]
  -- ‚ä¢ Independent t ‚Üî ‚àÄ (i : Œπ), Disjoint (t i) (‚®Ü (a : Œπ) (_ : a ‚àà {j | j ‚â† i}),  ‚Ä¶
  rfl
  -- üéâ no goals
#align complete_lattice.independent_def' CompleteLattice.independent_def'

theorem independent_def'' :
    Independent t ‚Üî ‚àÄ i, Disjoint (t i) (sSup { a | ‚àÉ (j : _) (_ : j ‚â† i), t j = a }) := by
  rw [independent_def']
  -- ‚ä¢ (‚àÄ (i : Œπ), Disjoint (t i) (sSup (t '' {j | j ‚â† i}))) ‚Üî ‚àÄ (i : Œπ), Disjoint  ‚Ä¶
  aesop
  -- üéâ no goals
#align complete_lattice.independent_def'' CompleteLattice.independent_def''

@[simp]
theorem independent_empty (t : Empty ‚Üí Œ±) : Independent t :=
  fun.
#align complete_lattice.independent_empty CompleteLattice.independent_empty

@[simp]
theorem independent_pempty (t : PEmpty ‚Üí Œ±) : Independent t :=
  fun.
#align complete_lattice.independent_pempty CompleteLattice.independent_pempty

/-- If the elements of a set are independent, then any pair within that set is disjoint. -/
theorem Independent.pairwiseDisjoint : Pairwise (Disjoint on t) := fun x y h =>
  disjoint_sSup_right (ht x) ‚ü®y, iSup_pos h.symm‚ü©
#align complete_lattice.independent.pairwise_disjoint CompleteLattice.Independent.pairwiseDisjoint

theorem Independent.mono {s t : Œπ ‚Üí Œ±} (hs : Independent s) (hst : t ‚â§ s) : Independent t :=
  fun i => (hs i).mono (hst i) <| iSup‚ÇÇ_mono fun j _ => hst j
#align complete_lattice.independent.mono CompleteLattice.Independent.mono

/-- Composing an independent indexed family with an injective function on the index results in
another indepedendent indexed family. -/
theorem Independent.comp {Œπ Œπ' : Sort*} {t : Œπ ‚Üí Œ±} {f : Œπ' ‚Üí Œπ} (ht : Independent t)
    (hf : Injective f) : Independent (t ‚àò f) := fun i =>
  (ht (f i)).mono_right <| by
    refine' (iSup_mono fun i => _).trans (iSup_comp_le _ f)
    -- ‚ä¢ ‚®Ü (_ : i ‚â† i‚úù), (t ‚àò f) i ‚â§ ‚®Ü (_ : f i ‚â† f i‚úù), t (f i)
    exact iSup_const_mono hf.ne
    -- üéâ no goals
#align complete_lattice.independent.comp CompleteLattice.Independent.comp

theorem Independent.comp' {Œπ Œπ' : Sort*} {t : Œπ ‚Üí Œ±} {f : Œπ' ‚Üí Œπ} (ht : Independent <| t ‚àò f)
    (hf : Surjective f) : Independent t := by
  intro i
  -- ‚ä¢ Disjoint (t i) (‚®Ü (j : Œπ) (_ : j ‚â† i), t j)
  obtain ‚ü®i', rfl‚ü© := hf i
  -- ‚ä¢ Disjoint (t (f i')) (‚®Ü (j : Œπ) (_ : j ‚â† f i'), t j)
  rw [‚Üê hf.iSup_comp]
  -- ‚ä¢ Disjoint (t (f i')) (‚®Ü (x : Œπ') (_ : f x ‚â† f i'), t (f x))
  exact (ht i').mono_right (biSup_mono fun j' hij => mt (congr_arg f) hij)
  -- üéâ no goals
#align complete_lattice.independent.comp' CompleteLattice.Independent.comp'

theorem Independent.setIndependent_range (ht : Independent t) : SetIndependent <| range t := by
  rw [setIndependent_iff]
  -- ‚ä¢ Independent Subtype.val
  rw [‚Üê coe_comp_rangeFactorization t] at ht
  -- ‚ä¢ Independent Subtype.val
  exact ht.comp' surjective_onto_range
  -- üéâ no goals
#align complete_lattice.independent.set_independent_range CompleteLattice.Independent.setIndependent_range

theorem Independent.injective (ht : Independent t) (h_ne_bot : ‚àÄ i, t i ‚â† ‚ä•) : Injective t := by
  intro i j h
  -- ‚ä¢ i = j
  by_contra' contra
  -- ‚ä¢ False
  apply h_ne_bot j
  -- ‚ä¢ t j = ‚ä•
  suffices t j ‚â§ ‚®Ü (k) (_ : k ‚â† i), t k by
    replace ht := (ht i).mono_right this
    rwa [h, disjoint_self] at ht
  replace contra : j ‚â† i
  -- ‚ä¢ j ‚â† i
  ¬∑ exact Ne.symm contra
    -- üéâ no goals
  -- Porting note: needs explicit `f`
  exact @le_iSup‚ÇÇ _ _ _ _ (fun x _ => t x) j contra
  -- üéâ no goals
#align complete_lattice.independent.injective CompleteLattice.Independent.injective

theorem independent_pair {i j : Œπ} (hij : i ‚â† j) (huniv : ‚àÄ k, k = i ‚à® k = j) :
    Independent t ‚Üî Disjoint (t i) (t j) := by
  constructor
  -- ‚ä¢ Independent t ‚Üí Disjoint (t i) (t j)
  ¬∑ exact fun h => h.pairwiseDisjoint hij
    -- üéâ no goals
  ¬∑ rintro h k
    -- ‚ä¢ Disjoint (t k) (‚®Ü (j : Œπ) (_ : j ‚â† k), t j)
    obtain rfl | rfl := huniv k
    -- ‚ä¢ Disjoint (t k) (‚®Ü (j : Œπ) (_ : j ‚â† k), t j)
    ¬∑ refine' h.mono_right (iSup_le fun i => iSup_le fun hi => Eq.le _)
      -- ‚ä¢ t i = t j
      rw [(huniv i).resolve_left hi]
      -- üéâ no goals
    ¬∑ refine' h.symm.mono_right (iSup_le fun j => iSup_le fun hj => Eq.le _)
      -- ‚ä¢ t j = t i
      rw [(huniv j).resolve_right hj]
      -- üéâ no goals
#align complete_lattice.independent_pair CompleteLattice.independent_pair

/-- Composing an independent indexed family with an order isomorphism on the elements results in
another independent indexed family. -/
theorem Independent.map_orderIso {Œπ : Sort*} {Œ± Œ≤ : Type*} [CompleteLattice Œ±]
    [CompleteLattice Œ≤] (f : Œ± ‚âÉo Œ≤) {a : Œπ ‚Üí Œ±} (ha : Independent a) : Independent (f ‚àò a) :=
  fun i => ((ha i).map_orderIso f).mono_right (f.monotone.le_map_iSup‚ÇÇ _)
#align complete_lattice.independent.map_order_iso CompleteLattice.Independent.map_orderIso

@[simp]
theorem independent_map_orderIso_iff {Œπ : Sort*} {Œ± Œ≤ : Type*} [CompleteLattice Œ±]
    [CompleteLattice Œ≤] (f : Œ± ‚âÉo Œ≤) {a : Œπ ‚Üí Œ±} : Independent (f ‚àò a) ‚Üî Independent a :=
  ‚ü®fun h =>
    have hf : f.symm ‚àò f ‚àò a = a := congr_arg (¬∑ ‚àò a) f.left_inv.comp_eq_id
    hf ‚ñ∏ h.map_orderIso f.symm,
    fun h => h.map_orderIso f‚ü©
#align complete_lattice.independent_map_order_iso_iff CompleteLattice.independent_map_orderIso_iff

/-- If the elements of a set are independent, then any element is disjoint from the `iSup` of some
subset of the rest. -/
theorem Independent.disjoint_biSup {Œπ : Type*} {Œ± : Type*} [CompleteLattice Œ±] {t : Œπ ‚Üí Œ±}
    (ht : Independent t) {x : Œπ} {y : Set Œπ} (hx : x ‚àâ y) : Disjoint (t x) (‚®Ü i ‚àà y, t i) :=
  Disjoint.mono_right (biSup_mono fun _ hi => (ne_of_mem_of_not_mem hi hx : _)) (ht x)
#align complete_lattice.independent.disjoint_bsupr CompleteLattice.Independent.disjoint_biSup

end CompleteLattice

theorem CompleteLattice.independent_iff_supIndep [CompleteLattice Œ±] {s : Finset Œπ} {f : Œπ ‚Üí Œ±} :
    CompleteLattice.Independent (f ‚àò ((‚Üë) : s ‚Üí Œπ)) ‚Üî s.SupIndep f := by
  classical
    rw [Finset.supIndep_iff_disjoint_erase]
    refine' Subtype.forall.trans (forall‚ÇÇ_congr fun a b => _)
    rw [Finset.sup_eq_iSup]
    congr! 1
    refine' iSup_subtype.trans _
    congr! 1
    simp [iSup_and, @iSup_comm _ (_ ‚àà s)]
#align complete_lattice.independent_iff_sup_indep CompleteLattice.independent_iff_supIndep

alias ‚ü®CompleteLattice.Independent.supIndep, Finset.SupIndep.independent‚ü© :=
  CompleteLattice.independent_iff_supIndep
#align complete_lattice.independent.sup_indep CompleteLattice.Independent.supIndep
#align finset.sup_indep.independent Finset.SupIndep.independent

/-- A variant of `CompleteLattice.independent_iff_supIndep` for `Fintype`s. -/
theorem CompleteLattice.independent_iff_supIndep_univ [CompleteLattice Œ±] [Fintype Œπ] {f : Œπ ‚Üí Œ±} :
    CompleteLattice.Independent f ‚Üî Finset.univ.SupIndep f := by
  classical
    simp [Finset.supIndep_iff_disjoint_erase, CompleteLattice.Independent, Finset.sup_eq_iSup]
#align complete_lattice.independent_iff_sup_indep_univ CompleteLattice.independent_iff_supIndep_univ

alias ‚ü®CompleteLattice.Independent.sup_indep_univ, Finset.SupIndep.independent_of_univ‚ü© :=
  CompleteLattice.independent_iff_supIndep_univ
#align complete_lattice.independent.sup_indep_univ CompleteLattice.Independent.sup_indep_univ
#align finset.sup_indep.independent_of_univ Finset.SupIndep.independent_of_univ

section Frame

namespace CompleteLattice

variable [Order.Frame Œ±]

theorem setIndependent_iff_pairwiseDisjoint {s : Set Œ±} :
    SetIndependent s ‚Üî s.PairwiseDisjoint id :=
  ‚ü®SetIndependent.pairwiseDisjoint, fun hs _ hi =>
    disjoint_sSup_iff.2 fun _ hj => hs hi hj.1 <| Ne.symm hj.2‚ü©
#align complete_lattice.set_independent_iff_pairwise_disjoint CompleteLattice.setIndependent_iff_pairwiseDisjoint

alias ‚ü®_, _root_.Set.PairwiseDisjoint.setIndependent‚ü© := setIndependent_iff_pairwiseDisjoint
#align set.pairwise_disjoint.set_independent Set.PairwiseDisjoint.setIndependent

theorem independent_iff_pairwiseDisjoint {f : Œπ ‚Üí Œ±} : Independent f ‚Üî Pairwise (Disjoint on f) :=
  ‚ü®Independent.pairwiseDisjoint, fun hs _ =>
    disjoint_iSup_iff.2 fun _ => disjoint_iSup_iff.2 fun hij => hs hij.symm‚ü©
#align complete_lattice.independent_iff_pairwise_disjoint CompleteLattice.independent_iff_pairwiseDisjoint

end CompleteLattice

end Frame
