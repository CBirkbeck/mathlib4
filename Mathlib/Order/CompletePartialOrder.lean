/-
Copyright (c) 2023 Christopher Hoskin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Christopher Hoskin
-/
import Mathlib.Data.Finset.Lattice
import Mathlib.Order.OmegaCompletePartialOrder

/-!
# Complete Partial Orders

This file begins by showing that each set `s` in a join-semilattice generates a set
`directedClosure s` such that:
* `subset_directedClosure`: `s` is a subset of `directedClosure s`
* `directedOn_directedClosure`: `directedClosure s` is directed
* `isLUB_directedClosure`: `u` is the least upper bound of `s` if and only if it is the least upper
  bound of `directedClosure s`

It follows that if every directed set in a join-semilattice has a least upper bound then the join is
complete.

The second part of this file considers complete partial orders (sometimes called directedly complete
partial orders). These are partial orders for which every directed set has a least upper bound.

## Main declarations

* `directedClosure`: Directed set generated by a given set.
* `CompletePartialOrder`: Typeclass for (directly) complete partial orders.

## References

- [B. A. Davey and H. A. Priestley, Introduction to lattices and order][davey_priestley]

## Tags

complete partial order, directedly complete partial order
-/

namespace Finset
variable {α β : Type*} [SemilatticeSup α]

-- This will come from https://github.com/leanprover-community/mathlib/pull/18989
lemma sup'_union [DecidableEq β] {s₁ s₂ : Finset β} (h₁ : s₁.Nonempty) (h₂ : s₂.Nonempty)
  (f : β → α) :
  (s₁ ∪ s₂).sup' (h₁.mono $ subset_union_left _ _) f = s₁.sup' h₁ f ⊔ s₂.sup' h₂ f :=
eq_of_forall_ge_iff $ λ a ↦ by simp [or_imp, forall_and]

end Finset

open Finset

variable {ι : Sort*} {α β : Type*}

section SemilatticeSup
variable [SemilatticeSup α] {s : Set α} {a : α}

/-- Every set in a join-semilattice generates a directed set. Note that this is **not** a closure
operator because directness is not preserved under intersections. -/
def directedClosure (s : Set α) : Set α :=
  {a | ∃ (t : Finset α) (ht : t.Nonempty), ↑t ⊆ s ∧ t.sup' ht id = a}

@[simp] lemma subset_directedClosure : s ⊆ directedClosure s :=
λ a ha ↦ ⟨{a}, singleton_nonempty _, by simpa⟩

@[simp] lemma directedOn_directedClosure (s : Set α) : DirectedOn (. ≤ .) (directedClosure s) := by
  classical
  rintro _ ⟨t, ht, hts, rfl⟩ _ ⟨u, hu, hus, rfl⟩
  refine' ⟨_, ⟨_, ht.mono $ subset_union_left _ _, _, sup'_union ht hu _⟩, le_sup_left, le_sup_right⟩
  rw [coe_union]
  exact Set.union_subset hts hus

@[simp] lemma upperBounds_directedClosure (s : Set α) :
  upperBounds (directedClosure s) = upperBounds s :=
(upperBounds_mono_set subset_directedClosure).antisymm $ by
  rintro a ha _ ⟨t, ht, hts, rfl⟩
  exact sup'_le _ _ λ b hb ↦ ha $ hts hb

@[simp] lemma isLUB_directedClosure : IsLUB (directedClosure s) a ↔ IsLUB s a := by simp [IsLUB]

/--
A join-semilattice where every directed set has a least upper bound is automatically complete.
-/
def SemilatticeSup.toCompleteSemilatticeSup (sSup : Set α → α)
    (h : ∀ d, DirectedOn (. ≤ .) d → IsLUB d (sSup d)) : CompleteSemilatticeSup α where
  sSup := fun s => sSup (directedClosure s)
  le_sSup s a ha := (h _ $ directedOn_directedClosure s).1 $ subset_directedClosure ha
  sSup_le s a ha := (isLUB_le_iff $ h _ $ directedOn_directedClosure s).2 $ by
    rwa [upperBounds_directedClosure]

end SemilatticeSup

section CompletePartialOrder

/--
Complete partial orders are partial orders where every directed set has a least upper bound.
-/
class CompletePartialOrder (α : Type*) extends PartialOrder α, SupSet α where
  /-- For each directed set `d`, `sSup d` is the least upper bound of `d`. -/
  lubOfDirected : ∀ d, DirectedOn (. ≤ .) d → IsLUB d (sSup d)

variable [CompletePartialOrder α] [Preorder β] {f : ι → α} {d : Set α} {a : α}

protected lemma DirectedOn.isLUB_sSup : DirectedOn (. ≤ .) d → IsLUB d (sSup d) :=
CompletePartialOrder.lubOfDirected _

protected lemma DirectedOn.le_sSup (hd : DirectedOn (. ≤ .) d) (ha : a ∈ d) : a ≤ sSup d :=
hd.isLUB_sSup.1 ha

protected lemma DirectedOn.sSup_le (hd : DirectedOn (. ≤ .) d) (ha : ∀ b ∈ d, b ≤ a) : sSup d ≤ a :=
hd.isLUB_sSup.2 ha

protected lemma Directed.le_iSup (hf : Directed (. ≤ .) f) (i : ι) : f i ≤ ⨆ j, f j :=
hf.directedOn_range.le_sSup $ Set.mem_range_self _

protected lemma Directed.iSup_le (hf : Directed (. ≤ .) f) (ha : ∀ i, f i ≤ a) :  ⨆ i, f i ≤ a :=
hf.directedOn_range.sSup_le $ Set.forall_range_iff.2 ha

--TODO: We could mimic more `sSup`/`iSup` lemmas

/-- Scott-continuity takes on a simpler form in complete partial orders. -/
lemma CompletePartialOrder.ScottContinuous {f : α → β} :
  ScottContinuous f ↔
    ∀ ⦃d : Set α⦄, d.Nonempty → DirectedOn (. ≤ .) d → IsLUB (f '' d) (f (sSup d)) := by
  refine' ⟨λ h d hd₁ hd₂ ↦ h hd₁ hd₂ hd₂.isLUB_sSup, λ h d hne hd a hda ↦ _⟩
  rw [hda.unique hd.isLUB_sSup]
  exact h hne hd

open OmegaCompletePartialOrder

/-- A complete partial order is an ω-complete partial order. -/
instance CompletePartialOrder.toOmegaCompletePartialOrder : OmegaCompletePartialOrder α where
  ωSup c := ⨆ n, c n
  le_ωSup c := c.directed.le_iSup
  ωSup_le c _ := c.directed.iSup_le

end CompletePartialOrder

/-- A complete lattice is a complete partial order. -/
instance CompleteLattice.toCompletePartialOrder [CompleteLattice α] : CompletePartialOrder α where
  sSup := sSup
  lubOfDirected _ _ := isLUB_sSup _
