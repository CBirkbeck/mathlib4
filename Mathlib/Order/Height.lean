/-
Copyright (c) 2022 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import Mathlib.Data.ENat.Lattice
import Mathlib.Order.OrderIsoNat
import Mathlib.Tactic.TFAE

#align_import order.height from "leanprover-community/mathlib"@"bf27744463e9620ca4e4ebe951fe83530ae6949b"

/-!

# Maximal length of chains

This file contains lemmas to work with the maximal length of strictly descending finite
sequences (chains) in a partial order.

## Main definition

- `Set.subchain`: The set of strictly ascending lists of `Œ±` contained in a `Set Œ±`.
- `Set.chainHeight`: The maximal length of a strictly ascending sequence in a partial order.
This is defined as the maximum of the lengths of `Set.subchain`s, valued in `‚Ñï‚àû`.

## Main results

- `Set.exists_chain_of_le_chainHeight`: For each `n : ‚Ñï` such that `n ‚â§ s.chainHeight`, there
  exists `s.subchain` of length `n`.
- `Set.chainHeight_mono`: If `s ‚äÜ t` then `s.chainHeight ‚â§ t.chainHeight`.
- `Set.chainHeight_image`: If `f` is an order embedding, then
  `(f '' s).chainHeight = s.chainHeight`.
- `Set.chainHeight_insert_of_forall_lt`: If `‚àÄ y ‚àà s, y < x`, then
  `(insert x s).chainHeight = s.chainHeight + 1`.
- `Set.chainHeight_insert_of_forall_gt`: If `‚àÄ y ‚àà s, x < y`, then
  `(insert x s).chainHeight = s.chainHeight + 1`.
- `Set.chainHeight_union_eq`: If `‚àÄ x ‚àà s, ‚àÄ y ‚àà t, s ‚â§ t`, then
  `(s ‚à™ t).chainHeight = s.chainHeight + t.chainHeight`.
- `Set.wellFoundedGT_of_chainHeight_ne_top`:
  If `s` has finite height, then `>` is well-founded on `s`.
- `Set.wellFoundedLT_of_chainHeight_ne_top`:
  If `s` has finite height, then `<` is well-founded on `s`.

-/


open List hiding le_antisymm
open OrderDual

universe u v

variable {Œ± Œ≤ : Type*}

namespace Set

section LT

variable [LT Œ±] [LT Œ≤] (s t : Set Œ±)

/-- The set of strictly ascending lists of `Œ±` contained in a `Set Œ±`. -/
def subchain : Set (List Œ±) :=
  { l | l.Chain' (¬∑ < ¬∑) ‚àß ‚àÄ i ‚àà l, i ‚àà s }
#align set.subchain Set.subchain

@[simp] -- porting note: new `simp`
theorem nil_mem_subchain : [] ‚àà s.subchain := ‚ü®trivial, fun _ ‚Ü¶ fun.‚ü©
#align set.nil_mem_subchain Set.nil_mem_subchain

variable {s} {l : List Œ±} {a : Œ±}

theorem cons_mem_subchain_iff :
    (a::l) ‚àà s.subchain ‚Üî a ‚àà s ‚àß l ‚àà s.subchain ‚àß ‚àÄ b ‚àà l.head?, a < b := by
  simp only [subchain, mem_setOf_eq, forall_mem_cons, chain'_cons', and_left_comm, and_comm,
    and_assoc]
#align set.cons_mem_subchain_iff Set.cons_mem_subchain_iff

@[simp] -- porting note: new lemma + `simp`
theorem singleton_mem_subchain_iff : [a] ‚àà s.subchain ‚Üî a ‚àà s := by simp [cons_mem_subchain_iff]
                                                                    -- üéâ no goals

instance : Nonempty s.subchain :=
  ‚ü®‚ü®[], s.nil_mem_subchain‚ü©‚ü©

variable (s)

/-- The maximal length of a strictly ascending sequence in a partial order. -/
noncomputable def chainHeight : ‚Ñï‚àû :=
  ‚®Ü l ‚àà s.subchain, length l
#align set.chain_height Set.chainHeight

theorem chainHeight_eq_iSup_subtype : s.chainHeight = ‚®Ü l : s.subchain, ‚Üël.1.length :=
  iSup_subtype'
#align set.chain_height_eq_supr_subtype Set.chainHeight_eq_iSup_subtype

theorem exists_chain_of_le_chainHeight {n : ‚Ñï} (hn : ‚Üën ‚â§ s.chainHeight) :
    ‚àÉ l ‚àà s.subchain, length l = n := by
  cases' (le_top : s.chainHeight ‚â§ ‚ä§).eq_or_lt with ha ha <;>
  -- ‚ä¢ ‚àÉ l, l ‚àà subchain s ‚àß length l = n
    rw [chainHeight_eq_iSup_subtype] at ha
    -- ‚ä¢ ‚àÉ l, l ‚àà subchain s ‚àß length l = n
    -- ‚ä¢ ‚àÉ l, l ‚àà subchain s ‚àß length l = n
  ¬∑ obtain ‚ü®_, ‚ü®‚ü®l, h‚ÇÅ, h‚ÇÇ‚ü©, rfl‚ü©, h‚ÇÉ‚ü© :=
      not_bddAbove_iff'.mp ((WithTop.iSup_coe_eq_top _).mp ha) n
    exact ‚ü®l.take n, ‚ü®h‚ÇÅ.take _, fun x h ‚Ü¶ h‚ÇÇ _ <| take_subset _ _ h‚ü©,
      (l.length_take n).trans <| min_eq_left <| le_of_not_ge h‚ÇÉ‚ü©
  ¬∑ rw [ENat.iSup_coe_lt_top] at ha
    -- ‚ä¢ ‚àÉ l, l ‚àà subchain s ‚àß length l = n
    obtain ‚ü®‚ü®l, h‚ÇÅ, h‚ÇÇ‚ü©, e : l.length = _‚ü© := Nat.sSup_mem (Set.range_nonempty _) ha
    -- ‚ä¢ ‚àÉ l, l ‚àà subchain s ‚àß length l = n
    refine'
      ‚ü®l.take n, ‚ü®h‚ÇÅ.take _, fun x h ‚Ü¶ h‚ÇÇ _ <| take_subset _ _ h‚ü©,
        (l.length_take n).trans <| min_eq_left <| _‚ü©
    rwa [e, ‚Üê Nat.cast_le (Œ± := ‚Ñï‚àû), sSup_range, ENat.coe_iSup ha, ‚Üê chainHeight_eq_iSup_subtype]
    -- üéâ no goals
#align set.exists_chain_of_le_chain_height Set.exists_chain_of_le_chainHeight

theorem le_chainHeight_TFAE (n : ‚Ñï) :
    TFAE [‚Üën ‚â§ s.chainHeight, ‚àÉ l ‚àà s.subchain, length l = n, ‚àÉ l ‚àà s.subchain, n ‚â§ length l] := by
  tfae_have 1 ‚Üí 2; ¬∑ exact s.exists_chain_of_le_chainHeight
  -- ‚ä¢ ‚Üën ‚â§ chainHeight s ‚Üí ‚àÉ l, l ‚àà subchain s ‚àß length l = n
                     -- üéâ no goals
  tfae_have 2 ‚Üí 3; ¬∑ rintro ‚ü®l, hls, he‚ü©; exact ‚ü®l, hls, he.ge‚ü©
  -- ‚ä¢ (‚àÉ l, l ‚àà subchain s ‚àß length l = n) ‚Üí ‚àÉ l, l ‚àà subchain s ‚àß n ‚â§ length l
                     -- ‚ä¢ ‚àÉ l, l ‚àà subchain s ‚àß n ‚â§ length l
                                          -- üéâ no goals
  tfae_have 3 ‚Üí 1; ¬∑ rintro ‚ü®l, hs, hn‚ü©; exact le_iSup‚ÇÇ_of_le l hs (WithTop.coe_le_coe.2 hn)
  -- ‚ä¢ (‚àÉ l, l ‚àà subchain s ‚àß n ‚â§ length l) ‚Üí ‚Üën ‚â§ chainHeight s
                     -- ‚ä¢ ‚Üën ‚â§ chainHeight s
                                         -- üéâ no goals
  tfae_finish
  -- üéâ no goals
#align set.le_chain_height_tfae Set.le_chainHeight_TFAE

variable {s t}

theorem le_chainHeight_iff {n : ‚Ñï} : ‚Üën ‚â§ s.chainHeight ‚Üî ‚àÉ l ‚àà s.subchain, length l = n :=
  (le_chainHeight_TFAE s n).out 0 1
#align set.le_chain_height_iff Set.le_chainHeight_iff

theorem length_le_chainHeight_of_mem_subchain (hl : l ‚àà s.subchain) : ‚Üël.length ‚â§ s.chainHeight :=
  le_chainHeight_iff.mpr ‚ü®l, hl, rfl‚ü©
#align set.length_le_chain_height_of_mem_subchain Set.length_le_chainHeight_of_mem_subchain

theorem chainHeight_eq_top_iff : s.chainHeight = ‚ä§ ‚Üî ‚àÄ n, ‚àÉ l ‚àà s.subchain, length l = n := by
  refine' ‚ü®fun h n ‚Ü¶ le_chainHeight_iff.1 (le_top.trans_eq h.symm), fun h ‚Ü¶ _‚ü©
  -- ‚ä¢ chainHeight s = ‚ä§
  contrapose! h; obtain ‚ü®n, hn‚ü© := WithTop.ne_top_iff_exists.1 h
  -- ‚ä¢ ‚àÉ n, ‚àÄ (l : List Œ±), l ‚àà subchain s ‚Üí length l ‚â† n
                 -- ‚ä¢ ‚àÉ n, ‚àÄ (l : List Œ±), l ‚àà subchain s ‚Üí length l ‚â† n
  exact ‚ü®n + 1, fun l hs ‚Ü¶ (Nat.lt_succ_iff.2 <| Nat.cast_le.1 <|
    (length_le_chainHeight_of_mem_subchain hs).trans_eq hn.symm).ne‚ü©
#align set.chain_height_eq_top_iff Set.chainHeight_eq_top_iff

@[simp]
theorem one_le_chainHeight_iff : 1 ‚â§ s.chainHeight ‚Üî s.Nonempty := by
  rw [‚Üê Nat.cast_one, Set.le_chainHeight_iff]
  -- ‚ä¢ (‚àÉ l, l ‚àà subchain s ‚àß length l = 1) ‚Üî Set.Nonempty s
  simp only [length_eq_one, @and_comm (_ ‚àà _), @eq_comm _ _ [_], exists_exists_eq_and,
    singleton_mem_subchain_iff, Set.Nonempty]
#align set.one_le_chain_height_iff Set.one_le_chainHeight_iff

@[simp]
theorem chainHeight_eq_zero_iff : s.chainHeight = 0 ‚Üî s = ‚àÖ := by
  rw [‚Üê not_iff_not, ‚Üê Ne.def, ‚Üê ENat.one_le_iff_ne_zero, one_le_chainHeight_iff,
    nonempty_iff_ne_empty]
#align set.chain_height_eq_zero_iff Set.chainHeight_eq_zero_iff

@[simp]
theorem chainHeight_empty : (‚àÖ : Set Œ±).chainHeight = 0 :=
  chainHeight_eq_zero_iff.2 rfl
#align set.chain_height_empty Set.chainHeight_empty

@[simp]
theorem chainHeight_of_isEmpty [IsEmpty Œ±] : s.chainHeight = 0 :=
  chainHeight_eq_zero_iff.mpr (Subsingleton.elim _ _)
#align set.chain_height_of_is_empty Set.chainHeight_of_isEmpty

theorem le_chainHeight_add_nat_iff {n m : ‚Ñï} :
    ‚Üën ‚â§ s.chainHeight + m ‚Üî ‚àÉ l ‚àà s.subchain, n ‚â§ length l + m := by
  simp_rw [‚Üê tsub_le_iff_right, ‚Üê ENat.coe_sub, (le_chainHeight_TFAE s (n - m)).out 0 2]
  -- üéâ no goals
#align set.le_chain_height_add_nat_iff Set.le_chainHeight_add_nat_iff

theorem chainHeight_add_le_chainHeight_add (s : Set Œ±) (t : Set Œ≤) (n m : ‚Ñï) :
    s.chainHeight + n ‚â§ t.chainHeight + m ‚Üî
      ‚àÄ l ‚àà s.subchain, ‚àÉ l' ‚àà t.subchain, length l + n ‚â§ length l' + m := by
  refine'
    ‚ü®fun e l h ‚Ü¶
      le_chainHeight_add_nat_iff.1
        ((add_le_add_right (length_le_chainHeight_of_mem_subchain h) _).trans e),
      fun H ‚Ü¶ _‚ü©
  by_cases s.chainHeight = ‚ä§
  -- ‚ä¢ chainHeight s + ‚Üën ‚â§ chainHeight t + ‚Üëm
  -- ‚ä¢ chainHeight s + ‚Üën ‚â§ chainHeight t + ‚Üëm
  ¬∑ suffices t.chainHeight = ‚ä§ by
      rw [this, top_add]
      exact le_top
    rw [chainHeight_eq_top_iff] at h ‚ä¢
    -- ‚ä¢ ‚àÄ (n : ‚Ñï), ‚àÉ l, l ‚àà subchain t ‚àß length l = n
    intro k
    -- ‚ä¢ ‚àÉ l, l ‚àà subchain t ‚àß length l = k
    have := (le_chainHeight_TFAE t k).out 1 2
    -- ‚ä¢ ‚àÉ l, l ‚àà subchain t ‚àß length l = k
    rw [this]
    -- ‚ä¢ ‚àÉ l, l ‚àà subchain t ‚àß k ‚â§ length l
    obtain ‚ü®l, hs, hl‚ü© := h (k + m)
    -- ‚ä¢ ‚àÉ l, l ‚àà subchain t ‚àß k ‚â§ length l
    obtain ‚ü®l', ht, hl'‚ü© := H l hs
    -- ‚ä¢ ‚àÉ l, l ‚àà subchain t ‚àß k ‚â§ length l
    exact ‚ü®l', ht, (add_le_add_iff_right m).1 <| _root_.trans (hl.symm.trans_le le_self_add) hl'‚ü©
    -- üéâ no goals
  ¬∑ obtain ‚ü®k, hk‚ü© := WithTop.ne_top_iff_exists.1 h
    -- ‚ä¢ chainHeight s + ‚Üën ‚â§ chainHeight t + ‚Üëm
    obtain ‚ü®l, hs, hl‚ü© := le_chainHeight_iff.1 hk.le
    -- ‚ä¢ chainHeight s + ‚Üën ‚â§ chainHeight t + ‚Üëm
    rw [‚Üê hk, ‚Üê hl]
    -- ‚ä¢ ‚Üë(length l) + ‚Üën ‚â§ chainHeight t + ‚Üëm
    exact le_chainHeight_add_nat_iff.2 (H l hs)
    -- üéâ no goals
#align set.chain_height_add_le_chain_height_add Set.chainHeight_add_le_chainHeight_add

theorem chainHeight_le_chainHeight_TFAE (s : Set Œ±) (t : Set Œ≤) :
    TFAE [s.chainHeight ‚â§ t.chainHeight, ‚àÄ l ‚àà s.subchain, ‚àÉ l' ‚àà t.subchain, length l = length l',
      ‚àÄ l ‚àà s.subchain, ‚àÉ l' ‚àà t.subchain, length l ‚â§ length l'] := by
  tfae_have 1 ‚Üî 3
  -- ‚ä¢ chainHeight s ‚â§ chainHeight t ‚Üî ‚àÄ (l : List Œ±), l ‚àà subchain s ‚Üí ‚àÉ l', l' ‚àà  ‚Ä¶
  ¬∑ convert ‚Üê chainHeight_add_le_chainHeight_add s t 0 0 <;> apply add_zero
    -- ‚ä¢ chainHeight s + ‚Üë0 = chainHeight s
                                                             -- üéâ no goals
                                                             -- üéâ no goals
  tfae_have 2 ‚Üî 3
  -- ‚ä¢ (‚àÄ (l : List Œ±), l ‚àà subchain s ‚Üí ‚àÉ l', l' ‚àà subchain t ‚àß length l = length  ‚Ä¶
  ¬∑ refine' forall‚ÇÇ_congr fun l hl ‚Ü¶ _
    -- ‚ä¢ (‚àÉ l', l' ‚àà subchain t ‚àß length l = length l') ‚Üî ‚àÉ l', l' ‚àà subchain t ‚àß len ‚Ä¶
    simp_rw [‚Üê (le_chainHeight_TFAE t l.length).out 1 2, eq_comm]
    -- üéâ no goals
  tfae_finish
  -- üéâ no goals
#align set.chain_height_le_chain_height_tfae Set.chainHeight_le_chainHeight_TFAE

theorem chainHeight_le_chainHeight_iff {t : Set Œ≤} :
    s.chainHeight ‚â§ t.chainHeight ‚Üî ‚àÄ l ‚àà s.subchain, ‚àÉ l' ‚àà t.subchain, length l = length l' :=
  (chainHeight_le_chainHeight_TFAE s t).out 0 1
#align set.chain_height_le_chain_height_iff Set.chainHeight_le_chainHeight_iff

theorem chainHeight_le_chainHeight_iff_le {t : Set Œ≤} :
    s.chainHeight ‚â§ t.chainHeight ‚Üî ‚àÄ l ‚àà s.subchain, ‚àÉ l' ‚àà t.subchain, length l ‚â§ length l' :=
  (chainHeight_le_chainHeight_TFAE s t).out 0 2
#align set.chain_height_le_chain_height_iff_le Set.chainHeight_le_chainHeight_iff_le

theorem chainHeight_mono (h : s ‚äÜ t) : s.chainHeight ‚â§ t.chainHeight :=
  chainHeight_le_chainHeight_iff.2 fun l hl ‚Ü¶ ‚ü®l, ‚ü®hl.1, fun i hi ‚Ü¶ h <| hl.2 i hi‚ü©, rfl‚ü©
#align set.chain_height_mono Set.chainHeight_mono

theorem chainHeight_image (f : Œ± ‚Üí Œ≤) (hf : ‚àÄ {x y}, x < y ‚Üî f x < f y) (s : Set Œ±) :
    (f '' s).chainHeight = s.chainHeight := by
  apply le_antisymm <;> rw [chainHeight_le_chainHeight_iff]
  -- ‚ä¢ chainHeight (f '' s) ‚â§ chainHeight s
                        -- ‚ä¢ ‚àÄ (l : List Œ≤), l ‚àà subchain (f '' s) ‚Üí ‚àÉ l', l' ‚àà subchain s ‚àß length l = l ‚Ä¶
                        -- ‚ä¢ ‚àÄ (l : List Œ±), l ‚àà subchain s ‚Üí ‚àÉ l', l' ‚àà subchain (f '' s) ‚àß length l = l ‚Ä¶
  ¬∑ suffices ‚àÄ l ‚àà (f '' s).subchain, ‚àÉ l' ‚àà s.subchain, map f l' = l by
      intro l hl
      obtain ‚ü®l', h‚ÇÅ, rfl‚ü© := this l hl
      exact ‚ü®l', h‚ÇÅ, length_map _ _‚ü©
    intro l
    -- ‚ä¢ l ‚àà subchain (f '' s) ‚Üí ‚àÉ l', l' ‚àà subchain s ‚àß map f l' = l
    induction' l with x xs hx
    -- ‚ä¢ [] ‚àà subchain (f '' s) ‚Üí ‚àÉ l', l' ‚àà subchain s ‚àß map f l' = []
    ¬∑ exact fun _ ‚Ü¶ ‚ü®nil, ‚ü®trivial, fun x h ‚Ü¶ (not_mem_nil x h).elim‚ü©, rfl‚ü©
      -- üéâ no goals
    ¬∑ intro h
      -- ‚ä¢ ‚àÉ l', l' ‚àà subchain s ‚àß map f l' = x :: xs
      rw [cons_mem_subchain_iff] at h
      -- ‚ä¢ ‚àÉ l', l' ‚àà subchain s ‚àß map f l' = x :: xs
      obtain ‚ü®‚ü®x, hx', rfl‚ü©, h‚ÇÅ, h‚ÇÇ‚ü© := h
      -- ‚ä¢ ‚àÉ l', l' ‚àà subchain s ‚àß map f l' = f x :: xs
      obtain ‚ü®l', h‚ÇÉ, rfl‚ü© := hx h‚ÇÅ
      -- ‚ä¢ ‚àÉ l'_1, l'_1 ‚àà subchain s ‚àß map f l'_1 = f x :: map f l'
      refine' ‚ü®x::l', Set.cons_mem_subchain_iff.mpr ‚ü®hx', h‚ÇÉ, _‚ü©, rfl‚ü©
      -- ‚ä¢ ‚àÄ (b : Œ±), b ‚àà head? l' ‚Üí x < b
      cases l'
      -- ‚ä¢ ‚àÄ (b : Œ±), b ‚àà head? [] ‚Üí x < b
      ¬∑ simp
        -- üéâ no goals
      ¬∑ simpa [‚Üê hf] using h‚ÇÇ
        -- üéâ no goals
  ¬∑ intro l hl
    -- ‚ä¢ ‚àÉ l', l' ‚àà subchain (f '' s) ‚àß length l = length l'
    refine' ‚ü®l.map f, ‚ü®_, _‚ü©, _‚ü©
    ¬∑ simp_rw [chain'_map, ‚Üê hf]
      -- ‚ä¢ Chain' (fun a b => a < b) l
      exact hl.1
      -- üéâ no goals
    ¬∑ intro _ e
      -- ‚ä¢ i‚úù ‚àà f '' s
      obtain ‚ü®a, ha, rfl‚ü© := mem_map.mp e
      -- ‚ä¢ f a ‚àà f '' s
      exact Set.mem_image_of_mem _ (hl.2 _ ha)
      -- üéâ no goals
    ¬∑ rw [length_map]
      -- üéâ no goals
#align set.chain_height_image Set.chainHeight_image

variable (s)

@[simp]
theorem chainHeight_dual : (ofDual ‚Åª¬π' s).chainHeight = s.chainHeight := by
  apply le_antisymm <;>
  -- ‚ä¢ chainHeight (‚ÜëofDual ‚Åª¬π' s) ‚â§ chainHeight s
  ¬∑ rw [chainHeight_le_chainHeight_iff]
    -- ‚ä¢ ‚àÄ (l : List Œ±·µí·µà), l ‚àà subchain (‚ÜëofDual ‚Åª¬π' s) ‚Üí ‚àÉ l', l' ‚àà subchain s ‚àß len ‚Ä¶
    -- ‚ä¢ ‚àÄ (l : List Œ±), l ‚àà subchain s ‚Üí ‚àÉ l', l' ‚àà subchain (‚ÜëofDual ‚Åª¬π' s) ‚àß lengt ‚Ä¶
    -- ‚ä¢ ‚àÉ l', l' ‚àà subchain s ‚àß length l = length l'
    rintro l ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
    -- ‚ä¢ ‚àÉ l', l' ‚àà subchain (‚ÜëofDual ‚Åª¬π' s) ‚àß length l = length l'
    exact ‚ü®l.reverse, ‚ü®chain'_reverse.mpr h‚ÇÅ, fun i h ‚Ü¶ h‚ÇÇ i (mem_reverse.mp h)‚ü©,
      (length_reverse _).symm‚ü©
#align set.chain_height_dual Set.chainHeight_dual

end LT

section Preorder

variable (s t : Set Œ±) [Preorder Œ±]

theorem chainHeight_eq_iSup_Ici : s.chainHeight = ‚®Ü i ‚àà s, (s ‚à© Set.Ici i).chainHeight := by
  apply le_antisymm
  -- ‚ä¢ chainHeight s ‚â§ ‚®Ü (i : Œ±) (_ : i ‚àà s), chainHeight (s ‚à© Ici i)
  ¬∑ refine' iSup‚ÇÇ_le _
    -- ‚ä¢ ‚àÄ (i : List Œ±), i ‚àà subchain s ‚Üí ‚Üë(length i) ‚â§ ‚®Ü (i : Œ±) (_ : i ‚àà s), chainH ‚Ä¶
    rintro (_ | ‚ü®x, xs‚ü©) h
    -- ‚ä¢ ‚Üë(length []) ‚â§ ‚®Ü (i : Œ±) (_ : i ‚àà s), chainHeight (s ‚à© Ici i)
    ¬∑ exact zero_le _
      -- üéâ no goals
    ¬∑ apply le_trans _ (le_iSup‚ÇÇ x (cons_mem_subchain_iff.mp h).1)
      -- ‚ä¢ ‚Üë(length (x :: xs)) ‚â§ chainHeight (s ‚à© Ici x)
      apply length_le_chainHeight_of_mem_subchain
      -- ‚ä¢ x :: xs ‚àà subchain (s ‚à© Ici x)
      refine' ‚ü®h.1, fun i hi ‚Ü¶ ‚ü®h.2 i hi, _‚ü©‚ü©
      -- ‚ä¢ i ‚àà Ici x
      cases hi
      -- ‚ä¢ x ‚àà Ici x
      ¬∑ exact left_mem_Ici
        -- üéâ no goals
      rename_i hi
      -- ‚ä¢ i ‚àà Ici x
      cases' chain'_iff_pairwise.mp h.1 with _ _ h'
      -- ‚ä¢ i ‚àà Ici x
      exact (h' _ hi).le
      -- üéâ no goals
  ¬∑ exact iSup‚ÇÇ_le fun i _ ‚Ü¶ chainHeight_mono <| Set.inter_subset_left _ _
    -- üéâ no goals
#align set.chain_height_eq_supr_Ici Set.chainHeight_eq_iSup_Ici

theorem chainHeight_eq_iSup_Iic : s.chainHeight = ‚®Ü i ‚àà s, (s ‚à© Set.Iic i).chainHeight := by
  simp_rw [‚Üê chainHeight_dual (_ ‚à© _)]
  -- ‚ä¢ chainHeight s = ‚®Ü (i : Œ±) (_ : i ‚àà s), chainHeight (‚ÜëofDual ‚Åª¬π' (s ‚à© Iic i))
  rw [‚Üê chainHeight_dual, chainHeight_eq_iSup_Ici]
  -- ‚ä¢ ‚®Ü (i : Œ±·µí·µà) (_ : i ‚àà ‚ÜëofDual ‚Åª¬π' s), chainHeight (‚ÜëofDual ‚Åª¬π' s ‚à© Ici i) = ‚®Ü ‚Ä¶
  rfl
  -- üéâ no goals
#align set.chain_height_eq_supr_Iic Set.chainHeight_eq_iSup_Iic

variable {s t}

theorem chainHeight_insert_of_forall_gt (a : Œ±) (hx : ‚àÄ b ‚àà s, a < b) :
    (insert a s).chainHeight = s.chainHeight + 1 := by
  rw [‚Üê add_zero (insert a s).chainHeight]
  -- ‚ä¢ chainHeight (insert a s) + 0 = chainHeight s + 1
  change (insert a s).chainHeight + (0 : ‚Ñï) = s.chainHeight + (1 : ‚Ñï)
  -- ‚ä¢ chainHeight (insert a s) + ‚Üë0 = chainHeight s + ‚Üë1
  apply le_antisymm <;> rw [chainHeight_add_le_chainHeight_add]
  -- ‚ä¢ chainHeight (insert a s) + ‚Üë0 ‚â§ chainHeight s + ‚Üë1
                        -- ‚ä¢ ‚àÄ (l : List Œ±), l ‚àà subchain (insert a s) ‚Üí ‚àÉ l', l' ‚àà subchain s ‚àß length l ‚Ä¶
                        -- ‚ä¢ ‚àÄ (l : List Œ±), l ‚àà subchain s ‚Üí ‚àÉ l', l' ‚àà subchain (insert a s) ‚àß length l ‚Ä¶
  ¬∑ rintro (_ | ‚ü®y, ys‚ü©) h
    -- ‚ä¢ ‚àÉ l', l' ‚àà subchain s ‚àß length [] + 0 ‚â§ length l' + 1
    ¬∑ exact ‚ü®[], nil_mem_subchain _, zero_le _‚ü©
      -- üéâ no goals
    ¬∑ have h' := cons_mem_subchain_iff.mp h
      -- ‚ä¢ ‚àÉ l', l' ‚àà subchain s ‚àß length (y :: ys) + 0 ‚â§ length l' + 1
      refine' ‚ü®ys, ‚ü®h'.2.1.1, fun i hi ‚Ü¶ _‚ü©, by simp‚ü©
      -- ‚ä¢ i ‚àà s
      apply (h'.2.1.2 i hi).resolve_left
      -- ‚ä¢ ¬¨i = a
      rintro rfl
      -- ‚ä¢ False
      cases' chain'_iff_pairwise.mp h.1 with _ _ hy
      -- ‚ä¢ False
      cases' h'.1 with h' h'
      -- ‚ä¢ False
      exacts [(hy _ hi).ne h', not_le_of_gt (hy _ hi) (hx _ h').le]
      -- üéâ no goals
  ¬∑ intro l hl
    -- ‚ä¢ ‚àÉ l', l' ‚àà subchain (insert a s) ‚àß length l + 1 ‚â§ length l' + 0
    refine' ‚ü®a::l, ‚ü®_, _‚ü©, by simp‚ü©
    -- ‚ä¢ Chain' (fun x x_1 => x < x_1) (a :: l)
    ¬∑ rw [chain'_cons']
      -- ‚ä¢ (‚àÄ (y : Œ±), y ‚àà head? l ‚Üí a < y) ‚àß Chain' (fun x x_1 => x < x_1) l
      exact ‚ü®fun y hy ‚Ü¶ hx _ (hl.2 _ (mem_of_mem_head? hy)), hl.1‚ü©
      -- üéâ no goals
    ¬∑ -- Porting note: originally this was
        -- rintro x (rfl | hx)
        -- exacts [Or.inl (Set.mem_singleton x), Or.inr (hl.2 x hx)]
      -- but this fails because `List.Mem` is now an inductive prop.
      -- I couldn't work out how to drive `rcases` here but asked at
      -- https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/rcases.3F/near/347976083
      rintro x (_ | _)
      -- ‚ä¢ a ‚àà insert a s
      exacts [Or.inl (Set.mem_singleton a), Or.inr (hl.2 x ‚Äπ_‚Ä∫)]
      -- üéâ no goals
#align set.chain_height_insert_of_forall_gt Set.chainHeight_insert_of_forall_gt

theorem chainHeight_insert_of_forall_lt (a : Œ±) (ha : ‚àÄ b ‚àà s, b < a) :
    (insert a s).chainHeight = s.chainHeight + 1 := by
  rw [‚Üê chainHeight_dual, ‚Üê chainHeight_dual s]
  -- ‚ä¢ chainHeight (‚ÜëofDual ‚Åª¬π' insert a s) = chainHeight (‚ÜëofDual ‚Åª¬π' s) + 1
  exact chainHeight_insert_of_forall_gt _ ha
  -- üéâ no goals
#align set.chain_height_insert_of_forall_lt Set.chainHeight_insert_of_forall_lt

theorem chainHeight_union_le : (s ‚à™ t).chainHeight ‚â§ s.chainHeight + t.chainHeight := by
  classical
    refine' iSup‚ÇÇ_le fun l hl ‚Ü¶ _
    let l‚ÇÅ := l.filter (¬∑ ‚àà s)
    let l‚ÇÇ := l.filter (¬∑ ‚àà t)
    have hl‚ÇÅ : ‚Üël‚ÇÅ.length ‚â§ s.chainHeight := by
      apply Set.length_le_chainHeight_of_mem_subchain
      exact ‚ü®hl.1.sublist (filter_sublist _), fun i h ‚Ü¶ by simpa using (of_mem_filter h : _)‚ü©
    have hl‚ÇÇ : ‚Üël‚ÇÇ.length ‚â§ t.chainHeight := by
      apply Set.length_le_chainHeight_of_mem_subchain
      exact ‚ü®hl.1.sublist (filter_sublist _), fun i h ‚Ü¶ by simpa using (of_mem_filter h : _)‚ü©
    refine' le_trans _ (add_le_add hl‚ÇÅ hl‚ÇÇ)
    simp_rw [‚Üê Nat.cast_add, ‚Üê Multiset.coe_card, ‚Üê Multiset.card_add, ‚Üê Multiset.coe_filter]
    rw [Multiset.filter_add_filter, Multiset.filter_eq_self.mpr, Multiset.card_add, Nat.cast_add]
    exacts [le_add_right rfl.le, hl.2]
#align set.chain_height_union_le Set.chainHeight_union_le

theorem chainHeight_union_eq (s t : Set Œ±) (H : ‚àÄ a ‚àà s, ‚àÄ b ‚àà t, a < b) :
    (s ‚à™ t).chainHeight = s.chainHeight + t.chainHeight := by
  cases h : t.chainHeight
  -- ‚ä¢ chainHeight (s ‚à™ t) = chainHeight s + none
  ¬∑ rw [WithTop.none_eq_top, add_top, eq_top_iff, ‚Üê WithTop.none_eq_top, ‚Üê h]
    -- ‚ä¢ chainHeight t ‚â§ chainHeight (s ‚à™ t)
    exact Set.chainHeight_mono (Set.subset_union_right _ _)
    -- üéâ no goals
  apply le_antisymm
  -- ‚ä¢ chainHeight (s ‚à™ t) ‚â§ chainHeight s + some val‚úù
  ¬∑ rw [‚Üê h]
    -- ‚ä¢ chainHeight (s ‚à™ t) ‚â§ chainHeight s + chainHeight t
    exact chainHeight_union_le
    -- üéâ no goals
  rw [WithTop.some_eq_coe, ‚Üê add_zero (s ‚à™ t).chainHeight, ‚Üê WithTop.coe_zero,
    ENat.some_eq_coe, chainHeight_add_le_chainHeight_add]
  intro l hl
  -- ‚ä¢ ‚àÉ l', l' ‚àà subchain (s ‚à™ t) ‚àß length l + val‚úù ‚â§ length l' + 0
  obtain ‚ü®l', hl', rfl‚ü© := exists_chain_of_le_chainHeight t h.symm.le
  -- ‚ä¢ ‚àÉ l'_1, l'_1 ‚àà subchain (s ‚à™ t) ‚àß length l + length l' ‚â§ length l'_1 + 0
  refine' ‚ü®l ++ l', ‚ü®Chain'.append hl.1 hl'.1 fun x hx y hy ‚Ü¶ _, fun i hi ‚Ü¶ _‚ü©, by simp‚ü©
  -- ‚ä¢ x < y
  ¬∑ exact H x (hl.2 _ <| mem_of_mem_getLast? hx) y (hl'.2 _ <| mem_of_mem_head? hy)
    -- üéâ no goals
  ¬∑ rw [mem_append] at hi
    -- ‚ä¢ i ‚àà s ‚à™ t
    cases' hi with hi hi
    -- ‚ä¢ i ‚àà s ‚à™ t
    exacts [Or.inl (hl.2 _ hi), Or.inr (hl'.2 _ hi)]
    -- üéâ no goals
#align set.chain_height_union_eq Set.chainHeight_union_eq

theorem wellFoundedGT_of_chainHeight_ne_top (s : Set Œ±) (hs : s.chainHeight ‚â† ‚ä§) :
    WellFoundedGT s := by
  -- Porting note: added
  haveI : IsTrans { x // x ‚àà s } (‚Üë¬∑ < ‚Üë¬∑) := inferInstance
  -- ‚ä¢ WellFoundedGT ‚Üës

  obtain ‚ü®n, hn‚ü© := WithTop.ne_top_iff_exists.1 hs
  -- ‚ä¢ WellFoundedGT ‚Üës
  refine' ‚ü®RelEmbedding.wellFounded_iff_no_descending_seq.2 ‚ü®fun f ‚Ü¶ _‚ü©‚ü©
  -- ‚ä¢ False
  refine' n.lt_succ_self.not_le (WithTop.coe_le_coe.1 <| hn.symm ‚ñ∏ _)
  -- ‚ä¢ ‚Üë(Nat.succ n) ‚â§ chainHeight s
  refine'
    le_iSup‚ÇÇ_of_le _
      ‚ü®chain'_map_of_chain' ((‚Üë) : {x // x ‚àà s} ‚Üí Œ±) (fun _ _ ‚Ü¶ id)
          (chain'_iff_pairwise.2 <| pairwise_ofFn.2 fun i j ‚Ü¶ f.map_rel_iff.2),
        fun i h ‚Ü¶ _‚ü©
      _
  ¬∑ exact n.succ
    -- üéâ no goals
  ¬∑ obtain ‚ü®a, -, rfl‚ü© := mem_map.1 h
    -- ‚ä¢ ‚Üëa ‚àà s
    exact a.prop
    -- üéâ no goals
  ¬∑ rw [length_map, length_ofFn]
    -- ‚ä¢ ‚Üë(Nat.succ n) ‚â§ ‚Üë(Nat.succ n)
    exact le_rfl
    -- üéâ no goals
#align set.well_founded_gt_of_chain_height_ne_top Set.wellFoundedGT_of_chainHeight_ne_top

theorem wellFoundedLT_of_chainHeight_ne_top (s : Set Œ±) (hs : s.chainHeight ‚â† ‚ä§) :
    WellFoundedLT s :=
  wellFoundedGT_of_chainHeight_ne_top (ofDual ‚Åª¬π' s) <| by rwa [chainHeight_dual]
                                                           -- üéâ no goals
#align set.well_founded_lt_of_chain_height_ne_top Set.wellFoundedLT_of_chainHeight_ne_top

end Preorder

end Set
