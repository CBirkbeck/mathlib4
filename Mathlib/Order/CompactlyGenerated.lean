/-
Copyright (c) 2021 Oliver Nash. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Oliver Nash
-/
import Mathlib.Order.Atoms
import Mathlib.Order.OrderIsoNat
import Mathlib.Order.RelIso.Set
import Mathlib.Order.SupIndep
import Mathlib.Order.Zorn
import Mathlib.Data.Finset.Order
import Mathlib.Data.Set.Intervals.OrderIso
import Mathlib.Data.Finite.Set
import Mathlib.Tactic.TFAE

#align_import order.compactly_generated from "leanprover-community/mathlib"@"c813ed7de0f5115f956239124e9b30f3a621966f"

/-!
# Compactness properties for complete lattices

For complete lattices, there are numerous equivalent ways to express the fact that the relation `>`
is well-founded. In this file we define three especially-useful characterisations and provide
proofs that they are indeed equivalent to well-foundedness.

## Main definitions
 * `CompleteLattice.IsSupClosedCompact`
 * `CompleteLattice.IsSupFiniteCompact`
 * `CompleteLattice.IsCompactElement`
 * `IsCompactlyGenerated`

## Main results
The main result is that the following four conditions are equivalent for a complete lattice:
 * `well_founded (>)`
 * `CompleteLattice.IsSupClosedCompact`
 * `CompleteLattice.IsSupFiniteCompact`
 * `‚àÄ k, CompleteLattice.IsCompactElement k`

This is demonstrated by means of the following four lemmas:
 * `CompleteLattice.WellFounded.isSupFiniteCompact`
 * `CompleteLattice.IsSupFiniteCompact.isSupClosedCompact`
 * `CompleteLattice.IsSupClosedCompact.wellFounded`
 * `CompleteLattice.isSupFiniteCompact_iff_all_elements_compact`

 We also show well-founded lattices are compactly generated
 (`CompleteLattice.isCompactlyGenerated_of_wellFounded`).

## References
- [G. CƒÉlugƒÉreanu, *Lattice Concepts of Module Theory*][calugareanu]

## Tags

complete lattice, well-founded, compact
-/

variable {Œπ : Sort*} {Œ± : Type*} [CompleteLattice Œ±] {f : Œπ ‚Üí Œ±}

namespace CompleteLattice

variable (Œ±)

/-- A compactness property for a complete lattice is that any `sup`-closed non-empty subset
contains its `sSup`. -/
def IsSupClosedCompact : Prop :=
  ‚àÄ (s : Set Œ±) (_ : s.Nonempty), (‚àÄ (a) (_ : a ‚àà s) (b) (_ : b ‚àà s), a ‚äî b ‚àà s) ‚Üí sSup s ‚àà s
#align complete_lattice.is_sup_closed_compact CompleteLattice.IsSupClosedCompact

/-- A compactness property for a complete lattice is that any subset has a finite subset with the
same `sSup`. -/
def IsSupFiniteCompact : Prop :=
  ‚àÄ s : Set Œ±, ‚àÉ t : Finset Œ±, ‚Üët ‚äÜ s ‚àß sSup s = t.sup id
#align complete_lattice.is_Sup_finite_compact CompleteLattice.IsSupFiniteCompact

/-- An element `k` of a complete lattice is said to be compact if any set with `sSup`
above `k` has a finite subset with `sSup` above `k`.  Such an element is also called
"finite" or "S-compact". -/
def IsCompactElement {Œ± : Type*} [CompleteLattice Œ±] (k : Œ±) :=
  ‚àÄ s : Set Œ±, k ‚â§ sSup s ‚Üí ‚àÉ t : Finset Œ±, ‚Üët ‚äÜ s ‚àß k ‚â§ t.sup id
#align complete_lattice.is_compact_element CompleteLattice.IsCompactElement

theorem isCompactElement_iff.{u} {Œ± : Type u} [CompleteLattice Œ±] (k : Œ±) :
    CompleteLattice.IsCompactElement k ‚Üî
      ‚àÄ (Œπ : Type u) (s : Œπ ‚Üí Œ±), k ‚â§ iSup s ‚Üí ‚àÉ t : Finset Œπ, k ‚â§ t.sup s := by
  classical
    constructor
    ¬∑ intro H Œπ s hs
      obtain ‚ü®t, ht, ht'‚ü© := H (Set.range s) hs
      have : ‚àÄ x : t, ‚àÉ i, s i = x := fun x => ht x.prop
      choose f hf using this
      refine' ‚ü®Finset.univ.image f, ht'.trans _‚ü©
      ¬∑ rw [Finset.sup_le_iff]
        intro b hb
        rw [‚Üê show s (f ‚ü®b, hb‚ü©) = id b from hf _]
        exact Finset.le_sup (Finset.mem_image_of_mem f <| Finset.mem_univ (Subtype.mk b hb))
    ¬∑ intro H s hs
      obtain ‚ü®t, ht‚ü© :=
        H s Subtype.val
          (by
            delta iSup
            rwa [Subtype.range_coe])
      refine' ‚ü®t.image Subtype.val, by simp, ht.trans _‚ü©
      rw [Finset.sup_le_iff]
      exact fun x hx => @Finset.le_sup _ _ _ _ _ id _ (Finset.mem_image_of_mem Subtype.val hx)
#align complete_lattice.is_compact_element_iff CompleteLattice.isCompactElement_iff

/-- An element `k` is compact if and only if any directed set with `sSup` above
`k` already got above `k` at some point in the set. -/
theorem isCompactElement_iff_le_of_directed_sSup_le (k : Œ±) :
    IsCompactElement k ‚Üî
      ‚àÄ s : Set Œ±, s.Nonempty ‚Üí DirectedOn (¬∑ ‚â§ ¬∑) s ‚Üí k ‚â§ sSup s ‚Üí ‚àÉ x : Œ±, x ‚àà s ‚àß k ‚â§ x := by
  classical
    constructor
    ¬∑ intro hk s hne hdir hsup
      obtain ‚ü®t, ht‚ü© := hk s hsup
      -- certainly every element of t is below something in s, since ‚Üët ‚äÜ s.
      have t_below_s : ‚àÄ x ‚àà t, ‚àÉ y ‚àà s, x ‚â§ y := fun x hxt => ‚ü®x, ht.left hxt, le_rfl‚ü©
      obtain ‚ü®x, ‚ü®hxs, hsupx‚ü©‚ü© := Finset.sup_le_of_le_directed s hne hdir t t_below_s
      exact ‚ü®x, ‚ü®hxs, le_trans ht.right hsupx‚ü©‚ü©
    ¬∑ intro hk s hsup
      -- Consider the set of finite joins of elements of the (plain) set s.
      let S : Set Œ± := { x | ‚àÉ t : Finset Œ±, ‚Üët ‚äÜ s ‚àß x = t.sup id }
      -- S is directed, nonempty, and still has sup above k.
      have dir_US : DirectedOn (¬∑ ‚â§ ¬∑) S := by
        rintro x ‚ü®c, hc‚ü© y ‚ü®d, hd‚ü©
        use x ‚äî y
        constructor
        ¬∑ use c ‚à™ d
          constructor
          ¬∑ simp only [hc.left, hd.left, Set.union_subset_iff, Finset.coe_union, and_self_iff]
          ¬∑ simp only [hc.right, hd.right, Finset.sup_union]
        simp only [and_self_iff, le_sup_left, le_sup_right]
      have sup_S : sSup s ‚â§ sSup S := by
        apply sSup_le_sSup
        intro x hx
        use {x}
        simpa only [and_true_iff, id.def, Finset.coe_singleton, eq_self_iff_true,
          Finset.sup_singleton, Set.singleton_subset_iff]
      have Sne : S.Nonempty := by
        suffices : ‚ä• ‚àà S
        exact Set.nonempty_of_mem this
        use ‚àÖ
        simp only [Set.empty_subset, Finset.coe_empty, Finset.sup_empty, eq_self_iff_true,
          and_self_iff]
      -- Now apply the defn of compact and finish.
      obtain ‚ü®j, ‚ü®hjS, hjk‚ü©‚ü© := hk S Sne dir_US (le_trans hsup sup_S)
      obtain ‚ü®t, ‚ü®htS, htsup‚ü©‚ü© := hjS
      use t
      exact ‚ü®htS, by rwa [‚Üê htsup]‚ü©
#align complete_lattice.is_compact_element_iff_le_of_directed_Sup_le CompleteLattice.isCompactElement_iff_le_of_directed_sSup_le

theorem IsCompactElement.exists_finset_of_le_iSup {k : Œ±} (hk : IsCompactElement k) {Œπ : Type*}
    (f : Œπ ‚Üí Œ±) (h : k ‚â§ ‚®Ü i, f i) : ‚àÉ s : Finset Œπ, k ‚â§ ‚®Ü i ‚àà s, f i := by
  classical
    let g : Finset Œπ ‚Üí Œ± := fun s => ‚®Ü i ‚àà s, f i
    have h1 : DirectedOn (¬∑ ‚â§ ¬∑) (Set.range g) := by
      rintro - ‚ü®s, rfl‚ü© - ‚ü®t, rfl‚ü©
      exact
        ‚ü®g (s ‚à™ t), ‚ü®s ‚à™ t, rfl‚ü©, iSup_le_iSup_of_subset (Finset.subset_union_left s t),
          iSup_le_iSup_of_subset (Finset.subset_union_right s t)‚ü©
    have h2 : k ‚â§ sSup (Set.range g) :=
      h.trans
        (iSup_le fun i =>
          le_sSup_of_le ‚ü®{i}, rfl‚ü©
            (le_iSup_of_le i (le_iSup_of_le (Finset.mem_singleton_self i) le_rfl)))
    obtain ‚ü®-, ‚ü®s, rfl‚ü©, hs‚ü© :=
      (isCompactElement_iff_le_of_directed_sSup_le Œ± k).mp hk (Set.range g) (Set.range_nonempty g)
        h1 h2
    exact ‚ü®s, hs‚ü©
#align complete_lattice.is_compact_element.exists_finset_of_le_supr CompleteLattice.IsCompactElement.exists_finset_of_le_iSup

/-- A compact element `k` has the property that any directed set lying strictly below `k` has
its `sSup` strictly below `k`. -/
theorem IsCompactElement.directed_sSup_lt_of_lt {Œ± : Type*} [CompleteLattice Œ±] {k : Œ±}
    (hk : IsCompactElement k) {s : Set Œ±} (hemp : s.Nonempty) (hdir : DirectedOn (¬∑ ‚â§ ¬∑) s)
    (hbelow : ‚àÄ x ‚àà s, x < k) : sSup s < k := by
  rw [isCompactElement_iff_le_of_directed_sSup_le] at hk
  -- ‚ä¢ sSup s < k
  by_contra h
  -- ‚ä¢ False
  have sSup' : sSup s ‚â§ k := sSup_le s k fun s hs => (hbelow s hs).le
  -- ‚ä¢ False
  replace sSup : sSup s = k := eq_iff_le_not_lt.mpr ‚ü®sSup', h‚ü©
  -- ‚ä¢ False
  obtain ‚ü®x, hxs, hkx‚ü© := hk s hemp hdir sSup.symm.le
  -- ‚ä¢ False
  obtain hxk := hbelow x hxs
  -- ‚ä¢ False
  exact hxk.ne (hxk.le.antisymm hkx)
  -- üéâ no goals
#align complete_lattice.is_compact_element.directed_Sup_lt_of_lt CompleteLattice.IsCompactElement.directed_sSup_lt_of_lt

theorem finset_sup_compact_of_compact {Œ± Œ≤ : Type*} [CompleteLattice Œ±] {f : Œ≤ ‚Üí Œ±} (s : Finset Œ≤)
    (h : ‚àÄ x ‚àà s, IsCompactElement (f x)) : IsCompactElement (s.sup f) := by
  classical
    rw [isCompactElement_iff_le_of_directed_sSup_le]
    intro d hemp hdir hsup
    rw [‚Üê Function.comp.left_id f]
    rw [‚Üê Finset.sup_image]
    apply Finset.sup_le_of_le_directed d hemp hdir
    rintro x hx
    obtain ‚ü®p, ‚ü®hps, rfl‚ü©‚ü© := Finset.mem_image.mp hx
    specialize h p hps
    rw [isCompactElement_iff_le_of_directed_sSup_le] at h
    specialize h d hemp hdir (le_trans (Finset.le_sup hps) hsup)
    simpa only [exists_prop]
#align complete_lattice.finset_sup_compact_of_compact CompleteLattice.finset_sup_compact_of_compact

theorem WellFounded.isSupFiniteCompact (h : WellFounded ((¬∑ > ¬∑) : Œ± ‚Üí Œ± ‚Üí Prop)) :
    IsSupFiniteCompact Œ± := fun s => by
  let S := { x | ‚àÉ t : Finset Œ±, ‚Üët ‚äÜ s ‚àß t.sup id = x }
  -- ‚ä¢ ‚àÉ t, ‚Üët ‚äÜ s ‚àß sSup s = Finset.sup t id
  obtain ‚ü®m, ‚ü®t, ‚ü®ht‚ÇÅ, rfl‚ü©‚ü©, hm‚ü© := h.has_min S ‚ü®‚ä•, ‚àÖ, by simp‚ü©
  -- ‚ä¢ ‚àÉ t, ‚Üët ‚äÜ s ‚àß sSup s = Finset.sup t id
  refine' ‚ü®t, ht‚ÇÅ, (sSup_le _ _ fun y hy => _).antisymm _‚ü©
  -- ‚ä¢ y ‚â§ Finset.sup t id
  ¬∑ classical
    rw [eq_of_le_of_not_lt (Finset.sup_mono (t.subset_insert y))
        (hm _ ‚ü®insert y t, by simp [Set.insert_subset_iff, hy, ht‚ÇÅ]‚ü©)]
    simp
  ¬∑ rw [Finset.sup_id_eq_sSup]
    -- ‚ä¢ sSup ‚Üët ‚â§ sSup s
    exact sSup_le_sSup ht‚ÇÅ
    -- üéâ no goals
#align complete_lattice.well_founded.is_Sup_finite_compact CompleteLattice.WellFounded.isSupFiniteCompact

theorem IsSupFiniteCompact.isSupClosedCompact (h : IsSupFiniteCompact Œ±) :
    IsSupClosedCompact Œ± := by
  intro s hne hsc; obtain ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü© := h s; clear h
  -- ‚ä¢ sSup s ‚àà s
                   -- ‚ä¢ sSup s ‚àà s
                                                -- ‚ä¢ sSup s ‚àà s
  cases' t.eq_empty_or_nonempty with h h
  -- ‚ä¢ sSup s ‚àà s
  ¬∑ subst h
    -- ‚ä¢ sSup s ‚àà s
    rw [Finset.sup_empty] at ht‚ÇÇ
    -- ‚ä¢ sSup s ‚àà s
    rw [ht‚ÇÇ]
    -- ‚ä¢ ‚ä• ‚àà s
    simp [eq_singleton_bot_of_sSup_eq_bot_of_nonempty ht‚ÇÇ hne]
    -- üéâ no goals
  ¬∑ rw [ht‚ÇÇ]
    -- ‚ä¢ Finset.sup t id ‚àà s
    exact t.sup_closed_of_sup_closed h ht‚ÇÅ hsc
    -- üéâ no goals
#align complete_lattice.is_Sup_finite_compact.is_sup_closed_compact CompleteLattice.IsSupFiniteCompact.isSupClosedCompact

theorem IsSupClosedCompact.wellFounded (h : IsSupClosedCompact Œ±) :
    WellFounded ((¬∑ > ¬∑) : Œ± ‚Üí Œ± ‚Üí Prop) := by
  refine' RelEmbedding.wellFounded_iff_no_descending_seq.mpr ‚ü®fun a => _‚ü©
  -- ‚ä¢ False
  suffices sSup (Set.range a) ‚àà Set.range a by
    obtain ‚ü®n, hn‚ü© := Set.mem_range.mp this
    have h' : sSup (Set.range a) < a (n + 1) := by
      change _ > _
      simp [‚Üê hn, a.map_rel_iff]
    apply lt_irrefl (a (n + 1))
    apply lt_of_le_of_lt _ h'
    apply le_sSup
    apply Set.mem_range_self
  apply h (Set.range a)
  -- ‚ä¢ Set.Nonempty (Set.range ‚Üëa)
  ¬∑ use a 37
    -- ‚ä¢ ‚Üëa 37 ‚àà Set.range ‚Üëa
    apply Set.mem_range_self
    -- üéâ no goals
  ¬∑ rintro x ‚ü®m, hm‚ü© y ‚ü®n, hn‚ü©
    -- ‚ä¢ x ‚äî y ‚àà Set.range ‚Üëa
    use m ‚äî n
    -- ‚ä¢ ‚Üëa (m ‚äî n) = x ‚äî y
    rw [‚Üê hm, ‚Üê hn]
    -- ‚ä¢ ‚Üëa (m ‚äî n) = ‚Üëa m ‚äî ‚Üëa n
    apply RelHomClass.map_sup a
    -- üéâ no goals
#align complete_lattice.is_sup_closed_compact.well_founded CompleteLattice.IsSupClosedCompact.wellFounded

theorem isSupFiniteCompact_iff_all_elements_compact :
    IsSupFiniteCompact Œ± ‚Üî ‚àÄ k : Œ±, IsCompactElement k := by
  refine' ‚ü®fun h k s hs => _, fun h s => _‚ü©
  -- ‚ä¢ ‚àÉ t, ‚Üët ‚äÜ s ‚àß k ‚â§ Finset.sup t id
  ¬∑ obtain ‚ü®t, ‚ü®hts, htsup‚ü©‚ü© := h s
    -- ‚ä¢ ‚àÉ t, ‚Üët ‚äÜ s ‚àß k ‚â§ Finset.sup t id
    use t, hts
    -- ‚ä¢ k ‚â§ Finset.sup t id
    rwa [‚Üê htsup]
    -- üéâ no goals
  ¬∑ obtain ‚ü®t, ‚ü®hts, htsup‚ü©‚ü© := h (sSup s) s (by rfl)
    -- ‚ä¢ ‚àÉ t, ‚Üët ‚äÜ s ‚àß sSup s = Finset.sup t id
    have : sSup s = t.sup id := by
      suffices t.sup id ‚â§ sSup s by apply le_antisymm <;> assumption
      simp only [id.def, Finset.sup_le_iff]
      intro x hx
      exact le_sSup _ _ (hts hx)
    exact ‚ü®t, hts, this‚ü©
    -- üéâ no goals
#align complete_lattice.is_Sup_finite_compact_iff_all_elements_compact CompleteLattice.isSupFiniteCompact_iff_all_elements_compact

open List in
theorem wellFounded_characterisations : List.TFAE
    [WellFounded (( ¬∑ > ¬∑ ) : Œ± ‚Üí Œ± ‚Üí Prop),
      IsSupFiniteCompact Œ±, IsSupClosedCompact Œ±, ‚àÄ k : Œ±, IsCompactElement k] := by
  tfae_have 1 ‚Üí 2
  -- ‚ä¢ (WellFounded fun x x_1 => x > x_1) ‚Üí IsSupFiniteCompact Œ±
  ¬∑ exact WellFounded.isSupFiniteCompact Œ±
    -- üéâ no goals
  tfae_have 2 ‚Üí 3
  -- ‚ä¢ IsSupFiniteCompact Œ± ‚Üí IsSupClosedCompact Œ±
  ¬∑ exact IsSupFiniteCompact.isSupClosedCompact Œ±
    -- üéâ no goals
  tfae_have 3 ‚Üí 1
  -- ‚ä¢ IsSupClosedCompact Œ± ‚Üí WellFounded fun x x_1 => x > x_1
  ¬∑ exact IsSupClosedCompact.wellFounded Œ±
    -- üéâ no goals
  tfae_have 2 ‚Üî 4
  -- ‚ä¢ IsSupFiniteCompact Œ± ‚Üî ‚àÄ (k : Œ±), IsCompactElement k
  ¬∑ exact isSupFiniteCompact_iff_all_elements_compact Œ±
    -- üéâ no goals
  tfae_finish
  -- üéâ no goals
#align complete_lattice.well_founded_characterisations CompleteLattice.wellFounded_characterisations

theorem wellFounded_iff_isSupFiniteCompact :
    WellFounded ((¬∑ > ¬∑) : Œ± ‚Üí Œ± ‚Üí Prop) ‚Üî IsSupFiniteCompact Œ± :=
  (wellFounded_characterisations Œ±).out 0 1
#align complete_lattice.well_founded_iff_is_Sup_finite_compact CompleteLattice.wellFounded_iff_isSupFiniteCompact

theorem isSupFiniteCompact_iff_isSupClosedCompact : IsSupFiniteCompact Œ± ‚Üî IsSupClosedCompact Œ± :=
  (wellFounded_characterisations Œ±).out 1 2
#align complete_lattice.is_Sup_finite_compact_iff_is_sup_closed_compact CompleteLattice.isSupFiniteCompact_iff_isSupClosedCompact

theorem isSupClosedCompact_iff_wellFounded :
    IsSupClosedCompact Œ± ‚Üî WellFounded ((¬∑ > ¬∑) : Œ± ‚Üí Œ± ‚Üí Prop) :=
  (wellFounded_characterisations Œ±).out 2 0
#align complete_lattice.is_sup_closed_compact_iff_well_founded CompleteLattice.isSupClosedCompact_iff_wellFounded

alias ‚ü®_, IsSupFiniteCompact.wellFounded‚ü© := wellFounded_iff_isSupFiniteCompact
#align complete_lattice.is_Sup_finite_compact.well_founded CompleteLattice.IsSupFiniteCompact.wellFounded

alias ‚ü®_, IsSupClosedCompact.isSupFiniteCompact‚ü© := isSupFiniteCompact_iff_isSupClosedCompact
#align complete_lattice.is_sup_closed_compact.is_Sup_finite_compact CompleteLattice.IsSupClosedCompact.isSupFiniteCompact

alias ‚ü®_, _root_.WellFounded.isSupClosedCompact‚ü© := isSupClosedCompact_iff_wellFounded
#align well_founded.is_sup_closed_compact WellFounded.isSupClosedCompact

variable {Œ±}

theorem WellFounded.finite_of_setIndependent (h : WellFounded ((¬∑ > ¬∑) : Œ± ‚Üí Œ± ‚Üí Prop)) {s : Set Œ±}
    (hs : SetIndependent s) : s.Finite := by
  classical
    refine' Set.not_infinite.mp fun contra => _
    obtain ‚ü®t, ht‚ÇÅ, ht‚ÇÇ‚ü© := WellFounded.isSupFiniteCompact Œ± h s
    replace contra : ‚àÉ x : Œ±, x ‚àà s ‚àß x ‚â† ‚ä• ‚àß x ‚àâ t
    ¬∑ have : (s \ (insert ‚ä• t : Finset Œ±)).Infinite := contra.diff (Finset.finite_toSet _)
      obtain ‚ü®x, hx‚ÇÅ, hx‚ÇÇ‚ü© := this.nonempty
      exact ‚ü®x, hx‚ÇÅ, by simpa [not_or] using hx‚ÇÇ‚ü©
    obtain ‚ü®x, hx‚ÇÄ, hx‚ÇÅ, hx‚ÇÇ‚ü© := contra
    replace hs : x ‚äì sSup s = ‚ä•
    ¬∑ have := hs.mono (by simp [ht‚ÇÅ, hx‚ÇÄ, -Set.union_singleton] : ‚Üët ‚à™ {x} ‚â§ s) (by simp : x ‚àà _)
      simpa [Disjoint, hx‚ÇÇ, ‚Üê t.sup_id_eq_sSup, ‚Üê ht‚ÇÇ] using this.eq_bot
    apply hx‚ÇÅ
    rw [‚Üê hs, eq_comm, inf_eq_left]
    exact le_sSup _ _ hx‚ÇÄ
#align complete_lattice.well_founded.finite_of_set_independent CompleteLattice.WellFounded.finite_of_setIndependent

theorem WellFounded.finite_of_independent (hwf : WellFounded ((¬∑ > ¬∑) : Œ± ‚Üí Œ± ‚Üí Prop)) {Œπ : Type*}
    {t : Œπ ‚Üí Œ±} (ht : Independent t) (h_ne_bot : ‚àÄ i, t i ‚â† ‚ä•) : Finite Œπ :=
  haveI := (WellFounded.finite_of_setIndependent hwf ht.setIndependent_range).to_subtype
  Finite.of_injective_finite_range (ht.injective h_ne_bot)
#align complete_lattice.well_founded.finite_of_independent CompleteLattice.WellFounded.finite_of_independent

end CompleteLattice

/-- A complete lattice is said to be compactly generated if any
element is the `sSup` of compact elements. -/
class IsCompactlyGenerated (Œ± : Type*) [CompleteLattice Œ±] : Prop where
  /-- In a compactly generated complete lattice,
    every element is the `sSup` of some set of compact elements. -/
  exists_sSup_eq : ‚àÄ x : Œ±, ‚àÉ s : Set Œ±, (‚àÄ x ‚àà s, CompleteLattice.IsCompactElement x) ‚àß sSup s = x
#align is_compactly_generated IsCompactlyGenerated

section

variable [CompleteLattice Œ±] [IsCompactlyGenerated Œ±] {a b : Œ±} {s : Set Œ±}

@[simp]
theorem sSup_compact_le_eq (b) :
    sSup { c : Œ± | CompleteLattice.IsCompactElement c ‚àß c ‚â§ b } = b := by
  rcases IsCompactlyGenerated.exists_sSup_eq b with ‚ü®s, hs, rfl‚ü©
  -- ‚ä¢ sSup {c | CompleteLattice.IsCompactElement c ‚àß c ‚â§ sSup s} = sSup s
  exact le_antisymm (sSup_le fun c hc => hc.2) (sSup_le_sSup fun c cs => ‚ü®hs c cs, le_sSup cs‚ü©)
  -- üéâ no goals
#align Sup_compact_le_eq sSup_compact_le_eq

@[simp]
theorem sSup_compact_eq_top : sSup { a : Œ± | CompleteLattice.IsCompactElement a } = ‚ä§ := by
  refine' Eq.trans (congr rfl (Set.ext fun x => _)) (sSup_compact_le_eq ‚ä§)
  -- ‚ä¢ x ‚àà {a | CompleteLattice.IsCompactElement a} ‚Üî x ‚àà {c | CompleteLattice.IsCo ‚Ä¶
  exact (and_iff_left le_top).symm
  -- üéâ no goals
#align Sup_compact_eq_top sSup_compact_eq_top

theorem le_iff_compact_le_imp {a b : Œ±} :
    a ‚â§ b ‚Üî ‚àÄ c : Œ±, CompleteLattice.IsCompactElement c ‚Üí c ‚â§ a ‚Üí c ‚â§ b :=
  ‚ü®fun ab c _ ca => le_trans ca ab, fun h => by
    rw [‚Üê sSup_compact_le_eq a, ‚Üê sSup_compact_le_eq b]
    -- ‚ä¢ sSup {c | CompleteLattice.IsCompactElement c ‚àß c ‚â§ a} ‚â§ sSup {c | CompleteLa ‚Ä¶
    exact sSup_le_sSup fun c hc => ‚ü®hc.1, h c hc.1 hc.2‚ü©‚ü©
    -- üéâ no goals
#align le_iff_compact_le_imp le_iff_compact_le_imp

/-- This property is sometimes referred to as `Œ±` being upper continuous. -/
theorem DirectedOn.inf_sSup_eq (h : DirectedOn (¬∑ ‚â§ ¬∑) s) : a ‚äì sSup s = ‚®Ü b ‚àà s, a ‚äì b :=
  le_antisymm
    (by
      rw [le_iff_compact_le_imp]
      -- ‚ä¢ ‚àÄ (c : Œ±), CompleteLattice.IsCompactElement c ‚Üí c ‚â§ a ‚äì sSup s ‚Üí c ‚â§ ‚®Ü (b :  ‚Ä¶
      by_cases hs : s.Nonempty
      -- ‚ä¢ ‚àÄ (c : Œ±), CompleteLattice.IsCompactElement c ‚Üí c ‚â§ a ‚äì sSup s ‚Üí c ‚â§ ‚®Ü (b :  ‚Ä¶
      ¬∑ intro c hc hcinf
        -- ‚ä¢ c ‚â§ ‚®Ü (b : Œ±) (_ : b ‚àà s), a ‚äì b
        rw [le_inf_iff] at hcinf
        -- ‚ä¢ c ‚â§ ‚®Ü (b : Œ±) (_ : b ‚àà s), a ‚äì b
        rw [CompleteLattice.isCompactElement_iff_le_of_directed_sSup_le] at hc
        -- ‚ä¢ c ‚â§ ‚®Ü (b : Œ±) (_ : b ‚àà s), a ‚äì b
        rcases hc s hs h hcinf.2 with ‚ü®d, ds, cd‚ü©
        -- ‚ä¢ c ‚â§ ‚®Ü (b : Œ±) (_ : b ‚àà s), a ‚äì b
        refine' (le_inf hcinf.1 cd).trans (le_trans _ (le_iSup‚ÇÇ d ds))
        -- ‚ä¢ a ‚äì d ‚â§ a ‚äì d
        rfl
        -- üéâ no goals
      ¬∑ rw [Set.not_nonempty_iff_eq_empty] at hs
        -- ‚ä¢ ‚àÄ (c : Œ±), CompleteLattice.IsCompactElement c ‚Üí c ‚â§ a ‚äì sSup s ‚Üí c ‚â§ ‚®Ü (b :  ‚Ä¶
        simp [hs])
        -- üéâ no goals
    iSup_inf_le_inf_sSup
#align directed_on.inf_Sup_eq DirectedOn.inf_sSup_eq

/-- This property is sometimes referred to as `Œ±` being upper continuous. -/
protected theorem DirectedOn.sSup_inf_eq (h : DirectedOn (¬∑ ‚â§ ¬∑) s) : sSup s ‚äì a = ‚®Ü b ‚àà s, b ‚äì a :=
  by simp_rw [@inf_comm _ _ _ a, h.inf_sSup_eq]
     -- üéâ no goals
#align directed_on.Sup_inf_eq DirectedOn.sSup_inf_eq

protected theorem Directed.inf_iSup_eq (h : Directed (¬∑ ‚â§ ¬∑) f) : (a ‚äì ‚®Ü i, f i) = ‚®Ü i, a ‚äì f i :=
  by rw [iSup, h.directedOn_range.inf_sSup_eq, iSup_range]
     -- üéâ no goals
#align directed.inf_supr_eq Directed.inf_iSup_eq

protected theorem Directed.iSup_inf_eq (h : Directed (¬∑ ‚â§ ¬∑) f) : (‚®Ü i, f i) ‚äì a = ‚®Ü i, f i ‚äì a :=
  by rw [iSup, h.directedOn_range.sSup_inf_eq, iSup_range]
     -- üéâ no goals
#align directed.supr_inf_eq Directed.iSup_inf_eq

protected theorem DirectedOn.disjoint_sSup_right (h : DirectedOn (¬∑ ‚â§ ¬∑) s) :
    Disjoint a (sSup s) ‚Üî ‚àÄ ‚¶Éb‚¶Ñ, b ‚àà s ‚Üí Disjoint a b := by
  simp_rw [disjoint_iff, h.inf_sSup_eq, iSup_eq_bot]
  -- üéâ no goals
#align directed_on.disjoint_Sup_right DirectedOn.disjoint_sSup_right

protected theorem DirectedOn.disjoint_sSup_left (h : DirectedOn (¬∑ ‚â§ ¬∑) s) :
    Disjoint (sSup s) a ‚Üî ‚àÄ ‚¶Éb‚¶Ñ, b ‚àà s ‚Üí Disjoint b a := by
  simp_rw [disjoint_iff, h.sSup_inf_eq, iSup_eq_bot]
  -- üéâ no goals
#align directed_on.disjoint_Sup_left DirectedOn.disjoint_sSup_left

protected theorem Directed.disjoint_iSup_right (h : Directed (¬∑ ‚â§ ¬∑) f) :
    Disjoint a (‚®Ü i, f i) ‚Üî ‚àÄ i, Disjoint a (f i) := by
  simp_rw [disjoint_iff, h.inf_iSup_eq, iSup_eq_bot]
  -- üéâ no goals
#align directed.disjoint_supr_right Directed.disjoint_iSup_right

protected theorem Directed.disjoint_iSup_left (h : Directed (¬∑ ‚â§ ¬∑) f) :
    Disjoint (‚®Ü i, f i) a ‚Üî ‚àÄ i, Disjoint (f i) a := by
  simp_rw [disjoint_iff, h.iSup_inf_eq, iSup_eq_bot]
  -- üéâ no goals
#align directed.disjoint_supr_left Directed.disjoint_iSup_left

/-- This property is equivalent to `Œ±` being upper continuous. -/
theorem inf_sSup_eq_iSup_inf_sup_finset :
    a ‚äì sSup s = ‚®Ü (t : Finset Œ±) (_ : ‚Üët ‚äÜ s), a ‚äì t.sup id :=
  le_antisymm
    (by
      rw [le_iff_compact_le_imp]
      -- ‚ä¢ ‚àÄ (c : Œ±), CompleteLattice.IsCompactElement c ‚Üí c ‚â§ a ‚äì sSup s ‚Üí c ‚â§ ‚®Ü (t :  ‚Ä¶
      intro c hc hcinf
      -- ‚ä¢ c ‚â§ ‚®Ü (t : Finset Œ±) (_ : ‚Üët ‚äÜ s), a ‚äì Finset.sup t id
      rw [le_inf_iff] at hcinf
      -- ‚ä¢ c ‚â§ ‚®Ü (t : Finset Œ±) (_ : ‚Üët ‚äÜ s), a ‚äì Finset.sup t id
      rcases hc s hcinf.2 with ‚ü®t, ht1, ht2‚ü©
      -- ‚ä¢ c ‚â§ ‚®Ü (t : Finset Œ±) (_ : ‚Üët ‚äÜ s), a ‚äì Finset.sup t id
      refine' (le_inf hcinf.1 ht2).trans (le_trans _ (le_iSup‚ÇÇ t ht1))
      -- ‚ä¢ a ‚äì Finset.sup t id ‚â§ a ‚äì Finset.sup t id
      rfl)
      -- üéâ no goals
    (iSup_le fun t =>
      iSup_le fun h => inf_le_inf_left _ ((Finset.sup_id_eq_sSup t).symm ‚ñ∏ sSup_le_sSup h))
#align inf_Sup_eq_supr_inf_sup_finset inf_sSup_eq_iSup_inf_sup_finset

theorem CompleteLattice.setIndependent_iff_finite {s : Set Œ±} :
    CompleteLattice.SetIndependent s ‚Üî
      ‚àÄ t : Finset Œ±, ‚Üët ‚äÜ s ‚Üí CompleteLattice.SetIndependent (‚Üët : Set Œ±) :=
  ‚ü®fun hs t ht => hs.mono ht, fun h a ha => by
    rw [disjoint_iff, inf_sSup_eq_iSup_inf_sup_finset, iSup_eq_bot]
    -- ‚ä¢ ‚àÄ (i : Finset Œ±), ‚®Ü (_ : ‚Üëi ‚äÜ s \ {a}), a ‚äì Finset.sup i id = ‚ä•
    intro t
    -- ‚ä¢ ‚®Ü (_ : ‚Üët ‚äÜ s \ {a}), a ‚äì Finset.sup t id = ‚ä•
    rw [iSup_eq_bot, Finset.sup_id_eq_sSup]
    -- ‚ä¢ ‚Üët ‚äÜ s \ {a} ‚Üí a ‚äì sSup ‚Üët = ‚ä•
    intro ht
    -- ‚ä¢ a ‚äì sSup ‚Üët = ‚ä•
    classical
      have h' := (h (insert a t) ?_ (t.mem_insert_self a)).eq_bot
      ¬∑ rwa [Finset.coe_insert, Set.insert_diff_self_of_not_mem] at h'
        exact fun con => ((Set.mem_diff a).1 (ht con)).2 (Set.mem_singleton a)
      ¬∑ rw [Finset.coe_insert, Set.insert_subset_iff]
        exact ‚ü®ha, Set.Subset.trans ht (Set.diff_subset _ _)‚ü©‚ü©
#align complete_lattice.set_independent_iff_finite CompleteLattice.setIndependent_iff_finite

theorem CompleteLattice.setIndependent_iUnion_of_directed {Œ∑ : Type*} {s : Œ∑ ‚Üí Set Œ±}
    (hs : Directed (¬∑ ‚äÜ ¬∑) s) (h : ‚àÄ i, CompleteLattice.SetIndependent (s i)) :
    CompleteLattice.SetIndependent (‚ãÉ i, s i) := by
  by_cases hŒ∑ : Nonempty Œ∑
  -- ‚ä¢ SetIndependent (‚ãÉ (i : Œ∑), s i)
  ¬∑ rw [CompleteLattice.setIndependent_iff_finite]
    -- ‚ä¢ ‚àÄ (t : Finset Œ±), ‚Üët ‚äÜ ‚ãÉ (i : Œ∑), s i ‚Üí SetIndependent ‚Üët
    intro t ht
    -- ‚ä¢ SetIndependent ‚Üët
    obtain ‚ü®I, fi, hI‚ü© := Set.finite_subset_iUnion t.finite_toSet ht
    -- ‚ä¢ SetIndependent ‚Üët
    obtain ‚ü®i, hi‚ü© := hs.finset_le fi.toFinset
    -- ‚ä¢ SetIndependent ‚Üët
    exact (h i).mono
        (Set.Subset.trans hI <| Set.iUnion‚ÇÇ_subset fun j hj => hi j (fi.mem_toFinset.2 hj))
  ¬∑ rintro a ‚ü®_, ‚ü®i, _‚ü©, _‚ü©
    -- ‚ä¢ Disjoint a (sSup ((‚ãÉ (i : Œ∑), s i) \ {a}))
    exfalso
    -- ‚ä¢ False
    exact hŒ∑ ‚ü®i‚ü©
    -- üéâ no goals
#align complete_lattice.set_independent_Union_of_directed CompleteLattice.setIndependent_iUnion_of_directed

theorem CompleteLattice.independent_sUnion_of_directed {s : Set (Set Œ±)} (hs : DirectedOn (¬∑ ‚äÜ ¬∑) s)
    (h : ‚àÄ a ‚àà s, CompleteLattice.SetIndependent a) : CompleteLattice.SetIndependent (‚ãÉ‚ÇÄ s) := by
  rw [Set.sUnion_eq_iUnion]
  -- ‚ä¢ SetIndependent (‚ãÉ (i : ‚Üës), ‚Üëi)
  exact CompleteLattice.setIndependent_iUnion_of_directed hs.directed_val (by simpa using h)
  -- üéâ no goals
#align complete_lattice.independent_sUnion_of_directed CompleteLattice.independent_sUnion_of_directed

end

namespace CompleteLattice

theorem isCompactlyGenerated_of_wellFounded (h : WellFounded ((¬∑ > ¬∑) : Œ± ‚Üí Œ± ‚Üí Prop)) :
    IsCompactlyGenerated Œ± := by
  rw [wellFounded_iff_isSupFiniteCompact, isSupFiniteCompact_iff_all_elements_compact] at h
  -- ‚ä¢ IsCompactlyGenerated Œ±
  -- x is the join of the set of compact elements {x}
  exact ‚ü®fun x => ‚ü®{x}, ‚ü®fun x _ => h x, sSup_singleton‚ü©‚ü©‚ü©
  -- üéâ no goals
#align complete_lattice.compactly_generated_of_well_founded CompleteLattice.isCompactlyGenerated_of_wellFounded

/-- A compact element `k` has the property that any `b < k` lies below a "maximal element below
`k`", which is to say `[‚ä•, k]` is coatomic. -/
theorem Iic_coatomic_of_compact_element {k : Œ±} (h : IsCompactElement k) :
    IsCoatomic (Set.Iic k) := by
  constructor
  -- ‚ä¢ ‚àÄ (b : ‚Üë(Set.Iic k)), b = ‚ä§ ‚à® ‚àÉ a, IsCoatom a ‚àß b ‚â§ a
  rintro ‚ü®b, hbk‚ü©
  -- ‚ä¢ { val := b, property := hbk } = ‚ä§ ‚à® ‚àÉ a, IsCoatom a ‚àß { val := b, property : ‚Ä¶
  obtain rfl | H := eq_or_ne b k
  -- ‚ä¢ { val := b, property := hbk } = ‚ä§ ‚à® ‚àÉ a, IsCoatom a ‚àß { val := b, property : ‚Ä¶
  ¬∑ left; ext; simp only [Set.Iic.coe_top, Subtype.coe_mk]
    -- ‚ä¢ { val := b, property := hbk } = ‚ä§
          -- ‚ä¢ ‚Üë{ val := b, property := hbk } = ‚Üë‚ä§
               -- üéâ no goals
  right
  -- ‚ä¢ ‚àÉ a, IsCoatom a ‚àß { val := b, property := hbk } ‚â§ a
  have ‚ü®a, a‚ÇÄ, ba, h‚ü© := zorn_nonempty_partialOrder‚ÇÄ (Set.Iio k) ?_ b (lt_of_le_of_ne hbk H)
  -- ‚ä¢ ‚àÉ a, IsCoatom a ‚àß { val := b, property := hbk } ‚â§ a
  ¬∑ refine' ‚ü®‚ü®a, le_of_lt a‚ÇÄ‚ü©, ‚ü®ne_of_lt a‚ÇÄ, fun c hck => by_contradiction fun c‚ÇÄ => _‚ü©, ba‚ü©
    -- ‚ä¢ False
    cases h c.1 (lt_of_le_of_ne c.2 fun con => c‚ÇÄ (Subtype.ext con)) hck.le
    -- ‚ä¢ False
    exact lt_irrefl _ hck
    -- üéâ no goals
  ¬∑ intro S SC cC I _
    -- ‚ä¢ ‚àÉ ub, ub ‚àà Set.Iio k ‚àß ‚àÄ (z : Œ±), z ‚àà S ‚Üí z ‚â§ ub
    by_cases hS : S.Nonempty
    -- ‚ä¢ ‚àÉ ub, ub ‚àà Set.Iio k ‚àß ‚àÄ (z : Œ±), z ‚àà S ‚Üí z ‚â§ ub
    ¬∑ refine' ‚ü®sSup S, h.directed_sSup_lt_of_lt hS cC.directedOn SC, _‚ü©
      -- ‚ä¢ ‚àÄ (z : Œ±), z ‚àà S ‚Üí z ‚â§ sSup S
      intro; apply le_sSup
      -- ‚ä¢ z‚úù ‚àà S ‚Üí z‚úù ‚â§ sSup S
             -- üéâ no goals
    exact
      ‚ü®b, lt_of_le_of_ne hbk H, by
        simp only [Set.not_nonempty_iff_eq_empty.mp hS, Set.mem_empty_iff_false, forall_const,
          forall_prop_of_false, not_false_iff]‚ü©
#align complete_lattice.Iic_coatomic_of_compact_element CompleteLattice.Iic_coatomic_of_compact_element

theorem coatomic_of_top_compact (h : IsCompactElement (‚ä§ : Œ±)) : IsCoatomic Œ± :=
  (@OrderIso.IicTop Œ± _ _).isCoatomic_iff.mp (Iic_coatomic_of_compact_element h)
#align complete_lattice.coatomic_of_top_compact CompleteLattice.coatomic_of_top_compact

end CompleteLattice

section

variable [IsModularLattice Œ±] [IsCompactlyGenerated Œ±]

instance (priority := 100) isAtomic_of_complementedLattice [ComplementedLattice Œ±] : IsAtomic Œ± :=
  ‚ü®fun b => by
    by_cases h : { c : Œ± | CompleteLattice.IsCompactElement c ‚àß c ‚â§ b } ‚äÜ {‚ä•}
    -- ‚ä¢ b = ‚ä• ‚à® ‚àÉ a, IsAtom a ‚àß a ‚â§ b
    ¬∑ left
      -- ‚ä¢ b = ‚ä•
      rw [‚Üê sSup_compact_le_eq b, sSup_eq_bot]
      -- ‚ä¢ ‚àÄ (a : Œ±), a ‚àà {c | CompleteLattice.IsCompactElement c ‚àß c ‚â§ b} ‚Üí a = ‚ä•
      exact h
      -- üéâ no goals
    ¬∑ rcases Set.not_subset.1 h with ‚ü®c, ‚ü®hc, hcb‚ü©, hcbot‚ü©
      -- ‚ä¢ b = ‚ä• ‚à® ‚àÉ a, IsAtom a ‚àß a ‚â§ b
      right
      -- ‚ä¢ ‚àÉ a, IsAtom a ‚àß a ‚â§ b
      have hc' := CompleteLattice.Iic_coatomic_of_compact_element hc
      -- ‚ä¢ ‚àÉ a, IsAtom a ‚àß a ‚â§ b
      rw [‚Üê isAtomic_iff_isCoatomic] at hc'
      -- ‚ä¢ ‚àÉ a, IsAtom a ‚àß a ‚â§ b
      haveI := hc'
      -- ‚ä¢ ‚àÉ a, IsAtom a ‚àß a ‚â§ b
      obtain con | ‚ü®a, ha, hac‚ü© := eq_bot_or_exists_atom_le (‚ü®c, le_refl c‚ü© : Set.Iic c)
      -- ‚ä¢ ‚àÉ a, IsAtom a ‚àß a ‚â§ b
      ¬∑ exfalso
        -- ‚ä¢ False
        apply hcbot
        -- ‚ä¢ c ‚àà {‚ä•}
        simp only [Subtype.ext_iff, Set.Iic.coe_bot, Subtype.coe_mk] at con
        -- ‚ä¢ c ‚àà {‚ä•}
        exact con
        -- üéâ no goals
      rw [‚Üê Subtype.coe_le_coe, Subtype.coe_mk] at hac
      -- ‚ä¢ ‚àÉ a, IsAtom a ‚àß a ‚â§ b
      exact ‚ü®a, ha.of_isAtom_coe_Iic, hac.trans hcb‚ü©‚ü©
      -- üéâ no goals
#align is_atomic_of_complemented_lattice isAtomic_of_complementedLattice

/-- See [Lemma 5.1][calugareanu]. -/
instance (priority := 100) isAtomistic_of_complementedLattice [ComplementedLattice Œ±] :
    IsAtomistic Œ± :=
  ‚ü®fun b =>
    ‚ü®{ a | IsAtom a ‚àß a ‚â§ b }, by
      symm
      -- ‚ä¢ sSup {a | IsAtom a ‚àß a ‚â§ b} = b
      have hle : sSup { a : Œ± | IsAtom a ‚àß a ‚â§ b } ‚â§ b := sSup_le fun _ => And.right
      -- ‚ä¢ sSup {a | IsAtom a ‚àß a ‚â§ b} = b
      apply (lt_or_eq_of_le hle).resolve_left _
      -- ‚ä¢ ¬¨sSup {a | IsAtom a ‚àß a ‚â§ b} < b
      intro con
      -- ‚ä¢ False
      obtain ‚ü®c, hc‚ü© := exists_isCompl (‚ü®sSup { a : Œ± | IsAtom a ‚àß a ‚â§ b }, hle‚ü© : Set.Iic b)
      -- ‚ä¢ False
      obtain rfl | ‚ü®a, ha, hac‚ü© := eq_bot_or_exists_atom_le c
      -- ‚ä¢ False
      ¬∑ exact ne_of_lt con (Subtype.ext_iff.1 (eq_top_of_isCompl_bot hc))
        -- üéâ no goals
      ¬∑ apply ha.1
        -- ‚ä¢ a = ‚ä•
        rw [eq_bot_iff]
        -- ‚ä¢ a ‚â§ ‚ä•
        apply le_trans (le_inf _ hac) hc.disjoint.le_bot
        -- ‚ä¢ a ‚â§ { val := sSup {a | IsAtom a ‚àß a ‚â§ b}, property := hle }
        rw [‚Üê Subtype.coe_le_coe, Subtype.coe_mk]
        -- ‚ä¢ ‚Üëa ‚â§ ‚Üë{ val := sSup {a | IsAtom a ‚àß a ‚â§ b}, property := hle }
        exact le_sSup ‚ü®ha.of_isAtom_coe_Iic, a.2‚ü©, fun _ => And.left‚ü©‚ü©
        -- üéâ no goals
#align is_atomistic_of_complemented_lattice isAtomistic_of_complementedLattice

/-!
Now we will prove that a compactly generated modular atomistic lattice is a complemented lattice.
Most explicitly, every element is the complement of a supremum of indepedendent atoms.
-/

/-- In an atomic lattice, every element `b` has a complement of the form `sSup s`, where each
element of `s` is an atom. See also `complementedLattice_of_sSup_atoms_eq_top`. -/
theorem exists_setIndependent_isCompl_sSup_atoms (h : sSup { a : Œ± | IsAtom a } = ‚ä§) (b : Œ±) :
    ‚àÉ s : Set Œ±, CompleteLattice.SetIndependent s ‚àß
    IsCompl b (sSup s) ‚àß ‚àÄ ‚¶Éa‚¶Ñ, a ‚àà s ‚Üí IsAtom a := by
  -- porting note(https://github.com/leanprover-community/mathlib4/issues/5732):
  -- `obtain` chokes on the placeholder.
  have := zorn_subset
    {s : Set Œ± | CompleteLattice.SetIndependent s ‚àß Disjoint b (sSup s) ‚àß ‚àÄ a ‚àà s, IsAtom a}
    fun c hc1 hc2 =>
      ‚ü®‚ãÉ‚ÇÄ c,
        ‚ü®CompleteLattice.independent_sUnion_of_directed hc2.directedOn fun s hs => (hc1 hs).1, ?_,
          fun a ‚ü®s, sc, as‚ü© => (hc1 sc).2.2 a as‚ü©,
        fun _ => Set.subset_sUnion_of_mem‚ü©
  obtain ‚ü®s, ‚ü®s_ind, b_inf_Sup_s, s_atoms‚ü©, s_max‚ü© := this
  -- ‚ä¢ ‚àÉ s, CompleteLattice.SetIndependent s ‚àß IsCompl b (sSup s) ‚àß ‚àÄ ‚¶Éa : Œ±‚¶Ñ, a ‚àà  ‚Ä¶
  swap
  -- ‚ä¢ Disjoint b (sSup (‚ãÉ‚ÇÄ c))
  ¬∑ rw [sSup_sUnion, ‚Üê sSup_image, DirectedOn.disjoint_sSup_right]
    -- ‚ä¢ ‚àÄ ‚¶Éb_1 : Œ±‚¶Ñ, b_1 ‚àà (fun t => sSup t) '' c ‚Üí Disjoint b b_1
    ¬∑ rintro _ ‚ü®s, hs, rfl‚ü©
      -- ‚ä¢ Disjoint b ((fun t => sSup t) s)
      exact (hc1 hs).2.1
      -- üéâ no goals
    ¬∑ rw [directedOn_image]
      -- ‚ä¢ DirectedOn ((fun t => sSup t) ‚Åª¬π'o fun x x_1 => x ‚â§ x_1) c
      exact hc2.directedOn.mono @fun s t => sSup_le_sSup
      -- üéâ no goals
  refine' ‚ü®s, s_ind, ‚ü®b_inf_Sup_s, _‚ü©, s_atoms‚ü©
  -- ‚ä¢ Codisjoint b (sSup s)
  rw [codisjoint_iff_le_sup, ‚Üê h, sSup_le_iff]
  -- ‚ä¢ ‚àÄ (b_1 : Œ±), b_1 ‚àà {a | IsAtom a} ‚Üí b_1 ‚â§ b ‚äî sSup s
  intro a ha
  -- ‚ä¢ a ‚â§ b ‚äî sSup s
  rw [‚Üê inf_eq_left]
  -- ‚ä¢ a ‚äì (b ‚äî sSup s) = a
  refine' (ha.le_iff.mp inf_le_left).resolve_left fun con => ha.1 _
  -- ‚ä¢ a = ‚ä•
  rw [‚Üê con, eq_comm, inf_eq_left]
  -- ‚ä¢ a ‚â§ b ‚äî sSup s
  refine' (le_sSup _).trans le_sup_right
  -- ‚ä¢ a ‚àà s
  rw [‚Üê disjoint_iff] at con
  -- ‚ä¢ a ‚àà s
  have a_dis_Sup_s : Disjoint a (sSup s) := con.mono_right le_sup_right
  -- ‚ä¢ a ‚àà s
  -- porting note: The two following `fun x hx => _` are no-op
  rw [‚Üê s_max (s ‚à™ {a}) ‚ü®fun x hx => _, _, fun x hx => _‚ü© (Set.subset_union_left _ _)]
  ¬∑ exact Set.mem_union_right _ (Set.mem_singleton _)
    -- üéâ no goals
  ¬∑ intro x hx
    -- ‚ä¢ Disjoint x (sSup ((s ‚à™ {a}) \ {x}))
    rw [Set.mem_union, Set.mem_singleton_iff] at hx
    -- ‚ä¢ Disjoint x (sSup ((s ‚à™ {a}) \ {x}))
    obtain rfl | xa := eq_or_ne x a
    -- ‚ä¢ Disjoint x (sSup ((s ‚à™ {x}) \ {x}))
    ¬∑ simp only [Set.mem_singleton, Set.insert_diff_of_mem, Set.union_singleton]
      -- ‚ä¢ Disjoint x (sSup (s \ {x}))
      exact con.mono_right ((sSup_le_sSup <| Set.diff_subset _ _).trans le_sup_right)
      -- üéâ no goals
    ¬∑ have h : (s ‚à™ {a}) \ {x} = s \ {x} ‚à™ {a} := by
        simp only [Set.union_singleton]
        rw [Set.insert_diff_of_not_mem]
        rw [Set.mem_singleton_iff]
        exact Ne.symm xa
      rw [h, sSup_union, sSup_singleton]
      -- ‚ä¢ Disjoint x (sSup (s \ {x}) ‚äî a)
      apply
        (s_ind (hx.resolve_right xa)).disjoint_sup_right_of_disjoint_sup_left
          (a_dis_Sup_s.mono_right _).symm
      rw [‚Üê sSup_insert, Set.insert_diff_singleton, Set.insert_eq_of_mem (hx.resolve_right xa)]
      -- üéâ no goals
  ¬∑ rw [sSup_union, sSup_singleton]
    -- ‚ä¢ Disjoint b (sSup s ‚äî a)
    exact b_inf_Sup_s.disjoint_sup_right_of_disjoint_sup_left con.symm
    -- üéâ no goals
  ¬∑ intro x hx
    -- ‚ä¢ IsAtom x
    rw [Set.mem_union, Set.mem_singleton_iff] at hx
    -- ‚ä¢ IsAtom x
    obtain hx | rfl := hx
    -- ‚ä¢ IsAtom x
    ¬∑ exact s_atoms x hx
      -- üéâ no goals
    ¬∑ exact ha
      -- üéâ no goals
#align exists_set_independent_is_compl_Sup_atoms exists_setIndependent_isCompl_sSup_atoms

theorem exists_setIndependent_of_sSup_atoms_eq_top (h : sSup { a : Œ± | IsAtom a } = ‚ä§) :
    ‚àÉ s : Set Œ±, CompleteLattice.SetIndependent s ‚àß sSup s = ‚ä§ ‚àß ‚àÄ ‚¶Éa‚¶Ñ, a ‚àà s ‚Üí IsAtom a :=
  let ‚ü®s, s_ind, s_top, s_atoms‚ü© := exists_setIndependent_isCompl_sSup_atoms h ‚ä•
  ‚ü®s, s_ind, eq_top_of_isCompl_bot s_top.symm, s_atoms‚ü©
#align exists_set_independent_of_Sup_atoms_eq_top exists_setIndependent_of_sSup_atoms_eq_top

/-- See [Theorem 6.6][calugareanu]. -/
theorem complementedLattice_of_sSup_atoms_eq_top (h : sSup { a : Œ± | IsAtom a } = ‚ä§) :
    ComplementedLattice Œ± :=
  ‚ü®fun b =>
    let ‚ü®s, _, s_top, _‚ü© := exists_setIndependent_isCompl_sSup_atoms h b
    ‚ü®sSup s, s_top‚ü©‚ü©
#align complemented_lattice_of_Sup_atoms_eq_top complementedLattice_of_sSup_atoms_eq_top

/-- See [Theorem 6.6][calugareanu]. -/
theorem complementedLattice_of_isAtomistic [IsAtomistic Œ±] : ComplementedLattice Œ± :=
  complementedLattice_of_sSup_atoms_eq_top sSup_atoms_eq_top
#align complemented_lattice_of_is_atomistic complementedLattice_of_isAtomistic

theorem complementedLattice_iff_isAtomistic : ComplementedLattice Œ± ‚Üî IsAtomistic Œ± := by
  constructor <;> intros
  -- ‚ä¢ ComplementedLattice Œ± ‚Üí IsAtomistic Œ±
                  -- ‚ä¢ IsAtomistic Œ±
                  -- ‚ä¢ ComplementedLattice Œ±
  ¬∑ exact isAtomistic_of_complementedLattice
    -- üéâ no goals
  ¬∑ exact complementedLattice_of_isAtomistic
    -- üéâ no goals
#align complemented_lattice_iff_is_atomistic complementedLattice_iff_isAtomistic

end
