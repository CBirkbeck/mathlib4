/-
Copyright (c) 2022 Floris van Doorn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Floris van Doorn

! This file was ported from Lean 3 source module main
-/
import Mathlib.MeasureTheory.Constructions.Pi
import Mathlib.MeasureTheory.Integral.IntegralEqImproper
import Mathlib.MeasureTheory.Integral.MeanInequalities
import Mathlib.MeasureTheory.Constructions.Prod.Integral
import Mathlib.MeasureTheory.Measure.Lebesgue.EqHaar
import Mathlib.Analysis.Calculus.ContDiff
import Mathlib.Analysis.Calculus.Deriv.Support

/-!
# Marginals of multivariate functions
-/


open scoped Classical BigOperators Topology ENNReal
open Filter

noncomputable section

variable {Œπ Œπ' Œπ'' : Type _}

section Finset

open Finset

namespace Real

theorem prod_rpow {Œπ} (s : Finset Œπ) {f : Œπ ‚Üí ‚Ñù} (hf : 0 ‚â§ f) (r : ‚Ñù) :
    ‚àè i in s, f i ^ r = (‚àè i in s, f i) ^ r :=
  finset_prod_rpow s f (fun i _ ‚Ü¶ hf i) r

end Real

namespace NNReal

local macro_rules | `($x ^ $y) => `(HPow.hPow $x $y) -- Porting note: See issue lean4#2220

theorem rpow_add_of_nonneg (x : ‚Ñù‚â•0) {y z : ‚Ñù} (hy : 0 ‚â§ y) (hz : 0 ‚â§ z) :
  x ^ (y + z) = x ^ y * x ^ z := by
  by_cases h : y + z = 0
  ¬∑ obtain rfl : y = 0 := by linarith
    obtain rfl : z = 0 := by linarith
    simp [h]
  ¬∑ exact rpow_add' _ h

end NNReal

namespace ENNReal

open NNReal

theorem rpow_add_of_nonneg {x : ‚Ñù‚â•0‚àû} (y z : ‚Ñù) (hy : 0 ‚â§ y) (hz : 0 ‚â§ z) :
    x ^ (y + z) = x ^ y * x ^ z := by
  induction x using recTopCoe
  ¬∑ rcases hy.eq_or_lt with rfl|hy
    ¬∑ rw [rpow_zero, one_mul, zero_add]
    rcases hz.eq_or_lt with rfl|hz
    ¬∑ rw [rpow_zero, mul_one, add_zero]
    simp [top_rpow_of_pos, hy, hz, add_pos hy hz]
  simp [coe_rpow_of_nonneg, hy, hz, add_nonneg hy hz, NNReal.rpow_add_of_nonneg _ hy hz]

theorem prod_rpow_of_nonneg {Œπ} {s : Finset Œπ} {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} {r : ‚Ñù} (hr : 0 ‚â§ r) :
    ‚àè i in s, f i ^ r = (‚àè i in s, f i) ^ r := by
  induction s using Finset.induction
  case empty => simp
  case insert i s hi ih => simp_rw [prod_insert hi, ih, ‚Üê mul_rpow_of_nonneg _ _ hr]

-- unused
theorem prod_rpow_of_ne_top {Œπ} {s : Finset Œπ} {f : Œπ ‚Üí ‚Ñù‚â•0‚àû} (hf : ‚àÄ i ‚àà s, f i ‚â† ‚àû) (r : ‚Ñù) :
    ‚àè i in s, f i ^ r = (‚àè i in s, f i) ^ r := by
  induction s using Finset.induction
  case empty => simp
  case insert i s hi ih =>
    have h2f : ‚àÄ i ‚àà s, f i ‚â† ‚àû := fun i hi ‚Ü¶ hf i <| mem_insert_of_mem hi
    rw [prod_insert hi, prod_insert hi, ih h2f, ‚Üê mul_rpow_of_ne_top <| hf i <| mem_insert_self ..]
    apply prod_lt_top h2f |>.ne

-- unused
theorem prod_coe_rpow {Œπ} (s : Finset Œπ) (f : Œπ ‚Üí ‚Ñù‚â•0) (r : ‚Ñù) :
    ‚àè i in s, (f i : ‚Ñù‚â•0‚àû) ^ r = ((‚àè i in s, f i : ‚Ñù‚â•0) : ‚Ñù‚â•0‚àû) ^ r := by
  induction s using Finset.induction
  case empty => simp
  case insert i s hi ih => simp_rw [prod_insert hi, ih, ‚Üê coe_mul_rpow, coe_mul]

end ENNReal


variable {Œ± Œ≤ Œ≥ : Type _}

theorem Equiv.finset_image_univ_eq_univ [Fintype Œ±] [Fintype Œ≤] (f : Œ± ‚âÉ Œ≤) : univ.image f = univ :=
  Finset.image_univ_of_surjective f.surjective

variable [CommMonoid Œ≤]

-- very similar to `equiv.prod_comp_finset` in #16948
theorem Finset.prod_comp_equiv {s : Finset Œ±} (f : Œ≥ ‚Üí Œ≤) (g : Œ± ‚âÉ Œ≥) :
    ‚àè a in s, f (g a) = ‚àè b in s.image g, f b :=
  by
  refine'
    prod_bij' (fun x _ => g x) (fun a ha => Finset.mem_image_of_mem _ ha) (fun _ _ => rfl)
      (fun a _ => g.symm a) _ (fun a _ => g.symm_apply_apply a) fun a _ => g.apply_symm_apply a
  simp only [Finset.mem_image, exists_imp]
  rintro _ _ ‚ü®_, rfl‚ü©
  simpa

theorem prod_univ_comp_equiv [Fintype Œ±] [Fintype Œ≥] (f : Œ≥ ‚Üí Œ≤) (g : Œ± ‚âÉ Œ≥) :
    ‚àè a, f (g a) = ‚àè b, f b :=
  g.prod_comp f

namespace Function

@[simp] theorem comp_def (f : Œ≤ ‚Üí Œ≥) (g : Œ± ‚Üí Œ≤) : f ‚àò g = fun x => f (g x) := rfl

end Function

namespace Finset

theorem insert_compl_insert [Fintype Œπ] {s : Finset Œπ} {i : Œπ} (hi : i ‚àâ s) :
    insert i (insert i s)·∂ú = s·∂ú := by
  simp_rw [@eq_compl_comm _ _ s, compl_insert, compl_erase, compl_compl, erase_insert hi]

-- no longer needed
-- @[to_additive]
-- theorem mul_prod_eq_prod_insertNone {Œ±} {M} [CommMonoid M] (f : Œ± ‚Üí M) (x : M) (s : Finset Œ±) :
--     x * ‚àè i in s, f i = ‚àè i in insertNone s, i.elim x f :=
--   (prod_insertNone (fun i => i.elim x f) _).symm

-- to Fintype/Sum
@[to_additive]
theorem prod_sum_univ [Fintype Œ±] [Fintype Œ≥] (f : Œ± ‚äï Œ≥ ‚Üí Œ≤) :
    ‚àè x, f x = (‚àè x, f (Sum.inl x)) * ‚àè x, f (Sum.inr x) := by
  rw [‚Üê univ_disjSum_univ, prod_disj_sum]

@[simp]
theorem card_add_card_compl [Fintype Œ±] (s : Finset Œ±) : s.card + s·∂ú.card = Fintype.card Œ± := by
  rw [Finset.card_compl, ‚Üê Nat.add_sub_assoc (card_le_univ s), Nat.add_sub_cancel_left]

@[simp]
theorem cast_card_erase_of_mem [AddGroupWithOne R] {s : Finset Œ±} (hs : a ‚àà s) :
    ((s.erase a).card : R) = s.card - 1 := by
  rw [card_erase_of_mem hs, Nat.cast_sub, Nat.cast_one]
  rw [Nat.add_one_le_iff, Finset.card_pos]
  exact ‚ü®a, hs‚ü©

instance : Unique ({i} : Finset Œ¥) :=
  ‚ü®‚ü®‚ü®i, mem_singleton_self i‚ü©‚ü©, fun j ‚Ü¶ Subtype.ext <| mem_singleton.mp j.2‚ü©

@[simp]
lemma default_singleton : ((default : ({i} : Finset Œ¥)) : Œ¥) = i := rfl

lemma none_mem_insertNone {s : Finset Œ±} : none ‚àà insertNone s := by simp

lemma insertNone_nonempty {s : Finset Œ±} : insertNone s |>.Nonempty := ‚ü®none, none_mem_insertNone‚ü©

end Finset

end Finset

section Calculus

variable {ùïú : Type _} [NontriviallyNormedField ùïú] [Fintype Œπ]

variable {E : Œπ ‚Üí Type _} [‚àÄ i, NormedAddCommGroup (E i)] [‚àÄ i, NormedSpace ùïú (E i)]

variable {F : Type _} [NormedAddCommGroup F] [NormedSpace ùïú F]

theorem contDiff_update (k : ‚Ñï‚àû) (x : ‚àÄ i, E i) (i : Œπ) : ContDiff ùïú k (Function.update x i) := by
  rw [contDiff_pi]
  intro j
  dsimp [Function.update]
  split_ifs with h
  ¬∑ subst h
    exact contDiff_id
  ¬∑ exact contDiff_const

theorem hasFDerivAt_sub_const {ùïú : Type _} [NontriviallyNormedField ùïú] {E : Type _}
    [NormedAddCommGroup E] [NormedSpace ùïú E]  {x : E} (c : E) :
    HasFDerivAt (¬∑ - c) (ContinuousLinearMap.id ùïú (E)) x :=
  (hasFDerivAt_id x).sub_const c

theorem hasFDerivAt_update {x : ‚àÄ i, E i} {i : Œπ} (y : E i) :
    HasFDerivAt (Function.update x i)
      (ContinuousLinearMap.pi (Function.update 0 i (ContinuousLinearMap.id ùïú (E i)))) y := by
  set l := (ContinuousLinearMap.pi (Function.update 0 i (ContinuousLinearMap.id ùïú (E i))))
  have update_eq : Function.update x i = (fun _ ‚Ü¶ x) + l ‚àò (¬∑ - x i)
  ¬∑ ext t j
    dsimp [Function.update]
    split_ifs with hji
    ¬∑ subst hji
      simp
    ¬∑ simp
  rw [update_eq]
  convert (hasFDerivAt_const _ _).add (l.hasFDerivAt.comp y (hasFDerivAt_sub_const (x i)))
  rw [zero_add, ContinuousLinearMap.comp_id]

theorem fderiv_update {x : ‚àÄ i, E i} {i : Œπ} (y : E i) :
    fderiv ùïú (Function.update x i) y =
      ContinuousLinearMap.pi (Function.update 0 i (ContinuousLinearMap.id ùïú (E i))) :=
  (hasFDerivAt_update y).fderiv

theorem hasDerivAt_update {x : Œπ ‚Üí ùïú} {i : Œπ} (y : ùïú) :
    HasDerivAt (Function.update x i) (Pi.single i (1:ùïú)) y := by
  convert (hasFDerivAt_update (E := fun _ ‚Ü¶ ùïú) y).hasDerivAt
  ext z j
  rw [Pi.single, Function.update_apply]
  split_ifs with h
  ¬∑ simp [h]
  ¬∑ simp [Function.update_noteq h]

theorem deriv_update {x : Œπ ‚Üí ùïú} {i : Œπ} (y : ùïú) :
    deriv (Function.update x i) y = (Pi.single i (1:ùïú)) :=
  (hasDerivAt_update y).deriv

open NNReal

theorem Pi.nnnorm_single (y : E i) : ‚ÄñPi.single i y‚Äñ‚Çä = ‚Äñy‚Äñ‚Çä := by
  classical
  have H : ‚àÄ b, ‚Äñsingle i y b‚Äñ‚Çä = single (f := fun _ ‚Ü¶ ‚Ñù‚â•0) i ‚Äñy‚Äñ‚Çä b
  ¬∑ intro b
    refine Pi.apply_single (fun i (x : E i) ‚Ü¶ ‚Äñx‚Äñ‚Çä) ?_ i y b
    simp
  simp [Pi.nnnorm_def, H, Pi.single_apply, Finset.sup_ite,
    Finset.filter_eq' (Finset.univ : Finset Œπ)]

theorem Pi.norm_single (y : E i) : ‚ÄñPi.single i y‚Äñ = ‚Äñy‚Äñ :=
  congr_arg Subtype.val (Pi.nnnorm_single y)

end Calculus

section RealCalculus

open Set MeasureTheory

variable {E : Type*} {f f' : ‚Ñù ‚Üí E} {g g' : ‚Ñù ‚Üí ‚Ñù} {a b l : ‚Ñù} {m : E} [NormedAddCommGroup E]
  [NormedSpace ‚Ñù E] [CompleteSpace E]

/-- **Fundamental theorem of calculus-2**, on semi-infinite intervals `(-‚àû, a)`.
When a function has a limit `m` at `-‚àû`, and its derivative is integrable, then the
integral of the derivative on `(-‚àû, a)` is `f a - m`. Version assuming differentiability
on `(-‚àû, a)` and continuity on `(-‚àû, a]`.-/
theorem integral_Iio_of_hasDerivAt_of_tendsto (hcont : ContinuousOn f (Iic a))
    (hderiv : ‚àÄ x ‚àà Iio a, HasDerivAt f (f' x) x) (f'int : IntegrableOn f' (Iic a))
    (hf : Tendsto f atBot (ùìù m)) : ‚à´ x in Iic a, f' x = f a - m := by
  refine' tendsto_nhds_unique (intervalIntegral_tendsto_integral_Iic a f'int tendsto_id) _
  apply Tendsto.congr' _ (hf.const_sub _)
  filter_upwards [Iic_mem_atBot a] with x hx
  symm
  apply intervalIntegral.integral_eq_sub_of_hasDerivAt_of_le hx
    (hcont.mono Icc_subset_Iic_self) fun y hy => hderiv y hy.2
  rw [intervalIntegrable_iff_integrable_Ioc_of_le hx]
  exact f'int.mono (fun y hy => hy.2) le_rfl

theorem atBot_le_cocompact : atBot ‚â§ cocompact ‚Ñù := by simp
theorem atTop_le_cocompact : atTop ‚â§ cocompact ‚Ñù := by simp

theorem _root_.Filter.EventuallyEq.tendsto [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±} {a : Œ≤}
    (hf : f =·∂†[l] fun _ ‚Ü¶ a) : Tendsto f l (ùìù a) :=
  tendsto_nhds_of_eventually_eq hf

-- very special case of `integral_Iio_of_hasDerivAt_of_tendsto`.
theorem _root_.HasCompactSupport.integral_deriv_eq {f : ‚Ñù ‚Üí E} (hf : ContDiff ‚Ñù 1 f)
    (h2f : HasCompactSupport f) (b : ‚Ñù) : ‚à´ x in Iic b, deriv f x = f b := by
  have := fun x (_ : x ‚àà Iio b) ‚Ü¶ hf.differentiable le_rfl x |>.hasDerivAt
  rw [integral_Iio_of_hasDerivAt_of_tendsto hf.continuous.continuousOn this, sub_zero]
  refine hf.continuous_deriv le_rfl |>.integrable_of_hasCompactSupport h2f.deriv |>.integrableOn
  rw [hasCompactSupport_iff_eventuallyEq, Filter.coclosedCompact_eq_cocompact] at h2f
  exact h2f.filter_mono atBot_le_cocompact |>.tendsto

end RealCalculus

section Logic

open Sum

@[simp]
theorem imp_and_neg_imp_iff (p q : Prop) : (p ‚Üí q) ‚àß (¬¨p ‚Üí q) ‚Üî q := by
  simp_rw [imp_iff_or_not, not_not, ‚Üê or_and_left, not_and_self_iff, or_false_iff]

theorem cast_sum_rec {Œ± Œ≤ : Type _} {P : Œ± ‚äï Œ≤ ‚Üí Sort _} (f : ‚àÄ i, P (inl i)) (g : ‚àÄ j, P (inr j))
    (x y : Œ± ‚äï Œ≤) (h : x = y) :
    cast (congr_arg P h) (@Sum.rec _ _ _ f g x) = @Sum.rec _ _ _ f g y := by cases h; rfl

theorem Eq.rec_eq_cast {Œ± : Sort _} {P : Œ± ‚Üí Sort _} {x y : Œ±} (h : x = y) (z : P x) :
    h ‚ñ∏ z = cast (congr_arg P h) z := by induction h; rfl

end Logic

open Set
namespace Equiv
open Set

-- simps doesn't work from another module :-(
lemma piCongrLeft_apply {P : Œ≤ ‚Üí Sort v} {e : Œ± ‚âÉ Œ≤}
    (f : (a : Œ±) ‚Üí P (e a)) (b : Œ≤) :
    piCongrLeft P e f b = cast (congr_arg P (e.apply_symm_apply b)) (f (e.symm b)) :=
  Eq.rec_eq_cast _ _

lemma piCongrLeft_symm_apply {P : Œ≤ ‚Üí Sort v} {e : Œ± ‚âÉ Œ≤}
    (g : (b : Œ≤) ‚Üí P b) (a : Œ±) :
    (piCongrLeft P e).symm g a = g (e a) := rfl

lemma subtypeEquivRight_apply {p q : Œ± ‚Üí Prop} (e : ‚àÄ x, p x ‚Üî q x)
    (z : { x // p x }) : subtypeEquivRight e z = ‚ü®z, (e z.1).mp z.2‚ü© := rfl

lemma subtypeEquivRight_symm_apply {p q : Œ± ‚Üí Prop} (e : ‚àÄ x, p x ‚Üî q x)
    (z : { x // q x }) : (subtypeEquivRight e).symm z = ‚ü®z, (e z.1).mpr z.2‚ü© := rfl

variable {Œ± : Œπ ‚Üí Type _}

theorem piCongrLeft_symm_preimage_pi (f : Œπ' ‚âÉ Œπ) (s : Set Œπ) (t : ‚àÄ i, Set (Œ± i)) :
    ((f.piCongrLeft Œ±).symm ‚Åª¬π' (f ‚Åª¬π' s).pi fun i' => t <| f i') = s.pi t := by
  ext; simp_rw [mem_preimage, Set.mem_pi, piCongrLeft_symm_apply]
  convert f.forall_congr_left; rfl

theorem piCongrLeft_preimage_univ_pi (f : Œπ' ‚âÉ Œπ) (t : ‚àÄ i, Set (Œ± i)) :
    f.piCongrLeft Œ± ‚Åª¬π' pi univ t = pi univ fun i => t (f i) := by
  apply Set.ext; rw [‚Üê (f.piCongrLeft Œ±).symm.forall_congr_left]
  intro x; simp_rw [mem_preimage, apply_symm_apply, piCongrLeft_symm_apply, mem_univ_pi]
  exact f.forall_congr_left.symm

open Sum

/-- The type of dependent functions on a sum type `Œπ ‚äï Œπ'` is equivalent to the type of pairs of
  functions on `Œπ` and on `Œπ'`. This is a dependent version of `equiv.sum_arrow_equiv_prod_arrow`. -/
@[simps]
def piSum (œÄ : Œπ ‚äï Œπ' ‚Üí Type _) : ((‚àÄ i, œÄ (inl i)) √ó ‚àÄ i', œÄ (inr i')) ‚âÉ ‚àÄ i, œÄ i
    where
  toFun f := Sum.rec f.1 f.2
  invFun g := ‚ü®fun i => g (inl i), fun i' => g (inr i')‚ü©
  left_inv f := Prod.ext rfl rfl
  right_inv g := by ext (i | i) <;> rfl

/-- unused -/
def piSum' (œÄ : Œπ ‚Üí Type _) (œÄ' : Œπ' ‚Üí Type _) :
    ((‚àÄ i, œÄ i) √ó ‚àÄ i', œÄ' i') ‚âÉ ‚àÄ i, Sum.elim œÄ œÄ' i :=
  Equiv.piSum (Sum.elim œÄ œÄ')

theorem piSum_preimage_univ_pi (œÄ : Œπ ‚äï Œπ' ‚Üí Type _) (t : ‚àÄ i, Set (œÄ i)) :
    piSum œÄ  ‚Åª¬π' pi univ t = pi univ (fun i => t (.inl i)) √óÀ¢ pi univ fun i => t (.inr i) := by
  ext
  simp_rw [mem_preimage, mem_prod, mem_univ_pi, piSum_apply]
  constructor
  ¬∑ intro h; constructor <;> intro i <;> apply h
  ¬∑ rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© (i|i) <;> simp <;> apply_assumption

theorem Set.union_apply_left' {Œ±} {s t : Set Œ±} [DecidablePred fun x => x ‚àà s] (H : s ‚à© t ‚äÜ ‚àÖ)
    {a : Œ±} (ha : a ‚àà s) : Equiv.Set.union H ‚ü®a, Set.mem_union_left _ ha‚ü© = Sum.inl ‚ü®a, ha‚ü© :=
  dif_pos ha

theorem Set.union_apply_right' {Œ±} {s t : Set Œ±} [DecidablePred fun x => x ‚àà s] (H : s ‚à© t ‚äÜ ‚àÖ)
    {a : Œ±} (ha : a ‚àà t) : Equiv.Set.union H ‚ü®a, Set.mem_union_right _ ha‚ü© = Sum.inr ‚ü®a, ha‚ü© :=
  dif_neg fun h => H ‚ü®h, ha‚ü©

theorem sum_rec_congr (P : Œπ ‚äï Œπ' ‚Üí Sort _) (f : ‚àÄ i, P (inl i)) (g : ‚àÄ i, P (inr i))
    {x y : Œπ ‚äï Œπ'} (h : x = y) :
    @Sum.rec _ _ _ f g x = cast (congr_arg P h.symm) (@Sum.rec _ _ _ f g y) := by cases h; rfl

theorem piCongrLeft_sum_inl (œÄ : Œπ'' ‚Üí Type _) (e : Œπ ‚äï Œπ' ‚âÉ Œπ'') (f : ‚àÄ i, œÄ (e (inl i)))
    (g : ‚àÄ i, œÄ (e (inr i))) (i : Œπ) :
    piCongrLeft œÄ e (piSum (fun x => œÄ (e x)) (f, g)) (e (inl i)) = f i := by
  simp_rw [piCongrLeft_apply, piSum_apply, sum_rec_congr _ _ _ (e.symm_apply_apply (inl i)),
    cast_cast, cast_eq]

theorem piCongrLeft_sum_inr (œÄ : Œπ'' ‚Üí Type _) (e : Œπ ‚äï Œπ' ‚âÉ Œπ'') (f : ‚àÄ i, œÄ (e (inl i)))
    (g : ‚àÄ i, œÄ (e (inr i))) (j : Œπ') :
    piCongrLeft œÄ e (piSum (fun x => œÄ (e x)) (f, g)) (e (inr j)) = g j := by
  simp_rw [piCongrLeft_apply, piSum_apply, sum_rec_congr _ _ _ (e.symm_apply_apply (inr j)),
    cast_cast, cast_eq]

end Equiv

namespace Option

theorem elim'_comp {Œπ Œ± Œ≤} (h : Œ± ‚Üí Œ≤) {f : Œπ ‚Üí Œ±} {x : Œ±} {i : Option Œπ} :
    (i.elim (h x) fun j => h (f j)) = h (i.elim x f) := by cases i <;> rfl

theorem elim'_comp‚ÇÇ {Œπ Œ± Œ≤ Œ≥} (h : Œ± ‚Üí Œ≤ ‚Üí Œ≥) {f : Œπ ‚Üí Œ±} {x : Œ±} {g : Œπ ‚Üí Œ≤} {y : Œ≤}
    {i : Option Œπ} : (i.elim (h x y) fun j => h (f j) (g j)) = h (i.elim x f) (i.elim y g) := by
  cases i <;> rfl

theorem elim'_apply {Œ± Œ≤ Œπ : Type _} {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {x : Œ± ‚Üí Œ≤} {i : Option Œπ} {y : Œ±} :
    i.elim x f y = i.elim (x y) fun j => f j y := by rw [elim'_comp fun f : Œ± ‚Üí Œ≤ => f y]

end Option

open Function MeasureTheory.OuterMeasure MeasurableSpace Equiv

section Set

open Set

-- @[simps apply symm_apply]
/-- `s ‚à™ t` (using finset union) is equivalent to `s ‚à™ t` (using set union) -/
def Equiv.finsetUnion {Œ±} (s t : Finset Œ±) : ((s ‚à™ t : Finset Œ±) : Set Œ±) ‚âÉ (s ‚à™ t : Set Œ±) :=
  subtypeEquivRight <| by simp

/-- The disjoint union of finsets is a sum -/
def finsetUnionEquivSum {Œ±} (s t : Finset Œ±) (h : Disjoint s t) : (s ‚à™ t : Finset Œ±) ‚âÉ s ‚äï t :=
  (Equiv.finsetUnion s t).trans <| Equiv.Set.union <| by
    rw [‚Üê Finset.coe_inter, ‚Üê Finset.coe_empty]
    exact h.le_bot

@[simp]
theorem finsetUnionEquivSum_symm_inl {Œ±} {s t : Finset Œ±} (h : Disjoint s t) (x : s) :
    (finsetUnionEquivSum s t h).symm (Sum.inl x) = ‚ü®x, Finset.mem_union.mpr <| Or.inl x.2‚ü© :=
  rfl

@[simp]
theorem finsetUnionEquivSum_symm_inr {Œ±} {s t : Finset Œ±} (h : Disjoint s t) (y : t) :
    (finsetUnionEquivSum s t h).symm (Sum.inr y) = ‚ü®y, Finset.mem_union.mpr <| Or.inr y.2‚ü© :=
  rfl

@[simp]
theorem finsetUnionEquivSum_symm_inl' {Œ±} {s t : Finset Œ±} (h : Disjoint s t) (x : Œ±) (hx : x ‚àà s)
    (h2x : x ‚àà s ‚à™ t) : (finsetUnionEquivSum s t h).symm (Sum.inl ‚ü®x, hx‚ü©) = ‚ü®x, h2x‚ü© :=
  rfl

@[simp]
theorem finsetUnionEquivSum_symm_inr' {Œ±} {s t : Finset Œ±} (h : Disjoint s t) (y : t) :
    (finsetUnionEquivSum s t h).symm (Sum.inr y) = ‚ü®y, Finset.mem_union.mpr <| Or.inr y.2‚ü© :=
  rfl

theorem iUnion_univ_pi {Œπ Œπ‚ÇÇ} {Œ± : Œπ ‚Üí Type _} (t : ‚àÄ i, Œπ‚ÇÇ ‚Üí Set (Œ± i)) :
    (‚ãÉ x : Œπ ‚Üí Œπ‚ÇÇ, pi univ fun i => t i (x i)) = pi univ fun i => ‚ãÉ j : Œπ‚ÇÇ, t i j := by
  ext
  simp [Classical.skolem]

theorem eval_preimage {Œπ} {Œ± : Œπ ‚Üí Type _} {i : Œπ} {s : Set (Œ± i)} :
    eval i ‚Åª¬π' s = pi univ (update (fun i => univ) i s) := by
  ext x
  simp [@forall_update_iff _ (fun i => Set (Œ± i)) _ _ _ _ fun i' y => x i' ‚àà y]

theorem eval_preimage' {Œπ} {Œ± : Œπ ‚Üí Type _} {i : Œπ} {s : Set (Œ± i)} :
    eval i ‚Åª¬π' s = pi {i} (update (fun i => univ) i s) := by ext; simp

theorem mem_pi_univ {Œπ : Type _} {Œ± : Œπ ‚Üí Type _} (t : ‚àÄ i, Set (Œ± i)) (x : ‚àÄ i, Œ± i) :
    x ‚àà pi univ t ‚Üî ‚àÄ i, x i ‚àà t i := by simp

theorem pi_univ_ite {Œπ} {Œ± : Œπ ‚Üí Type _} (s : Set Œπ) (t : ‚àÄ i, Set (Œ± i)) :
    (pi univ fun i => if i ‚àà s then t i else univ) = s.pi t := by
  ext; simp_rw [Set.mem_pi]; apply forall_congr'; intro i; split_ifs with h <;> simp [h]

theorem pi_univ_eq_iInter {Œπ} {Œ± : Œπ ‚Üí Type _} (t : ‚àÄ i, Set (Œ± i)) :
    pi univ t = ‚ãÇ i, eval i ‚Åª¬π' t i := by simp_rw [pi_def, mem_univ, iInter_true]

end Set


section Function

open Set

variable {Œ± : Œπ ‚Üí Type _}

/-- Given one value over a unique, we get a dependent function. -/
def uniqueElim [Unique Œπ] (x : Œ± (default : Œπ)) (i : Œπ) : Œ± i := by
  rw [Unique.eq_default i]
  exact x

@[simp]
theorem uniqueElim_default {_ : Unique Œπ} (x : Œ± (default : Œπ)) : uniqueElim x (default : Œπ) = x :=
  rfl

theorem uniqueElim_preimage [Unique Œπ] (t : ‚àÄ i, Set (Œ± i)) :
    uniqueElim ‚Åª¬π' pi univ t = t (default : Œπ) := by ext; simp [Unique.forall_iff]

theorem pred_update {Œ±} {Œ≤ : Œ± ‚Üí Type _} (P : ‚àÄ ‚¶Éa‚¶Ñ, Œ≤ a ‚Üí Prop) (f : ‚àÄ a, Œ≤ a) (a' : Œ±) (v : Œ≤ a')
    (a : Œ±) : P (update f a' v a) ‚Üî a = a' ‚àß P v ‚à® a ‚â† a' ‚àß P (f a) := by
  rw [update]
  split_ifs with h
  ¬∑ subst h
    simp
  ¬∑ rw [‚Üê Ne.def] at h
    simp [h]

theorem surjective_decode_iget (Œ± : Type _) [Encodable Œ±] [Inhabited Œ±] :
    Surjective fun n => (Encodable.decode (Œ± := Œ±) n).iget := fun x =>
  ‚ü®Encodable.encode x, by simp_rw [Encodable.encodek]‚ü©


variable {Œπ : Sort _} {œÄ : Œπ ‚Üí Sort _} {x : ‚àÄ i, œÄ i}

/-- `updateSet x s y` is the vector `x` with the coordinates in `s` changed to the values of `y`. -/
def updateSet (x : ‚àÄ i, œÄ i) (s : Finset Œπ) (y : ‚àÄ i : ‚Ü•s, œÄ i) (i : Œπ) : œÄ i :=
  if hi : i ‚àà s then y ‚ü®i, hi‚ü© else x i

/-
todo: do `updateSet` this for SetLike, like this:
```
def updateSet {ùì¢} [SetLike ùì¢ Œπ] (s : ùì¢) (x : ‚àÄ i, œÄ i) (y : ‚àÄ i : ‚Ü•s, œÄ i) (i : Œπ) : œÄ i :=
  if hi : i ‚àà s then y ‚ü®i, hi‚ü© else x i
```
however, `Finset` is not currently `SetLike`.
```
instance : SetLike (Finset Œπ) Œπ where
  coe := (¬∑.toSet)
  coe_injective' := coe_injective
```
-/

open Finset
theorem updateSet_empty {y} : updateSet x ‚àÖ y = x :=
  rfl
theorem updateSet_singleton {i y} :
    updateSet x {i} y = Function.update x i (y ‚ü®i, mem_singleton_self i‚ü©) := by
  congr with j
  by_cases hj : j = i
  ¬∑ cases hj
    simp only [dif_pos, Finset.mem_singleton, update_same, updateSet]
  ¬∑ simp [hj, updateSet]

theorem update_eq_updateSet {i y} :
    Function.update x i y = updateSet x {i} (uniqueElim y) := by
  congr with j
  by_cases hj : j = i
  ¬∑ cases hj
    simp only [dif_pos, Finset.mem_singleton, update_same, updateSet]
    exact uniqueElim_default (Œ± := fun j : ({i} : Finset Œπ) => œÄ j) y
  ¬∑ simp [hj, updateSet]

theorem updateSet_updateSet {s t : Finset Œπ} (hst : Disjoint s t) {y z} :
    updateSet (updateSet x s y) t z =
    updateSet x (s ‚à™ t)
      (Equiv.piCongrLeft (fun i : ‚Ü•(s ‚à™ t) ‚Ü¶ œÄ i) (finsetUnionEquivSum s t hst).symm <|
      Equiv.piSum _ ‚ü®y, z‚ü©) := by
  set e‚ÇÅ := finsetUnionEquivSum s t hst |>.symm
  congr with i
  by_cases his : i ‚àà s <;> by_cases hit : i ‚àà t <;>
    simp only [updateSet, his, hit, dif_pos, dif_neg, Finset.mem_union, true_or_iff, false_or_iff,
      not_false_iff]
  ¬∑ exfalso; exact Finset.disjoint_left.mp hst his hit
  ¬∑ exact piCongrLeft_sum_inl (fun b : ‚Ü•(s ‚à™ t) => œÄ b) e‚ÇÅ y z ‚ü®i, his‚ü© |>.symm
  ¬∑ exact piCongrLeft_sum_inr (fun b : ‚Ü•(s ‚à™ t) => œÄ b) e‚ÇÅ y z ‚ü®i, _‚ü© |>.symm

end Function

section Measurable

open Set

variable {Œ± : Œπ ‚Üí Type _}

theorem measurable_uniqueElim [Unique Œπ] [‚àÄ i, MeasurableSpace (Œ± i)] :
    Measurable (uniqueElim : Œ± (default : Œπ) ‚Üí ‚àÄ i, Œ± i) := by
  simp_rw [measurable_pi_iff, Unique.forall_iff, uniqueElim_default]; exact measurable_id

/-- The measurable equivalence `(‚àÄ i, Œ± i) ‚âÉ·µê Œ± ‚ãÜ` when the domain of `Œ±` only contains `‚ãÜ` -/
@[simps (config := .asFn)]
def MeasurableEquiv.piUnique (Œ± : Œπ ‚Üí Type _) [Unique Œπ] [‚àÄ i, MeasurableSpace (Œ± i)] :
    (‚àÄ i, Œ± i) ‚âÉ·µê Œ± (default : Œπ) where
      toFun := fun f => f default
      invFun := uniqueElim
      left_inv := fun f => funext fun i => by
        cases Unique.eq_default i
        rfl
      right_inv := fun x => rfl
      measurable_toFun := measurable_pi_apply _
      measurable_invFun := measurable_uniqueElim

theorem MeasurableSet.univ_pi_fintype {Œ¥} {œÄ : Œ¥ ‚Üí Type _} [‚àÄ i, MeasurableSpace (œÄ i)] [Fintype Œ¥]
    {t : ‚àÄ i, Set (œÄ i)} (ht : ‚àÄ i, MeasurableSet (t i)) : MeasurableSet (pi univ t) :=
  MeasurableSet.pi finite_univ.countable fun i _ => ht i

end Measurable

section MeasurableOnFamily

variable {Œ± : Œπ ‚Üí Type _}

variable [‚àÄ i, MeasurableSpace (Œ± i)]

variable (Œ±)

theorem measurable_eq_mp {i i' : Œπ} (h : i = i') : Measurable (congr_arg Œ± h).mp := by
  cases h
  exact measurable_id

theorem Measurable.eq_mp {Œ≤} [MeasurableSpace Œ≤] {i i' : Œπ} (h : i = i') {f : Œ≤ ‚Üí Œ± i}
    (hf : Measurable f) : Measurable fun x => (congr_arg Œ± h).mp (f x) :=
  (measurable_eq_mp Œ± h).comp hf

variable {Œ±}

theorem measurable_piCongrLeft (f : Œπ' ‚âÉ Œπ) : Measurable (piCongrLeft Œ± f) := by
  rw [measurable_pi_iff]
  intro i
  simp_rw [piCongrLeft_apply]
  apply Measurable.eq_mp Œ± (f.apply_symm_apply i)
  exact measurable_pi_apply (f.symm i)

variable (Œ±)
/-- Moving a dependent type along an equivalence of coordinates, as a measurable equivalence. -/
def MeasurableEquiv.piCongrLeft (f : Œπ' ‚âÉ Œπ) : (‚àÄ b, Œ± (f b)) ‚âÉ·µê ‚àÄ a, Œ± a := by
  refine' { Equiv.piCongrLeft Œ± f with .. }
  ¬∑ exact measurable_piCongrLeft f
  simp only [invFun_as_coe, coe_fn_symm_mk]
  rw [measurable_pi_iff]
  exact fun i => measurable_pi_apply (f i)
variable {Œ±}

theorem MeasurableEquiv.piCongrLeft_eq (f : Œπ' ‚âÉ Œπ) :
  (MeasurableEquiv.piCongrLeft Œ± f : _ ‚Üí _) = f.piCongrLeft Œ± := by rfl

/-- The measurable equivalence between the pi type over a sum type and a product of pi-types. -/
def MeasurableEquiv.piSum (Œ± : Œπ ‚äï Œπ' ‚Üí Type _) [‚àÄ i, MeasurableSpace (Œ± i)] :
  ((‚àÄ i, Œ± (.inl i)) √ó ‚àÄ i', Œ± (.inr i')) ‚âÉ·µê ‚àÄ i, Œ± i := by
  refine' { Equiv.piSum Œ± with .. }
  ¬∑ rw [measurable_pi_iff]; rintro (i|i)
    exact measurable_pi_iff.1 measurable_fst _
    exact measurable_pi_iff.1 measurable_snd _
  ¬∑ refine Measurable.prod ?_ ?_ <;>
      rw [measurable_pi_iff] <;> rintro i <;> apply measurable_pi_apply

theorem MeasurableEquiv.piSum_eq (Œ± : Œπ ‚äï Œπ' ‚Üí Type _) [‚àÄ i, MeasurableSpace (Œ± i)] :
  (MeasurableEquiv.piSum Œ± : _ ‚Üí _) = Equiv.piSum Œ± := by rfl

end MeasurableOnFamily

open Finset

namespace MeasureTheory

-- workaround for `@[gcongr]` not recognizing some existing lemmas, like `lintegral_mono`, as valid
@[gcongr] theorem lintegral_mono2 ‚¶Éf g : Œ± ‚Üí ‚Ñù‚â•0‚àû‚¶Ñ (hfg : ‚àÄ x, f x ‚â§ g x) :
    lintegral Œº f ‚â§ lintegral Œº g :=
lintegral_mono hfg

@[gcongr] theorem lintegral_mono3 ‚¶Éf g : Œ± ‚Üí ‚Ñù‚â•0‚àû‚¶Ñ (hfg : ‚àÄ x, f x ‚â§ g x) (h2 : Œº ‚â§ ŒΩ) :
    lintegral Œº f ‚â§ lintegral ŒΩ g :=
lintegral_mono' h2 hfg

@[gcongr] theorem lintegral_congr2 ‚¶Éf g : Œ± ‚Üí ‚Ñù‚â•0‚àû‚¶Ñ (hfg : ‚àÄ x, f x = g x) :
    lintegral Œº f = lintegral Œº g :=
lintegral_congr hfg

alias ENNReal.coe_le_coe ‚Üî _ ENNReal.monotone2
attribute [gcongr] ENNReal.monotone2 ENNReal.rpow_le_rpow


theorem Subsingleton.measurableSingletonClass {Œ±} [MeasurableSpace Œ±] [Subsingleton Œ±] :
    MeasurableSingletonClass Œ± := by
  refine' ‚ü®fun i => _‚ü©
  convert MeasurableSet.univ
  simp [Set.eq_univ_iff_forall]

/-- A different formulation of H√∂lder's inequality for two functions -/
theorem ENNReal.lintegral_mul_norm_pow_le {Œ±} [MeasurableSpace Œ±] {Œº : Measure Œ±}
    {f g : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : AEMeasurable f Œº) (hg : AEMeasurable g Œº)
    {p q : ‚Ñù} (hp : 0 ‚â§ p) (hq : 0 ‚â§ q) (hpq : p + q = 1) :
    ‚à´‚Åª a, f a ^ p * g a ^ q ‚àÇŒº ‚â§ (‚à´‚Åª a, f a ‚àÇŒº) ^ p * (‚à´‚Åª a, g a ‚àÇŒº) ^ q := by
  rcases hp.eq_or_lt with rfl|hp
  ¬∑ simp at hpq
    subst hpq
    simp
  rcases hq.eq_or_lt with rfl|hq
  ¬∑ simp at hpq
    subst hpq
    simp
  have h2p : 1 < 1 / p
  ¬∑ rw [one_div]
    apply one_lt_inv hp
    linarith
  have h2pq : 1 / (1 / p) + 1 / (1 / q) = 1
  ¬∑ simp [hp.ne', hq.ne', hpq]
  have := ENNReal.lintegral_mul_le_Lp_mul_Lq Œº ‚ü®h2p, h2pq‚ü© (hf.pow_const p) (hg.pow_const q)
  simpa [‚Üê ENNReal.rpow_mul, hp.ne', hq.ne'] using this


@[to_additive]
theorem prod_insert_div [CommGroup Œ≤] [DecidableEq Œ±] (ha : a ‚àâ s) {f : Œ± ‚Üí Œ≤} :
    (‚àè x in insert a s, f x) / f a = ‚àè x in s, f x := by simp [ha]

/-- A version of H√∂lder with multiple arguments -/
theorem ENNReal.lintegral_prod_norm_pow_le {Œ±} [MeasurableSpace Œ±] {Œº : Measure Œ±} (s : Finset Œπ)
    (hs : s.Nonempty)
    {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (hf : ‚àÄ i ‚àà s, AEMeasurable (f i) Œº) {p : Œπ ‚Üí ‚Ñù} (hp : ‚àë i in s, p i = 1)
    (h2p : ‚àÄ i ‚àà s, 0 ‚â§ p i) :
      ‚à´‚Åª a, ‚àè i in s, f i a ^ p i ‚àÇŒº ‚â§
      ‚àè i in s, (‚à´‚Åª a, f i a ‚àÇŒº) ^ p i := by
  induction s using Finset.induction generalizing p
  case empty =>
    simp at hs
  case insert i‚ÇÄ s hi‚ÇÄ ih =>
    rcases eq_or_ne (p i‚ÇÄ) 1 with h2i‚ÇÄ|h2i‚ÇÄ
    ¬∑ simp [hi‚ÇÄ]
      have h2p : ‚àÄ i ‚àà s, p i = 0
      ¬∑ simpa [hi‚ÇÄ, h2i‚ÇÄ, sum_eq_zero_iff_of_nonneg (fun i hi ‚Ü¶ h2p i <| mem_insert_of_mem hi)]
          using hp
      calc ‚à´‚Åª a, f i‚ÇÄ a ^ p i‚ÇÄ * ‚àè i in s, f i a ^ p i ‚àÇŒº
          = ‚à´‚Åª a, f i‚ÇÄ a ^ p i‚ÇÄ * ‚àè i in s, 1 ‚àÇŒº := by
            congr with x
            congr 1
            apply prod_congr rfl fun i hi ‚Ü¶ by rw [h2p i hi, ENNReal.rpow_zero]
        _ ‚â§ (‚à´‚Åª a, f i‚ÇÄ a ‚àÇŒº) ^ p i‚ÇÄ * ‚àè i in s, 1 := by simp [h2i‚ÇÄ]
        _ = (‚à´‚Åª a, f i‚ÇÄ a ‚àÇŒº) ^ p i‚ÇÄ * ‚àè i in s, (‚à´‚Åª a, f i a ‚àÇŒº) ^ p i := by
            congr 1
            apply prod_congr rfl fun i hi ‚Ü¶ by rw [h2p i hi, ENNReal.rpow_zero]
    ¬∑ have hs : s.Nonempty
      ¬∑ rw [Finset.nonempty_iff_ne_empty]
        rintro rfl
        simp [h2i‚ÇÄ] at hp
      have hpi‚ÇÄ : 0 ‚â§ 1 - p i‚ÇÄ
      ¬∑ simp_rw [sub_nonneg, ‚Üê hp, single_le_sum h2p (mem_insert_self ..)]
      have h2pi‚ÇÄ : 1 - p i‚ÇÄ ‚â† 0
      ¬∑ rwa [sub_ne_zero, ne_comm]
      let q := fun i ‚Ü¶ p i / (1 - p i‚ÇÄ)
      have hq : ‚àë i in s, q i = 1
      ¬∑ rw [‚Üê sum_div, ‚Üê sum_insert_sub hi‚ÇÄ, hp, div_self h2pi‚ÇÄ]
      have h2q : ‚àÄ i ‚àà s, 0 ‚â§ q i
      ¬∑ exact fun i hi ‚Ü¶ div_nonneg (h2p i <| mem_insert_of_mem hi) hpi‚ÇÄ
      calc ‚à´‚Åª a, ‚àè i in insert i‚ÇÄ s, f i a ^ p i ‚àÇŒº
          = ‚à´‚Åª a, f i‚ÇÄ a ^ p i‚ÇÄ * ‚àè i in s, f i a ^ p i ‚àÇŒº := by simp [hi‚ÇÄ]
        _ = ‚à´‚Åª a, f i‚ÇÄ a ^ p i‚ÇÄ * (‚àè i in s, f i a ^ q i) ^ (1 - p i‚ÇÄ) ‚àÇŒº := by
            simp [‚Üê ENNReal.prod_rpow_of_nonneg hpi‚ÇÄ, ‚Üê ENNReal.rpow_mul,
              div_mul_cancel (h := h2pi‚ÇÄ)]
        _ ‚â§ (‚à´‚Åª a, f i‚ÇÄ a ‚àÇŒº) ^ p i‚ÇÄ * (‚à´‚Åª a, ‚àè i in s, f i a ^ q i ‚àÇŒº) ^ (1 - p i‚ÇÄ) := by
            apply ENNReal.lintegral_mul_norm_pow_le
            ¬∑ exact hf i‚ÇÄ <| mem_insert_self ..
            ¬∑ exact s.aemeasurable_prod <| fun i hi ‚Ü¶ (hf i <| mem_insert_of_mem hi).pow_const _
            ¬∑ exact h2p i‚ÇÄ <| mem_insert_self ..
            ¬∑ exact hpi‚ÇÄ
            ¬∑ apply add_sub_cancel'_right
        _ ‚â§ (‚à´‚Åª a, f i‚ÇÄ a ‚àÇŒº) ^ p i‚ÇÄ * (‚àè i in s, (‚à´‚Åª a, f i a ‚àÇŒº) ^ q i) ^ (1 - p i‚ÇÄ) := by
            gcongr
            exact ih hs (fun i hi ‚Ü¶ hf i <| mem_insert_of_mem hi) hq h2q
        _ = (‚à´‚Åª a, f i‚ÇÄ a ‚àÇŒº) ^ p i‚ÇÄ * ‚àè i in s, (‚à´‚Åª a, f i a ‚àÇŒº) ^ p i := by
            simp [‚Üê ENNReal.prod_rpow_of_nonneg hpi‚ÇÄ, ‚Üê ENNReal.rpow_mul,
              div_mul_cancel (h := h2pi‚ÇÄ)]
        _ = ‚àè i in insert i‚ÇÄ s, (‚à´‚Åª a, f i a ‚àÇŒº) ^ p i := by simp [hi‚ÇÄ]

/-- A version of H√∂lder with multiple arguments, one of which plays a distinguished role -/
theorem ENNReal.lintegral_mul_prod_norm_pow_le {Œ±} [MeasurableSpace Œ±] {Œº : Measure Œ±} (s : Finset Œπ)
    {g : Œ± ‚Üí  ‚Ñù‚â•0‚àû} {f : Œπ ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû} (hg : AEMeasurable g Œº) (hf : ‚àÄ i ‚àà s, AEMeasurable (f i) Œº)
    (q : ‚Ñù) {p : Œπ ‚Üí ‚Ñù} (hpq : q + ‚àë i in s, p i = 1) (hq :  0 ‚â§ q)
    (hp : ‚àÄ i ‚àà s, 0 ‚â§ p i) :
    ‚à´‚Åª a, g a ^ q * ‚àè i in s, f i a ^ p i ‚àÇŒº ‚â§
      (‚à´‚Åª a, g a ‚àÇŒº) ^ q * ‚àè i in s, (‚à´‚Åª a, f i a ‚àÇŒº) ^ p i := by
  calc
    ‚à´‚Åª t, g t ^ q * ‚àè j in s, (f j t) ^ p j ‚àÇŒº
      = ‚à´‚Åª t, ‚àè j in insertNone s,
            Option.elim j (g t) (fun j ‚Ü¶ f j t) ^ Option.elim j q p ‚àÇŒº := by
          congr! 1
          ext t
          rw [prod_insertNone]
          dsimp
    _ ‚â§ ‚àè j in insertNone s,
          (‚à´‚Åª t, Option.elim j (g t) (fun j ‚Ü¶ f j t) ‚àÇŒº) ^ Option.elim j q p := by
          refine ENNReal.lintegral_prod_norm_pow_le _ insertNone_nonempty ?_ ?_ ?_
          ¬∑ rintro (_|i) hi
            ¬∑ exact hg
            ¬∑ refine hf i ?_
              simpa using hi
          ¬∑ simp_rw [sum_insertNone, compl_insert, Option.elim, sum_const, nsmul_eq_mul]
            exact hpq
          ¬∑ rintro (_|i) hi
            ¬∑ exact hq
            ¬∑ refine hp i ?_
              simpa using hi
    _ = (‚à´‚Åª t, g t ‚àÇŒº) ^ q * ‚àè j in s, (‚à´‚Åª t, f j t ‚àÇŒº) ^ p j := by
          -- this proof could be `simp [prod_insertNone]` but that's too slow
          simp_rw [prod_insertNone]
          dsimp

section Measure

variable {Œ± : Œπ ‚Üí Type _}
variable [‚àÄ i, MeasurableSpace (Œ± i)]
variable [Fintype Œπ] [Fintype Œπ']
variable {m : ‚àÄ i, OuterMeasure (Œ± i)}
variable [‚àÄ i, MeasurableSpace (Œ± i)] {Œº : ‚àÄ i, Measure (Œ± i)}
variable [‚àÄ i, SigmaFinite (Œº i)]
variable (Œº)

namespace Measure

open Sum

/-- Some properties of `Measure.pi` -/

theorem pi_map_left (f : Œπ' ‚âÉ Œπ) :
    map (MeasurableEquiv.piCongrLeft Œ± f) (Measure.pi fun i' => Œº (f i')) = Measure.pi Œº := by
  refine' (pi_eq fun s _ => _).symm
  rw [MeasurableEquiv.map_apply, MeasurableEquiv.piCongrLeft_eq,
    piCongrLeft_preimage_univ_pi, pi_pi _ _, prod_univ_comp_equiv (fun i => Œº i (s i)) f]

theorem pi_sum {œÄ : Œπ ‚äï Œπ' ‚Üí Type _} [‚àÄ i, MeasurableSpace (œÄ i)] (Œº : ‚àÄ i, Measure (œÄ i))
    [‚àÄ i, SigmaFinite (Œº i)] :
    map (MeasurableEquiv.piSum œÄ)
      ((Measure.pi fun i => Œº (.inl i)).prod (Measure.pi fun i => Œº (.inr i))) = Measure.pi Œº := by
  refine' (pi_eq fun s _ => _).symm
  simp_rw [MeasurableEquiv.map_apply, MeasurableEquiv.piSum_eq, piSum_preimage_univ_pi,
    Measure.prod_prod, Measure.pi_pi, prod_sum_univ]

theorem pi_unique {œÄ : Œπ ‚Üí Type _} [Unique Œπ] [‚àÄ i, MeasurableSpace (œÄ i)]
    (Œº : ‚àÄ i, Measure (œÄ i)) :
    map (MeasurableEquiv.piUnique œÄ) (Measure.pi Œº) = Œº default := by
  set e := MeasurableEquiv.piUnique œÄ
  have : (piPremeasure fun i => (Œº i).toOuterMeasure) = Measure.map e.symm (Œº default) := by
    ext1 s
    rw [piPremeasure, Fintype.prod_unique, e.symm.map_apply]
    congr 1; exact e.toEquiv.image_eq_preimage s
  simp_rw [Measure.pi, OuterMeasure.pi, this, boundedBy_eq_self, toOuterMeasure_toMeasure,
    MeasurableEquiv.map_map_symm]

end Measure

open Measure
-- todo: use the next lemmas. For them to be useful we want to have a lemma like
-- `MeasurePreserving.lintegral_comp_equiv`
theorem measurePreserving_piCongrLeft (f : Œπ' ‚âÉ Œπ) :
    MeasurePreserving (MeasurableEquiv.piCongrLeft Œ± f)
      (Measure.pi fun i' => Œº (f i')) (Measure.pi Œº) where
  measurable := (MeasurableEquiv.piCongrLeft Œ± f).measurable
  map_eq := pi_map_left Œº f

theorem measurePreserving_piSum {œÄ : Œπ ‚äï Œπ' ‚Üí Type _} [‚àÄ i, MeasurableSpace (œÄ i)]
    (Œº : ‚àÄ i, Measure (œÄ i)) [‚àÄ i, SigmaFinite (Œº i)] :
    MeasurePreserving (MeasurableEquiv.piSum œÄ)
      ((Measure.pi fun i => Œº (.inl i)).prod (Measure.pi fun i => Œº (.inr i))) (Measure.pi Œº) where
  measurable := (MeasurableEquiv.piSum œÄ).measurable
  map_eq := pi_sum Œº

-- generalizes `measurePreserving_funUnique`
theorem measurePreserving_piUnique {œÄ : Œπ ‚Üí Type _} [Unique Œπ] [‚àÄ i, MeasurableSpace (œÄ i)]
    (Œº : ‚àÄ i, Measure (œÄ i)) :
    MeasurePreserving (MeasurableEquiv.piUnique œÄ) (Measure.pi Œº) (Œº default) where
  measurable := (MeasurableEquiv.piUnique œÄ).measurable
  map_eq := pi_unique Œº

theorem Measure.map_piUnique_symm [Unique Œπ] :
    map (MeasurableEquiv.piUnique Œ±).symm (Œº (default : Œπ)) = Measure.pi Œº :=
  (measurePreserving_piUnique Œº).symm _ |>.map_eq

end Measure

section

variable {Œ± E : Type _} [MeasurableSpace Œ±] [NormedAddCommGroup E]

theorem _root_.Measurable.hasFiniteIntegral_dirac {f : Œ± ‚Üí E}
    (hf : Measurable (fun x => ‚Äñf x‚Äñ‚Çä : Œ± ‚Üí ‚Ñù‚â•0‚àû)) {x : Œ±} :
    HasFiniteIntegral f (Measure.dirac x) := by
  rw [HasFiniteIntegral, lintegral_dirac' _ hf]
  exact ENNReal.coe_lt_top

theorem hasFiniteIntegral_dirac [MeasurableSingletonClass Œ±] {f : Œ± ‚Üí E} {x : Œ±} :
    HasFiniteIntegral f (Measure.dirac x) := by
  rw [HasFiniteIntegral, lintegral_dirac]
  exact ENNReal.coe_lt_top

theorem StronglyMeasurable.integrable_dirac [MeasurableSpace E] [BorelSpace E] {f : Œ± ‚Üí E}
    (hf : StronglyMeasurable f) {x : Œ±} : Integrable f (Measure.dirac x) :=
  ‚ü®hf.aestronglyMeasurable, hf.measurable.ennnorm.hasFiniteIntegral_dirac‚ü©


end

section Marginal

open TopologicalSpace

variable {Œ¥ : Type _} {œÄ : Œ¥ ‚Üí Type _} [‚àÄ x, MeasurableSpace (œÄ x)]

variable {Œº : ‚àÄ i, Measure (œÄ i)} [‚àÄ i, SigmaFinite (Œº i)]

theorem lintegral_of_isEmpty {Œ±} [MeasurableSpace Œ±] [IsEmpty Œ±] (Œº : Measure Œ±) (f : Œ± ‚Üí ‚Ñù‚â•0‚àû) :
    ‚à´‚Åª x, f x ‚àÇŒº = 0 := by convert lintegral_zero_measure f

variable {s t : Finset Œ¥} {f g : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû} {x y : ‚àÄ i, œÄ i} {i : Œ¥}

theorem measurable_updateSet : Measurable (updateSet x s) := by
  simp_rw [updateSet, measurable_pi_iff]
  intro i
  by_cases h : i ‚àà s <;> simp [h, measurable_pi_apply]

/-- Integrate `f(x‚ÇÅ,‚Ä¶,x‚Çô)` over all variables `x·µ¢` where `i ‚àà s`. Return a function in the
  remaining variables (it will be constant in the `x·µ¢` for `i ‚àà s`).
  This is the marginal distribution of all variables not in `s`. -/
def marginal (Œº : ‚àÄ i, Measure (œÄ i)) (s : Finset Œ¥) (f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû) (x : ‚àÄ i, œÄ i) :
    ‚Ñù‚â•0‚àû :=
  ‚à´‚Åª y : ‚àÄ i : s, œÄ i, f (updateSet x s y) ‚àÇMeasure.pi fun i : s => Œº i

-- Note: this notation is not a binder. This is more convenient since it returns a function.
notation "‚à´‚ãØ‚à´_" s ", " f " ‚àÇ" Œº:70 => marginal Œº s f

notation "‚à´‚ãØ‚à´_" s ", " f => marginal (fun _ ‚Ü¶ volume) s f

variable (Œº)

theorem _root_.Measurable.marginal (hf : Measurable f) : Measurable (‚à´‚ãØ‚à´_s, f ‚àÇŒº) := by
  refine' Measurable.lintegral_prod_right _
  refine' hf.comp _
  rw [measurable_pi_iff]; intro i
  by_cases hi : i ‚àà s
  ¬∑ simp [hi, updateSet]
    exact measurable_pi_iff.1 measurable_snd _
  ¬∑ simp [hi, updateSet]
    exact measurable_pi_iff.1 measurable_fst _

theorem marginal_empty (f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû) : ‚à´‚ãØ‚à´_‚àÖ, f ‚àÇŒº = f := by
  ext1 x
  simp_rw [marginal, Measure.pi_of_empty fun i : (‚àÖ : Finset Œ¥) => Œº i]
  apply lintegral_dirac'
  exact Subsingleton.measurable

/-- The marginal distribution is independent of the variables in `s`. -/
-- todo: notation `‚àÄ i ‚àâ s, ...`
@[gcongr]
theorem marginal_congr {x y : ‚àÄ i, œÄ i} (f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû)
    (h : ‚àÄ (i) (_ : i ‚àâ s), x i = y i) :
    (‚à´‚ãØ‚à´_s, f ‚àÇŒº) x = (‚à´‚ãØ‚à´_s, f ‚àÇŒº) y := by
  dsimp [marginal, updateSet]; rcongr; exact h _ ‚Äπ_‚Ä∫

theorem marginal_update (x : ‚àÄ i, œÄ i) (f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû) {i : Œ¥} (y : œÄ i) (hi : i ‚àà s) :
    (‚à´‚ãØ‚à´_s, f ‚àÇŒº) (Function.update x i y) = (‚à´‚ãØ‚à´_s, f ‚àÇŒº) x := by
  gcongr with j hj
  have : j ‚â† i := by rintro rfl; exact hj hi
  apply update_noteq this

theorem marginal_union (f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû) (hf : Measurable f) (hst : Disjoint s t) :
    ‚à´‚ãØ‚à´_s ‚à™ t, f ‚àÇŒº = ‚à´‚ãØ‚à´_s, ‚à´‚ãØ‚à´_t, f ‚àÇŒº ‚àÇŒº := by
  ext1 x
  set e‚ÇÅ := (finsetUnionEquivSum s t hst).symm
  set e‚ÇÇ := MeasurableEquiv.piCongrLeft (fun i : ‚Ü•(s ‚à™ t) => œÄ i) e‚ÇÅ
  set e‚ÇÉ := MeasurableEquiv.piSum fun b ‚Ü¶ œÄ (e‚ÇÅ b)
  calc (‚à´‚ãØ‚à´_s ‚à™ t, f ‚àÇŒº) x
      = ‚à´‚Åª (y : (i : ‚Ü•(s ‚à™ t)) ‚Üí œÄ i), f (updateSet x (s ‚à™ t) y)
          ‚àÇ.pi fun i' : ‚Ü•(s ‚à™ t) ‚Ü¶ Œº i' := by rfl
    _ = ‚à´‚Åª (y : (i : s ‚äï t) ‚Üí œÄ (e‚ÇÅ i)), f (updateSet x (s ‚à™ t) (e‚ÇÇ y))
          ‚àÇ.pi fun i' : s ‚äï t ‚Ü¶ Œº (e‚ÇÅ i') := by
        simp_rw [marginal, ‚Üê Measure.pi_map_left _ e‚ÇÅ, lintegral_map_equiv]
    _ = ‚à´‚Åª (y : ((i : s) ‚Üí œÄ i) √ó ((j : t) ‚Üí œÄ j)), f (updateSet x (s ‚à™ t) (e‚ÇÇ (e‚ÇÉ y)))
          ‚àÇ(Measure.pi fun i : s ‚Ü¶ Œº i).prod (.pi fun j : t ‚Ü¶ Œº j) := by
        simp_rw [‚Üê Measure.pi_sum, lintegral_map_equiv]; rfl
    _ = ‚à´‚Åª (y : (i : s) ‚Üí œÄ i), ‚à´‚Åª (z : (j : t) ‚Üí œÄ j), f (updateSet x (s ‚à™ t) (e‚ÇÇ (e‚ÇÉ (y, z))))
          ‚àÇ.pi fun j : t ‚Ü¶ Œº j ‚àÇ.pi fun i : s ‚Ü¶ Œº i := by
        apply lintegral_prod
        apply Measurable.aemeasurable
        exact hf.comp <| measurable_updateSet.comp <| e‚ÇÇ.measurable.comp e‚ÇÉ.measurable
    _ = (‚à´‚ãØ‚à´_s, ‚à´‚ãØ‚à´_t, f ‚àÇŒº ‚àÇŒº) x := by
        simp_rw [marginal, updateSet_updateSet hst]
        rfl

theorem marginal_union' (f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû) (hf : Measurable f) {s t : Finset Œ¥}
    (hst : Disjoint s t) : ‚à´‚ãØ‚à´_s ‚à™ t, f ‚àÇŒº = ‚à´‚ãØ‚à´_t, ‚à´‚ãØ‚à´_s, f ‚àÇŒº ‚àÇŒº := by
  rw [Finset.union_comm, marginal_union Œº f hf hst.symm]

variable {Œº}

theorem marginal_singleton (f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû) (i : Œ¥) :
    ‚à´‚ãØ‚à´_{i}, f ‚àÇŒº = fun x => ‚à´‚Åª x·µ¢, f (Function.update x i x·µ¢) ‚àÇŒº i := by
  let Œ± : Type _ := ({i} : Finset Œ¥)
  let e := (MeasurableEquiv.piUnique fun j : Œ± ‚Ü¶ œÄ j).symm
  ext1 x
  calc (‚à´‚ãØ‚à´_{i}, f ‚àÇŒº) x
      = ‚à´‚Åª (y : œÄ (default : Œ±)), f (updateSet x {i} (e y)) ‚àÇŒº (default : Œ±) := by
        simp_rw [marginal, ‚Üê Measure.map_piUnique_symm, lintegral_map_equiv]
    _ = ‚à´‚Åª x·µ¢, f (Function.update x i x·µ¢) ‚àÇŒº i := by simp [update_eq_updateSet]

theorem integral_update (f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû) (i : Œ¥) (x : ‚àÄ i, œÄ i) :
    ‚à´‚Åª x·µ¢, f (Function.update x i x·µ¢) ‚àÇŒº i = (‚à´‚ãØ‚à´_{i}, f ‚àÇŒº) x := by
  simp_rw [marginal_singleton f i]

theorem marginal_insert (f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû) (hf : Measurable f) {i : Œ¥} (hi : i ‚àâ s)
    (x : ‚àÄ i, œÄ i) :
    (‚à´‚ãØ‚à´_insert i s, f ‚àÇŒº) x = ‚à´‚Åª x·µ¢, (‚à´‚ãØ‚à´_s, f ‚àÇŒº) (Function.update x i x·µ¢) ‚àÇŒº i := by
  rw [Finset.insert_eq, marginal_union Œº f hf (Finset.disjoint_singleton_left.mpr hi),
    marginal_singleton]

open Filter

@[gcongr]
theorem marginal_mono {f g : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû} (hfg : f ‚â§ g) : ‚à´‚ãØ‚à´_s, f ‚àÇŒº ‚â§ ‚à´‚ãØ‚à´_s, g ‚àÇŒº :=
  fun _ => lintegral_mono fun _ => hfg _

theorem marginal_univ [Fintype Œ¥] {f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû} :
    ‚à´‚ãØ‚à´_univ, f ‚àÇŒº = fun _ => ‚à´‚Åª x, f x ‚àÇMeasure.pi Œº := by
  let e : { j // j ‚àà Finset.univ } ‚âÉ Œ¥ := Equiv.subtypeUnivEquiv mem_univ
  ext1 x
  simp_rw [marginal, ‚Üê Measure.pi_map_left Œº e, lintegral_map_equiv, updateSet]
  simp
  rfl

end Marginal

end MeasureTheory

open MeasureTheory

section Sobolev

open TopologicalSpace

variable [Fintype Œπ] {œÄ : Œπ ‚Üí Type _} [‚àÄ i, MeasurableSpace (œÄ i)] (Œº : ‚àÄ i, Measure (œÄ i))
  [‚àÄ i, SigmaFinite (Œº i)] (u : (Œπ ‚Üí ‚Ñù) ‚Üí ‚Ñù) {f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû}


local prefix:max "#" => Fintype.card

/--
  The function that is central in the inductive proof of the Sobolev inequality.
-/
def rhsAux (f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû) (s : Finset Œπ) : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû :=
  (‚à´‚ãØ‚à´_s, f ‚àÇŒº) ^ ((s.card : ‚Ñù) / (#Œπ - 1 : ‚Ñù)) *
    ‚àè i in s·∂ú, (‚à´‚ãØ‚à´_insert i s, f ‚àÇŒº) ^ (1 / (#Œπ - 1 : ‚Ñù))

lemma rhsAux_empty (f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû) (x : ‚àÄ i, œÄ i) :
    rhsAux Œº f ‚àÖ x = ‚àè i, (‚à´‚Åª x·µ¢, f (Function.update x i x·µ¢) ‚àÇŒº i) ^ ((1 : ‚Ñù) / (#Œπ - 1 : ‚Ñù)) := by
  simp [rhsAux, marginal_singleton]

lemma rhsAux_univ (f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû) (x : ‚àÄ i, œÄ i) :
   rhsAux Œº f univ x = (‚à´‚Åª x, f x ‚àÇ(Measure.pi Œº)) ^ ((#Œπ : ‚Ñù) / (#Œπ - 1 : ‚Ñù)) := by
  simp [rhsAux, marginal_univ, Finset.card_univ]

/- Isolate the occurrence of `‚à´‚ãØ‚à´_insert i s` in `rhsAux`, for an index `i ‚àâ s`. -/
lemma rhsAux_not_mem (f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû) {s : Finset Œπ} {i : Œπ} (hi : i ‚àâ s) (x : ‚àÄ i, œÄ i) :
    rhsAux Œº f s x
      = (‚à´‚ãØ‚à´_insert i s, f ‚àÇŒº) x ^ (1 / ((#Œπ:‚Ñù) - 1))
            * ((‚à´‚ãØ‚à´_s, f ‚àÇŒº) x ^ ((s.card:‚Ñù) * (1 / ((#Œπ:‚Ñù) - 1)))
            * ‚àè j in (insert i s)·∂ú, (‚à´‚ãØ‚à´_insert j s, f ‚àÇŒº) x ^ (1 / ((#Œπ:‚Ñù) - 1))) := by
  set p := 1 / ((#Œπ:‚Ñù) - 1)
  set m : ‚Ñù := ‚Üë(s.card)
  calc
    rhsAux Œº f s x
      = (‚à´‚ãØ‚à´_s, f ‚àÇŒº) x ^ (m * p) * ‚àè j in s·∂ú, (‚à´‚ãØ‚à´_insert j s, f ‚àÇŒº) x ^ p := by
              dsimp [rhsAux]
              rw [prod_apply]
              dsimp
              -- this proof could be `ring_nf` but that's too slow`
              congr! 2
              ring
    _ = (‚à´‚ãØ‚à´_s, f ‚àÇŒº) x ^ (m * p) * ((‚à´‚ãØ‚à´_insert i s, f ‚àÇŒº) x ^ p
          * ‚àè j in (insert i s)·∂ú, (‚à´‚ãØ‚à´_insert j s, f ‚àÇŒº) x ^ p) := by
              simp_rw [‚Üê insert_compl_insert hi]
              rw [prod_insert (not_mem_compl.mpr <| mem_insert_self i s)]
    _ = (‚à´‚ãØ‚à´_insert i s, f ‚àÇŒº) x ^ p * ((‚à´‚ãØ‚à´_s, f ‚àÇŒº) x ^ (m * p)
          * ‚àè j in (insert i s)·∂ú, (‚à´‚ãØ‚à´_insert j s, f ‚àÇŒº) x ^ p) := by ring

set_option maxHeartbeats 400000 in
/--
The main inductive step

Note: this also holds without assuming `Nontrivial Œπ`, by tracing through the junk values
(note that `s = ‚àÖ` in that case).
-/
theorem marginal_singleton_rhsAux_le [Nontrivial Œπ] (f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû) (hf : Measurable f)
    (s : Finset Œπ) (i : Œπ) (hi : i ‚àâ s) (x : ‚àÄ i, œÄ i):
    ‚à´‚Åª t, rhsAux Œº f s (update x i t) ‚àÇ(Œº i) ‚â§ rhsAux Œº f (insert i s) x := by
  have hŒπ : 2 ‚â§ (#Œπ : ‚Ñù) := by exact_mod_cast Fintype.one_lt_card
  have : 1 ‚â§ (#Œπ:‚Ñù) - 1 := by linarith
  let p : ‚Ñù := 1 / ((#Œπ:‚Ñù) - 1)
  have hp : s.card * p + (insert i s)·∂ú.card * p = 1
  ¬∑ have H‚ÇÅ : ((insert i s).card : ‚Ñù) = s.card + 1 := by exact_mod_cast Finset.card_insert_of_not_mem hi
    have H‚ÇÇ : ((insert i s).card : ‚Ñù) + (insert i s)·∂ú.card = #Œπ := by exact_mod_cast (insert i s).card_add_card_compl
    have H‚ÇÉ : p * (#Œπ - 1) = 1
    ¬∑ dsimp only
      have : (#Œπ:‚Ñù) - 1 ‚â† 0 := by positivity
      field_simp [this]
    linear_combination -p * H‚ÇÅ + p * H‚ÇÇ + H‚ÇÉ
  let m : ‚Ñù := s.card
  calc ‚à´‚Åª t, rhsAux Œº f s (update x i t) ‚àÇ(Œº i)
      = ‚à´‚Åª t, ((‚à´‚ãØ‚à´_insert i s, f ‚àÇŒº) (update x i t) ^ p * ((‚à´‚ãØ‚à´_s, f ‚àÇŒº) (update x i t) ^ (m * p)
          * ‚àè j in (insert i s)·∂ú, (‚à´‚ãØ‚à´_insert j s, f ‚àÇŒº) (update x i t) ^ p)) ‚àÇ(Œº i) := by
              simp_rw [rhsAux_not_mem Œº f hi]
    _ = (‚à´‚ãØ‚à´_insert i s, f ‚àÇŒº) x ^ p * (‚à´‚Åª t, ((‚à´‚ãØ‚à´_s, f ‚àÇŒº) (update x i t) ^ (m * p)
          * ‚àè j in (insert i s)·∂ú, ((‚à´‚ãØ‚à´_insert j s, f ‚àÇŒº) (update x i t)) ^ p) ‚àÇ(Œº i)) := by
              clear_value p m
              simp_rw [fun x x·µ¢ => marginal_update Œº x f x·µ¢ (s.mem_insert_self i)]
              rw [lintegral_const_mul]
              refine (hf.marginal Œº).comp (measurable_update x) |>.pow measurable_const |>.mul ?_
              refine Finset.measurable_prod _ fun i _ ‚Ü¶ ?_
              exact (hf.marginal Œº).comp (measurable_update x) |>.pow measurable_const
    _ ‚â§ ((‚à´‚ãØ‚à´_insert i s, f ‚àÇŒº) x) ^ p *
          ((‚à´‚Åª t, (‚à´‚ãØ‚à´_s, f ‚àÇŒº) (update x i t) ‚àÇŒº i) ^ (m * p) *
            ‚àè j in (insert i s)·∂ú, (‚à´‚Åª t, (‚à´‚ãØ‚à´_insert j s, f ‚àÇŒº) (update x i t) ‚àÇ(Œº i)) ^ p) := by
              gcongr
              -- we now apply H√∂lder's inequality
              apply ENNReal.lintegral_mul_prod_norm_pow_le
              ¬∑ exact (hf.marginal Œº |>.comp <| measurable_update _).aemeasurable
              ¬∑ intros
                exact (hf.marginal Œº |>.comp <| measurable_update _).aemeasurable
              ¬∑ simp_rw [sum_const, nsmul_eq_mul]
                exact hp
              ¬∑ positivity
              ¬∑ intros
                positivity
    _ = ((‚à´‚ãØ‚à´_insert i s, f ‚àÇŒº) x) ^ p * (((‚à´‚ãØ‚à´_insert i s, f ‚àÇŒº) x) ^ (m * p) *
            ‚àè j in (insert i s)·∂ú, ((‚à´‚ãØ‚à´_insert i (insert j s), f ‚àÇŒº) x) ^ p) := by
              rw [marginal_insert _ hf hi]
              congr! 2; refine prod_congr rfl fun j hj => ?_
              have hi' : i ‚àâ insert j s
              ¬∑ simp only [Finset.mem_insert, Finset.mem_compl] at hj ‚ä¢
                tauto
              rw [marginal_insert _ hf hi']
    _ = ((‚à´‚ãØ‚à´_insert i s, f ‚àÇŒº) x) ^ ((m + 1 : ‚Ñù) * p) *
            ‚àè j in (insert i s)·∂ú, ((‚à´‚ãØ‚à´_insert i (insert j s), f ‚àÇŒº) x) ^ p := by
              rw [‚Üê mul_assoc]
              congr
              rw [‚Üê ENNReal.rpow_add_of_nonneg]
              ¬∑ -- this proof could be `ring_nf` but that's too slow`
                congr
                ring
              ¬∑ positivity
              ¬∑ positivity
    _ = ((‚à´‚ãØ‚à´_insert i s, f ‚àÇŒº) ^ (((insert i s).card : ‚Ñù) * p) *
            ‚àè j in (insert i s)·∂ú, (‚à´‚ãØ‚à´_insert j (insert i s), f ‚àÇŒº) ^ p) x := by
              -- this proof could be `simp [Insert.comm, Finset.card_insert_of_not_mem hi]` but
              -- that's too slow
              dsimp
              simp_rw [Insert.comm, prod_apply, Finset.card_insert_of_not_mem hi]
              push_cast
              rfl
    _ = rhsAux Œº f (insert i s) x := by
              rw [rhsAux]
              -- this proof could be `ring_nf` but that's too slow`
              congr! 2
              ring

lemma Measurable.rhsAux (hf : Measurable f) : Measurable (rhsAux Œº f s) := by
  simp [_root_.rhsAux]
  refine Measurable.mul ?_ ?_
  ¬∑ dsimp
    exact (hf.marginal Œº).pow measurable_const
  simp_rw [prod_apply]
  refine Finset.measurable_prod _ fun i _ ‚Ü¶ ?_
  dsimp
  exact hf.marginal Œº |>.pow measurable_const

theorem marginal_rhsAux_empty_le [Nontrivial Œπ] (f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù‚â•0‚àû) (hf : Measurable f)
    (s : Finset Œπ) : ‚à´‚ãØ‚à´_s, rhsAux Œº f ‚àÖ ‚àÇŒº ‚â§ rhsAux Œº f s := by
  induction' s using Finset.induction with i s hi ih
  ¬∑ simp [marginal_empty]
  intro x
  calc (‚à´‚ãØ‚à´_insert i s, rhsAux Œº f ‚àÖ ‚àÇŒº) x
      = ‚à´‚Åª t, (‚à´‚ãØ‚à´_s, rhsAux Œº f ‚àÖ ‚àÇŒº) (update x i t) ‚àÇ(Œº i) := by
        rw [marginal_insert]
        ¬∑ exact hf.rhsAux Œº
        ¬∑ exact hi
    _ ‚â§ ‚à´‚Åª t, rhsAux Œº f s (update x i t) ‚àÇ(Œº i) := by
        apply lintegral_mono; intro t; dsimp -- should be `gcongr`
        apply ih
    _ ‚â§ rhsAux Œº f (insert i s) x := marginal_singleton_rhsAux_le _ _ hf _ _ hi x

theorem lintegral_prod_lintegral_pow_le [Nontrivial Œπ] (hf : Measurable f) :
    ‚à´‚Åª x, ‚àè i, (‚à´‚Åª x·µ¢, f (Function.update x i x·µ¢) ‚àÇŒº i) ^ ((1 : ‚Ñù) / (#Œπ - 1 : ‚Ñù)) ‚àÇMeasure.pi Œº ‚â§
      (‚à´‚Åª x, f x ‚àÇMeasure.pi Œº) ^ ((#Œπ : ‚Ñù) / (#Œπ - 1 : ‚Ñù)) := by
  cases isEmpty_or_nonempty (‚àÄ i, œÄ i)
  ¬∑ simp_rw [lintegral_of_isEmpty]; refine' zero_le _
  inhabit ‚àÄ i, œÄ i
  simpa [marginal_univ, rhsAux_empty, rhsAux_univ] using
    marginal_rhsAux_empty_le Œº f hf Finset.univ default

-- theorem integral_prod_integral_pow_le {f : (‚àÄ i, œÄ i) ‚Üí ‚Ñù} (hf : Measurable f)
--     (h2f : ‚àÄ x, 0 ‚â§ f x) :
--     ‚à´ x,
--         ‚àè i,
--           (‚à´ x·µ¢, f (Function.update x i x·µ¢) ‚àÇŒº i) ^ ((1 : ‚Ñù) / (#Œπ - 1)) ‚àÇMeasure.pi Œº ‚â§
--       (‚à´ x, f x ‚àÇMeasure.pi Œº) ^ ((#Œπ : ‚Ñù) / (#Œπ - 1)) :=
--   by sorry
section

-- move to MeasureTheory.Function.L1Space
theorem _root_.MeasureTheory.Integrable.nnnorm_toL1 {Œ± : Type _} {Œ≤ : Type _}
    {m : MeasurableSpace Œ±} {Œº : Measure Œ±} [NormedAddCommGroup Œ≤] (f : Œ± ‚Üí Œ≤)
    (hf : Integrable f Œº) :
    (‚Äñhf.toL1 f‚Äñ‚Çä : ‚Ñù‚â•0‚àû) = ‚à´‚Åª a, ‚Äñf a‚Äñ‚Çä ‚àÇŒº := by
  simpa [Integrable.toL1, snorm, snorm'] using ENNReal.coe_toNNReal hf.2.ne

-- move to MeasureTheory.Integral.Bochner
theorem _root_.MeasureTheory.L1.nnnorm_Integral_le_one {Œ± : Type _} {E : Type _}
    [NormedAddCommGroup E] {_ : MeasurableSpace Œ±} {Œº : Measure Œ±} [NormedSpace ‚Ñù E]
    [CompleteSpace E] : ‚ÄñL1.integralCLM (Œ± := Œ±) (E := E) (Œº := Œº)‚Äñ‚Çä ‚â§ (1 : ‚Ñù) :=
  L1.norm_Integral_le_one

-- move to MeasureTheory.Integral.Bochner
theorem _root_.MeasureTheory.L1.nnnorm_integral_le {Œ± : Type _} {E : Type _}
    [NormedAddCommGroup E] {_ : MeasurableSpace Œ±} {Œº : Measure Œ±} [NormedSpace ‚Ñù E]
    [CompleteSpace E] (f : Œ± ‚Üí‚ÇÅ[Œº] E) : ‚ÄñL1.integral f‚Äñ‚Çä ‚â§ ‚Äñf‚Äñ‚Çä :=
  L1.norm_integral_le f

end

-- move to MeasureTheory.Integral.Bochner
theorem nnnorm_integral_le_lintegral_nnnorm {Œ± E : Type _} [MeasurableSpace Œ±] {Œº : Measure Œ±}
    [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [CompleteSpace E] (f : Œ± ‚Üí E) :
    ‚Äñ‚à´ x, f x ‚àÇŒº‚Äñ‚Çä ‚â§ ‚à´‚Åª x, ‚Äñf x‚Äñ‚Çä ‚àÇ Œº := by
  rw [integral_def, dif_pos ‚Äπ_‚Ä∫]
  split_ifs with hf
  ¬∑ calc _ ‚â§ (‚Äñ(Integrable.toL1 f hf)‚Äñ‚Çä : ‚Ñù‚â•0‚àû) := by norm_cast; apply L1.nnnorm_integral_le
      _ = _ := hf.nnnorm_toL1
  ¬∑ simp

/-- The Gagliardo-Nirenberg-Sobolev inequality -/
theorem lintegral_pow_le [Nontrivial Œπ] [Fintype Œπ] (hu : ContDiff ‚Ñù 1 u)
    (h2u : HasCompactSupport u) : ‚à´‚Åª x, ‚Äñu x‚Äñ‚Çä ^ ((#Œπ : ‚Ñù) / (#Œπ - 1 : ‚Ñù)) ‚â§
      (‚à´‚Åª x, ‚Äñfderiv ‚Ñù u x‚Äñ‚Çä) ^ ((#Œπ : ‚Ñù) / (#Œπ - 1 : ‚Ñù)) := by
  have : (1:‚Ñù) ‚â§ ‚Üë#Œπ - 1
  ¬∑ have hŒπ : (2:‚Ñù) ‚â§ #Œπ := by exact_mod_cast Fintype.one_lt_card
    linarith
  calc ‚à´‚Åª x, ‚Äñu x‚Äñ‚Çä ^ ((#Œπ : ‚Ñù) / (#Œπ - 1 : ‚Ñù))
      = ‚à´‚Åª x, ((‚Äñu x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ (1 / (#Œπ - 1 : ‚Ñù))) ^ (#Œπ : ‚Ñù) := by
        gcongr with x
        rw [‚Üê ENNReal.coe_rpow_of_nonneg _ (by positivity), ‚Üê ENNReal.rpow_mul]
        field_simp
    _ = ‚à´‚Åª x, ‚àè _i : Œπ, (‚Äñu x‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ (1 / (#Œπ - 1 : ‚Ñù)) := by
        gcongr with x
        simp_rw [prod_const, card_univ]
        norm_cast
    _ ‚â§ ‚à´‚Åª x, ‚àè i, (‚à´‚Åª x·µ¢, ‚Äñfderiv ‚Ñù u (Function.update x i x·µ¢)‚Äñ‚Çä) ^ ((1 : ‚Ñù) / (#Œπ - 1 : ‚Ñù)) := ?_
    _ ‚â§ (‚à´‚Åª x, ‚Äñfderiv ‚Ñù u x‚Äñ‚Çä) ^ ((#Œπ : ‚Ñù) / (#Œπ - 1 : ‚Ñù)) := by
        apply lintegral_prod_lintegral_pow_le
        borelize ((Œπ ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] ‚Ñù)
        have : Measurable (fun x ‚Ü¶ fderiv ‚Ñù u x) := (hu.continuous_fderiv (le_refl _)).measurable
        measurability
  gcongr with x i
  calc (‚Äñu x‚Äñ‚Çä : ‚Ñù‚â•0‚àû)
      = (‚Äñ‚à´ x·µ¢ : ‚Ñù in Set.Iic (x i), deriv (u ‚àò update x i) x·µ¢‚Äñ‚Çä : ‚Ñù‚â•0‚àû) := by
        have h3u : ContDiff ‚Ñù 1 (u ‚àò update x i) := hu.comp (contDiff_update 1 x i)
        have h4u : HasCompactSupport (u ‚àò update x i)
        ¬∑ apply h2u.comp_closedEmbedding
          -- `update x i` is a closed embedding -- make this a lemma
          have h5u : LeftInverse (fun v ‚Ü¶ v i) (update x i) := fun t ‚Ü¶ update_same i t x
          apply h5u.closedEmbedding
          ¬∑ exact continuous_apply i
          ¬∑ have : Continuous (fun t : ‚Ñù ‚Ü¶ (x, t)) := continuous_const.prod_mk continuous_id
            exact (continuous_update i).comp this
        rw [h4u.integral_deriv_eq h3u (x i)]
        simp
    _ ‚â§ ‚à´‚Åª x·µ¢ : ‚Ñù in Set.Iic (x i), ‚Äñderiv (u ‚àò update x i) x·µ¢‚Äñ‚Çä :=
        nnnorm_integral_le_lintegral_nnnorm _
    _ ‚â§ ‚à´‚Åª (x·µ¢ : ‚Ñù), ‚Üë‚Äñfderiv ‚Ñù u (update x i x·µ¢)‚Äñ‚Çä := ?_
  gcongr with y; swap; exact Measure.restrict_le_self
  calc ‚Äñderiv (u ‚àò update x i) y‚Äñ‚Çä = ‚Äñfderiv ‚Ñù u (update x i y) (deriv (update x i) y)‚Äñ‚Çä := by
        rw [fderiv.comp_deriv _ (hu.differentiable le_rfl).differentiableAt
          (hasDerivAt_update y).differentiableAt]
    _ ‚â§ ‚Äñfderiv ‚Ñù u (update x i y)‚Äñ‚Çä * ‚Äñderiv (update x i) y‚Äñ‚Çä :=
        ContinuousLinearMap.le_op_nnnorm ..
    _ ‚â§ ‚Äñfderiv ‚Ñù u (update x i y)‚Äñ‚Çä := by simp [deriv_update, Pi.nnnorm_single]

-- /-- The Sobolev inequality for the Lebesgue l=integral(?) -/
-- theorem lintegral_pow_le :
--     ‚à´‚Åª x, ‚Äñu x‚Äñ‚Çä ^ ((#Œπ : ‚Ñù) / (#Œπ - 1 : ‚Ñù)) ‚â§
--       (‚à´‚Åª x, ‚Äñfderiv ‚Ñù u x‚Äñ‚Çä) ^ ((#Œπ : ‚Ñù) / (#Œπ - 1 : ‚Ñù)) :=
--   by sorry

end Sobolev
