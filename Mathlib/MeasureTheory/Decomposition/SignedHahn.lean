/-
Copyright (c) 2021 Kexing Ying. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kexing Ying
-/
import Mathlib.MeasureTheory.Measure.VectorMeasure
import Mathlib.Order.SymmDiff

#align_import measure_theory.decomposition.signed_hahn from "leanprover-community/mathlib"@"bc7d81beddb3d6c66f71449c5bc76c38cb77cf9e"

/-!
# Hahn decomposition

This file proves the Hahn decomposition theorem (signed version). The Hahn decomposition theorem
states that, given a signed measure `s`, there exist complementary, measurable sets `i` and `j`,
such that `i` is positive and `j` is negative with respect to `s`; that is, `s` restricted on `i`
is non-negative and `s` restricted on `j` is non-positive.

The Hahn decomposition theorem leads to many other results in measure theory, most notably,
the Jordan decomposition theorem, the Lebesgue decomposition theorem and the Radon-Nikodym theorem.

## Main results

* `MeasureTheory.SignedMeasure.exists_isCompl_positive_negative` : the Hahn decomposition
  theorem.
* `MeasureTheory.SignedMeasure.exists_subset_restrict_nonpos` : A measurable set of negative
  measure contains a negative subset.

## Notation

We use the notations `0 ‚â§[i] s` and `s ‚â§[i] 0` to denote the usual definitions of a set `i`
being positive/negative with respect to the signed measure `s`.

## Tags

Hahn decomposition theorem
-/


noncomputable section

open scoped Classical BigOperators NNReal ENNReal MeasureTheory

variable {Œ± Œ≤ : Type*} [MeasurableSpace Œ±]

variable {M : Type*} [AddCommMonoid M] [TopologicalSpace M] [OrderedAddCommMonoid M]

namespace MeasureTheory

namespace SignedMeasure

open Filter VectorMeasure

variable {s : SignedMeasure Œ±} {i j : Set Œ±}

section ExistsSubsetRestrictNonpos

/-! ### exists_subset_restrict_nonpos

In this section we will prove that a set `i` whose measure is negative contains a negative subset
`j` with respect to the signed measure `s` (i.e. `s ‚â§[j] 0`), whose measure is negative. This lemma
is used to prove the Hahn decomposition theorem.

To prove this lemma, we will construct a sequence of measurable sets $(A_n)_{n \in \mathbb{N}}$,
such that, for all $n$, $s(A_{n + 1})$ is close to maximal among subsets of
$i \setminus \bigcup_{k \le n} A_k$.

This sequence of sets does not necessarily exist. However, if this sequence terminates; that is,
there does not exists any sets satisfying the property, the last $A_n$ will be a negative subset
of negative measure, hence proving our claim.

In the case that the sequence does not terminate, it is easy to see that
$i \setminus \bigcup_{k = 0}^\infty A_k$ is the required negative set.

To implement this in Lean, we define several auxiliary definitions.

- given the sets `i` and the natural number `n`, `ExistsOneDivLT s i n` is the property that
  there exists a measurable set `k ‚äÜ i` such that `1 / (n + 1) < s k`.
- given the sets `i` and that `i` is not negative, `findExistsOneDivLT s i` is the
  least natural number `n` such that `ExistsOneDivLT s i n`.
- given the sets `i` and that `i` is not negative, `someExistsOneDivLT` chooses the set
  `k` from `ExistsOneDivLT s i (findExistsOneDivLT s i)`.
- lastly, given the set `i`, `restrictNonposSeq s i` is the sequence of sets defined inductively
  where
  `restrictNonposSeq s i 0 = someExistsOneDivLT s (i \ ‚àÖ)` and
  `restrictNonposSeq s i (n + 1) = someExistsOneDivLT s (i \ ‚ãÉ k ‚â§ n, restrictNonposSeq k)`.
  This definition represents the sequence $(A_n)$¬†in the proof as described above.

With these definitions, we are able consider the case where the sequence terminates separately,
allowing us to prove `exists_subset_restrict_nonpos`.
-/


/-- Given the set `i` and the natural number `n`, `ExistsOneDivLT s i j` is the property that
there exists a measurable set `k ‚äÜ i` such that `1 / (n + 1) < s k`. -/
private def ExistsOneDivLT (s : SignedMeasure Œ±) (i : Set Œ±) (n : ‚Ñï) : Prop :=
  ‚àÉ k : Set Œ±, k ‚äÜ i ‚àß MeasurableSet k ‚àß (1 / (n + 1) : ‚Ñù) < s k

private theorem existsNatOneDivLTMeasure_of_not_negative (hi : ¬¨s ‚â§[i] 0) :
    ‚àÉ n : ‚Ñï, ExistsOneDivLT s i n :=
  let ‚ü®k, hj‚ÇÅ, hj‚ÇÇ, hj‚ü© := exists_pos_measure_of_not_restrict_le_zero s hi
  let ‚ü®n, hn‚ü© := exists_nat_one_div_lt hj
  ‚ü®n, k, hj‚ÇÇ, hj‚ÇÅ, hn‚ü©

/-- Given the set `i`, if `i` is not negative, `findExistsOneDivLT s i` is the
least natural number `n` such that `ExistsOneDivLT s i n`, otherwise, it returns 0. -/
private def findExistsOneDivLT (s : SignedMeasure Œ±) (i : Set Œ±) : ‚Ñï :=
  if hi : ¬¨s ‚â§[i] 0 then Nat.find (existsNatOneDivLTMeasure_of_not_negative hi) else 0

private theorem findExistsOneDivLT_spec (hi : ¬¨s ‚â§[i] 0) :
    ExistsOneDivLT s i (findExistsOneDivLT s i) := by
  rw [findExistsOneDivLT, dif_pos hi]
  -- ‚ä¢ MeasureTheory.SignedMeasure.ExistsOneDivLT s i (Nat.find (_ : ‚àÉ n, MeasureTh ‚Ä¶
  convert Nat.find_spec (existsNatOneDivLTMeasure_of_not_negative hi)
  -- üéâ no goals

private theorem findExistsOneDivLT_min (hi : ¬¨s ‚â§[i] 0) {m : ‚Ñï}
    (hm : m < findExistsOneDivLT s i) : ¬¨ExistsOneDivLT s i m := by
  rw [findExistsOneDivLT, dif_pos hi] at hm
  -- ‚ä¢ ¬¨MeasureTheory.SignedMeasure.ExistsOneDivLT s i m
  exact Nat.find_min _ hm
  -- üéâ no goals

/-- Given the set `i`, if `i` is not negative, `someExistsOneDivLT` chooses the set
`k` from `ExistsOneDivLT s i (findExistsOneDivLT s i)`, otherwise, it returns the
empty set. -/
private def someExistsOneDivLT (s : SignedMeasure Œ±) (i : Set Œ±) : Set Œ± :=
  if hi : ¬¨s ‚â§[i] 0 then Classical.choose (findExistsOneDivLT_spec hi) else ‚àÖ

private theorem someExistsOneDivLT_spec (hi : ¬¨s ‚â§[i] 0) :
    someExistsOneDivLT s i ‚äÜ i ‚àß
      MeasurableSet (someExistsOneDivLT s i) ‚àß
        (1 / (findExistsOneDivLT s i + 1) : ‚Ñù) < s (someExistsOneDivLT s i) := by
  rw [someExistsOneDivLT, dif_pos hi]
  -- ‚ä¢ Classical.choose (_ : MeasureTheory.SignedMeasure.ExistsOneDivLT s i (Measur ‚Ä¶
  exact Classical.choose_spec (findExistsOneDivLT_spec hi)
  -- üéâ no goals

private theorem someExistsOneDivLT_subset : someExistsOneDivLT s i ‚äÜ i := by
  by_cases hi : ¬¨s ‚â§[i] 0
  -- ‚ä¢ MeasureTheory.SignedMeasure.someExistsOneDivLT s i ‚äÜ i
  ¬∑ exact
      let ‚ü®h, _‚ü© := someExistsOneDivLT_spec hi
      h
  ¬∑ rw [someExistsOneDivLT, dif_neg hi]
    -- ‚ä¢ ‚àÖ ‚äÜ i
    exact Set.empty_subset _
    -- üéâ no goals

private theorem someExistsOneDivLT_subset' : someExistsOneDivLT s (i \ j) ‚äÜ i :=
  Set.Subset.trans someExistsOneDivLT_subset (Set.diff_subset _ _)

private theorem someExistsOneDivLT_measurableSet : MeasurableSet (someExistsOneDivLT s i) := by
  by_cases hi : ¬¨s ‚â§[i] 0
  -- ‚ä¢ MeasurableSet (MeasureTheory.SignedMeasure.someExistsOneDivLT s i)
  ¬∑ exact
      let ‚ü®_, h, _‚ü© := someExistsOneDivLT_spec hi
      h
  ¬∑ rw [someExistsOneDivLT, dif_neg hi]
    -- ‚ä¢ MeasurableSet ‚àÖ
    exact MeasurableSet.empty
    -- üéâ no goals

private theorem someExistsOneDivLT_lt (hi : ¬¨s ‚â§[i] 0) :
    (1 / (findExistsOneDivLT s i + 1) : ‚Ñù) < s (someExistsOneDivLT s i) :=
  let ‚ü®_, _, h‚ü© := someExistsOneDivLT_spec hi
  h

/-- Given the set `i`, `restrictNonposSeq s i` is the sequence of sets defined inductively where
`restrictNonposSeq s i 0 = someExistsOneDivLT s (i \ ‚àÖ)` and
`restrictNonposSeq s i (n + 1) = someExistsOneDivLT s (i \ ‚ãÉ k ‚â§ n, restrictNonposSeq k)`.

For each `n : ‚Ñï`,`s (restrictNonposSeq s i n)` is close to maximal among all subsets of
`i \ ‚ãÉ k ‚â§ n, restrictNonposSeq s i k`. -/
private def restrictNonposSeq (s : SignedMeasure Œ±) (i : Set Œ±) : ‚Ñï ‚Üí Set Œ±
  | 0 => someExistsOneDivLT s (i \ ‚àÖ) -- I used `i \ ‚àÖ` instead of `i` to simplify some proofs
  | n + 1 =>
    someExistsOneDivLT s
      (i \
        ‚ãÉ (k) (H : k ‚â§ n),
          have : k < n + 1 := Nat.lt_succ_iff.mpr H
          restrictNonposSeq s i k)

private theorem restrictNonposSeq_succ (n : ‚Ñï) :
    restrictNonposSeq s i n.succ = someExistsOneDivLT s (i \ ‚ãÉ k ‚â§ n, restrictNonposSeq s i k) := by
  rw [restrictNonposSeq]
  -- üéâ no goals

private theorem restrictNonposSeq_subset (n : ‚Ñï) : restrictNonposSeq s i n ‚äÜ i := by
  cases n <;> ¬∑ rw [restrictNonposSeq]; exact someExistsOneDivLT_subset'
  -- ‚ä¢ MeasureTheory.SignedMeasure.restrictNonposSeq s i Nat.zero ‚äÜ i
                -- ‚ä¢ MeasureTheory.SignedMeasure.someExistsOneDivLT s (i \ ‚àÖ) ‚äÜ i
                                        -- üéâ no goals
                -- ‚ä¢ MeasureTheory.SignedMeasure.someExistsOneDivLT s
                                        -- üéâ no goals

private theorem restrictNonposSeq_lt (n : ‚Ñï) (hn : ¬¨s ‚â§[i \ ‚ãÉ k ‚â§ n, restrictNonposSeq s i k] 0) :
    (1 / (findExistsOneDivLT s (i \ ‚ãÉ k ‚â§ n, restrictNonposSeq s i k) + 1) : ‚Ñù) <
      s (restrictNonposSeq s i n.succ) := by
  rw [restrictNonposSeq_succ]
  -- ‚ä¢ 1 / (‚Üë(MeasureTheory.SignedMeasure.findExistsOneDivLT s (i \ ‚ãÉ (k : ‚Ñï) (_ :  ‚Ä¶
  apply someExistsOneDivLT_lt hn
  -- üéâ no goals

private theorem measure_of_restrictNonposSeq (hi‚ÇÇ : ¬¨s ‚â§[i] 0) (n : ‚Ñï)
    (hn : ¬¨s ‚â§[i \ ‚ãÉ k < n, restrictNonposSeq s i k] 0) : 0 < s (restrictNonposSeq s i n) := by
  cases n with
  | zero =>
    rw [restrictNonposSeq]; rw [‚Üê @Set.diff_empty _ i] at hi‚ÇÇ
    rcases someExistsOneDivLT_spec hi‚ÇÇ with ‚ü®_, _, h‚ü©
    exact lt_trans Nat.one_div_pos_of_nat h
  | succ n =>
    rw [restrictNonposSeq_succ]
    have h‚ÇÅ : ¬¨s ‚â§[i \ ‚ãÉ (k : ‚Ñï) (_ : k ‚â§ n), restrictNonposSeq s i k] 0 := by
      refine' mt (restrict_le_zero_subset _ _ (by simp [Nat.lt_succ_iff]; rfl)) hn
      convert measurable_of_not_restrict_le_zero _ hn using 3
      exact funext fun x => by rw [Nat.lt_succ_iff]
    rcases someExistsOneDivLT_spec h‚ÇÅ with ‚ü®_, _, h‚ü©
    exact lt_trans Nat.one_div_pos_of_nat h

private theorem restrictNonposSeq_measurableSet (n : ‚Ñï) :
    MeasurableSet (restrictNonposSeq s i n) := by
  cases n <;>
  -- ‚ä¢ MeasurableSet (MeasureTheory.SignedMeasure.restrictNonposSeq s i Nat.zero)
    ¬∑ rw [restrictNonposSeq]
      -- ‚ä¢ MeasurableSet (MeasureTheory.SignedMeasure.someExistsOneDivLT s (i \ ‚àÖ))
      -- ‚ä¢ MeasurableSet
      -- üéâ no goals
      exact someExistsOneDivLT_measurableSet
      -- üéâ no goals

private theorem restrictNonposSeq_disjoint' {n m : ‚Ñï} (h : n < m) :
    restrictNonposSeq s i n ‚à© restrictNonposSeq s i m = ‚àÖ := by
  rw [Set.eq_empty_iff_forall_not_mem]
  -- ‚ä¢ ‚àÄ (x : Œ±), ¬¨x ‚àà MeasureTheory.SignedMeasure.restrictNonposSeq s i n ‚à© Measur ‚Ä¶
  rintro x ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©
  -- ‚ä¢ False
  cases m; ¬∑ rw [Nat.zero_eq] at h; linarith
  -- ‚ä¢ False
             -- ‚ä¢ False
                                    -- üéâ no goals
  ¬∑ rw [restrictNonposSeq] at hx‚ÇÇ
    -- ‚ä¢ False
    exact
      (someExistsOneDivLT_subset hx‚ÇÇ).2
        (Set.mem_iUnion.2 ‚ü®n, Set.mem_iUnion.2 ‚ü®Nat.lt_succ_iff.mp h, hx‚ÇÅ‚ü©‚ü©)

private theorem restrictNonposSeq_disjoint : Pairwise (Disjoint on restrictNonposSeq s i) := by
  intro n m h
  -- ‚ä¢ (Disjoint on MeasureTheory.SignedMeasure.restrictNonposSeq s i) n m
  rw [Function.onFun, Set.disjoint_iff_inter_eq_empty]
  -- ‚ä¢ MeasureTheory.SignedMeasure.restrictNonposSeq s i n ‚à© MeasureTheory.SignedMe ‚Ä¶
  rcases lt_or_gt_of_ne h with (h | h)
  -- ‚ä¢ MeasureTheory.SignedMeasure.restrictNonposSeq s i n ‚à© MeasureTheory.SignedMe ‚Ä¶
  ¬∑ rw [restrictNonposSeq_disjoint' h]
    -- üéâ no goals
  ¬∑ rw [Set.inter_comm, restrictNonposSeq_disjoint' h]
    -- üéâ no goals

private theorem exists_subset_restrict_nonpos' (hi‚ÇÅ : MeasurableSet i) (hi‚ÇÇ : s i < 0)
    (hn : ¬¨‚àÄ n : ‚Ñï, ¬¨s ‚â§[i \ ‚ãÉ l < n, restrictNonposSeq s i l] 0) :
    ‚àÉ j : Set Œ±, MeasurableSet j ‚àß j ‚äÜ i ‚àß s ‚â§[j] 0 ‚àß s j < 0 := by
  by_cases s ‚â§[i] 0; ¬∑ exact ‚ü®i, hi‚ÇÅ, Set.Subset.refl _, h, hi‚ÇÇ‚ü©
  -- ‚ä¢ ‚àÉ j, MeasurableSet j ‚àß j ‚äÜ i ‚àß restrict s j ‚â§ restrict 0 j ‚àß ‚Üës j < 0
  -- ‚ä¢ ‚àÉ j, MeasurableSet j ‚àß j ‚äÜ i ‚àß restrict s j ‚â§ restrict 0 j ‚àß ‚Üës j < 0
                       -- üéâ no goals
  push_neg at hn
  -- ‚ä¢ ‚àÉ j, MeasurableSet j ‚àß j ‚äÜ i ‚àß restrict s j ‚â§ restrict 0 j ‚àß ‚Üës j < 0
  set k := Nat.find hn
  -- ‚ä¢ ‚àÉ j, MeasurableSet j ‚àß j ‚äÜ i ‚àß restrict s j ‚â§ restrict 0 j ‚àß ‚Üës j < 0
  have hk‚ÇÇ : s ‚â§[i \ ‚ãÉ l < k, restrictNonposSeq s i l] 0 := Nat.find_spec hn
  -- ‚ä¢ ‚àÉ j, MeasurableSet j ‚àß j ‚äÜ i ‚àß restrict s j ‚â§ restrict 0 j ‚àß ‚Üës j < 0
  have hmeas : MeasurableSet (‚ãÉ (l : ‚Ñï) (_ : l < k), restrictNonposSeq s i l) :=
    MeasurableSet.iUnion fun _ => MeasurableSet.iUnion fun _ => restrictNonposSeq_measurableSet _
  refine' ‚ü®i \ ‚ãÉ l < k, restrictNonposSeq s i l, hi‚ÇÅ.diff hmeas, Set.diff_subset _ _, hk‚ÇÇ, _‚ü©
  -- ‚ä¢ ‚Üës (i \ ‚ãÉ (l : ‚Ñï) (_ : l < k), MeasureTheory.SignedMeasure.restrictNonposSeq ‚Ä¶
  rw [of_diff hmeas hi‚ÇÅ, s.of_disjoint_iUnion_nat]
  ¬∑ have h‚ÇÅ : ‚àÄ l < k, 0 ‚â§ s (restrictNonposSeq s i l) := by
      intro l hl
      refine' le_of_lt (measure_of_restrictNonposSeq h _ _)
      refine' mt (restrict_le_zero_subset _ (hi‚ÇÅ.diff _) (Set.Subset.refl _)) (Nat.find_min hn hl)
      exact
        MeasurableSet.iUnion fun _ =>
          MeasurableSet.iUnion fun _ => restrictNonposSeq_measurableSet _
    suffices 0 ‚â§ ‚àë' l : ‚Ñï, s (‚ãÉ _ : l < k, restrictNonposSeq s i l) by
      rw [sub_neg]
      exact lt_of_lt_of_le hi‚ÇÇ this
    refine' tsum_nonneg _
    -- ‚ä¢ ‚àÄ (i_1 : ‚Ñï), 0 ‚â§ ‚Üës (‚ãÉ (_ : i_1 < k), MeasureTheory.SignedMeasure.restrictNo ‚Ä¶
    intro l; by_cases l < k
    -- ‚ä¢ 0 ‚â§ ‚Üës (‚ãÉ (_ : l < k), MeasureTheory.SignedMeasure.restrictNonposSeq s i l)
             -- ‚ä¢ 0 ‚â§ ‚Üës (‚ãÉ (_ : l < k), MeasureTheory.SignedMeasure.restrictNonposSeq s i l)
             -- ‚ä¢ 0 ‚â§ ‚Üës (‚ãÉ (_ : l < k), MeasureTheory.SignedMeasure.restrictNonposSeq s i l)
    ¬∑ convert h‚ÇÅ _ h
      -- ‚ä¢ ‚ãÉ (_ : l < k), MeasureTheory.SignedMeasure.restrictNonposSeq s i l = Measure ‚Ä¶
      ext x
      -- ‚ä¢ x ‚àà ‚ãÉ (_ : l < k), MeasureTheory.SignedMeasure.restrictNonposSeq s i l ‚Üî x ‚àà ‚Ä¶
      rw [Set.mem_iUnion, exists_prop, and_iff_right_iff_imp]
      -- ‚ä¢ x ‚àà MeasureTheory.SignedMeasure.restrictNonposSeq s i l ‚Üí l < k
      exact fun _ => h
      -- üéâ no goals
    ¬∑ convert le_of_eq s.empty.symm
      -- ‚ä¢ ‚ãÉ (_ : l < k), MeasureTheory.SignedMeasure.restrictNonposSeq s i l = ‚àÖ
      ext; simp only [exists_prop, Set.mem_empty_iff_false, Set.mem_iUnion, not_and, iff_false_iff]
      -- ‚ä¢ x‚úù ‚àà ‚ãÉ (_ : l < k), MeasureTheory.SignedMeasure.restrictNonposSeq s i l ‚Üî x‚úù ‚Ä¶
           -- ‚ä¢ l < Nat.find hn ‚Üí ¬¨x‚úù ‚àà MeasureTheory.SignedMeasure.restrictNonposSeq s i l
      exact fun h' => False.elim (h h')
      -- üéâ no goals
  ¬∑ intro; exact MeasurableSet.iUnion fun _ => restrictNonposSeq_measurableSet _
    -- ‚ä¢ MeasurableSet (‚ãÉ (_ : i‚úù < k), MeasureTheory.SignedMeasure.restrictNonposSeq ‚Ä¶
           -- üéâ no goals
  ¬∑ intro a b hab
    -- ‚ä¢ (Disjoint on fun l => ‚ãÉ (_ : l < k), MeasureTheory.SignedMeasure.restrictNon ‚Ä¶
    refine' Set.disjoint_iUnion_left.mpr fun _ => _
    -- ‚ä¢ Disjoint (MeasureTheory.SignedMeasure.restrictNonposSeq s i a) ((fun l => ‚ãÉ  ‚Ä¶
    refine' Set.disjoint_iUnion_right.mpr fun _ => _
    -- ‚ä¢ Disjoint (MeasureTheory.SignedMeasure.restrictNonposSeq s i a) (MeasureTheor ‚Ä¶
    exact restrictNonposSeq_disjoint hab
    -- üéâ no goals
  ¬∑ apply Set.iUnion_subset
    -- ‚ä¢ ‚àÄ (i_1 : ‚Ñï), ‚ãÉ (_ : i_1 < k), MeasureTheory.SignedMeasure.restrictNonposSeq  ‚Ä¶
    intro a x
    -- ‚ä¢ x ‚àà ‚ãÉ (_ : a < k), MeasureTheory.SignedMeasure.restrictNonposSeq s i a ‚Üí x ‚àà i
    simp only [and_imp, exists_prop, Set.mem_iUnion]
    -- ‚ä¢ a < Nat.find hn ‚Üí x ‚àà MeasureTheory.SignedMeasure.restrictNonposSeq s i a ‚Üí  ‚Ä¶
    intro _ hx
    -- ‚ä¢ x ‚àà i
    exact restrictNonposSeq_subset _ hx
    -- üéâ no goals

/-- A measurable set of negative measure has a negative subset of negative measure. -/
theorem exists_subset_restrict_nonpos (hi : s i < 0) :
    ‚àÉ j : Set Œ±, MeasurableSet j ‚àß j ‚äÜ i ‚àß s ‚â§[j] 0 ‚àß s j < 0 := by
  have hi‚ÇÅ : MeasurableSet i := by_contradiction fun h => ne_of_lt hi <| s.not_measurable h
  -- ‚ä¢ ‚àÉ j, MeasurableSet j ‚àß j ‚äÜ i ‚àß restrict s j ‚â§ restrict 0 j ‚àß ‚Üës j < 0
  by_cases s ‚â§[i] 0; ¬∑ exact ‚ü®i, hi‚ÇÅ, Set.Subset.refl _, h, hi‚ü©
  -- ‚ä¢ ‚àÉ j, MeasurableSet j ‚àß j ‚äÜ i ‚àß restrict s j ‚â§ restrict 0 j ‚àß ‚Üës j < 0
  -- ‚ä¢ ‚àÉ j, MeasurableSet j ‚àß j ‚äÜ i ‚àß restrict s j ‚â§ restrict 0 j ‚àß ‚Üës j < 0
                       -- üéâ no goals
  by_cases hn : ‚àÄ n : ‚Ñï, ¬¨s ‚â§[i \ ‚ãÉ l < n, restrictNonposSeq s i l] 0
  -- ‚ä¢ ‚àÉ j, MeasurableSet j ‚àß j ‚äÜ i ‚àß restrict s j ‚â§ restrict 0 j ‚àß ‚Üës j < 0
  swap; ¬∑ exact exists_subset_restrict_nonpos' hi‚ÇÅ hi hn
  -- ‚ä¢ ‚àÉ j, MeasurableSet j ‚àß j ‚äÜ i ‚àß restrict s j ‚â§ restrict 0 j ‚àß ‚Üës j < 0
          -- üéâ no goals
  set A := i \ ‚ãÉ l, restrictNonposSeq s i l with hA
  -- ‚ä¢ ‚àÉ j, MeasurableSet j ‚àß j ‚äÜ i ‚àß restrict s j ‚â§ restrict 0 j ‚àß ‚Üës j < 0
  set bdd : ‚Ñï ‚Üí ‚Ñï := fun n => findExistsOneDivLT s (i \ ‚ãÉ k ‚â§ n, restrictNonposSeq s i k)
  -- ‚ä¢ ‚àÉ j, MeasurableSet j ‚àß j ‚äÜ i ‚àß restrict s j ‚â§ restrict 0 j ‚àß ‚Üës j < 0
  have hn' : ‚àÄ n : ‚Ñï, ¬¨s ‚â§[i \ ‚ãÉ l ‚â§ n, restrictNonposSeq s i l] 0 := by
    intro n
    convert hn (n + 1) using 5 <;>
      ¬∑ ext l
        simp only [exists_prop, Set.mem_iUnion, and_congr_left_iff]
        exact fun _ => Nat.lt_succ_iff.symm
  have h‚ÇÅ : s i = s A + ‚àë' l, s (restrictNonposSeq s i l) := by
    rw [hA, ‚Üê s.of_disjoint_iUnion_nat, add_comm, of_add_of_diff]
    exact MeasurableSet.iUnion fun _ => restrictNonposSeq_measurableSet _
    exacts [hi‚ÇÅ, Set.iUnion_subset fun _ => restrictNonposSeq_subset _, fun _ =>
      restrictNonposSeq_measurableSet _, restrictNonposSeq_disjoint]
  have h‚ÇÇ : s A ‚â§ s i := by
    rw [h‚ÇÅ]
    apply le_add_of_nonneg_right
    exact tsum_nonneg fun n => le_of_lt (measure_of_restrictNonposSeq h _ (hn n))
  have h‚ÇÉ' : Summable fun n => (1 / (bdd n + 1) : ‚Ñù) := by
    have : Summable fun l => s (restrictNonposSeq s i l) :=
      HasSum.summable
        (s.m_iUnion (fun _ => restrictNonposSeq_measurableSet _) restrictNonposSeq_disjoint)
    refine'
      summable_of_nonneg_of_le (fun n => _) (fun n => _)
        (Summable.comp_injective this Nat.succ_injective)
    ¬∑ exact le_of_lt Nat.one_div_pos_of_nat
    ¬∑ exact le_of_lt (restrictNonposSeq_lt n (hn' n))
  have h‚ÇÉ : Tendsto (fun n => (bdd n : ‚Ñù) + 1) atTop atTop := by
    simp only [one_div] at h‚ÇÉ'
    exact Summable.tendsto_atTop_of_pos h‚ÇÉ' fun n => Nat.cast_add_one_pos (bdd n)
  have h‚ÇÑ : Tendsto (fun n => (bdd n : ‚Ñù)) atTop atTop := by
    convert atTop.tendsto_atTop_add_const_right (-1) h‚ÇÉ; simp
  have A_meas : MeasurableSet A :=
    hi‚ÇÅ.diff (MeasurableSet.iUnion fun _ => restrictNonposSeq_measurableSet _)
  refine' ‚ü®A, A_meas, Set.diff_subset _ _, _, h‚ÇÇ.trans_lt hi‚ü©
  -- ‚ä¢ restrict s A ‚â§ restrict 0 A
  by_contra hnn
  -- ‚ä¢ False
  rw [restrict_le_restrict_iff _ _ A_meas] at hnn; push_neg at hnn
  -- ‚ä¢ False
                                                   -- ‚ä¢ False
  obtain ‚ü®E, hE‚ÇÅ, hE‚ÇÇ, hE‚ÇÉ‚ü© := hnn
  -- ‚ä¢ False
  have : ‚àÉ k, 1 ‚â§ bdd k ‚àß 1 / (bdd k : ‚Ñù) < s E := by
    rw [tendsto_atTop_atTop] at h‚ÇÑ
    obtain ‚ü®k, hk‚ü© := h‚ÇÑ (max (1 / s E + 1) 1)
    refine' ‚ü®k, _, _‚ü©
    ¬∑ have hle := le_of_max_le_right (hk k le_rfl)
      norm_cast at hle
    ¬∑ have : 1 / s E < bdd k := by
        linarith only [le_of_max_le_left (hk k le_rfl)]
      rw [one_div] at this ‚ä¢
      rwa [inv_lt (lt_trans (inv_pos.2 hE‚ÇÉ) this) hE‚ÇÉ]
  obtain ‚ü®k, hk‚ÇÅ, hk‚ÇÇ‚ü© := this
  -- ‚ä¢ False
  have hA' : A ‚äÜ i \ ‚ãÉ l ‚â§ k, restrictNonposSeq s i l := by
    apply Set.diff_subset_diff_right
    intro x; simp only [Set.mem_iUnion]
    rintro ‚ü®n, _, hn‚ÇÇ‚ü©
    exact ‚ü®n, hn‚ÇÇ‚ü©
  refine'
    findExistsOneDivLT_min (hn' k) (Nat.sub_lt hk‚ÇÅ Nat.zero_lt_one)
      ‚ü®E, Set.Subset.trans hE‚ÇÇ hA', hE‚ÇÅ, _‚ü©
  convert hk‚ÇÇ; norm_cast
  -- ‚ä¢ ‚Üë(MeasureTheory.SignedMeasure.findExistsOneDivLT s (i \ ‚ãÉ (l : ‚Ñï) (_ : l ‚â§ k ‚Ä¶
               -- ‚ä¢ MeasureTheory.SignedMeasure.findExistsOneDivLT s (i \ ‚ãÉ (l : ‚Ñï) (_ : l ‚â§ k), ‚Ä¶
  exact tsub_add_cancel_of_le hk‚ÇÅ
  -- üéâ no goals
#align measure_theory.signed_measure.exists_subset_restrict_nonpos MeasureTheory.SignedMeasure.exists_subset_restrict_nonpos

end ExistsSubsetRestrictNonpos

/-- The set of measures of the set of measurable negative sets. -/
def measureOfNegatives (s : SignedMeasure Œ±) : Set ‚Ñù :=
  s '' { B | MeasurableSet B ‚àß s ‚â§[B] 0 }
#align measure_theory.signed_measure.measure_of_negatives MeasureTheory.SignedMeasure.measureOfNegatives

theorem zero_mem_measureOfNegatives : (0 : ‚Ñù) ‚àà s.measureOfNegatives :=
  ‚ü®‚àÖ, ‚ü®MeasurableSet.empty, le_restrict_empty _ _‚ü©, s.empty‚ü©
#align measure_theory.signed_measure.zero_mem_measure_of_negatives MeasureTheory.SignedMeasure.zero_mem_measureOfNegatives

theorem bddBelow_measureOfNegatives : BddBelow s.measureOfNegatives := by
  simp_rw [BddBelow, Set.Nonempty, mem_lowerBounds]
  -- ‚ä¢ ‚àÉ x, ‚àÄ (x_1 : ‚Ñù), x_1 ‚àà measureOfNegatives s ‚Üí x ‚â§ x_1
  by_contra' h
  -- ‚ä¢ False
  have h' : ‚àÄ n : ‚Ñï, ‚àÉ y : ‚Ñù, y ‚àà s.measureOfNegatives ‚àß y < -n := fun n => h (-n)
  -- ‚ä¢ False
  choose f hf using h'
  -- ‚ä¢ False
  have hf' : ‚àÄ n : ‚Ñï, ‚àÉ B, MeasurableSet B ‚àß s ‚â§[B] 0 ‚àß s B < -n := by
    intro n
    rcases hf n with ‚ü®‚ü®B, ‚ü®hB‚ÇÅ, hBr‚ü©, hB‚ÇÇ‚ü©, hlt‚ü©
    exact ‚ü®B, hB‚ÇÅ, hBr, hB‚ÇÇ.symm ‚ñ∏ hlt‚ü©
  choose B hmeas hr h_lt using hf'
  -- ‚ä¢ False
  set A := ‚ãÉ n, B n with hA
  -- ‚ä¢ False
  have hfalse : ‚àÄ n : ‚Ñï, s A ‚â§ -n := by
    intro n
    refine' le_trans _ (le_of_lt (h_lt _))
    rw [hA, ‚Üê Set.diff_union_of_subset (Set.subset_iUnion _ n),
      of_union Set.disjoint_sdiff_left _ (hmeas n)]
    ¬∑ refine' add_le_of_nonpos_left _
      have : s ‚â§[A] 0 := restrict_le_restrict_iUnion _ _ hmeas hr
      refine' nonpos_of_restrict_le_zero _ (restrict_le_zero_subset _ _ (Set.diff_subset _ _) this)
      exact MeasurableSet.iUnion hmeas
    ¬∑ exact (MeasurableSet.iUnion hmeas).diff (hmeas n)
  rcases exists_nat_gt (-s A) with ‚ü®n, hn‚ü©
  -- ‚ä¢ False
  exact lt_irrefl _ ((neg_lt.1 hn).trans_le (hfalse n))
  -- üéâ no goals
#align measure_theory.signed_measure.bdd_below_measure_of_negatives MeasureTheory.SignedMeasure.bddBelow_measureOfNegatives

/-- Alternative formulation of `measure_theory.signed_measure.exists_is_compl_positive_negative`
(the Hahn decomposition theorem) using set complements. -/
theorem exists_compl_positive_negative (s : SignedMeasure Œ±) :
    ‚àÉ i : Set Œ±, MeasurableSet i ‚àß 0 ‚â§[i] s ‚àß s ‚â§[i·∂ú] 0 := by
  obtain ‚ü®f, _, hf‚ÇÇ, hf‚ÇÅ‚ü© :=
    exists_seq_tendsto_sInf ‚ü®0, @zero_mem_measureOfNegatives _ _ s‚ü© bddBelow_measureOfNegatives
  choose B hB using hf‚ÇÅ
  -- ‚ä¢ ‚àÉ i, MeasurableSet i ‚àß restrict 0 i ‚â§ restrict s i ‚àß restrict s i·∂ú ‚â§ restric ‚Ä¶
  have hB‚ÇÅ : ‚àÄ n, MeasurableSet (B n) := fun n => (hB n).1.1
  -- ‚ä¢ ‚àÉ i, MeasurableSet i ‚àß restrict 0 i ‚â§ restrict s i ‚àß restrict s i·∂ú ‚â§ restric ‚Ä¶
  have hB‚ÇÇ : ‚àÄ n, s ‚â§[B n] 0 := fun n => (hB n).1.2
  -- ‚ä¢ ‚àÉ i, MeasurableSet i ‚àß restrict 0 i ‚â§ restrict s i ‚àß restrict s i·∂ú ‚â§ restric ‚Ä¶
  set A := ‚ãÉ n, B n with hA
  -- ‚ä¢ ‚àÉ i, MeasurableSet i ‚àß restrict 0 i ‚â§ restrict s i ‚àß restrict s i·∂ú ‚â§ restric ‚Ä¶
  have hA‚ÇÅ : MeasurableSet A := MeasurableSet.iUnion hB‚ÇÅ
  -- ‚ä¢ ‚àÉ i, MeasurableSet i ‚àß restrict 0 i ‚â§ restrict s i ‚àß restrict s i·∂ú ‚â§ restric ‚Ä¶
  have hA‚ÇÇ : s ‚â§[A] 0 := restrict_le_restrict_iUnion _ _ hB‚ÇÅ hB‚ÇÇ
  -- ‚ä¢ ‚àÉ i, MeasurableSet i ‚àß restrict 0 i ‚â§ restrict s i ‚àß restrict s i·∂ú ‚â§ restric ‚Ä¶
  have hA‚ÇÉ : s A = sInf s.measureOfNegatives := by
    apply le_antisymm
    ¬∑ refine' le_of_tendsto_of_tendsto tendsto_const_nhds hf‚ÇÇ (eventually_of_forall fun n => _)
      rw [‚Üê (hB n).2, hA, ‚Üê Set.diff_union_of_subset (Set.subset_iUnion _ n),
        of_union Set.disjoint_sdiff_left _ (hB‚ÇÅ n)]
      ¬∑ refine' add_le_of_nonpos_left _
        have : s ‚â§[A] 0 :=
          restrict_le_restrict_iUnion _ _ hB‚ÇÅ fun m =>
            let ‚ü®_, h‚ü© := (hB m).1
            h
        refine'
          nonpos_of_restrict_le_zero _ (restrict_le_zero_subset _ _ (Set.diff_subset _ _) this)
        exact MeasurableSet.iUnion hB‚ÇÅ
      ¬∑ exact (MeasurableSet.iUnion hB‚ÇÅ).diff (hB‚ÇÅ n)
    ¬∑ exact csInf_le bddBelow_measureOfNegatives ‚ü®A, ‚ü®hA‚ÇÅ, hA‚ÇÇ‚ü©, rfl‚ü©
  refine' ‚ü®A·∂ú, hA‚ÇÅ.compl, _, (compl_compl A).symm ‚ñ∏ hA‚ÇÇ‚ü©
  -- ‚ä¢ restrict 0 A·∂ú ‚â§ restrict s A·∂ú
  rw [restrict_le_restrict_iff _ _ hA‚ÇÅ.compl]
  -- ‚ä¢ ‚àÄ ‚¶Éj : Set Œ±‚¶Ñ, MeasurableSet j ‚Üí j ‚äÜ A·∂ú ‚Üí ‚Üë0 j ‚â§ ‚Üës j
  intro C _ hC‚ÇÅ
  -- ‚ä¢ ‚Üë0 C ‚â§ ‚Üës C
  by_contra' hC‚ÇÇ
  -- ‚ä¢ False
  rcases exists_subset_restrict_nonpos hC‚ÇÇ with ‚ü®D, hD‚ÇÅ, hD, hD‚ÇÇ, hD‚ÇÉ‚ü©
  -- ‚ä¢ False
  have : s (A ‚à™ D) < sInf s.measureOfNegatives := by
    rw [‚Üê hA‚ÇÉ,
      of_union (Set.disjoint_of_subset_right (Set.Subset.trans hD hC‚ÇÅ) disjoint_compl_right) hA‚ÇÅ
        hD‚ÇÅ]
    linarith
  refine' not_le.2 this _
  -- ‚ä¢ sInf (measureOfNegatives s) ‚â§ ‚Üës (A ‚à™ D)
  refine' csInf_le bddBelow_measureOfNegatives ‚ü®A ‚à™ D, ‚ü®_, _‚ü©, rfl‚ü©
  -- ‚ä¢ MeasurableSet (A ‚à™ D)
  ¬∑ exact hA‚ÇÅ.union hD‚ÇÅ
    -- üéâ no goals
  ¬∑ exact restrict_le_restrict_union _ _ hA‚ÇÅ hA‚ÇÇ hD‚ÇÅ hD‚ÇÇ
    -- üéâ no goals
#align measure_theory.signed_measure.exists_compl_positive_negative MeasureTheory.SignedMeasure.exists_compl_positive_negative

/-- **The Hahn decomposition theorem**: Given a signed measure `s`, there exist
complement measurable sets `i` and `j` such that `i` is positive, `j` is negative. -/
theorem exists_isCompl_positive_negative (s : SignedMeasure Œ±) :
    ‚àÉ i j : Set Œ±, MeasurableSet i ‚àß 0 ‚â§[i] s ‚àß MeasurableSet j ‚àß s ‚â§[j] 0 ‚àß IsCompl i j :=
  let ‚ü®i, hi‚ÇÅ, hi‚ÇÇ, hi‚ÇÉ‚ü© := exists_compl_positive_negative s
  ‚ü®i, i·∂ú, hi‚ÇÅ, hi‚ÇÇ, hi‚ÇÅ.compl, hi‚ÇÉ, isCompl_compl‚ü©
#align measure_theory.signed_measure.exists_is_compl_positive_negative MeasureTheory.SignedMeasure.exists_isCompl_positive_negative

/-- The symmetric difference of two Hahn decompositions has measure zero. -/
theorem of_symmDiff_compl_positive_negative {s : SignedMeasure Œ±} {i j : Set Œ±}
    (hi : MeasurableSet i) (hj : MeasurableSet j) (hi' : 0 ‚â§[i] s ‚àß s ‚â§[i·∂ú] 0)
    (hj' : 0 ‚â§[j] s ‚àß s ‚â§[j·∂ú] 0) : s (i ‚àÜ j) = 0 ‚àß s (i·∂ú ‚àÜ j·∂ú) = 0 := by
  rw [restrict_le_restrict_iff s 0, restrict_le_restrict_iff 0 s] at hi' hj'
  constructor
  ¬∑ rw [Set.symmDiff_def, Set.diff_eq_compl_inter, Set.diff_eq_compl_inter, of_union,
      le_antisymm (hi'.2 (hi.compl.inter hj) (Set.inter_subset_left _ _))
        (hj'.1 (hi.compl.inter hj) (Set.inter_subset_right _ _)),
      le_antisymm (hj'.2 (hj.compl.inter hi) (Set.inter_subset_left _ _))
        (hi'.1 (hj.compl.inter hi) (Set.inter_subset_right _ _)),
      zero_apply, zero_apply, zero_add]
    ¬∑ exact
        Set.disjoint_of_subset_left (Set.inter_subset_left _ _)
          (Set.disjoint_of_subset_right (Set.inter_subset_right _ _)
            (disjoint_comm.1 (IsCompl.disjoint isCompl_compl)))
    ¬∑ exact hj.compl.inter hi
      -- üéâ no goals
    ¬∑ exact hi.compl.inter hj
      -- üéâ no goals
  ¬∑ rw [Set.symmDiff_def, Set.diff_eq_compl_inter, Set.diff_eq_compl_inter, compl_compl,
      compl_compl, of_union,
      le_antisymm (hi'.2 (hj.inter hi.compl) (Set.inter_subset_right _ _))
        (hj'.1 (hj.inter hi.compl) (Set.inter_subset_left _ _)),
      le_antisymm (hj'.2 (hi.inter hj.compl) (Set.inter_subset_right _ _))
        (hi'.1 (hi.inter hj.compl) (Set.inter_subset_left _ _)),
      zero_apply, zero_apply, zero_add]
    ¬∑ exact
        Set.disjoint_of_subset_left (Set.inter_subset_left _ _)
          (Set.disjoint_of_subset_right (Set.inter_subset_right _ _)
            (IsCompl.disjoint isCompl_compl))
    ¬∑ exact hj.inter hi.compl
      -- üéâ no goals
    ¬∑ exact hi.inter hj.compl
      -- üéâ no goals
  all_goals measurability
  -- üéâ no goals
#align measure_theory.signed_measure.of_symm_diff_compl_positive_negative MeasureTheory.SignedMeasure.of_symmDiff_compl_positive_negative

end SignedMeasure

end MeasureTheory
