/-
Copyright (c) 2020 Yury Kudryashov All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yury Kudryashov, Moritz Doll
-/
import Mathlib.LinearAlgebra.Basic
import Mathlib.LinearAlgebra.Prod

#align_import linear_algebra.linear_pmap from "leanprover-community/mathlib"@"8b981918a93bc45a8600de608cde7944a80d92b9"

/-!
# Partially defined linear maps

A `LinearPMap R E F` or `E ‚Üí‚Çó.[R] F` is a linear map from a submodule of `E` to `F`.
We define a `SemilatticeInf` with `OrderBot` instance on this, and define three operations:

* `mkSpanSingleton` defines a partial linear map defined on the span of a singleton.
* `sup` takes two partial linear maps `f`, `g` that agree on the intersection of their
  domains, and returns the unique partial linear map on `f.domain ‚äî g.domain` that
  extends both `f` and `g`.
* `sSup` takes a `DirectedOn (¬∑ ‚â§ ¬∑)` set of partial linear maps, and returns the unique
  partial linear map on the `sSup` of their domains that extends all these maps.

Moreover, we define
* `LinearPMap.graph` is the graph of the partial linear map viewed as a submodule of `E √ó F`.

Partially defined maps are currently used in `Mathlib` to prove Hahn-Banach theorem
and its variations. Namely, `LinearPMap.sSup` implies that every chain of `LinearPMap`s
is bounded above.
They are also the basis for the theory of unbounded operators.

-/

open Set

universe u v w

/-- A `LinearPMap R E F` or `E ‚Üí‚Çó.[R] F` is a linear map from a submodule of `E` to `F`. -/
structure LinearPMap (R : Type u) [Ring R] (E : Type v) [AddCommGroup E] [Module R E] (F : Type w)
  [AddCommGroup F] [Module R F] where
  domain : Submodule R E
  toFun : domain ‚Üí‚Çó[R] F
#align linear_pmap LinearPMap

notation:25 E " ‚Üí‚Çó.[" R:25 "] " F:0 => LinearPMap R E F

variable {R : Type*} [Ring R] {E : Type*} [AddCommGroup E] [Module R E] {F : Type*}
  [AddCommGroup F] [Module R F] {G : Type*} [AddCommGroup G] [Module R G]

namespace LinearPMap

open Submodule

-- Porting note: A new definition underlying a coercion `‚Üë`.
@[coe]
def toFun' (f : E ‚Üí‚Çó.[R] F) : f.domain ‚Üí F := f.toFun

instance : CoeFun (E ‚Üí‚Çó.[R] F) fun f : E ‚Üí‚Çó.[R] F => f.domain ‚Üí F :=
  ‚ü®toFun'‚ü©

@[simp]
theorem toFun_eq_coe (f : E ‚Üí‚Çó.[R] F) (x : f.domain) : f.toFun x = f x :=
  rfl
#align linear_pmap.to_fun_eq_coe LinearPMap.toFun_eq_coe

@[ext]
theorem ext {f g : E ‚Üí‚Çó.[R] F} (h : f.domain = g.domain)
    (h' : ‚àÄ ‚¶Éx : f.domain‚¶Ñ ‚¶Éy : g.domain‚¶Ñ (_h : (x : E) = y), f x = g y) : f = g := by
  rcases f with ‚ü®f_dom, f‚ü©
  -- ‚ä¢ { domain := f_dom, toFun := f } = g
  rcases g with ‚ü®g_dom, g‚ü©
  -- ‚ä¢ { domain := f_dom, toFun := f } = { domain := g_dom, toFun := g }
  obtain rfl : f_dom = g_dom := h
  -- ‚ä¢ { domain := f_dom, toFun := f } = { domain := f_dom, toFun := g }
  obtain rfl : f = g := LinearMap.ext fun x => h' rfl
  -- ‚ä¢ { domain := f_dom, toFun := f } = { domain := f_dom, toFun := f }
  rfl
  -- üéâ no goals
#align linear_pmap.ext LinearPMap.ext

@[simp]
theorem map_zero (f : E ‚Üí‚Çó.[R] F) : f 0 = 0 :=
  f.toFun.map_zero
#align linear_pmap.map_zero LinearPMap.map_zero

theorem ext_iff {f g : E ‚Üí‚Çó.[R] F} :
    f = g ‚Üî
      ‚àÉ _domain_eq : f.domain = g.domain,
        ‚àÄ ‚¶Éx : f.domain‚¶Ñ ‚¶Éy : g.domain‚¶Ñ (_h : (x : E) = y), f x = g y :=
  ‚ü®fun EQ =>
    EQ ‚ñ∏
      ‚ü®rfl, fun x y h => by
        congr
        -- ‚ä¢ x = y
        exact_mod_cast h‚ü©,
        -- üéâ no goals
    fun ‚ü®deq, feq‚ü© => ext deq feq‚ü©
#align linear_pmap.ext_iff LinearPMap.ext_iff

theorem ext' {s : Submodule R E} {f g : s ‚Üí‚Çó[R] F} (h : f = g) : mk s f = mk s g :=
  h ‚ñ∏ rfl
#align linear_pmap.ext' LinearPMap.ext'

theorem map_add (f : E ‚Üí‚Çó.[R] F) (x y : f.domain) : f (x + y) = f x + f y :=
  f.toFun.map_add x y
#align linear_pmap.map_add LinearPMap.map_add

theorem map_neg (f : E ‚Üí‚Çó.[R] F) (x : f.domain) : f (-x) = -f x :=
  f.toFun.map_neg x
#align linear_pmap.map_neg LinearPMap.map_neg

theorem map_sub (f : E ‚Üí‚Çó.[R] F) (x y : f.domain) : f (x - y) = f x - f y :=
  f.toFun.map_sub x y
#align linear_pmap.map_sub LinearPMap.map_sub

theorem map_smul (f : E ‚Üí‚Çó.[R] F) (c : R) (x : f.domain) : f (c ‚Ä¢ x) = c ‚Ä¢ f x :=
  f.toFun.map_smul c x
#align linear_pmap.map_smul LinearPMap.map_smul

@[simp]
theorem mk_apply (p : Submodule R E) (f : p ‚Üí‚Çó[R] F) (x : p) : mk p f x = f x :=
  rfl
#align linear_pmap.mk_apply LinearPMap.mk_apply

/-- The unique `LinearPMap` on `R ‚àô x` that sends `x` to `y`. This version works for modules
over rings, and requires a proof of `‚àÄ c, c ‚Ä¢ x = 0 ‚Üí c ‚Ä¢ y = 0`. -/
noncomputable def mkSpanSingleton' (x : E) (y : F) (H : ‚àÄ c : R, c ‚Ä¢ x = 0 ‚Üí c ‚Ä¢ y = 0) :
    E ‚Üí‚Çó.[R] F where
  domain := R ‚àô x
  toFun :=
    have H : ‚àÄ c‚ÇÅ c‚ÇÇ : R, c‚ÇÅ ‚Ä¢ x = c‚ÇÇ ‚Ä¢ x ‚Üí c‚ÇÅ ‚Ä¢ y = c‚ÇÇ ‚Ä¢ y := by
      intro c‚ÇÅ c‚ÇÇ h
      -- ‚ä¢ c‚ÇÅ ‚Ä¢ y = c‚ÇÇ ‚Ä¢ y
      rw [‚Üê sub_eq_zero, ‚Üê sub_smul] at h ‚ä¢
      -- ‚ä¢ (c‚ÇÅ - c‚ÇÇ) ‚Ä¢ y = 0
      exact H _ h
      -- üéâ no goals
    { toFun := fun z => Classical.choose (mem_span_singleton.1 z.prop) ‚Ä¢ y
      -- Porting note: `dsimp only []` are required.
      -- Porting note: Were `Classical.choose_spec (mem_span_singleton.1 _)`.
      map_add' := fun y z => by
        dsimp only []
        -- ‚ä¢ Classical.choose (_ : ‚àÉ a, a ‚Ä¢ x = ‚Üë(y + z)) ‚Ä¢ y‚úù = Classical.choose (_ : ‚àÉ  ‚Ä¶
        rw [‚Üê add_smul]
        -- ‚ä¢ Classical.choose (_ : ‚àÉ a, a ‚Ä¢ x = ‚Üë(y + z)) ‚Ä¢ y‚úù = (Classical.choose (_ : ‚àÉ ‚Ä¶
        apply H
        -- ‚ä¢ Classical.choose (_ : ‚àÉ a, a ‚Ä¢ x = ‚Üë(y + z)) ‚Ä¢ x = (Classical.choose (_ : ‚àÉ  ‚Ä¶
        simp only [add_smul, sub_smul,
          fun w : R ‚àô x => Classical.choose_spec (mem_span_singleton.1 w.prop)]
        apply coe_add
        -- üéâ no goals
      map_smul' := fun c z => by
        dsimp only []
        -- ‚ä¢ Classical.choose (_ : ‚àÉ a, a ‚Ä¢ x = ‚Üë(c ‚Ä¢ z)) ‚Ä¢ y = ‚Üë(RingHom.id R) c ‚Ä¢ Class ‚Ä¶
        rw [smul_smul]
        -- ‚ä¢ Classical.choose (_ : ‚àÉ a, a ‚Ä¢ x = ‚Üë(c ‚Ä¢ z)) ‚Ä¢ y = (‚Üë(RingHom.id R) c * Clas ‚Ä¶
        apply H
        -- ‚ä¢ Classical.choose (_ : ‚àÉ a, a ‚Ä¢ x = ‚Üë(c ‚Ä¢ z)) ‚Ä¢ x = (‚Üë(RingHom.id R) c * Clas ‚Ä¶
        simp only [mul_smul,
          fun w : R ‚àô x => Classical.choose_spec (mem_span_singleton.1 w.prop)]
        apply coe_smul }
        -- üéâ no goals
#align linear_pmap.mk_span_singleton' LinearPMap.mkSpanSingleton'

@[simp]
theorem domain_mkSpanSingleton (x : E) (y : F) (H : ‚àÄ c : R, c ‚Ä¢ x = 0 ‚Üí c ‚Ä¢ y = 0) :
    (mkSpanSingleton' x y H).domain = R ‚àô x :=
  rfl
#align linear_pmap.domain_mk_span_singleton LinearPMap.domain_mkSpanSingleton

@[simp]
theorem mkSpanSingleton'_apply (x : E) (y : F) (H : ‚àÄ c : R, c ‚Ä¢ x = 0 ‚Üí c ‚Ä¢ y = 0) (c : R) (h) :
    mkSpanSingleton' x y H ‚ü®c ‚Ä¢ x, h‚ü© = c ‚Ä¢ y := by
  dsimp [mkSpanSingleton']
  -- ‚ä¢ Classical.choose (_ : ‚àÉ a, a ‚Ä¢ x = c ‚Ä¢ x) ‚Ä¢ y = c ‚Ä¢ y
  rw [‚Üê sub_eq_zero, ‚Üê sub_smul]
  -- ‚ä¢ (Classical.choose (_ : ‚àÉ a, a ‚Ä¢ x = c ‚Ä¢ x) - c) ‚Ä¢ y = 0
  apply H
  -- ‚ä¢ (Classical.choose (_ : ‚àÉ a, a ‚Ä¢ x = c ‚Ä¢ x) - c) ‚Ä¢ x = 0
  simp only [sub_smul, one_smul, sub_eq_zero]
  -- ‚ä¢ Classical.choose (_ : ‚àÉ a, a ‚Ä¢ x = c ‚Ä¢ x) ‚Ä¢ x = c ‚Ä¢ x
  apply Classical.choose_spec (mem_span_singleton.1 h)
  -- üéâ no goals
#align linear_pmap.mk_span_singleton'_apply LinearPMap.mkSpanSingleton'_apply

@[simp]
theorem mkSpanSingleton'_apply_self (x : E) (y : F) (H : ‚àÄ c : R, c ‚Ä¢ x = 0 ‚Üí c ‚Ä¢ y = 0) (h) :
    mkSpanSingleton' x y H ‚ü®x, h‚ü© = y := by
  -- Porting note: A placeholder should be specified before `convert`.
  have := by refine mkSpanSingleton'_apply x y H 1 ?_; rwa [one_smul]
  -- ‚ä¢ ‚Üë(mkSpanSingleton' x y H) { val := x, property := h } = y
  convert this <;> rw [one_smul]
  -- ‚ä¢ x = 1 ‚Ä¢ x
                   -- üéâ no goals
                   -- üéâ no goals
#align linear_pmap.mk_span_singleton'_apply_self LinearPMap.mkSpanSingleton'_apply_self

/-- The unique `LinearPMap` on `span R {x}` that sends a non-zero vector `x` to `y`.
This version works for modules over division rings. -/
@[reducible]
noncomputable def mkSpanSingleton {K E F : Type*} [DivisionRing K] [AddCommGroup E] [Module K E]
    [AddCommGroup F] [Module K F] (x : E) (y : F) (hx : x ‚â† 0) : E ‚Üí‚Çó.[K] F :=
  mkSpanSingleton' x y fun c hc =>
    (smul_eq_zero.1 hc).elim (fun hc => by rw [hc, zero_smul]) fun hx' => absurd hx' hx
                                           -- üéâ no goals
#align linear_pmap.mk_span_singleton LinearPMap.mkSpanSingleton

theorem mkSpanSingleton_apply (K : Type*) {E F : Type*} [DivisionRing K] [AddCommGroup E]
    [Module K E] [AddCommGroup F] [Module K F] {x : E} (hx : x ‚â† 0) (y : F) :
    mkSpanSingleton x y hx ‚ü®x, (Submodule.mem_span_singleton_self x : x ‚àà Submodule.span K {x})‚ü© =
      y :=
  LinearPMap.mkSpanSingleton'_apply_self _ _ _ _
#align linear_pmap.mk_span_singleton_apply LinearPMap.mkSpanSingleton_apply

/-- Projection to the first coordinate as a `LinearPMap` -/
protected def fst (p : Submodule R E) (p' : Submodule R F) : E √ó F ‚Üí‚Çó.[R] E where
  domain := p.prod p'
  toFun := (LinearMap.fst R E F).comp (p.prod p').subtype
#align linear_pmap.fst LinearPMap.fst

@[simp]
theorem fst_apply (p : Submodule R E) (p' : Submodule R F) (x : p.prod p') :
    LinearPMap.fst p p' x = (x : E √ó F).1 :=
  rfl
#align linear_pmap.fst_apply LinearPMap.fst_apply

/-- Projection to the second coordinate as a `LinearPMap` -/
protected def snd (p : Submodule R E) (p' : Submodule R F) : E √ó F ‚Üí‚Çó.[R] F where
  domain := p.prod p'
  toFun := (LinearMap.snd R E F).comp (p.prod p').subtype
#align linear_pmap.snd LinearPMap.snd

@[simp]
theorem snd_apply (p : Submodule R E) (p' : Submodule R F) (x : p.prod p') :
    LinearPMap.snd p p' x = (x : E √ó F).2 :=
  rfl
#align linear_pmap.snd_apply LinearPMap.snd_apply

instance le : LE (E ‚Üí‚Çó.[R] F) :=
  ‚ü®fun f g => f.domain ‚â§ g.domain ‚àß ‚àÄ ‚¶Éx : f.domain‚¶Ñ ‚¶Éy : g.domain‚¶Ñ (_h : (x : E) = y), f x = g y‚ü©
#align linear_pmap.has_le LinearPMap.le

theorem apply_comp_ofLe {T S : E ‚Üí‚Çó.[R] F} (h : T ‚â§ S) (x : T.domain) :
    T x = S (Submodule.ofLe h.1 x) :=
  h.2 rfl
#align linear_pmap.apply_comp_of_le LinearPMap.apply_comp_ofLe

theorem exists_of_le {T S : E ‚Üí‚Çó.[R] F} (h : T ‚â§ S) (x : T.domain) :
    ‚àÉ y : S.domain, (x : E) = y ‚àß T x = S y :=
  ‚ü®‚ü®x.1, h.1 x.2‚ü©, ‚ü®rfl, h.2 rfl‚ü©‚ü©
#align linear_pmap.exists_of_le LinearPMap.exists_of_le

theorem eq_of_le_of_domain_eq {f g : E ‚Üí‚Çó.[R] F} (hle : f ‚â§ g) (heq : f.domain = g.domain) :
    f = g :=
  ext heq hle.2
#align linear_pmap.eq_of_le_of_domain_eq LinearPMap.eq_of_le_of_domain_eq

/-- Given two partial linear maps `f`, `g`, the set of points `x` such that
both `f` and `g` are defined at `x` and `f x = g x` form a submodule. -/
def eqLocus (f g : E ‚Üí‚Çó.[R] F) : Submodule R E where
  carrier := { x | ‚àÉ (hf : x ‚àà f.domain) (hg : x ‚àà g.domain), f ‚ü®x, hf‚ü© = g ‚ü®x, hg‚ü© }
  zero_mem' := ‚ü®zero_mem _, zero_mem _, f.map_zero.trans g.map_zero.symm‚ü©
  add_mem' := fun {x y} ‚ü®hfx, hgx, hx‚ü© ‚ü®hfy, hgy, hy‚ü© =>
    ‚ü®add_mem hfx hfy, add_mem hgx hgy, by
      erw [f.map_add ‚ü®x, hfx‚ü© ‚ü®y, hfy‚ü©, g.map_add ‚ü®x, hgx‚ü© ‚ü®y, hgy‚ü©, hx, hy]‚ü©
      -- üéâ no goals
  -- Porting note: `by rintro` is required, or error of a free variable happens.
  smul_mem' := by
    rintro c x ‚ü®hfx, hgx, hx‚ü©
    -- ‚ä¢ c ‚Ä¢ x ‚àà { toAddSubsemigroup := { carrier := {x | ‚àÉ hf hg, ‚Üëf { val := x, pro ‚Ä¶
    exact
      ‚ü®smul_mem _ c hfx, smul_mem _ c hgx,
        by erw [f.map_smul c ‚ü®x, hfx‚ü©, g.map_smul c ‚ü®x, hgx‚ü©, hx]‚ü©
#align linear_pmap.eq_locus LinearPMap.eqLocus

instance inf : Inf (E ‚Üí‚Çó.[R] F) :=
  ‚ü®fun f g => ‚ü®f.eqLocus g, f.toFun.comp <| ofLe fun _x hx => hx.fst‚ü©‚ü©
#align linear_pmap.has_inf LinearPMap.inf

instance bot : Bot (E ‚Üí‚Çó.[R] F) :=
  ‚ü®‚ü®‚ä•, 0‚ü©‚ü©
#align linear_pmap.has_bot LinearPMap.bot

instance inhabited : Inhabited (E ‚Üí‚Çó.[R] F) :=
  ‚ü®‚ä•‚ü©
#align linear_pmap.inhabited LinearPMap.inhabited

instance semilatticeInf : SemilatticeInf (E ‚Üí‚Çó.[R] F) where
  le := (¬∑ ‚â§ ¬∑)
  le_refl f := ‚ü®le_refl f.domain, fun x y h => Subtype.eq h ‚ñ∏ rfl‚ü©
  le_trans := fun f g h ‚ü®fg_le, fg_eq‚ü© ‚ü®gh_le, gh_eq‚ü© =>
    ‚ü®le_trans fg_le gh_le, fun x z hxz =>
      have hxy : (x : E) = ofLe fg_le x := rfl
      (fg_eq hxy).trans (gh_eq <| hxy.symm.trans hxz)‚ü©
  le_antisymm f g fg gf := eq_of_le_of_domain_eq fg (le_antisymm fg.1 gf.1)
  inf := (¬∑ ‚äì ¬∑)
  -- Porting note: `by rintro` is required, or error of a metavariable happens.
  le_inf := by
    rintro f g h ‚ü®fg_le, fg_eq‚ü© ‚ü®fh_le, fh_eq‚ü©
    -- ‚ä¢ f ‚â§ g ‚äì h
    exact ‚ü®fun x hx =>
      ‚ü®fg_le hx, fh_le hx, by
        -- Porting note: `[exact ‚ü®x, hx‚ü©, rfl, rfl]` ‚Üí `[skip, exact ‚ü®x, hx‚ü©, skip] <;> rfl`
        refine' (fg_eq _).symm.trans (fh_eq _) <;> [skip; exact ‚ü®x, hx‚ü©; skip] <;> rfl‚ü©,
      fun x ‚ü®y, yg, hy‚ü© h => by
        apply fg_eq
        exact h‚ü©
  inf_le_left f g := ‚ü®fun x hx => hx.fst, fun x y h => congr_arg f <| Subtype.eq <| h‚ü©
  inf_le_right f g :=
    ‚ü®fun x hx => hx.snd.fst, fun ‚ü®x, xf, xg, hx‚ü© y h => hx.trans <| congr_arg g <| Subtype.eq <| h‚ü©
#align linear_pmap.semilattice_inf LinearPMap.semilatticeInf

instance orderBot : OrderBot (E ‚Üí‚Çó.[R] F) where
  bot := ‚ä•
  bot_le f :=
    ‚ü®bot_le, fun x y h => by
      have hx : x = 0 := Subtype.eq ((mem_bot R).1 x.2)
      -- ‚ä¢ ‚Üë‚ä• x = ‚Üëf y
      have hy : y = 0 := Subtype.eq (h.symm.trans (congr_arg _ hx))
      -- ‚ä¢ ‚Üë‚ä• x = ‚Üëf y
      rw [hx, hy, map_zero, map_zero]‚ü©
      -- üéâ no goals
#align linear_pmap.order_bot LinearPMap.orderBot

theorem le_of_eqLocus_ge {f g : E ‚Üí‚Çó.[R] F} (H : f.domain ‚â§ f.eqLocus g) : f ‚â§ g :=
  suffices f ‚â§ f ‚äì g from le_trans this inf_le_right
  ‚ü®H, fun _x _y hxy => ((inf_le_left : f ‚äì g ‚â§ f).2 hxy.symm).symm‚ü©
#align linear_pmap.le_of_eq_locus_ge LinearPMap.le_of_eqLocus_ge

theorem domain_mono : StrictMono (@domain R _ E _ _ F _ _) := fun _f _g hlt =>
  lt_of_le_of_ne hlt.1.1 fun heq => ne_of_lt hlt <| eq_of_le_of_domain_eq (le_of_lt hlt) heq
#align linear_pmap.domain_mono LinearPMap.domain_mono

private theorem sup_aux (f g : E ‚Üí‚Çó.[R] F)
    (h : ‚àÄ (x : f.domain) (y : g.domain), (x : E) = y ‚Üí f x = g y) :
    ‚àÉ fg : ‚Ü•(f.domain ‚äî g.domain) ‚Üí‚Çó[R] F,
      ‚àÄ (x : f.domain) (y : g.domain) (z : ‚Ü•(f.domain ‚äî g.domain)),
        (x : E) + y = ‚Üëz ‚Üí fg z = f x + g y := by
  choose x hx y hy hxy using fun z : ‚Ü•(f.domain ‚äî g.domain) => mem_sup.1 z.prop
  -- ‚ä¢ ‚àÉ fg, ‚àÄ (x : { x // x ‚àà f.domain }) (y : { x // x ‚àà g.domain }) (z : { x //  ‚Ä¶
  set fg := fun z => f ‚ü®x z, hx z‚ü© + g ‚ü®y z, hy z‚ü©
  -- ‚ä¢ ‚àÉ fg, ‚àÄ (x : { x // x ‚àà f.domain }) (y : { x // x ‚àà g.domain }) (z : { x //  ‚Ä¶
  have fg_eq : ‚àÄ (x' : f.domain) (y' : g.domain) (z' : ‚Ü•(f.domain ‚äî g.domain))
      (_H : (x' : E) + y' = z'), fg z' = f x' + g y' := by
    intro x' y' z' H
    dsimp
    rw [add_comm, ‚Üê sub_eq_sub_iff_add_eq_add, eq_comm, ‚Üê map_sub, ‚Üê map_sub]
    apply h
    simp only [‚Üê eq_sub_iff_add_eq] at hxy
    simp only [AddSubgroupClass.coe_sub, coe_mk, coe_mk, hxy, ‚Üê sub_add, ‚Üê sub_sub, sub_self,
      zero_sub, ‚Üê H]
    apply neg_add_eq_sub
  refine' ‚ü®{ toFun := fg.. }, fg_eq‚ü©
  -- ‚ä¢ ‚àÄ (x y : { x // x ‚àà f.domain ‚äî g.domain }), fg (x + y) = fg x + fg y
  ¬∑ rintro ‚ü®z‚ÇÅ, hz‚ÇÅ‚ü© ‚ü®z‚ÇÇ, hz‚ÇÇ‚ü©
    -- ‚ä¢ fg ({ val := z‚ÇÅ, property := hz‚ÇÅ } + { val := z‚ÇÇ, property := hz‚ÇÇ }) = fg {  ‚Ä¶
    rw [‚Üê add_assoc, add_right_comm (f _), ‚Üê map_add, add_assoc, ‚Üê map_add]
    -- ‚ä¢ fg ({ val := z‚ÇÅ, property := hz‚ÇÅ } + { val := z‚ÇÇ, property := hz‚ÇÇ }) = ‚Üëf ({ ‚Ä¶
    apply fg_eq
    -- ‚ä¢ ‚Üë({ val := x { val := z‚ÇÅ, property := hz‚ÇÅ }, property := (_ : x { val := z‚ÇÅ, ‚Ä¶
    simp only [coe_add, coe_mk, ‚Üê add_assoc]
    -- ‚ä¢ x { val := z‚ÇÅ, property := hz‚ÇÅ } + x { val := z‚ÇÇ, property := hz‚ÇÇ } + y { va ‚Ä¶
    rw [add_right_comm (x _), hxy, add_assoc, hxy, coe_mk, coe_mk]
    -- üéâ no goals
  ¬∑ intro c z
    -- ‚ä¢ AddHom.toFun { toFun := fg, map_add' := (_ : ‚àÄ (x y : { x // x ‚àà f.domain ‚äî  ‚Ä¶
    rw [smul_add, ‚Üê map_smul, ‚Üê map_smul]
    -- ‚ä¢ AddHom.toFun { toFun := fg, map_add' := (_ : ‚àÄ (x y : { x // x ‚àà f.domain ‚äî  ‚Ä¶
    apply fg_eq
    -- ‚ä¢ ‚Üë(‚Üë(RingHom.id R) c ‚Ä¢ { val := x z, property := (_ : x z ‚àà f.domain) }) + ‚Üë( ‚Ä¶
    simp only [coe_smul, coe_mk, ‚Üê smul_add, hxy, RingHom.id_apply]
    -- üéâ no goals

/-- Given two partial linear maps that agree on the intersection of their domains,
`f.sup g h` is the unique partial linear map on `f.domain ‚äî g.domain` that agrees
with `f` and `g`. -/
protected noncomputable def sup (f g : E ‚Üí‚Çó.[R] F)
    (h : ‚àÄ (x : f.domain) (y : g.domain), (x : E) = y ‚Üí f x = g y) : E ‚Üí‚Çó.[R] F :=
  ‚ü®_, Classical.choose (sup_aux f g h)‚ü©
#align linear_pmap.sup LinearPMap.sup

@[simp]
theorem domain_sup (f g : E ‚Üí‚Çó.[R] F)
    (h : ‚àÄ (x : f.domain) (y : g.domain), (x : E) = y ‚Üí f x = g y) :
    (f.sup g h).domain = f.domain ‚äî g.domain :=
  rfl
#align linear_pmap.domain_sup LinearPMap.domain_sup

theorem sup_apply {f g : E ‚Üí‚Çó.[R] F} (H : ‚àÄ (x : f.domain) (y : g.domain), (x : E) = y ‚Üí f x = g y)
    (x : f.domain) (y : g.domain) (z : ‚Ü•(f.domain ‚äî g.domain)) (hz : (‚Üëx : E) + ‚Üëy = ‚Üëz) :
    f.sup g H z = f x + g y :=
  Classical.choose_spec (sup_aux f g H) x y z hz
#align linear_pmap.sup_apply LinearPMap.sup_apply

protected theorem left_le_sup (f g : E ‚Üí‚Çó.[R] F)
    (h : ‚àÄ (x : f.domain) (y : g.domain), (x : E) = y ‚Üí f x = g y) : f ‚â§ f.sup g h := by
  refine' ‚ü®le_sup_left, fun z‚ÇÅ z‚ÇÇ hz => _‚ü©
  -- ‚ä¢ ‚Üëf z‚ÇÅ = ‚Üë(LinearPMap.sup f g h) z‚ÇÇ
  rw [‚Üê add_zero (f _), ‚Üê g.map_zero]
  -- ‚ä¢ ‚Üëf z‚ÇÅ + ‚Üëg 0 = ‚Üë(LinearPMap.sup f g h) z‚ÇÇ
  refine' (sup_apply h _ _ _ _).symm
  -- ‚ä¢ ‚Üëz‚ÇÅ + ‚Üë0 = ‚Üëz‚ÇÇ
  simpa
  -- üéâ no goals
#align linear_pmap.left_le_sup LinearPMap.left_le_sup

protected theorem right_le_sup (f g : E ‚Üí‚Çó.[R] F)
    (h : ‚àÄ (x : f.domain) (y : g.domain), (x : E) = y ‚Üí f x = g y) : g ‚â§ f.sup g h := by
  refine' ‚ü®le_sup_right, fun z‚ÇÅ z‚ÇÇ hz => _‚ü©
  -- ‚ä¢ ‚Üëg z‚ÇÅ = ‚Üë(LinearPMap.sup f g h) z‚ÇÇ
  rw [‚Üê zero_add (g _), ‚Üê f.map_zero]
  -- ‚ä¢ ‚Üëf 0 + ‚Üëg z‚ÇÅ = ‚Üë(LinearPMap.sup f g h) z‚ÇÇ
  refine' (sup_apply h _ _ _ _).symm
  -- ‚ä¢ ‚Üë0 + ‚Üëz‚ÇÅ = ‚Üëz‚ÇÇ
  simpa
  -- üéâ no goals
#align linear_pmap.right_le_sup LinearPMap.right_le_sup

protected theorem sup_le {f g h : E ‚Üí‚Çó.[R] F}
    (H : ‚àÄ (x : f.domain) (y : g.domain), (x : E) = y ‚Üí f x = g y) (fh : f ‚â§ h) (gh : g ‚â§ h) :
    f.sup g H ‚â§ h :=
  have Hf : f ‚â§ f.sup g H ‚äì h := le_inf (f.left_le_sup g H) fh
  have Hg : g ‚â§ f.sup g H ‚äì h := le_inf (f.right_le_sup g H) gh
  le_of_eqLocus_ge <| sup_le Hf.1 Hg.1
#align linear_pmap.sup_le LinearPMap.sup_le

/-- Hypothesis for `LinearPMap.sup` holds, if `f.domain` is disjoint with `g.domain`. -/
theorem sup_h_of_disjoint (f g : E ‚Üí‚Çó.[R] F) (h : Disjoint f.domain g.domain) (x : f.domain)
    (y : g.domain) (hxy : (x : E) = y) : f x = g y := by
  rw [disjoint_def] at h
  -- ‚ä¢ ‚Üëf x = ‚Üëg y
  have hy : y = 0 := Subtype.eq (h y (hxy ‚ñ∏ x.2) y.2)
  -- ‚ä¢ ‚Üëf x = ‚Üëg y
  have hx : x = 0 := Subtype.eq (hxy.trans <| congr_arg _ hy)
  -- ‚ä¢ ‚Üëf x = ‚Üëg y
  simp [*]
  -- üéâ no goals
#align linear_pmap.sup_h_of_disjoint LinearPMap.sup_h_of_disjoint

/-! ### Algebraic operations -/


section Zero

instance instZero : Zero (E ‚Üí‚Çó.[R] F) := ‚ü®‚ä§, 0‚ü©

@[simp]
theorem zero_domain : (0 : E ‚Üí‚Çó.[R] F).domain = ‚ä§ := rfl

@[simp]
theorem zero_apply (x : (‚ä§ : Submodule R E)) : (0 : E ‚Üí‚Çó.[R] F) x = 0 := rfl

end Zero

section SMul

variable {M N : Type*} [Monoid M] [DistribMulAction M F] [SMulCommClass R M F]

variable [Monoid N] [DistribMulAction N F] [SMulCommClass R N F]

instance instSMul : SMul M (E ‚Üí‚Çó.[R] F) :=
  ‚ü®fun a f =>
    { domain := f.domain
      toFun := a ‚Ä¢ f.toFun }‚ü©
#align linear_pmap.has_smul LinearPMap.instSMul

@[simp]
theorem smul_domain (a : M) (f : E ‚Üí‚Çó.[R] F) : (a ‚Ä¢ f).domain = f.domain :=
  rfl
#align linear_pmap.smul_domain LinearPMap.smul_domain

theorem smul_apply (a : M) (f : E ‚Üí‚Çó.[R] F) (x : (a ‚Ä¢ f).domain) : (a ‚Ä¢ f) x = a ‚Ä¢ f x :=
  rfl
#align linear_pmap.smul_apply LinearPMap.smul_apply

@[simp]
theorem coe_smul (a : M) (f : E ‚Üí‚Çó.[R] F) : ‚áë(a ‚Ä¢ f) = a ‚Ä¢ ‚áëf :=
  rfl
#align linear_pmap.coe_smul LinearPMap.coe_smul

instance instSMulCommClass [SMulCommClass M N F] : SMulCommClass M N (E ‚Üí‚Çó.[R] F) :=
  ‚ü®fun a b f => ext' <| smul_comm a b f.toFun‚ü©
#align linear_pmap.smul_comm_class LinearPMap.instSMulCommClass

instance instIsScalarTower [SMul M N] [IsScalarTower M N F] : IsScalarTower M N (E ‚Üí‚Çó.[R] F) :=
  ‚ü®fun a b f => ext' <| smul_assoc a b f.toFun‚ü©
#align linear_pmap.is_scalar_tower LinearPMap.instIsScalarTower

instance instMulAction : MulAction M (E ‚Üí‚Çó.[R] F) where
  smul := (¬∑ ‚Ä¢ ¬∑)
  one_smul := fun ‚ü®_s, f‚ü© => ext' <| one_smul M f
  mul_smul a b f := ext' <| mul_smul a b f.toFun
#align linear_pmap.mul_action LinearPMap.instMulAction

end SMul

instance instNeg : Neg (E ‚Üí‚Çó.[R] F) :=
  ‚ü®fun f => ‚ü®f.domain, -f.toFun‚ü©‚ü©
#align linear_pmap.has_neg LinearPMap.instNeg

@[simp]
theorem neg_domain (f : E ‚Üí‚Çó.[R] F) : (-f).domain = f.domain := rfl

@[simp]
theorem neg_apply (f : E ‚Üí‚Çó.[R] F) (x) : (-f) x = -f x :=
  rfl
#align linear_pmap.neg_apply LinearPMap.neg_apply

instance instInvolutiveNeg : InvolutiveNeg (E ‚Üí‚Çó.[R] F) :=
  ‚ü®fun f => by
    ext x y hxy
    -- ‚ä¢ x ‚àà (- -f).domain ‚Üî x ‚àà f.domain
    ¬∑ rfl
      -- üéâ no goals
    ¬∑ simp only [neg_apply, neg_neg]
      -- ‚ä¢ ‚Üëf x = ‚Üëf y
      cases x
      -- ‚ä¢ ‚Üëf { val := val‚úù, property := property‚úù } = ‚Üëf y
      congr‚ü©
      -- üéâ no goals

section Add

instance instAdd : Add (E ‚Üí‚Çó.[R] F) :=
  ‚ü®fun f g =>
    { domain := f.domain ‚äì g.domain
      toFun := f.toFun.comp (ofLe (inf_le_left : f.domain ‚äì g.domain ‚â§ _))
        + g.toFun.comp (ofLe (inf_le_right : f.domain ‚äì g.domain ‚â§ _)) }‚ü©

theorem add_domain (f g : E ‚Üí‚Çó.[R] F) : (f + g).domain = f.domain ‚äì g.domain := rfl

theorem add_apply (f g : E ‚Üí‚Çó.[R] F) (x : (f.domain ‚äì g.domain : Submodule R E)) :
    (f + g) x = f ‚ü®x, x.prop.1‚ü© + g ‚ü®x, x.prop.2‚ü© := rfl

instance instAddSemigroup : AddSemigroup (E ‚Üí‚Çó.[R] F) :=
  ‚ü®fun f g h => by
    ext x y hxy
    -- ‚ä¢ x ‚àà (f + g + h).domain ‚Üî x ‚àà (f + (g + h)).domain
    ¬∑ simp only [add_domain, inf_assoc]
      -- üéâ no goals
    ¬∑ simp only [add_apply, hxy, add_assoc]‚ü©
      -- üéâ no goals

instance instAddZeroClass : AddZeroClass (E ‚Üí‚Çó.[R] F) :=
  ‚ü®fun f => by
    ext x y hxy
    -- ‚ä¢ x ‚àà (0 + f).domain ‚Üî x ‚àà f.domain
    ¬∑ simp [add_domain]
      -- üéâ no goals
    ¬∑ simp only [add_apply, hxy, zero_apply, zero_add],
      -- üéâ no goals
  fun f => by
    ext x y hxy
    -- ‚ä¢ x ‚àà (f + 0).domain ‚Üî x ‚àà f.domain
    ¬∑ simp [add_domain]
      -- üéâ no goals
    ¬∑ simp only [add_apply, hxy, zero_apply, add_zero]‚ü©
      -- üéâ no goals

instance instAddMonoid : AddMonoid (E ‚Üí‚Çó.[R] F) where
  zero_add f := by
    simp
    -- üéâ no goals
  add_zero := by
    simp
    -- üéâ no goals

instance instAddCommMonoid : AddCommMonoid (E ‚Üí‚Çó.[R] F) :=
  ‚ü®fun f g => by
    ext x y hxy
    -- ‚ä¢ x ‚àà (f + g).domain ‚Üî x ‚àà (g + f).domain
    ¬∑ simp only [add_domain, inf_comm]
      -- üéâ no goals
    ¬∑ simp only [add_apply, hxy, add_comm]‚ü©
      -- üéâ no goals

end Add

section VAdd

instance instVAdd : VAdd (E ‚Üí‚Çó[R] F) (E ‚Üí‚Çó.[R] F) :=
  ‚ü®fun f g =>
    { domain := g.domain
      toFun := f.comp g.domain.subtype + g.toFun }‚ü©
#align linear_pmap.has_vadd LinearPMap.instVAdd

@[simp]
theorem vadd_domain (f : E ‚Üí‚Çó[R] F) (g : E ‚Üí‚Çó.[R] F) : (f +·µ• g).domain = g.domain :=
  rfl
#align linear_pmap.vadd_domain LinearPMap.vadd_domain

theorem vadd_apply (f : E ‚Üí‚Çó[R] F) (g : E ‚Üí‚Çó.[R] F) (x : (f +·µ• g).domain) :
    (f +·µ• g) x = f x + g x :=
  rfl
#align linear_pmap.vadd_apply LinearPMap.vadd_apply

@[simp]
theorem coe_vadd (f : E ‚Üí‚Çó[R] F) (g : E ‚Üí‚Çó.[R] F) : ‚áë(f +·µ• g) = ‚áë(f.comp g.domain.subtype) + ‚áëg :=
  rfl
#align linear_pmap.coe_vadd LinearPMap.coe_vadd

instance instAddAction : AddAction (E ‚Üí‚Çó[R] F) (E ‚Üí‚Çó.[R] F)
    where
  vadd := (¬∑ +·µ• ¬∑)
  zero_vadd := fun ‚ü®_s, _f‚ü© => ext' <| zero_add _
  add_vadd := fun _f‚ÇÅ _f‚ÇÇ ‚ü®_s, _g‚ü© => ext' <| LinearMap.ext fun _x => add_assoc _ _ _
#align linear_pmap.add_action LinearPMap.instAddAction

end VAdd

section Sub

instance instSub : Sub (E ‚Üí‚Çó.[R] F) :=
  ‚ü®fun f g =>
    { domain := f.domain ‚äì g.domain
      toFun := f.toFun.comp (ofLe (inf_le_left : f.domain ‚äì g.domain ‚â§ _))
        - g.toFun.comp (ofLe (inf_le_right : f.domain ‚äì g.domain ‚â§ _)) }‚ü©

theorem sub_domain (f g : E ‚Üí‚Çó.[R] F) : (f - g).domain = f.domain ‚äì g.domain := rfl

theorem sub_apply (f g : E ‚Üí‚Çó.[R] F) (x : (f.domain ‚äì g.domain : Submodule R E)) :
    (f - g) x = f ‚ü®x, x.prop.1‚ü© - g ‚ü®x, x.prop.2‚ü© := rfl

instance instSubtractionCommMonoid : SubtractionCommMonoid (E ‚Üí‚Çó.[R] F) where
  add_comm := add_comm
  sub_eq_add_neg f g := by
    ext x y h
    -- ‚ä¢ x ‚àà (f - g).domain ‚Üî x ‚àà (f + -g).domain
    ¬∑ rfl
      -- üéâ no goals
    simp [sub_apply, add_apply, neg_apply, ‚Üê sub_eq_add_neg, h]
    -- üéâ no goals
  neg_neg := neg_neg
  neg_add_rev f g := by
    ext x y h
    -- ‚ä¢ x ‚àà (-(f + g)).domain ‚Üî x ‚àà (-g + -f).domain
    ¬∑ simp [add_domain, sub_domain, neg_domain, And.comm]
      -- üéâ no goals
    simp [sub_apply, add_apply, neg_apply, ‚Üê sub_eq_add_neg, h]
    -- üéâ no goals
  neg_eq_of_add f g h' := by
    ext x y h
    -- ‚ä¢ x ‚àà (-f).domain ‚Üî x ‚àà g.domain
    ¬∑ have : (0 : E ‚Üí‚Çó.[R] F).domain = ‚ä§ := zero_domain
      -- ‚ä¢ x ‚àà (-f).domain ‚Üî x ‚àà g.domain
      simp only [‚Üê h', add_domain, ge_iff_le, inf_eq_top_iff] at this
      -- ‚ä¢ x ‚àà (-f).domain ‚Üî x ‚àà g.domain
      rw [neg_domain, this.1, this.2]
      -- üéâ no goals
    simp only [inf_coe, neg_domain, Eq.ndrec, Int.ofNat_eq_coe, neg_apply]
    -- ‚ä¢ -‚Üëf x = ‚Üëg y
    rw [ext_iff] at h'
    -- ‚ä¢ -‚Üëf x = ‚Üëg y
    rcases h' with ‚ü®hdom, h'‚ü©
    -- ‚ä¢ -‚Üëf x = ‚Üëg y
    rw [zero_domain] at hdom
    -- ‚ä¢ -‚Üëf x = ‚Üëg y
    simp only [inf_coe, neg_domain, Eq.ndrec, Int.ofNat_eq_coe, zero_domain, top_coe, zero_apply,
      Subtype.forall, mem_top, forall_true_left, forall_eq'] at h'
    specialize h' x.1 (by simp [hdom])
    -- ‚ä¢ -‚Üëf x = ‚Üëg y
    simp only [inf_coe, neg_domain, Eq.ndrec, Int.ofNat_eq_coe, add_apply, Subtype.coe_eta,
      ‚Üê neg_eq_iff_add_eq_zero] at h'
    rw [h', h]
    -- üéâ no goals

end Sub

section

variable {K : Type*} [DivisionRing K] [Module K E] [Module K F]

/-- Extend a `LinearPMap` to `f.domain ‚äî K ‚àô x`. -/
noncomputable def supSpanSingleton (f : E ‚Üí‚Çó.[K] F) (x : E) (y : F) (hx : x ‚àâ f.domain) :
    E ‚Üí‚Çó.[K] F :=
  -- Porting note: `simpa [..]` ‚Üí `simp [..]; exact ..`
  f.sup (mkSpanSingleton x y fun h‚ÇÄ => hx <| h‚ÇÄ.symm ‚ñ∏ f.domain.zero_mem) <|
    sup_h_of_disjoint _ _ <| by simp [disjoint_span_singleton]; exact fun h => False.elim <| hx h
                                -- ‚ä¢ x ‚àà f.domain ‚Üí x = 0
                                                                -- üéâ no goals
#align linear_pmap.sup_span_singleton LinearPMap.supSpanSingleton

@[simp]
theorem domain_supSpanSingleton (f : E ‚Üí‚Çó.[K] F) (x : E) (y : F) (hx : x ‚àâ f.domain) :
    (f.supSpanSingleton x y hx).domain = f.domain ‚äî K ‚àô x :=
  rfl
#align linear_pmap.domain_sup_span_singleton LinearPMap.domain_supSpanSingleton

@[simp, nolint simpNF] -- Porting note: Left-hand side does not simplify.
theorem supSpanSingleton_apply_mk (f : E ‚Üí‚Çó.[K] F) (x : E) (y : F) (hx : x ‚àâ f.domain) (x' : E)
    (hx' : x' ‚àà f.domain) (c : K) :
    f.supSpanSingleton x y hx
        ‚ü®x' + c ‚Ä¢ x, mem_sup.2 ‚ü®x', hx', _, mem_span_singleton.2 ‚ü®c, rfl‚ü©, rfl‚ü©‚ü© =
      f ‚ü®x', hx'‚ü© + c ‚Ä¢ y := by
  -- Porting note: `erw [..]; rfl; exact ..` ‚Üí `erw [..]; exact ..; rfl`
  -- That is, the order of the side goals generated by `erw` changed.
  erw [sup_apply _ ‚ü®x', hx'‚ü© ‚ü®c ‚Ä¢ x, _‚ü©, mkSpanSingleton'_apply]
  -- ‚ä¢ c ‚Ä¢ x ‚àà (mkSpanSingleton' x y (_ : ‚àÄ (c : K), c ‚Ä¢ x = 0 ‚Üí c ‚Ä¢ y = 0)).domain
  ¬∑ exact mem_span_singleton.2 ‚ü®c, rfl‚ü©
    -- üéâ no goals
  ¬∑ rfl
    -- üéâ no goals
#align linear_pmap.sup_span_singleton_apply_mk LinearPMap.supSpanSingleton_apply_mk

end

private theorem sSup_aux (c : Set (E ‚Üí‚Çó.[R] F)) (hc : DirectedOn (¬∑ ‚â§ ¬∑) c) :
    ‚àÉ f : ‚Ü•(sSup (domain '' c)) ‚Üí‚Çó[R] F, (‚ü®_, f‚ü© : E ‚Üí‚Çó.[R] F) ‚àà upperBounds c := by
  cases' c.eq_empty_or_nonempty with ceq cne
  -- ‚ä¢ ‚àÉ f, { domain := sSup (domain '' c), toFun := f } ‚àà upperBounds c
  ¬∑ subst c
    -- ‚ä¢ ‚àÉ f, { domain := sSup (domain '' ‚àÖ), toFun := f } ‚àà upperBounds ‚àÖ
    simp
    -- üéâ no goals
  have hdir : DirectedOn (¬∑ ‚â§ ¬∑) (domain '' c) :=
    directedOn_image.2 (hc.mono @(domain_mono.monotone))
  have P : ‚àÄ x : ‚Ü•(sSup (domain '' c)), { p : c // (x : E) ‚àà p.val.domain } := by
    rintro x
    apply Classical.indefiniteDescription
    have := (mem_sSup_of_directed (cne.image _) hdir).1 x.2
    -- Porting note: + `‚Üê bex_def`
    rwa [bex_image_iff, ‚Üê bex_def, SetCoe.exists'] at this
  set f : ‚Ü•(sSup (domain '' c)) ‚Üí F := fun x => (P x).val.val ‚ü®x, (P x).property‚ü©
  -- ‚ä¢ ‚àÉ f, { domain := sSup (domain '' c), toFun := f } ‚àà upperBounds c
  have f_eq : ‚àÄ (p : c) (x : ‚Ü•(sSup (domain '' c))) (y : p.1.1) (_hxy : (x : E) = y),
      f x = p.1 y := by
    intro p x y hxy
    rcases hc (P x).1.1 (P x).1.2 p.1 p.2 with ‚ü®q, _hqc, hxq, hpq‚ü©
    -- Porting note: `refine' ..; exacts [ofLe hpq.1 y, hxy, rfl]`
    --               ‚Üí `refine' .. <;> [skip; exact ofLe hpq.1 y; rfl]; exact hxy`
    refine' (hxq.2 _).trans (hpq.2 _).symm <;> [skip; exact ofLe hpq.1 y; rfl]; exact hxy
  refine' ‚ü®{ toFun := f.. }, _‚ü©
  ¬∑ intro x y
    -- ‚ä¢ f (x + y) = f x + f y
    rcases hc (P x).1.1 (P x).1.2 (P y).1.1 (P y).1.2 with ‚ü®p, hpc, hpx, hpy‚ü©
    -- ‚ä¢ f (x + y) = f x + f y
    set x' := ofLe hpx.1 ‚ü®x, (P x).2‚ü©
    -- ‚ä¢ f (x + y) = f x + f y
    set y' := ofLe hpy.1 ‚ü®y, (P y).2‚ü©
    -- ‚ä¢ f (x + y) = f x + f y
    rw [f_eq ‚ü®p, hpc‚ü© x x' rfl, f_eq ‚ü®p, hpc‚ü© y y' rfl, f_eq ‚ü®p, hpc‚ü© (x + y) (x' + y') rfl,
      map_add]
  ¬∑ intro c x
    -- ‚ä¢ AddHom.toFun { toFun := f, map_add' := (_ : ‚àÄ (x y : { x // x ‚àà sSup (domain ‚Ä¶
    -- Porting note: `simp [..]` to `simp only [..]`, or timeouts.
    simp only [f_eq (P x).1 (c ‚Ä¢ x) (c ‚Ä¢ ‚ü®x, (P x).2‚ü©) rfl, ‚Üê map_smul, RingHom.id_apply]
    -- üéâ no goals
  ¬∑ intro p hpc
    -- ‚ä¢ p ‚â§ { domain := sSup (domain '' c), toFun := { toAddHom := { toFun := f, map ‚Ä¶
    refine' ‚ü®le_sSup <| mem_image_of_mem domain hpc, fun x y hxy => Eq.symm _‚ü©
    -- ‚ä¢ ‚Üë{ domain := sSup (domain '' c), toFun := { toAddHom := { toFun := f, map_ad ‚Ä¶
    exact f_eq ‚ü®p, hpc‚ü© _ _ hxy.symm
    -- üéâ no goals

protected noncomputable def sSup (c : Set (E ‚Üí‚Çó.[R] F)) (hc : DirectedOn (¬∑ ‚â§ ¬∑) c) : E ‚Üí‚Çó.[R] F :=
  ‚ü®_, Classical.choose <| sSup_aux c hc‚ü©
#align linear_pmap.Sup LinearPMap.sSup

protected theorem le_sSup {c : Set (E ‚Üí‚Çó.[R] F)} (hc : DirectedOn (¬∑ ‚â§ ¬∑) c) {f : E ‚Üí‚Çó.[R] F}
    (hf : f ‚àà c) : f ‚â§ LinearPMap.sSup c hc :=
  Classical.choose_spec (sSup_aux c hc) hf
#align linear_pmap.le_Sup LinearPMap.le_sSup

protected theorem sSup_le {c : Set (E ‚Üí‚Çó.[R] F)} (hc : DirectedOn (¬∑ ‚â§ ¬∑) c) {g : E ‚Üí‚Çó.[R] F}
    (hg : ‚àÄ f ‚àà c, f ‚â§ g) : LinearPMap.sSup c hc ‚â§ g :=
  le_of_eqLocus_ge <|
    sSup_le fun _ ‚ü®f, hf, Eq‚ü© =>
      Eq ‚ñ∏
        have : f ‚â§ LinearPMap.sSup c hc ‚äì g := le_inf (LinearPMap.le_sSup _ hf) (hg f hf)
        this.1
#align linear_pmap.Sup_le LinearPMap.sSup_le

protected theorem sSup_apply {c : Set (E ‚Üí‚Çó.[R] F)} (hc : DirectedOn (¬∑ ‚â§ ¬∑) c) {l : E ‚Üí‚Çó.[R] F}
    (hl : l ‚àà c) (x : l.domain) :
    (LinearPMap.sSup c hc) ‚ü®x, (LinearPMap.le_sSup hc hl).1 x.2‚ü© = l x := by
  symm
  -- ‚ä¢ ‚Üël x = ‚Üë(LinearPMap.sSup c hc) { val := ‚Üëx, property := (_ : ‚Üëx ‚àà (LinearPMa ‚Ä¶
  apply (Classical.choose_spec (sSup_aux c hc) hl).2
  -- ‚ä¢ ‚Üëx = ‚Üë{ val := ‚Üëx, property := (_ : ‚Üëx ‚àà (LinearPMap.sSup c hc).domain) }
  rfl
  -- üéâ no goals
#align linear_pmap.Sup_apply LinearPMap.sSup_apply

end LinearPMap

namespace LinearMap

/-- Restrict a linear map to a submodule, reinterpreting the result as a `LinearPMap`. -/
def toPMap (f : E ‚Üí‚Çó[R] F) (p : Submodule R E) : E ‚Üí‚Çó.[R] F :=
  ‚ü®p, f.comp p.subtype‚ü©
#align linear_map.to_pmap LinearMap.toPMap

@[simp]
theorem toPMap_apply (f : E ‚Üí‚Çó[R] F) (p : Submodule R E) (x : p) : f.toPMap p x = f x :=
  rfl
#align linear_map.to_pmap_apply LinearMap.toPMap_apply

@[simp]
theorem toPMap_domain (f : E ‚Üí‚Çó[R] F) (p : Submodule R E) : (f.toPMap p).domain = p :=
  rfl
#align linear_map.to_pmap_domain LinearMap.toPMap_domain

/-- Compose a linear map with a `LinearPMap` -/
def compPMap (g : F ‚Üí‚Çó[R] G) (f : E ‚Üí‚Çó.[R] F) : E ‚Üí‚Çó.[R] G where
  domain := f.domain
  toFun := g.comp f.toFun
#align linear_map.comp_pmap LinearMap.compPMap

@[simp]
theorem compPMap_apply (g : F ‚Üí‚Çó[R] G) (f : E ‚Üí‚Çó.[R] F) (x) : g.compPMap f x = g (f x) :=
  rfl
#align linear_map.comp_pmap_apply LinearMap.compPMap_apply

end LinearMap

namespace LinearPMap

/-- Restrict codomain of a `LinearPMap` -/
def codRestrict (f : E ‚Üí‚Çó.[R] F) (p : Submodule R F) (H : ‚àÄ x, f x ‚àà p) : E ‚Üí‚Çó.[R] p
    where
  domain := f.domain
  toFun := f.toFun.codRestrict p H
#align linear_pmap.cod_restrict LinearPMap.codRestrict

/-- Compose two `LinearPMap`s -/
def comp (g : F ‚Üí‚Çó.[R] G) (f : E ‚Üí‚Çó.[R] F) (H : ‚àÄ x : f.domain, f x ‚àà g.domain) : E ‚Üí‚Çó.[R] G :=
  g.toFun.compPMap <| f.codRestrict _ H
#align linear_pmap.comp LinearPMap.comp

/-- `f.coprod g` is the partially defined linear map defined on `f.domain √ó g.domain`,
and sending `p` to `f p.1 + g p.2`. -/
def coprod (f : E ‚Üí‚Çó.[R] G) (g : F ‚Üí‚Çó.[R] G) : E √ó F ‚Üí‚Çó.[R] G where
  domain := f.domain.prod g.domain
  toFun :=
    -- Porting note: This is just
    -- `(f.comp (LinearPMap.fst f.domain g.domain) fun x => x.2.1).toFun +`
    -- `  (g.comp (LinearPMap.snd f.domain g.domain) fun x => x.2.2).toFun`,
    HAdd.hAdd
      (Œ± := f.domain.prod g.domain ‚Üí‚Çó[R] G)
      (Œ≤ := f.domain.prod g.domain ‚Üí‚Çó[R] G)
      (f.comp (LinearPMap.fst f.domain g.domain) fun x => x.2.1).toFun
      (g.comp (LinearPMap.snd f.domain g.domain) fun x => x.2.2).toFun
#align linear_pmap.coprod LinearPMap.coprod

@[simp]
theorem coprod_apply (f : E ‚Üí‚Çó.[R] G) (g : F ‚Üí‚Çó.[R] G) (x) :
    f.coprod g x = f ‚ü®(x : E √ó F).1, x.2.1‚ü© + g ‚ü®(x : E √ó F).2, x.2.2‚ü© :=
  rfl
#align linear_pmap.coprod_apply LinearPMap.coprod_apply

/-- Restrict a partially defined linear map to a submodule of `E` contained in `f.domain`. -/
def domRestrict (f : E ‚Üí‚Çó.[R] F) (S : Submodule R E) : E ‚Üí‚Çó.[R] F :=
  ‚ü®S ‚äì f.domain, f.toFun.comp (Submodule.ofLe (by simp))‚ü©
                                                  -- üéâ no goals
#align linear_pmap.dom_restrict LinearPMap.domRestrict

@[simp]
theorem domRestrict_domain (f : E ‚Üí‚Çó.[R] F) {S : Submodule R E} :
    (f.domRestrict S).domain = S ‚äì f.domain :=
  rfl
#align linear_pmap.dom_restrict_domain LinearPMap.domRestrict_domain

theorem domRestrict_apply {f : E ‚Üí‚Çó.[R] F} {S : Submodule R E} ‚¶Éx : ‚Ü•(S ‚äì f.domain)‚¶Ñ ‚¶Éy : f.domain‚¶Ñ
    (h : (x : E) = y) : f.domRestrict S x = f y := by
  have : Submodule.ofLe (by simp) x = y := by
    ext
    simp [h]
  rw [‚Üê this]
  -- ‚ä¢ ‚Üë(domRestrict f S) x = ‚Üëf (‚Üë(Submodule.ofLe (_ : S ‚äì f.domain ‚â§ f.domain)) x)
  exact LinearPMap.mk_apply _ _ _
  -- üéâ no goals
#align linear_pmap.dom_restrict_apply LinearPMap.domRestrict_apply

theorem domRestrict_le {f : E ‚Üí‚Çó.[R] F} {S : Submodule R E} : f.domRestrict S ‚â§ f :=
  ‚ü®by simp, fun x y hxy => domRestrict_apply hxy‚ü©
      -- üéâ no goals
#align linear_pmap.dom_restrict_le LinearPMap.domRestrict_le

/-! ### Graph -/


section Graph

/-- The graph of a `LinearPMap` viewed as a submodule on `E √ó F`. -/
def graph (f : E ‚Üí‚Çó.[R] F) : Submodule R (E √ó F) :=
  f.toFun.graph.map (f.domain.subtype.prodMap (LinearMap.id : F ‚Üí‚Çó[R] F))
#align linear_pmap.graph LinearPMap.graph

theorem mem_graph_iff' (f : E ‚Üí‚Çó.[R] F) {x : E √ó F} : x ‚àà f.graph ‚Üî ‚àÉ y : f.domain, (‚Üëy, f y) = x :=
  by simp [graph]
     -- üéâ no goals
#align linear_pmap.mem_graph_iff' LinearPMap.mem_graph_iff'

@[simp]
theorem mem_graph_iff (f : E ‚Üí‚Çó.[R] F) {x : E √ó F} :
    x ‚àà f.graph ‚Üî ‚àÉ y : f.domain, (‚Üëy : E) = x.1 ‚àß f y = x.2 := by
  cases x
  -- ‚ä¢ (fst‚úù, snd‚úù) ‚àà graph f ‚Üî ‚àÉ y, ‚Üëy = (fst‚úù, snd‚úù).fst ‚àß ‚Üëf y = (fst‚úù, snd‚úù).snd
  simp_rw [mem_graph_iff', Prod.mk.inj_iff]
  -- üéâ no goals
#align linear_pmap.mem_graph_iff LinearPMap.mem_graph_iff

/-- The tuple `(x, f x)` is contained in the graph of `f`. -/
theorem mem_graph (f : E ‚Üí‚Çó.[R] F) (x : domain f) : ((x : E), f x) ‚àà f.graph := by simp
                                                                                   -- üéâ no goals
#align linear_pmap.mem_graph LinearPMap.mem_graph

theorem graph_map_fst_eq_domain (f : E ‚Üí‚Çó.[R] F) :
    f.graph.map (LinearMap.fst R E F) = f.domain := by
  ext x
  -- ‚ä¢ x ‚àà Submodule.map (LinearMap.fst R E F) (graph f) ‚Üî x ‚àà f.domain
  simp only [Submodule.mem_map, mem_graph_iff, Subtype.exists, exists_and_left, exists_eq_left,
    LinearMap.fst_apply, Prod.exists, exists_and_right, exists_eq_right]
  constructor <;> intro h
  -- ‚ä¢ (‚àÉ x_1 h, ‚Üëf { val := x, property := (_ : (x, x_1).fst ‚àà f.domain) } = x_1)  ‚Ä¶
                  -- ‚ä¢ x ‚àà f.domain
                  -- ‚ä¢ ‚àÉ x_1 h, ‚Üëf { val := x, property := (_ : (x, x_1).fst ‚àà f.domain) } = x_1
  ¬∑ rcases h with ‚ü®x, hx, _‚ü©
    -- ‚ä¢ x‚úù ‚àà f.domain
    exact hx
    -- üéâ no goals
  ¬∑ use f ‚ü®x, h‚ü©
    -- ‚ä¢ ‚àÉ h_1, ‚Üëf { val := x, property := (_ : (x, ‚Üëf { val := x, property := h }).f ‚Ä¶
    simp only [h, exists_prop]
    -- üéâ no goals

theorem graph_map_snd_eq_range (f : E ‚Üí‚Çó.[R] F) :
    f.graph.map (LinearMap.snd R E F) = LinearMap.range f.toFun := by ext; simp
                                                                      -- ‚ä¢ x‚úù ‚àà Submodule.map (LinearMap.snd R E F) (graph f) ‚Üî x‚úù ‚àà LinearMap.range f. ‚Ä¶
                                                                           -- üéâ no goals

variable {M : Type*} [Monoid M] [DistribMulAction M F] [SMulCommClass R M F] (y : M)

/-- The graph of `z ‚Ä¢ f` as a pushforward. -/
theorem smul_graph (f : E ‚Üí‚Çó.[R] F) (z : M) :
    (z ‚Ä¢ f).graph =
      f.graph.map ((LinearMap.id : E ‚Üí‚Çó[R] E).prodMap (z ‚Ä¢ (LinearMap.id : F ‚Üí‚Çó[R] F))) := by
  ext x; cases' x with x_fst x_snd
  -- ‚ä¢ x ‚àà graph (z ‚Ä¢ f) ‚Üî x ‚àà Submodule.map (LinearMap.prodMap LinearMap.id (z ‚Ä¢ L ‚Ä¶
         -- ‚ä¢ (x_fst, x_snd) ‚àà graph (z ‚Ä¢ f) ‚Üî (x_fst, x_snd) ‚àà Submodule.map (LinearMap.p ‚Ä¶
  constructor <;> intro h
  -- ‚ä¢ (x_fst, x_snd) ‚àà graph (z ‚Ä¢ f) ‚Üí (x_fst, x_snd) ‚àà Submodule.map (LinearMap.p ‚Ä¶
                  -- ‚ä¢ (x_fst, x_snd) ‚àà Submodule.map (LinearMap.prodMap LinearMap.id (z ‚Ä¢ LinearMa ‚Ä¶
                  -- ‚ä¢ (x_fst, x_snd) ‚àà graph (z ‚Ä¢ f)
  ¬∑ rw [mem_graph_iff] at h
    -- ‚ä¢ (x_fst, x_snd) ‚àà Submodule.map (LinearMap.prodMap LinearMap.id (z ‚Ä¢ LinearMa ‚Ä¶
    rcases h with ‚ü®y, hy, h‚ü©
    -- ‚ä¢ (x_fst, x_snd) ‚àà Submodule.map (LinearMap.prodMap LinearMap.id (z ‚Ä¢ LinearMa ‚Ä¶
    rw [LinearPMap.smul_apply] at h
    -- ‚ä¢ (x_fst, x_snd) ‚àà Submodule.map (LinearMap.prodMap LinearMap.id (z ‚Ä¢ LinearMa ‚Ä¶
    rw [Submodule.mem_map]
    -- ‚ä¢ ‚àÉ y, y ‚àà graph f ‚àß ‚Üë(LinearMap.prodMap LinearMap.id (z ‚Ä¢ LinearMap.id)) y =  ‚Ä¶
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id.def,
      LinearMap.smul_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y, hy
    -- üéâ no goals
  rw [Submodule.mem_map] at h
  -- ‚ä¢ (x_fst, x_snd) ‚àà graph (z ‚Ä¢ f)
  rcases h with ‚ü®x', hx', h‚ü©
  -- ‚ä¢ (x_fst, x_snd) ‚àà graph (z ‚Ä¢ f)
  cases x'
  -- ‚ä¢ (x_fst, x_snd) ‚àà graph (z ‚Ä¢ f)
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id.def, LinearMap.smul_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx' ‚ä¢
  -- ‚ä¢ ‚àÉ y, ‚Üëy = (x_fst, x_snd).fst ‚àß ‚Üë(z ‚Ä¢ f) y = (x_fst, x_snd).snd
  rcases hx' with ‚ü®y, hy, hx'‚ü©
  -- ‚ä¢ ‚àÉ y, ‚Üëy = (x_fst, x_snd).fst ‚àß ‚Üë(z ‚Ä¢ f) y = (x_fst, x_snd).snd
  use y
  -- ‚ä¢ ‚Üëy = (x_fst, x_snd).fst ‚àß ‚Üë(z ‚Ä¢ f) y = (x_fst, x_snd).snd
  rw [‚Üê h.1, ‚Üê h.2]
  -- ‚ä¢ ‚Üëy = (fst‚úù, z ‚Ä¢ snd‚úù).fst ‚àß ‚Üë(z ‚Ä¢ f) y = (fst‚úù, z ‚Ä¢ snd‚úù).snd
  simp [hy, hx']
  -- üéâ no goals
#align linear_pmap.smul_graph LinearPMap.smul_graph

/-- The graph of `-f` as a pushforward. -/
theorem neg_graph (f : E ‚Üí‚Çó.[R] F) :
    (-f).graph =
    f.graph.map ((LinearMap.id : E ‚Üí‚Çó[R] E).prodMap (-(LinearMap.id : F ‚Üí‚Çó[R] F))) := by
  ext x; cases' x with x_fst x_snd
  -- ‚ä¢ x ‚àà graph (-f) ‚Üî x ‚àà Submodule.map (LinearMap.prodMap LinearMap.id (-LinearM ‚Ä¶
         -- ‚ä¢ (x_fst, x_snd) ‚àà graph (-f) ‚Üî (x_fst, x_snd) ‚àà Submodule.map (LinearMap.prod ‚Ä¶
  constructor <;> intro h
  -- ‚ä¢ (x_fst, x_snd) ‚àà graph (-f) ‚Üí (x_fst, x_snd) ‚àà Submodule.map (LinearMap.prod ‚Ä¶
                  -- ‚ä¢ (x_fst, x_snd) ‚àà Submodule.map (LinearMap.prodMap LinearMap.id (-LinearMap.i ‚Ä¶
                  -- ‚ä¢ (x_fst, x_snd) ‚àà graph (-f)
  ¬∑ rw [mem_graph_iff] at h
    -- ‚ä¢ (x_fst, x_snd) ‚àà Submodule.map (LinearMap.prodMap LinearMap.id (-LinearMap.i ‚Ä¶
    rcases h with ‚ü®y, hy, h‚ü©
    -- ‚ä¢ (x_fst, x_snd) ‚àà Submodule.map (LinearMap.prodMap LinearMap.id (-LinearMap.i ‚Ä¶
    rw [LinearPMap.neg_apply] at h
    -- ‚ä¢ (x_fst, x_snd) ‚àà Submodule.map (LinearMap.prodMap LinearMap.id (-LinearMap.i ‚Ä¶
    rw [Submodule.mem_map]
    -- ‚ä¢ ‚àÉ y, y ‚àà graph f ‚àß ‚Üë(LinearMap.prodMap LinearMap.id (-LinearMap.id)) y = (x_ ‚Ä¶
    simp only [mem_graph_iff, LinearMap.prodMap_apply, LinearMap.id_coe, id.def,
      LinearMap.neg_apply, Prod.mk.inj_iff, Prod.exists, exists_exists_and_eq_and]
    use x_fst, y, hy
    -- üéâ no goals
  rw [Submodule.mem_map] at h
  -- ‚ä¢ (x_fst, x_snd) ‚àà graph (-f)
  rcases h with ‚ü®x', hx', h‚ü©
  -- ‚ä¢ (x_fst, x_snd) ‚àà graph (-f)
  cases x'
  -- ‚ä¢ (x_fst, x_snd) ‚àà graph (-f)
  simp only [LinearMap.prodMap_apply, LinearMap.id_coe, id.def, LinearMap.neg_apply,
    Prod.mk.inj_iff] at h
  rw [mem_graph_iff] at hx' ‚ä¢
  -- ‚ä¢ ‚àÉ y, ‚Üëy = (x_fst, x_snd).fst ‚àß ‚Üë(-f) y = (x_fst, x_snd).snd
  rcases hx' with ‚ü®y, hy, hx'‚ü©
  -- ‚ä¢ ‚àÉ y, ‚Üëy = (x_fst, x_snd).fst ‚àß ‚Üë(-f) y = (x_fst, x_snd).snd
  use y
  -- ‚ä¢ ‚Üëy = (x_fst, x_snd).fst ‚àß ‚Üë(-f) y = (x_fst, x_snd).snd
  rw [‚Üê h.1, ‚Üê h.2]
  -- ‚ä¢ ‚Üëy = (fst‚úù, -snd‚úù).fst ‚àß ‚Üë(-f) y = (fst‚úù, -snd‚úù).snd
  simp [hy, hx']
  -- üéâ no goals
#align linear_pmap.neg_graph LinearPMap.neg_graph

theorem mem_graph_snd_inj (f : E ‚Üí‚Çó.[R] F) {x y : E} {x' y' : F} (hx : (x, x') ‚àà f.graph)
    (hy : (y, y') ‚àà f.graph) (hxy : x = y) : x' = y' := by
  rw [mem_graph_iff] at hx hy
  -- ‚ä¢ x' = y'
  rcases hx with ‚ü®x'', hx1, hx2‚ü©
  -- ‚ä¢ x' = y'
  rcases hy with ‚ü®y'', hy1, hy2‚ü©
  -- ‚ä¢ x' = y'
  simp only at hx1 hx2 hy1 hy2
  -- ‚ä¢ x' = y'
  rw [‚Üê hx1, ‚Üê hy1, SetLike.coe_eq_coe] at hxy
  -- ‚ä¢ x' = y'
  rw [‚Üê hx2, ‚Üê hy2, hxy]
  -- üéâ no goals
#align linear_pmap.mem_graph_snd_inj LinearPMap.mem_graph_snd_inj

theorem mem_graph_snd_inj' (f : E ‚Üí‚Çó.[R] F) {x y : E √ó F} (hx : x ‚àà f.graph) (hy : y ‚àà f.graph)
    (hxy : x.1 = y.1) : x.2 = y.2 := by
  cases x
  -- ‚ä¢ (fst‚úù, snd‚úù).snd = y.snd
  cases y
  -- ‚ä¢ (fst‚úù¬π, snd‚úù¬π).snd = (fst‚úù, snd‚úù).snd
  exact f.mem_graph_snd_inj hx hy hxy
  -- üéâ no goals
#align linear_pmap.mem_graph_snd_inj' LinearPMap.mem_graph_snd_inj'

/-- The property that `f 0 = 0` in terms of the graph. -/
theorem graph_fst_eq_zero_snd (f : E ‚Üí‚Çó.[R] F) {x : E} {x' : F} (h : (x, x') ‚àà f.graph)
    (hx : x = 0) : x' = 0 :=
  f.mem_graph_snd_inj h f.graph.zero_mem hx
#align linear_pmap.graph_fst_eq_zero_snd LinearPMap.graph_fst_eq_zero_snd

theorem mem_domain_iff {f : E ‚Üí‚Çó.[R] F} {x : E} : x ‚àà f.domain ‚Üî ‚àÉ y : F, (x, y) ‚àà f.graph := by
  constructor <;> intro h
  -- ‚ä¢ x ‚àà f.domain ‚Üí ‚àÉ y, (x, y) ‚àà graph f
                  -- ‚ä¢ ‚àÉ y, (x, y) ‚àà graph f
                  -- ‚ä¢ x ‚àà f.domain
  ¬∑ use f ‚ü®x, h‚ü©
    -- ‚ä¢ (x, ‚Üëf { val := x, property := h }) ‚àà graph f
    exact f.mem_graph ‚ü®x, h‚ü©
    -- üéâ no goals
  cases' h with y h
  -- ‚ä¢ x ‚àà f.domain
  rw [mem_graph_iff] at h
  -- ‚ä¢ x ‚àà f.domain
  cases' h with x' h
  -- ‚ä¢ x ‚àà f.domain
  simp only at h
  -- ‚ä¢ x ‚àà f.domain
  rw [‚Üê h.1]
  -- ‚ä¢ ‚Üëx' ‚àà f.domain
  simp
  -- üéâ no goals
#align linear_pmap.mem_domain_iff LinearPMap.mem_domain_iff

theorem mem_domain_of_mem_graph {f : E ‚Üí‚Çó.[R] F} {x : E} {y : F} (h : (x, y) ‚àà f.graph) :
    x ‚àà f.domain := by
  rw [mem_domain_iff]
  -- ‚ä¢ ‚àÉ y, (x, y) ‚àà graph f
  exact ‚ü®y, h‚ü©
  -- üéâ no goals
#align linear_pmap.mem_domain_of_mem_graph LinearPMap.mem_domain_of_mem_graph

theorem image_iff {f : E ‚Üí‚Çó.[R] F} {x : E} {y : F} (hx : x ‚àà f.domain) :
    y = f ‚ü®x, hx‚ü© ‚Üî (x, y) ‚àà f.graph := by
  rw [mem_graph_iff]
  -- ‚ä¢ y = ‚Üëf { val := x, property := hx } ‚Üî ‚àÉ y_1, ‚Üëy_1 = (x, y).fst ‚àß ‚Üëf y_1 = (x ‚Ä¶
  constructor <;> intro h
  -- ‚ä¢ y = ‚Üëf { val := x, property := hx } ‚Üí ‚àÉ y_1, ‚Üëy_1 = (x, y).fst ‚àß ‚Üëf y_1 = (x ‚Ä¶
                  -- ‚ä¢ ‚àÉ y_1, ‚Üëy_1 = (x, y).fst ‚àß ‚Üëf y_1 = (x, y).snd
                  -- ‚ä¢ y = ‚Üëf { val := x, property := hx }
  ¬∑ use ‚ü®x, hx‚ü©
    -- ‚ä¢ ‚Üë{ val := x, property := hx } = (x, y).fst ‚àß ‚Üëf { val := x, property := hx } ‚Ä¶
    simp [h]
    -- üéâ no goals
  rcases h with ‚ü®‚ü®x', hx'‚ü©, ‚ü®h1, h2‚ü©‚ü©
  -- ‚ä¢ y = ‚Üëf { val := x, property := hx }
  simp only [Submodule.coe_mk] at h1 h2
  -- ‚ä¢ y = ‚Üëf { val := x, property := hx }
  simp only [‚Üê h2, h1]
  -- üéâ no goals
#align linear_pmap.image_iff LinearPMap.image_iff

theorem mem_range_iff {f : E ‚Üí‚Çó.[R] F} {y : F} : y ‚àà Set.range f ‚Üî ‚àÉ x : E, (x, y) ‚àà f.graph := by
  constructor <;> intro h
  -- ‚ä¢ y ‚àà range ‚Üëf ‚Üí ‚àÉ x, (x, y) ‚àà graph f
                  -- ‚ä¢ ‚àÉ x, (x, y) ‚àà graph f
                  -- ‚ä¢ y ‚àà range ‚Üëf
  ¬∑ rw [Set.mem_range] at h
    -- ‚ä¢ ‚àÉ x, (x, y) ‚àà graph f
    rcases h with ‚ü®‚ü®x, hx‚ü©, h‚ü©
    -- ‚ä¢ ‚àÉ x, (x, y) ‚àà graph f
    use x
    -- ‚ä¢ (x, y) ‚àà graph f
    rw [‚Üê h]
    -- ‚ä¢ (x, ‚Üëf { val := x, property := hx }) ‚àà graph f
    exact f.mem_graph ‚ü®x, hx‚ü©
    -- üéâ no goals
  cases' h with x h
  -- ‚ä¢ y ‚àà range ‚Üëf
  rw [mem_graph_iff] at h
  -- ‚ä¢ y ‚àà range ‚Üëf
  cases' h with x h
  -- ‚ä¢ y ‚àà range ‚Üëf
  rw [Set.mem_range]
  -- ‚ä¢ ‚àÉ y_1, ‚Üëf y_1 = y
  use x
  -- ‚ä¢ ‚Üëf x = y
  simp only at h
  -- ‚ä¢ ‚Üëf x = y
  rw [h.2]
  -- üéâ no goals
#align linear_pmap.mem_range_iff LinearPMap.mem_range_iff

theorem mem_domain_iff_of_eq_graph {f g : E ‚Üí‚Çó.[R] F} (h : f.graph = g.graph) {x : E} :
    x ‚àà f.domain ‚Üî x ‚àà g.domain := by simp_rw [mem_domain_iff, h]
                                      -- üéâ no goals
#align linear_pmap.mem_domain_iff_of_eq_graph LinearPMap.mem_domain_iff_of_eq_graph

theorem le_of_le_graph {f g : E ‚Üí‚Çó.[R] F} (h : f.graph ‚â§ g.graph) : f ‚â§ g := by
  constructor
  -- ‚ä¢ f.domain ‚â§ g.domain
  ¬∑ intro x hx
    -- ‚ä¢ x ‚àà g.domain
    rw [mem_domain_iff] at hx ‚ä¢
    -- ‚ä¢ ‚àÉ y, (x, y) ‚àà graph g
    cases' hx with y hx
    -- ‚ä¢ ‚àÉ y, (x, y) ‚àà graph g
    use y
    -- ‚ä¢ (x, y) ‚àà graph g
    exact h hx
    -- üéâ no goals
  rintro ‚ü®x, hx‚ü© ‚ü®y, hy‚ü© hxy
  -- ‚ä¢ ‚Üëf { val := x, property := hx } = ‚Üëg { val := y, property := hy }
  rw [image_iff]
  -- ‚ä¢ (y, ‚Üëf { val := x, property := hx }) ‚àà graph g
  refine' h _
  -- ‚ä¢ (y, ‚Üëf { val := x, property := hx }) ‚àà graph f
  simp only [Submodule.coe_mk] at hxy
  -- ‚ä¢ (y, ‚Üëf { val := x, property := hx }) ‚àà graph f
  rw [hxy] at hx
  -- ‚ä¢ (y, ‚Üëf { val := x, property := hx‚úù }) ‚àà graph f
  rw [‚Üê image_iff hx]
  -- ‚ä¢ ‚Üëf { val := x, property := hx‚úù } = ‚Üëf { val := y, property := hx }
  simp [hxy]
  -- üéâ no goals
#align linear_pmap.le_of_le_graph LinearPMap.le_of_le_graph

theorem le_graph_of_le {f g : E ‚Üí‚Çó.[R] F} (h : f ‚â§ g) : f.graph ‚â§ g.graph := by
  intro x hx
  -- ‚ä¢ x ‚àà graph g
  rw [mem_graph_iff] at hx ‚ä¢
  -- ‚ä¢ ‚àÉ y, ‚Üëy = x.fst ‚àß ‚Üëg y = x.snd
  cases' hx with y hx
  -- ‚ä¢ ‚àÉ y, ‚Üëy = x.fst ‚àß ‚Üëg y = x.snd
  use ‚ü®y, h.1 y.2‚ü©
  -- ‚ä¢ ‚Üë{ val := ‚Üëy, property := (_ : ‚Üëy ‚àà g.domain) } = x.fst ‚àß ‚Üëg { val := ‚Üëy, pr ‚Ä¶
  simp only [hx, Submodule.coe_mk, eq_self_iff_true, true_and_iff]
  -- ‚ä¢ ‚Üëg { val := x.fst, property := (_ : (fun x => x ‚àà g.domain) x.fst) } = x.snd
  convert hx.2 using 1
  -- ‚ä¢ ‚Üëg { val := x.fst, property := (_ : (fun x => x ‚àà g.domain) x.fst) } = ‚Üëf y
  refine' (h.2 _).symm
  -- ‚ä¢ ‚Üëy = ‚Üë{ val := x.fst, property := (_ : (fun x => x ‚àà g.domain) x.fst) }
  simp only [hx.1, Submodule.coe_mk]
  -- üéâ no goals
#align linear_pmap.le_graph_of_le LinearPMap.le_graph_of_le

theorem le_graph_iff {f g : E ‚Üí‚Çó.[R] F} : f.graph ‚â§ g.graph ‚Üî f ‚â§ g :=
  ‚ü®le_of_le_graph, le_graph_of_le‚ü©
#align linear_pmap.le_graph_iff LinearPMap.le_graph_iff

theorem eq_of_eq_graph {f g : E ‚Üí‚Çó.[R] F} (h : f.graph = g.graph) : f = g := by
  -- Porting note: `ext` ‚Üí `refine ext ..`
  refine ext (Submodule.ext fun x => ?_) (fun x y h' => ?_)
  -- ‚ä¢ x ‚àà f.domain ‚Üî x ‚àà g.domain
  exact mem_domain_iff_of_eq_graph h
  -- ‚ä¢ ‚Üëf x = ‚Üëg y
  exact (le_of_le_graph h.le).2 h'
  -- üéâ no goals
#align linear_pmap.eq_of_eq_graph LinearPMap.eq_of_eq_graph

end Graph

end LinearPMap

namespace Submodule

section SubmoduleToLinearPMap

theorem existsUnique_from_graph {g : Submodule R (E √ó F)}
    (hg : ‚àÄ {x : E √ó F} (_hx : x ‚àà g) (_hx' : x.fst = 0), x.snd = 0) {a : E}
    (ha : a ‚àà g.map (LinearMap.fst R E F)) : ‚àÉ! b : F, (a, b) ‚àà g := by
  refine' exists_unique_of_exists_of_unique _ _
  -- ‚ä¢ ‚àÉ x, (a, x) ‚àà g
  ¬∑ convert ha
    -- ‚ä¢ (‚àÉ x, (a, x) ‚àà g) ‚Üî a ‚àà map (LinearMap.fst R E F) g
    simp
    -- üéâ no goals
  intro y‚ÇÅ y‚ÇÇ hy‚ÇÅ hy‚ÇÇ
  -- ‚ä¢ y‚ÇÅ = y‚ÇÇ
  have hy : ((0 : E), y‚ÇÅ - y‚ÇÇ) ‚àà g := by
    convert g.sub_mem hy‚ÇÅ hy‚ÇÇ
    exact (sub_self _).symm
  exact sub_eq_zero.mp (hg hy (by simp))
  -- üéâ no goals
#align submodule.exists_unique_from_graph Submodule.existsUnique_from_graph

/-- Auxiliary definition to unfold the existential quantifier. -/
noncomputable def valFromGraph {g : Submodule R (E √ó F)}
    (hg : ‚àÄ (x : E √ó F) (_hx : x ‚àà g) (_hx' : x.fst = 0), x.snd = 0) {a : E}
    (ha : a ‚àà g.map (LinearMap.fst R E F)) : F :=
  (ExistsUnique.exists (existsUnique_from_graph @hg ha)).choose
#align submodule.val_from_graph Submodule.valFromGraph

theorem valFromGraph_mem {g : Submodule R (E √ó F)}
    (hg : ‚àÄ (x : E √ó F) (_hx : x ‚àà g) (_hx' : x.fst = 0), x.snd = 0) {a : E}
    (ha : a ‚àà g.map (LinearMap.fst R E F)) : (a, valFromGraph hg ha) ‚àà g :=
  (ExistsUnique.exists (existsUnique_from_graph @hg ha)).choose_spec
#align submodule.val_from_graph_mem Submodule.valFromGraph_mem

/-- Define a `LinearMap` from its graph.

Helper definition for `LinearPMap`. -/
noncomputable def toLinearPMapAux (g : Submodule R (E √ó F))
    (hg : ‚àÄ (x : E √ó F) (_hx : x ‚àà g) (_hx' : x.fst = 0), x.snd = 0) :
    g.map (LinearMap.fst R E F) ‚Üí‚Çó[R] F where
  toFun := fun x => valFromGraph hg x.2
  map_add' := fun v w => by
    have hadd := (g.map (LinearMap.fst R E F)).add_mem v.2 w.2
    -- ‚ä¢ (fun x => valFromGraph hg (_ : ‚Üëx ‚àà map (LinearMap.fst R E F) g)) (v + w) =  ‚Ä¶
    have hvw := valFromGraph_mem hg hadd
    -- ‚ä¢ (fun x => valFromGraph hg (_ : ‚Üëx ‚àà map (LinearMap.fst R E F) g)) (v + w) =  ‚Ä¶
    have hvw' := g.add_mem (valFromGraph_mem hg v.2) (valFromGraph_mem hg w.2)
    -- ‚ä¢ (fun x => valFromGraph hg (_ : ‚Üëx ‚àà map (LinearMap.fst R E F) g)) (v + w) =  ‚Ä¶
    rw [Prod.mk_add_mk] at hvw'
    -- ‚ä¢ (fun x => valFromGraph hg (_ : ‚Üëx ‚àà map (LinearMap.fst R E F) g)) (v + w) =  ‚Ä¶
    exact (existsUnique_from_graph @hg hadd).unique hvw hvw'
    -- üéâ no goals
  map_smul' := fun a v => by
    have hsmul := (g.map (LinearMap.fst R E F)).smul_mem a v.2
    -- ‚ä¢ AddHom.toFun { toFun := fun x => valFromGraph hg (_ : ‚Üëx ‚àà map (LinearMap.fs ‚Ä¶
    have hav := valFromGraph_mem hg hsmul
    -- ‚ä¢ AddHom.toFun { toFun := fun x => valFromGraph hg (_ : ‚Üëx ‚àà map (LinearMap.fs ‚Ä¶
    have hav' := g.smul_mem a (valFromGraph_mem hg v.2)
    -- ‚ä¢ AddHom.toFun { toFun := fun x => valFromGraph hg (_ : ‚Üëx ‚àà map (LinearMap.fs ‚Ä¶
    rw [Prod.smul_mk] at hav'
    -- ‚ä¢ AddHom.toFun { toFun := fun x => valFromGraph hg (_ : ‚Üëx ‚àà map (LinearMap.fs ‚Ä¶
    exact (existsUnique_from_graph @hg hsmul).unique hav hav'
    -- üéâ no goals

open Classical in
/-- Define a `LinearPMap` from its graph.

In the case that the submodule is not a graph of a `LinearPMap` then the underlying linear map
is just the zero map. -/
noncomputable def toLinearPMap (g : Submodule R (E √ó F)) : E ‚Üí‚Çó.[R] F
    where
  domain := g.map (LinearMap.fst R E F)
  toFun := if hg : ‚àÄ (x : E √ó F) (_hx : x ‚àà g) (_hx' : x.fst = 0), x.snd = 0 then
    g.toLinearPMapAux hg else 0
#align submodule.to_linear_pmap Submodule.toLinearPMap

theorem toLinearPMap_domain (g : Submodule R (E √ó F)) :
    g.toLinearPMap.domain = g.map (LinearMap.fst R E F) := rfl

theorem toLinearPMap_apply_aux {g : Submodule R (E √ó F)}
    (hg : ‚àÄ (x : E √ó F) (_hx : x ‚àà g) (_hx' : x.fst = 0), x.snd = 0)
    (x : g.map (LinearMap.fst R E F)) :
    g.toLinearPMap x = valFromGraph hg x.2 := by
  classical
  change (if hg : _ then g.toLinearPMapAux hg else 0) x = _
  rw [dif_pos]
  ¬∑ rfl
  ¬∑ exact hg

theorem mem_graph_toLinearPMap {g : Submodule R (E √ó F)}
    (hg : ‚àÄ (x : E √ó F) (_hx : x ‚àà g) (_hx' : x.fst = 0), x.snd = 0)
    (x : g.map (LinearMap.fst R E F)) : (x.val, g.toLinearPMap x) ‚àà g := by
  rw [toLinearPMap_apply_aux hg]
  -- ‚ä¢ (‚Üëx, valFromGraph hg (_ : ‚Üëx ‚àà map (LinearMap.fst R E F) g)) ‚àà g
  exact valFromGraph_mem hg x.2
  -- üéâ no goals
#align submodule.mem_graph_to_linear_pmap Submodule.mem_graph_toLinearPMap

@[simp]
theorem toLinearPMap_graph_eq (g : Submodule R (E √ó F))
    (hg : ‚àÄ (x : E √ó F) (_hx : x ‚àà g) (_hx' : x.fst = 0), x.snd = 0) :
    g.toLinearPMap.graph = g := by
  ext x
  -- ‚ä¢ x ‚àà LinearPMap.graph (toLinearPMap g) ‚Üî x ‚àà g
  constructor <;> intro hx
  -- ‚ä¢ x ‚àà LinearPMap.graph (toLinearPMap g) ‚Üí x ‚àà g
                  -- ‚ä¢ x ‚àà g
                  -- ‚ä¢ x ‚àà LinearPMap.graph (toLinearPMap g)
  ¬∑ rw [LinearPMap.mem_graph_iff] at hx
    -- ‚ä¢ x ‚àà g
    rcases hx with ‚ü®y, hx1, hx2‚ü©
    -- ‚ä¢ x ‚àà g
    convert g.mem_graph_toLinearPMap hg y using 1
    -- ‚ä¢ x = (‚Üëy, ‚Üë(toLinearPMap g) y)
    exact Prod.ext hx1.symm hx2.symm
    -- üéâ no goals
  rw [LinearPMap.mem_graph_iff]
  -- ‚ä¢ ‚àÉ y, ‚Üëy = x.fst ‚àß ‚Üë(toLinearPMap g) y = x.snd
  cases' x with x_fst x_snd
  -- ‚ä¢ ‚àÉ y, ‚Üëy = (x_fst, x_snd).fst ‚àß ‚Üë(toLinearPMap g) y = (x_fst, x_snd).snd
  have hx_fst : x_fst ‚àà g.map (LinearMap.fst R E F) := by
    simp only [mem_map, LinearMap.fst_apply, Prod.exists, exists_and_right, exists_eq_right]
    exact ‚ü®x_snd, hx‚ü©
  refine' ‚ü®‚ü®x_fst, hx_fst‚ü©, Subtype.coe_mk x_fst hx_fst, _‚ü©
  -- ‚ä¢ ‚Üë(toLinearPMap g) { val := x_fst, property := hx_fst } = (x_fst, x_snd).snd
  rw [toLinearPMap_apply_aux hg]
  -- ‚ä¢ valFromGraph hg (_ : ‚Üë{ val := x_fst, property := hx_fst } ‚àà map (LinearMap. ‚Ä¶
  exact (existsUnique_from_graph @hg hx_fst).unique (valFromGraph_mem hg hx_fst) hx
  -- üéâ no goals
#align submodule.to_linear_pmap_graph_eq Submodule.toLinearPMap_graph_eq

theorem toLinearPMap_range (g : Submodule R (E √ó F))
    (hg : ‚àÄ (x : E √ó F) (_hx : x ‚àà g) (_hx' : x.fst = 0), x.snd = 0) :
    LinearMap.range g.toLinearPMap.toFun = g.map (LinearMap.snd R E F) := by
  rwa [‚Üê LinearPMap.graph_map_snd_eq_range, toLinearPMap_graph_eq]
  -- üéâ no goals

end SubmoduleToLinearPMap

end Submodule

namespace LinearPMap

section inverse

/-- The inverse of a `LinearPMap`. -/
noncomputable def inverse (f : E ‚Üí‚Çó.[R] F) : F ‚Üí‚Çó.[R] E :=
  (f.graph.map (LinearEquiv.prodComm R E F)).toLinearPMap

variable {f : E ‚Üí‚Çó.[R] F}

theorem inverse_domain : (inverse f).domain = LinearMap.range f.toFun := by
  rw [inverse, Submodule.toLinearPMap_domain, ‚Üê graph_map_snd_eq_range,
    ‚Üê LinearEquiv.fst_comp_prodComm, Submodule.map_comp]
  rfl
  -- üéâ no goals

variable (hf : LinearMap.ker f.toFun = ‚ä•)

/-- The graph of the inverse generates a `LinearPMap`. -/
theorem mem_inverse_graph_snd_eq_zero (x : F √ó E)
    (hv : x ‚àà (graph f).map (LinearEquiv.prodComm R E F))
    (hv' : x.fst = 0) : x.snd = 0 := by
  simp only [Submodule.mem_map, mem_graph_iff, Subtype.exists, exists_and_left, exists_eq_left,
    LinearEquiv.prodComm_apply, Prod.exists, Prod.swap_prod_mk] at hv
  rcases hv with ‚ü®a, b, ‚ü®ha, h1‚ü©, ‚ü®h2, h3‚ü©‚ü©
  -- ‚ä¢ (b, a).snd = 0
  simp only at hv' ‚ä¢
  -- ‚ä¢ a = 0
  rw [hv'] at h1
  -- ‚ä¢ a = 0
  rw [LinearMap.ker_eq_bot'] at hf
  -- ‚ä¢ a = 0
  specialize hf ‚ü®a, ha‚ü© h1
  -- ‚ä¢ a = 0
  simp only [Submodule.mk_eq_zero] at hf
  -- ‚ä¢ a = 0
  exact hf
  -- üéâ no goals

theorem inverse_graph : (inverse f).graph = f.graph.map (LinearEquiv.prodComm R E F) := by
  rw [inverse, Submodule.toLinearPMap_graph_eq _ (mem_inverse_graph_snd_eq_zero hf)]
  -- üéâ no goals

theorem inverse_range : LinearMap.range (inverse f).toFun = f.domain := by
  rw [inverse, Submodule.toLinearPMap_range _ (mem_inverse_graph_snd_eq_zero hf),
    ‚Üê graph_map_fst_eq_domain, ‚Üê LinearEquiv.snd_comp_prodComm, Submodule.map_comp]
  rfl
  -- üéâ no goals

theorem mem_inverse_graph (x : f.domain) : (f x, (x : E)) ‚àà (inverse f).graph := by
  simp only [inverse_graph hf, Submodule.mem_map, mem_graph_iff, Subtype.exists, exists_and_left,
    exists_eq_left, LinearEquiv.prodComm_apply, Prod.exists, Prod.swap_prod_mk, Prod.mk.injEq]
  exact ‚ü®(x : E), f x, ‚ü®x.2, Eq.refl _‚ü©, Eq.refl _, Eq.refl _‚ü©
  -- üéâ no goals

theorem inverse_apply_eq {y : (inverse f).domain} {x : f.domain} (hxy : f x = y) :
    (inverse f) y = x := by
  have := mem_inverse_graph hf x
  -- ‚ä¢ ‚Üë(inverse f) y = ‚Üëx
  simp only [mem_graph_iff, Subtype.exists, exists_and_left, exists_eq_left] at this
  -- ‚ä¢ ‚Üë(inverse f) y = ‚Üëx
  rcases this with ‚ü®hx, h‚ü©
  -- ‚ä¢ ‚Üë(inverse f) y = ‚Üëx
  rw [‚Üê h]
  -- ‚ä¢ ‚Üë(inverse f) y = ‚Üë(inverse f) { val := ‚Üëf x, property := (_ : ‚Üëf x ‚àà (invers ‚Ä¶
  congr
  -- ‚ä¢ y = { val := ‚Üëf x, property := (_ : ‚Üëf x ‚àà (inverse f).domain) }
  simp only [hxy, Subtype.coe_eta]
  -- üéâ no goals

end inverse

end LinearPMap
