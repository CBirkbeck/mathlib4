/-
Copyright (c) 2025 Raphael Douglas Giles. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Raphael Douglas Giles, Zhixuan Dai, Zhenyan Fu, Yiming Fu, Wang Jingting
-/
import Mathlib.LinearAlgebra.TensorAlgebra.Basic
import Mathlib.Algebra.MvPolynomial.Basic
import Mathlib.RingTheory.Finiteness.Defs
import Mathlib.Algebra.Algebra.Hom
import Mathlib.Algebra.Lie.Basic
import Mathlib.Algebra.Lie.OfAssociative
import Mathlib.Algebra.MvPolynomial.CommRing
import Mathlib.GroupTheory.MonoidLocalization.Basic

/-!
# Symmetric Algebras

Given a commutative ring `R`, and an `R`-module `L`, we construct the symmetric algebra of `L`.
This is the free commutative `R`-algebra generated (`R`-linearly) by the module `L`.

## Notation

1. `SymmetricAlgebra R L` is a concrete construction of the symmetric algebra defined as a
   quotient of the tensor algebra. It is endowed with an R-algebra structure and a commutative
   ring structure.
2. `SymmetricAlgebra.Œπ R` is the canonical R-linear map `L ‚Üí TensorAlgebra R L`.
3. Given a morphism `Œπ : L ‚Üí‚Çó[R] RL`, `IsSymmetricAlgebra Œπ` is a proposition saying whether
   RL satisfies the universal property of the symmetric algebra over L with Œπ as the canonical
   inclusion morphism.
3. Given a linear map `f : M ‚Üí A` to an commutative R-algebra `A`, and a morphism
   `Œπ : L ‚Üí‚Çó[R] RL` with `p : IsSymmetricAlgebra Œπ`, `IsSymmetricAlgebra.lift R p f`
   is the lift of `f` to an `R`-algebra morphism `RL ‚Üí‚Çê[R] A`.

## Theorems

1. `SymmetricAlgebra.isSymmetricAlgebra R L` states that the concrete construction of the symmetric
   algebra satisfies the univeral property codified in `IsSymmetricAlgebra`.
2. Given a proof `hl` that `L` is subsingleton (meaning as a module it must be the zero module)
   `IsSymmetricAlgebra.baseRingOfZeroModule hl` states that `R` viewed as an `R` algebra satisfies
   the universal property of the symmetric algebra of `L`.
3. `IsSymmetricAlgebra.isomorphismOfSymmetricAlgebraOfSymmetricAlgebra` states that any two algebras
   `RM` and `RM'` both satisfying the universal property of the symmetric algebra over a module `M`
   must be isorphic as `R`-algebras.
4. `IsSymmetricAlgebra.mvPolynomial` states that given a basis of `L` indexed by type `I`, the
   multivariate polynomial ring generated by monomials `X_i` for all `i : I` satisfies the
   universal property of the symmetric algebra over `L`.

-/

open MvPolynomial RingQuot

noncomputable section
universe u
variable (R L : Type u) {RL : Type u} [CommRing R]
         [AddCommMonoid L] [Module R L]
         [CommRing RL] [Algebra R RL]

         {L' : Type u} [CommRing L'] [Algebra R L']
--local notation "Œπ" => TensorAlgebra.Œπ R

open TensorAlgebra in
/--
Relation on the tensor algebra which will yield the symmetric algebra when
quotiented out by
-/
inductive SymRel : (TensorAlgebra R L) ‚Üí (TensorAlgebra R L) ‚Üí Prop where
  | mul_comm (x y : L) : SymRel (Œπ R x * Œπ R y) (Œπ R y * Œπ R x)

/--
Concrete construction of the symmetric algebra of L by quotienting out
the tensor algebra by the commutativity relation
-/
abbrev SymmetricAlgebra := RingQuot (SymRel R L)


variable {R} {L} in
/--
Given a morphism Œπ : L ‚Üí‚Çó[R] RL, where RL is some commutative algebra over R,
IsSymmetricAlgebra Œπ means that RL satisfies the universal property of the
symmetric algebra of L, i.e. it means that for any morphism œÜ : L ‚Üí‚Çó[R] A into a
commutative algebra A, there exists a unique œÜ' : RL ‚Üí‚Çê[R] A such that œÜ = œÜ' ‚àò Œπ.
-/
structure IsSymmetricAlgebra (Œπ : L ‚Üí‚Çó[R] RL) : Prop where
  ex_map {A : Type u} [CommRing A] [Algebra R A] (œÜ : L ‚Üí‚Çó[R] A)
    : ‚àÉ! œÜ' : RL ‚Üí‚Çê[R] A, œÜ = œÜ'.toLinearMap ‚àò‚Çó Œπ



local notation "ùîñ" => SymmetricAlgebra


namespace SymmetricAlgebra
open TensorAlgebra in
instance : CommRing (ùîñ R L) where
  mul_comm a b := match a, b with
    | ‚ü®a‚ü©, ‚ü®b‚ü© => by
      apply Quot.ind _ a; apply Quot.ind _ b; intro a b;
      rw [mul_quot, mul_quot]
      suffices h : ‚àÄ (x : TensorAlgebra R L),
      (‚ü®Quot.mk (RingQuot.Rel (SymRel R L)) (x * a)‚ü© : (RingQuot (SymRel R L))) =
       ‚ü®Quot.mk (RingQuot.Rel (SymRel R L)) (a * x)‚ü© by
        exact (h b)
      let P : TensorAlgebra R L ‚Üí TensorAlgebra R L ‚Üí Prop :=
       fun x y ‚Ü¶ (‚ü®Quot.mk (RingQuot.Rel (SymRel R L)) (x * y)‚ü© : (RingQuot (SymRel R L))) =
        ‚ü®Quot.mk (RingQuot.Rel (SymRel R L)) (y * x)‚ü©
      have P_smul (r : R) (x : TensorAlgebra R L) : P x (algebraMap R (TensorAlgebra R L) r) := by
        unfold P; rw [Algebra.commutes]
      have P_mul (x y z : TensorAlgebra R L) (h1 : P z x) (h2 : P z y) : P z (x * y) := by
        unfold P at h1 h2 ‚ä¢
        rw [‚Üê mul_quot, ‚Üê mul_quot, ‚Üê mul_quot, ‚Üê mul_quot,
            ‚Üê mul_assoc, mul_quot, h1, ‚Üê mul_quot, mul_assoc, mul_quot, h2, ‚Üê mul_quot, mul_assoc]
      have P_add (x y z : TensorAlgebra R L) (h1 : P z x) (h2 : P z y) : P z (x + y) := by
        unfold P at h1 h2 ‚ä¢
        rw [mul_add, add_mul, ‚Üê add_quot, ‚Üê add_quot, h1, h2]
      have P_symm {x y : TensorAlgebra R L} (h : P x y) : P y x := h.symm
      have P_base (x y : L) : P (Œπ R x) (Œπ R y) := by
        unfold P
        rw [Quot.sound (Rel.of (SymRel.mul_comm x y))]
      apply TensorAlgebra.induction (C := fun y ‚Ü¶ ‚àÄ (x : TensorAlgebra R L), P x y) _ _ _ _ a
      ¬∑ intro r; exact P_smul r
      ¬∑ intro x; apply TensorAlgebra.induction
        ¬∑ intro r; exact P_symm (P_smul r (Œπ R x))
        ¬∑ intro y; exact P_base y x
        ¬∑ intro a1 a2 h1 h2; exact P_symm (P_mul a1 a2 (Œπ R x) (P_symm h1) (P_symm h2))
        ¬∑ intro a1 a2 h1 h2; exact P_symm (P_add a1 a2 (Œπ R x) (P_symm h1) (P_symm h2))
      ¬∑ intro a1 a2 h1 h2 x; exact P_mul a1 a2 x (h1 x) (h2 x)
      ¬∑ intro a1 a2 h1 h2 x; exact P_add a1 a2 x (h1 x) (h2 x)

/--
Algebra homomorphism from the tensor algebra over L to the symmetric algebra over L.
-/
abbrev algHom : TensorAlgebra R L ‚Üí‚Çê[R] ùîñ R L := RingQuot.mkAlgHom R (SymRel R L)

/--
Canonical inclusion of `L` into the symmetric algebra `ùîñ R L`.
-/
def Œπ : L ‚Üí‚Çó[R] ùîñ R L := (algHom R L).toLinearMap.comp (TensorAlgebra.Œπ R (M := L))

end SymmetricAlgebra

namespace IsSymmetricAlgebra
/--
The zero module over base ring R has R as its symmetric algebra
-/
theorem baseRingOfZeroModule (hm : Subsingleton L) :
   IsSymmetricAlgebra (R := R) (L := L) (RL := R) 0 where
    ex_map := by
      intro a b c œÜ
      have hœÜ : œÜ = 0 := Subsingleton.eq_zero œÜ
      let œÜ' : R ‚Üí‚Çê[R] a := Algebra.ofId R a
      use œÜ'
      constructor
      ¬∑ rw [hœÜ]
        ext x
        simp only [LinearMap.zero_apply, LinearMap.comp_zero]
      ¬∑  intro œà hœà
         exact Algebra.ext_id_iff.mpr trivial

open SymmetricAlgebra in
/--
The concrete construction of the symmetric algebra as a quotient of the tensor algebra
satisfies the universal property of the symmetric algebra
-/
theorem SymmetricAlgebra.isSymmetricAlgebra : IsSymmetricAlgebra (Œπ R L) where
  ex_map := by
    intro alg com halg œÜ
    let tensorphi : TensorAlgebra R L ‚Üí‚Çê[R] alg := TensorAlgebra.lift R œÜ
    have res : ‚àÄ ‚¶Éx y : TensorAlgebra R L‚¶Ñ, SymRel R L x y ‚Üí tensorphi x = tensorphi y := by
        intro x y h
        induction h
        case mul_comm x y =>
          simp only [map_mul]
          rw [@NonUnitalCommSemiring.mul_comm]
    use (RingQuot.liftAlgHom (S := R) (s := SymRel R L) (B := alg)) ‚ü®TensorAlgebra.lift R œÜ, res‚ü©
    constructor
    ¬∑ unfold Œπ
      ext a
      simp
    ¬∑ intro a b
      apply RingQuot.liftAlgHom_unique
      exact
        (TensorAlgebra.lift_unique œÜ (a.comp (RingQuot.mkAlgHom R (SymRel R L)))).mp
          (id (Eq.symm b))


variable {L}

/--
Given a morphism `œÜ : L ‚Üí‚Çó[R] L'`, lift this to a morphism of type `RL ‚Üí‚Çê[R] L'` (where `RL`
satisfies the universal property of the symmetric algebra of `L`)
-/
def lift {iM : L ‚Üí‚Çó[R] RL} (salg : IsSymmetricAlgebra iM) (œÜ : L ‚Üí‚Çó[R] L') : RL ‚Üí‚Çê[R] L' :=
  (salg.ex_map œÜ).choose

/--
The lift `œÜ' : RL ‚Üí‚Çê[R] L'` of a morhpism `œÜ : L ‚Üí‚Çó[R] L'` satisfies `œÜ = œÜ' ‚àò Œπ`
-/
theorem lift_spec {iM : L ‚Üí‚Çó[R] RL} (salg : IsSymmetricAlgebra iM) (œÜ : L ‚Üí‚Çó[R] L') :
         œÜ = (lift R salg œÜ).toLinearMap ‚àò‚Çó iM := (salg.ex_map œÜ).choose_spec.1

lemma comp_spec {M : Type u} [AddCommMonoid M] [Module R M]
         {RM RM' : Type u}
         [CommRing RM] [Algebra R RM] [CommRing RM'] [Algebra R RM']
         {iM : M ‚Üí‚Çó[R] RM} {iM' : M ‚Üí‚Çó[R] RM'}
         (salg : IsSymmetricAlgebra iM) (salg' : IsSymmetricAlgebra iM') :
  iM = ((AlgHom.comp (lift _ salg' iM) (lift _ salg iM')).toLinearMap) ‚àò‚Çó iM := by
  rw [AlgHom.comp_toLinearMap]
  rw [LinearMap.comp_assoc]
  rw [‚Üê lift_spec _ salg iM']
  exact lift_spec _ salg' iM

@[simp]
lemma comp_id {M : Type u} [AddCommMonoid M] [Module R M]
    {RM RM' : Type u}
    [CommRing RM] [Algebra R RM] [CommRing RM'] [Algebra R RM']
    {iM : M ‚Üí‚Çó[R] RM} {iM' : M ‚Üí‚Çó[R] RM'}
    (salg : IsSymmetricAlgebra iM) (salg' : IsSymmetricAlgebra iM')
    : (lift R salg' iM).comp (lift R salg iM') = AlgHom.id R RM :=
    (salg.ex_map iM).unique (comp_spec _ salg salg') (by rfl)


lemma lift_comp {M : Type u} [AddCommMonoid M] [Module R M]
    {RM RM' : Type u}
    [CommRing RM] [Algebra R RM] [CommRing RM'] [Algebra R RM']
    {iM : M ‚Üí‚Çó[R] RM} {iM' : M ‚Üí‚Çó[R] RM'}
    (salg : IsSymmetricAlgebra iM) (salg' : IsSymmetricAlgebra iM') :
    ‚áë(lift R salg' iM) ‚àò ‚áë(lift R salg iM') =
    (AlgHom.comp (lift R salg' iM) (lift R salg iM')) := rfl

/--
Two algebras RM and RM' satisfying the universal property for the symmetric algebra of M over R
must be isomorphic
-/
def isomorphismOfSymmetricAlgebraOfSymmetricAlgebra {M : Type u} [AddCommMonoid M] [Module R M]
    {RM RM' : Type u}
    [CommRing RM] [Algebra R RM] [CommRing RM'] [Algebra R RM']
    {iM : M ‚Üí‚Çó[R] RM} {iM' : M ‚Üí‚Çó[R] RM'}
    (salg : IsSymmetricAlgebra iM) (salg' : IsSymmetricAlgebra iM') : RM ‚âÉ‚Çê[R] RM' where
  toFun : RM ‚Üí‚Çê[R] RM' := lift R salg iM'
  invFun : RM' ‚Üí‚Çê[R] RM := lift R salg' iM
  left_inv := by
    rw [@Function.leftInverse_iff_comp]
    simp[lift_comp]
  right_inv := by
    rw [@Function.rightInverse_iff_comp]
    simp[lift_comp]
  map_mul' := by simp only [map_mul, implies_true]
  map_add' := by simp only [map_add, implies_true]
  commutes' := by simp only [AlgHom.commutes, implies_true]


variable (I : Type u) (basis_I : Basis I R L)

/--
Given a basis I of an R-module L, the polynomial ring with variables generated by the elements
of I satisfies the universal property of a symmetric algebra of L
-/
theorem mvPolynomial :
  IsSymmetricAlgebra (Basis.constr basis_I R (fun i ‚Ü¶ MvPolynomial.X i) : L ‚Üí‚Çó[R] MvPolynomial I R)
  where
  ex_map := by
    intro alg b c œÜ
    use MvPolynomial.aeval (R := R) (fun i => œÜ (basis_I i))
    constructor
    ¬∑ apply Basis.ext basis_I
      intro i
      simp
    ¬∑ intro f hf
      ext i
      simp only [aeval_X]
      rw [hf]
      simp only [LinearMap.coe_comp, LieHom.coe_toLinearMap, AlgHom.coe_toLieHom,
        Function.comp_apply, Basis.constr_basis, AlgHom.toLinearMap_apply]

end IsSymmetricAlgebra
