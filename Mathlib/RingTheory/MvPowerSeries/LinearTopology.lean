/-
Copyright (c) 2024 Antoine Chambert-Loir, Mar√≠a In√©s de Frutos-Fern√°ndez. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Antoine Chambert-Loir, Mar√≠a In√©s de Frutos-Fern√°ndez
-/
import Mathlib.Data.Finsupp.Interval
import Mathlib.RingTheory.MvPowerSeries.PiTopology
import Mathlib.Topology.Algebra.LinearTopology
import Mathlib.Topology.Algebra.Nonarchimedean.Bases

/-! # Linear topology on the ring of multivariate power series

- `MvPowerSeries.basis`: the ideals of the ring of multivariate power series
all coefficients the exponent of which is smaller than some bound vanish.

- `MvPowerSeries.idealIsBasis`: it defines an `Ideal.IsBasis`.

## Instances :

- `MvPowerSeries.linearTopology`.

TODO. For the moment, this is restricted to commutative rings because of the similar
restriction for linear topologies. However, the definition below is already correct
in the general case, the issue is solely about the definition of a linear topology.

-/
namespace MvPowerSeries

open scoped Topology

open Set SetLike

variable (œÉ : Type*) (Œ± : Type*) [Ring Œ±]

section Ideal.IsBasis

/-- The underlying family for the `Ideal.IsBasis` in a multivariate power series ring. -/
def basis : (œÉ ‚Üí‚ÇÄ ‚Ñï) ‚Üí Ideal (MvPowerSeries œÉ Œ±) := fun d =>
  { carrier   := {f | ‚àÄ e ‚â§ d, coeff Œ± e f = 0} -- monomial e 1 ‚à£ f
    zero_mem' := fun _ _ => by rw [coeff_zero]
    add_mem'  := fun hf hg e he => by rw [map_add, hf e he, hg e he, add_zero]
    smul_mem' := fun f g hg e he => by
      classical
      rw [smul_eq_mul, coeff_mul]
      apply Finset.sum_eq_zero
      rintro uv huv
      convert MulZeroClass.mul_zero (coeff Œ± uv.fst f)
      exact hg  _ (le_trans (le_iff_exists_add'.mpr
        ‚ü®uv.fst, (Finset.mem_antidiagonal.mp huv).symm‚ü©) he) }

/-- The underlying family for the `Ideal.IsBasis` in a multivariate power series ring. -/
def basis‚ÇÇ : (œÉ ‚Üí‚ÇÄ ‚Ñï) ‚Üí TwoSidedIdeal (MvPowerSeries œÉ Œ±) := fun d ‚Ü¶ by
  apply TwoSidedIdeal.mk' {f | ‚àÄ e ‚â§ d, coeff Œ± e f = 0}
  ¬∑ simp [coeff_zero]
  ¬∑ exact fun hf hg e he ‚Ü¶ by rw [map_add, hf e he, hg e he, add_zero]
  ¬∑ exact fun {f} hf e he ‚Ü¶ by simp only [map_neg, neg_eq_zero, hf e he]
  ¬∑ exact fun {f g} hg e he ‚Ü¶ by
      classical
      rw [coeff_mul]
      apply Finset.sum_eq_zero
      rintro uv huv
      convert MulZeroClass.mul_zero (coeff Œ± uv.fst f)
      exact hg  _ (le_trans (le_iff_exists_add'.mpr
        ‚ü®uv.fst, (Finset.mem_antidiagonal.mp huv).symm‚ü©) he)
  ¬∑ exact fun {f g} hf e he ‚Ü¶ by
      classical
      rw [coeff_mul]
      apply Finset.sum_eq_zero
      rintro uv huv
      convert MulZeroClass.zero_mul (coeff Œ± uv.snd g)
      exact hf _ (le_trans (le_iff_exists_add.mpr ‚ü®uv.2, (Finset.mem_antidiagonal.mp huv).symm‚ü©) he)

/-- A power series `f` belongs to the ideal `basis œÉ Œ± d` if and only if `coeff Œ± e f = 0` for all
`e ‚â§ d`. -/
theorem mem_basis (f : MvPowerSeries œÉ Œ±) (d : œÉ ‚Üí‚ÇÄ ‚Ñï) :
    f ‚àà basis œÉ Œ± d ‚Üî ‚àÄ e ‚â§ d, coeff Œ± e f = 0 := by
  simp [basis]

/-- A power series `f` belongs to the ideal `basis œÉ Œ± d` if and only if `coeff Œ± e f = 0` for all
`e ‚â§ d`. -/
theorem mem_basis‚ÇÇ (f : MvPowerSeries œÉ Œ±) (d : œÉ ‚Üí‚ÇÄ ‚Ñï) :
    f ‚àà basis‚ÇÇ œÉ Œ± d ‚Üî ‚àÄ e ‚â§ d, coeff Œ± e f = 0 := by
  simp [basis‚ÇÇ]

/-- If `e ‚â§ d`, then we have the inclusion of ideals `basis œÉ Œ± d ‚â§ basis œÉ Œ± e`. -/
theorem basis_le {e d : œÉ ‚Üí‚ÇÄ ‚Ñï} (hed : e ‚â§ d) : basis œÉ Œ± d ‚â§ basis œÉ Œ± e :=
  fun _ => forall_imp (fun _ h ha => h (le_trans ha hed))

/-- If `e ‚â§ d`, then we have the inclusion of ideals `basis œÉ Œ± d ‚â§ basis œÉ Œ± e`. -/
theorem basis‚ÇÇ_le {e d : œÉ ‚Üí‚ÇÄ ‚Ñï} (hed : e ‚â§ d) : basis‚ÇÇ œÉ Œ± d ‚â§ basis‚ÇÇ œÉ Œ± e :=
  fun _ => forall_imp (fun _ h ha => h (le_trans ha hed))

/-- `basis œÉ Œ± d ‚â§ basis œÉ Œ± e` if and only if `e ‚â§ d`. -/
theorem basis_le_iff [Nontrivial Œ±] {d e : œÉ ‚Üí‚ÇÄ ‚Ñï} :
    basis œÉ Œ± d ‚â§ basis œÉ Œ± e ‚Üî e ‚â§ d := by
  refine ‚ü®?_, basis_le _ _‚ü©
  simp only [basis, Submodule.mk_le_mk, AddSubmonoid.mk_le_mk, setOf_subset_setOf]
  intro h
  rw [‚Üê inf_eq_right]
  apply le_antisymm inf_le_right
  by_contra h'
  simp only [AddSubsemigroup.mk_le_mk, setOf_subset_setOf] at h
  specialize h (monomial Œ± e 1) _
  ¬∑ intro e' he'
    apply coeff_monomial_ne
    intro hee'
    rw [hee'] at he'
    apply h'
    exact le_inf_iff.mpr ‚ü®he', le_rfl‚ü©
  ¬∑ apply one_ne_zero' Œ±
    convert h e le_rfl
    rw [coeff_monomial_same]

/-- `basis œÉ Œ± d ‚â§ basis œÉ Œ± e` if and only if `e ‚â§ d`. -/
theorem basis‚ÇÇ_le_iff [Nontrivial Œ±] {d e : œÉ ‚Üí‚ÇÄ ‚Ñï} :
    basis‚ÇÇ œÉ Œ± d ‚â§ basis‚ÇÇ œÉ Œ± e ‚Üî e ‚â§ d := by
  refine ‚ü®?_, basis‚ÇÇ_le _ _‚ü©
  simp only [basis‚ÇÇ]
  intro h
  rw [‚Üê inf_eq_right]
  apply le_antisymm inf_le_right
  by_contra h'
  simp only [TwoSidedIdeal.le_iff, TwoSidedIdeal.coe_mk', setOf_subset_setOf] at h
  specialize h (monomial Œ± e 1) _
  ¬∑ intro e' he'
    apply coeff_monomial_ne
    intro hee'
    rw [hee'] at he'
    apply h'
    exact le_inf_iff.mpr ‚ü®he', le_rfl‚ü©
  ¬∑ apply one_ne_zero' Œ±
    convert h e le_rfl
    rw [coeff_monomial_same]

/-- The function `basis œÉ Œ±` is antitone. -/
theorem basis_antitone : Antitone (basis œÉ Œ±) := fun _ _ h => basis_le œÉ Œ± h

/-- The function `basis œÉ Œ±` is strictly antitone. -/
theorem basis_strict_anti [Nontrivial Œ±] : StrictAnti (basis œÉ Œ±) :=
  strictAnti_of_le_iff_le (fun _ _ ‚Ü¶ (basis_le_iff œÉ Œ±).symm)

/-- The function `basis‚ÇÇ œÉ Œ±` is antitone. -/
theorem basis‚ÇÇ_antitone : Antitone (basis‚ÇÇ œÉ Œ±) := fun _ _ h => basis‚ÇÇ_le œÉ Œ± h

/-- The function `basis‚ÇÇ œÉ Œ±` is strictly antitone. -/
theorem basis‚ÇÇ_strict_anti [Nontrivial Œ±] : StrictAnti (basis‚ÇÇ œÉ Œ±) :=
  strictAnti_of_le_iff_le (fun _ _ ‚Ü¶ (basis‚ÇÇ_le_iff œÉ Œ±).symm)

theorem ringSubgroupsBasis : RingSubgroupsBasis (fun d ‚Ü¶ (basis œÉ Œ± d).toAddSubgroup) where
  inter d e := ‚ü®d ‚äî e, (basis_antitone œÉ Œ±).map_sup_le d e‚ü©
  mul d := ‚ü®d, fun f ‚Ü¶ by
    simp only [Submodule.coe_toAddSubgroup, mem_mul]
    rintro ‚ü®x, hx, y, hy, rfl‚ü©
    exact Ideal.mul_mem_left _ _ hy‚ü©
  leftMul f d := ‚ü®d, fun g hg ‚Ü¶ (basis œÉ Œ± d).mul_mem_left f hg‚ü©
  rightMul f d := ‚ü®d, fun g hg ‚Ü¶ by
    simp only [Submodule.coe_toAddSubgroup, mem_preimage, mem_coe, mem_basis] at hg ‚ä¢
    intro e he
    classical
    rw [coeff_mul]
    apply Finset.sum_eq_zero
    rintro ‚ü®i, j‚ü© h
    rw [hg i (le_trans ?_ he), zero_mul]
    simp only [‚Üê Finset.mem_antidiagonal.mp h, le_self_add]‚ü©

theorem ringSubgroupsBasis‚ÇÇ :
    RingSubgroupsBasis (fun d ‚Ü¶ (basis‚ÇÇ œÉ Œ± d).asIdeal.toAddSubgroup) where
  inter d e := ‚ü®d ‚äî e, (basis‚ÇÇ_antitone œÉ Œ±).map_sup_le d e‚ü©
  mul d := ‚ü®d, fun f ‚Ü¶ by
    simp only [Submodule.coe_toAddSubgroup, mem_mul]
    rintro ‚ü®x, hx, y, hy, rfl‚ü©
    exact Ideal.mul_mem_left _ _ hy‚ü©
  leftMul f d := ‚ü®d, fun g hg ‚Ü¶ (basis‚ÇÇ œÉ Œ± d).mul_mem_left f g hg‚ü©
  rightMul f d := ‚ü®d, fun g hg ‚Ü¶ by
    intro e he
    simp only [Submodule.coe_toAddSubgroup, TwoSidedIdeal.coe_asIdeal,
      mem_coe, sub_zero, mem_basis‚ÇÇ] at hg ‚ä¢
    classical
    rw [coeff_mul]
    apply Finset.sum_eq_zero
    rintro ‚ü®i, j‚ü© h
    rw [hg i (le_trans ?_ he), zero_mul]
    simp only [‚Üê Finset.mem_antidiagonal.mp h, le_self_add]‚ü©

/- /-- `MvPowerSeries.basis` is an `Ideal.IsBasis`. -/
theorem idealIsBasis : Ideal.IsBasis (basis œÉ Œ±) where
  nonempty := inferInstance
  inter := fun d e ‚Ü¶ ‚ü®d ‚äî e, Antitone.map_sup_le (basis_antitone œÉ Œ±) d e ‚ü©
  mul_right := fun d f g ‚Ü¶ by
    simp only [mem_basis]
    intro hf e he
    classical
    rw [coeff_mul]
    apply Finset.sum_eq_zero
    rintro ‚ü®i, j‚ü© h
    rw [hf i (le_trans ?_ he), zero_mul]
    simp only [‚Üê Finset.mem_antidiagonal.mp h, le_self_add]

/-- `MvPowerSeries.basis` is a `RingSubgroupsBasis`. -/
theorem ringSubgroupsBasis : RingSubgroupsBasis fun d => (basis œÉ Œ± d).toAddSubgroup :=
  (idealIsBasis œÉ Œ±).toRingSubgroupsBasis -/

end Ideal.IsBasis

section DiscreteTopology

-- We endow MvPowerSeries œÉ Œ± with the product topology.
open WithPiTopology

variable [TopologicalSpace Œ±] [DiscreteTopology Œ±]

/-- If the coefficient ring `Œ±` is endowed with the discrete topology, then for every `d : œÉ ‚Üí‚ÇÄ ‚Ñï`,
`‚Üë(basis œÉ Œ± d) ‚àà ùìù (0 : MvPowerSeries œÉ Œ±)`. -/
theorem basis_mem_nhds_zero (d : œÉ ‚Üí‚ÇÄ ‚Ñï) :
    (basis œÉ Œ± d : Set (MvPowerSeries œÉ Œ±)) ‚àà ùìù 0 := by
  classical
  rw [nhds_pi, Filter.mem_pi]
  use Finset.Iic d, Finset.finite_toSet _, (fun e => if e ‚â§ d then {0} else univ)
  constructor
  ¬∑ intro e
    split_ifs
    ¬∑ simp only [nhds_discrete, Filter.mem_pure, mem_singleton_iff]
      rfl
    ¬∑ simp only [Filter.univ_mem]
  ¬∑ intro f
    simp only [Finset.coe_Iic, mem_pi, mem_Iic, mem_ite_univ_right, mem_singleton_iff, mem_coe]
    exact forall_imp (fun e h he => h he he)

lemma mem_nhds_zero_iff {U : Set (MvPowerSeries œÉ Œ±)} :
    U ‚àà nhds 0 ‚Üî ‚àÉ d, {b | b ‚àà basis œÉ Œ± d} ‚äÜ U := by
  refine ‚ü®?_ , fun ‚ü®d, hd‚ü© ‚Ü¶ Filter.sets_of_superset _ (basis_mem_nhds_zero œÉ Œ± d) hd‚ü©
  ¬∑ rw [nhds_pi, Filter.mem_pi]
    rintro ‚ü®D, hD, t, ht, ht'‚ü©
    use Finset.sup hD.toFinset id
    apply subset_trans _ ht'
    intros f hf e he
    rw [‚Üê coeff_apply Œ± f e, hf e (id_eq e ‚ñ∏ Finset.le_sup (hD.mem_toFinset.mpr he))]
    exact mem_of_mem_nhds (ht e)

/-- If the coefficient ring `Œ±` is endowed with the discrete topology, then the pointwise
topology on `MvPowerSeries œÉ Œ±)` agrees with the topology generated by `MvPowerSeries.basis`. -/
theorem topology_eq_ideals_basis_topology :
    MvPowerSeries.WithPiTopology.instTopologicalSpace Œ± =
      (ringSubgroupsBasis œÉ Œ±).toRingFilterBasis.topology := by
  rw [TopologicalAddGroup.ext_iff inferInstance inferInstance]
  ext s
  rw [mem_nhds_zero_iff, ((ringSubgroupsBasis œÉ Œ±).hasBasis_nhds  0).mem_iff]
  simp only [sub_zero, Submodule.mem_toAddSubgroup, true_and]

example : (ùìù (0 : MvPowerSeries œÉ Œ±)).HasBasis (fun _ ‚Ü¶ True) (fun d ‚Ü¶ (basis œÉ Œ± d)) := by
  apply Filter.HasBasis.mk
  intro s
  rw [mem_nhds_iff]
  constructor
  ¬∑ rintro ‚ü®t, hts, hopen, hmem‚ü©
    obtain ‚ü®d, hd‚ü© := (mem_nhds_zero_iff œÉ Œ±).mp
      (Filter.mem_of_superset  (IsOpen.mem_nhds hopen hmem) hts)
    refine ‚ü®d, ‚ü®by trivial, hd‚ü©‚ü©
  ¬∑ rintro ‚ü®d, _, hd‚ü©
    use basis œÉ Œ± d
    simp only [mem_coe, Submodule.zero_mem, and_true]
    exact ‚ü®hd, (basis œÉ Œ± d).toAddSubgroup.isOpen_of_mem_nhds (basis_mem_nhds_zero œÉ Œ± d)‚ü©

/-- If the coefficient ring `Œ±` is endowed with the discrete topology, then for every `d : œÉ ‚Üí‚ÇÄ ‚Ñï`,
`‚Üë(basis‚ÇÇ œÉ Œ± d) ‚àà ùìù (0 : MvPowerSeries œÉ Œ±)`. -/
theorem basis‚ÇÇ_mem_nhds_zero (d : œÉ ‚Üí‚ÇÄ ‚Ñï) :
    (basis‚ÇÇ œÉ Œ± d : Set (MvPowerSeries œÉ Œ±)) ‚àà ùìù 0 := by
  classical
  rw [nhds_pi, Filter.mem_pi]
  use Finset.Iic d, Finset.finite_toSet _, (fun e => if e ‚â§ d then {0} else univ)
  constructor
  ¬∑ intro e
    split_ifs
    ¬∑ simp only [nhds_discrete, Filter.mem_pure, mem_singleton_iff]
      rfl
    ¬∑ simp only [Filter.univ_mem]
  ¬∑ intro f
    simp only [Finset.coe_Iic, mem_pi, mem_Iic, mem_ite_univ_right, mem_singleton_iff, mem_coe]
    rw [mem_basis‚ÇÇ]
    exact forall_imp (fun e h he => h he he)

lemma mem_nhds_zero_iff‚ÇÇ {U : Set (MvPowerSeries œÉ Œ±)} :
    U ‚àà ùìù 0 ‚Üî ‚àÉ d, {b | b ‚àà basis‚ÇÇ œÉ Œ± d} ‚äÜ U := by
  refine ‚ü®?_ , fun ‚ü®d, hd‚ü© ‚Ü¶ Filter.sets_of_superset _ (basis‚ÇÇ_mem_nhds_zero œÉ Œ± d) hd‚ü©
  ¬∑ rw [nhds_pi, Filter.mem_pi]
    rintro ‚ü®D, hD, t, ht, ht'‚ü©
    use Finset.sup hD.toFinset id
    apply subset_trans _ ht'
    intros f hf e he
    simp only [‚Üê coeff_apply Œ± f e,
      sub_zero f ‚ñ∏ hf e (id_eq e ‚ñ∏ Finset.le_sup (hD.mem_toFinset.mpr he))]
    exact mem_of_mem_nhds (ht e)

/-- If the coefficient ring `Œ±` is endowed with the discrete topology, then the pointwise
topology on `MvPowerSeries œÉ Œ±)` agrees with the topology generated by `MvPowerSeries.basis`. -/
theorem topology_eq_ideals_basis_topology‚ÇÇ :
    MvPowerSeries.WithPiTopology.instTopologicalSpace Œ± =
      (ringSubgroupsBasis‚ÇÇ œÉ Œ±).toRingFilterBasis.topology := by
  rw [TopologicalAddGroup.ext_iff inferInstance inferInstance]
  ext s
  simp [mem_nhds_zero_iff‚ÇÇ, ((ringSubgroupsBasis‚ÇÇ œÉ Œ±).hasBasis_nhds  0).mem_iff]

example : (ùìù (0 : MvPowerSeries œÉ Œ±)).HasBasis (fun _ ‚Ü¶ True) (fun d ‚Ü¶ (basis œÉ Œ± d)) := by
  apply Filter.HasBasis.mk
  intro s
  rw [mem_nhds_iff]
  constructor
  ¬∑ rintro ‚ü®t, hts, hopen, hmem‚ü©
    obtain ‚ü®d, hd‚ü© := (mem_nhds_zero_iff œÉ Œ±).mp
      (Filter.mem_of_superset  (IsOpen.mem_nhds hopen hmem) hts)
    refine ‚ü®d, ‚ü®by trivial, hd‚ü©‚ü©
  ¬∑ rintro ‚ü®d, _, hd‚ü©
    use basis œÉ Œ± d
    simp only [mem_coe, Submodule.zero_mem, and_true]
    exact ‚ü®hd, (basis œÉ Œ± d).toAddSubgroup.isOpen_of_mem_nhds (basis_mem_nhds_zero œÉ Œ± d)‚ü©

theorem basis‚ÇÇ_hasBasis :
    (ùìù (0 : MvPowerSeries œÉ Œ±)).HasBasis (fun _ ‚Ü¶ True) (fun d ‚Ü¶ (basis‚ÇÇ œÉ Œ± d)) := by
  apply Filter.HasBasis.mk
  intro s
  simp [mem_nhds_zero_iff‚ÇÇ]

/-- The topology on `MvPowerSeries` is a linear topology when the ring of coefficients has
the discrete topology. -/
instance : LinearTopology (MvPowerSeries œÉ Œ±) :=
  LinearTopology.mk_of_twoSidedIdeal (basis‚ÇÇ_hasBasis œÉ Œ±)

end DiscreteTopology

end MvPowerSeries
