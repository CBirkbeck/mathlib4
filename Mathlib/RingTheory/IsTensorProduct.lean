/-
Copyright (c) 2022 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import Mathlib.RingTheory.TensorProduct
import Mathlib.Algebra.Module.ULift

#align_import ring_theory.is_tensor_product from "leanprover-community/mathlib"@"c4926d76bb9c5a4a62ed2f03d998081786132105"

/-!
# The characteristic predicate of tensor product

## Main definitions

- `IsTensorProduct`: A predicate on `f : M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ ‚Üí‚Çó[R] M` expressing that `f` realizes `M` as
  the tensor product of `M‚ÇÅ ‚äó[R] M‚ÇÇ`. This is defined by requiring the lift `M‚ÇÅ ‚äó[R] M‚ÇÇ ‚Üí M` to be
  bijective.
- `IsBaseChange`: A predicate on an `R`-algebra `S` and a map `f : M ‚Üí‚Çó[R] N` with `N` being an
  `S`-module, expressing that `f` realizes `N` as the base change of `M` along `R ‚Üí S`.
- `Algebra.IsPushout`: A predicate on the following diagram of scalar towers
  ```
    R  ‚Üí  S
    ‚Üì     ‚Üì
    R' ‚Üí  S'
  ```
    asserting that is a pushout diagram (i.e. `S' = S ‚äó[R] R'`)

## Main results
- `TensorProduct.isBaseChange`: `S ‚äó[R] M` is the base change of `M` along `R ‚Üí S`.

-/


universe u v‚ÇÅ v‚ÇÇ v‚ÇÉ v‚ÇÑ

open TensorProduct

section IsTensorProduct

variable {R : Type*} [CommRing R]

variable {M‚ÇÅ M‚ÇÇ M M' : Type*}

variable [AddCommMonoid M‚ÇÅ] [AddCommMonoid M‚ÇÇ] [AddCommMonoid M] [AddCommMonoid M']

variable [Module R M‚ÇÅ] [Module R M‚ÇÇ] [Module R M] [Module R M']

variable (f : M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ ‚Üí‚Çó[R] M)

variable {N‚ÇÅ N‚ÇÇ N : Type*} [AddCommMonoid N‚ÇÅ] [AddCommMonoid N‚ÇÇ] [AddCommMonoid N]

variable [Module R N‚ÇÅ] [Module R N‚ÇÇ] [Module R N]

variable {g : N‚ÇÅ ‚Üí‚Çó[R] N‚ÇÇ ‚Üí‚Çó[R] N}

/-- Given a bilinear map `f : M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ ‚Üí‚Çó[R] M`, `IsTensorProduct f` means that
`M` is the tensor product of `M‚ÇÅ` and `M‚ÇÇ` via `f`.
This is defined by requiring the lift `M‚ÇÅ ‚äó[R] M‚ÇÇ ‚Üí M` to be bijective.
-/
def IsTensorProduct : Prop :=
  Function.Bijective (TensorProduct.lift f)
#align is_tensor_product IsTensorProduct

variable (R M N) {f}

theorem TensorProduct.isTensorProduct : IsTensorProduct (TensorProduct.mk R M N) := by
  delta IsTensorProduct
  -- ‚ä¢ Function.Bijective ‚Üë(lift (mk R M N))
  convert_to Function.Bijective (LinearMap.id : M ‚äó[R] N ‚Üí‚Çó[R] M ‚äó[R] N) using 2
  -- ‚ä¢ lift (mk R M N) = LinearMap.id
  ¬∑ apply TensorProduct.ext'
    -- ‚ä¢ ‚àÄ (x : M) (y : N), ‚Üë(lift (mk R M N)) (x ‚äó‚Çú[R] y) = ‚ÜëLinearMap.id (x ‚äó‚Çú[R] y)
    simp
    -- üéâ no goals
  ¬∑ exact Function.bijective_id
    -- üéâ no goals
#align tensor_product.is_tensor_product TensorProduct.isTensorProduct

variable {R M N}

/-- If `M` is the tensor product of `M‚ÇÅ` and `M‚ÇÇ`, it is linearly equivalent to `M‚ÇÅ ‚äó[R] M‚ÇÇ`. -/
@[simps! apply]
noncomputable def IsTensorProduct.equiv (h : IsTensorProduct f) : M‚ÇÅ ‚äó[R] M‚ÇÇ ‚âÉ‚Çó[R] M :=
  LinearEquiv.ofBijective _ h
#align is_tensor_product.equiv IsTensorProduct.equiv

@[simp]
theorem IsTensorProduct.equiv_toLinearMap (h : IsTensorProduct f) :
    h.equiv.toLinearMap = TensorProduct.lift f :=
  rfl
#align is_tensor_product.equiv_to_linear_map IsTensorProduct.equiv_toLinearMap

@[simp]
theorem IsTensorProduct.equiv_symm_apply (h : IsTensorProduct f) (x‚ÇÅ : M‚ÇÅ) (x‚ÇÇ : M‚ÇÇ) :
    h.equiv.symm (f x‚ÇÅ x‚ÇÇ) = x‚ÇÅ ‚äó‚Çú x‚ÇÇ := by
  apply h.equiv.injective
  -- ‚ä¢ ‚Üë(equiv h) (‚Üë(LinearEquiv.symm (equiv h)) (‚Üë(‚Üëf x‚ÇÅ) x‚ÇÇ)) = ‚Üë(equiv h) (x‚ÇÅ ‚äó‚Çú ‚Ä¶
  refine' (h.equiv.apply_symm_apply _).trans _
  -- ‚ä¢ ‚Üë(‚Üëf x‚ÇÅ) x‚ÇÇ = ‚Üë(equiv h) (x‚ÇÅ ‚äó‚Çú[R] x‚ÇÇ)
  simp
  -- üéâ no goals
#align is_tensor_product.equiv_symm_apply IsTensorProduct.equiv_symm_apply

/-- If `M` is the tensor product of `M‚ÇÅ` and `M‚ÇÇ`, we may lift a bilinear map `M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ ‚Üí‚Çó[R] M'`
to a `M ‚Üí‚Çó[R] M'`. -/
noncomputable def IsTensorProduct.lift (h : IsTensorProduct f) (f' : M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ ‚Üí‚Çó[R] M') :
    M ‚Üí‚Çó[R] M' :=
  (TensorProduct.lift f').comp h.equiv.symm.toLinearMap
#align is_tensor_product.lift IsTensorProduct.lift

theorem IsTensorProduct.lift_eq (h : IsTensorProduct f) (f' : M‚ÇÅ ‚Üí‚Çó[R] M‚ÇÇ ‚Üí‚Çó[R] M') (x‚ÇÅ : M‚ÇÅ)
    (x‚ÇÇ : M‚ÇÇ) : h.lift f' (f x‚ÇÅ x‚ÇÇ) = f' x‚ÇÅ x‚ÇÇ := by
  delta IsTensorProduct.lift
  -- ‚ä¢ ‚Üë(LinearMap.comp (TensorProduct.lift f') ‚Üë(LinearEquiv.symm (equiv h))) (‚Üë(‚Üë ‚Ä¶
  simp
  -- üéâ no goals
#align is_tensor_product.lift_eq IsTensorProduct.lift_eq

/-- The tensor product of a pair of linear maps between modules. -/
noncomputable def IsTensorProduct.map (hf : IsTensorProduct f) (hg : IsTensorProduct g)
    (i‚ÇÅ : M‚ÇÅ ‚Üí‚Çó[R] N‚ÇÅ) (i‚ÇÇ : M‚ÇÇ ‚Üí‚Çó[R] N‚ÇÇ) : M ‚Üí‚Çó[R] N :=
  hg.equiv.toLinearMap.comp ((TensorProduct.map i‚ÇÅ i‚ÇÇ).comp hf.equiv.symm.toLinearMap)
#align is_tensor_product.map IsTensorProduct.map

theorem IsTensorProduct.map_eq (hf : IsTensorProduct f) (hg : IsTensorProduct g) (i‚ÇÅ : M‚ÇÅ ‚Üí‚Çó[R] N‚ÇÅ)
    (i‚ÇÇ : M‚ÇÇ ‚Üí‚Çó[R] N‚ÇÇ) (x‚ÇÅ : M‚ÇÅ) (x‚ÇÇ : M‚ÇÇ) : hf.map hg i‚ÇÅ i‚ÇÇ (f x‚ÇÅ x‚ÇÇ) = g (i‚ÇÅ x‚ÇÅ) (i‚ÇÇ x‚ÇÇ) := by
  delta IsTensorProduct.map
  -- ‚ä¢ ‚Üë(LinearMap.comp (‚Üë(equiv hg)) (LinearMap.comp (TensorProduct.map i‚ÇÅ i‚ÇÇ) ‚Üë(L ‚Ä¶
  simp
  -- üéâ no goals
#align is_tensor_product.map_eq IsTensorProduct.map_eq

theorem IsTensorProduct.inductionOn (h : IsTensorProduct f) {C : M ‚Üí Prop} (m : M) (h0 : C 0)
    (htmul : ‚àÄ x y, C (f x y)) (hadd : ‚àÄ x y, C x ‚Üí C y ‚Üí C (x + y)) : C m := by
  rw [‚Üê h.equiv.right_inv m]
  -- ‚ä¢ C (AddHom.toFun (‚Üë(equiv h)).toAddHom (LinearEquiv.invFun (equiv h) m))
  generalize h.equiv.invFun m = y
  -- ‚ä¢ C (AddHom.toFun (‚Üë(equiv h)).toAddHom y)
  change C (TensorProduct.lift f y)
  -- ‚ä¢ C (‚Üë(TensorProduct.lift f) y)
  induction y using TensorProduct.induction_on with
  | zero => rwa [map_zero]
  | tmul _ _ =>
    rw [TensorProduct.lift.tmul]
    apply htmul
  | add _ _ _ _ =>
    rw [map_add]
    apply hadd <;> assumption
#align is_tensor_product.induction_on IsTensorProduct.inductionOn

end IsTensorProduct

section IsBaseChange

variable {R : Type*} {M : Type v‚ÇÅ} {N : Type v‚ÇÇ} (S : Type v‚ÇÉ)

variable [AddCommMonoid M] [AddCommMonoid N] [CommRing R]

variable [CommRing S] [Algebra R S] [Module R M] [Module R N] [Module S N] [IsScalarTower R S N]

variable (f : M ‚Üí‚Çó[R] N)

/-- Given an `R`-algebra `S` and an `R`-module `M`, an `S`-module `N` together with a map
`f : M ‚Üí‚Çó[R] N` is the base change of `M` to `S` if the map `S √ó M ‚Üí N, (s, m) ‚Ü¶ s ‚Ä¢ f m` is the
tensor product. -/
def IsBaseChange : Prop :=
  IsTensorProduct
    (((Algebra.linearMap S <| Module.End S (M ‚Üí‚Çó[R] N)).flip f).restrictScalars R)
#align is_base_change IsBaseChange

-- Porting note: split `variable`
variable {S f}
variable (h : IsBaseChange S f)

variable {P Q : Type*} [AddCommMonoid P] [Module R P]

variable [AddCommMonoid Q] [Module S Q]

section

variable [Module R Q] [IsScalarTower R S Q]

/-- Suppose `f : M ‚Üí‚Çó[R] N` is the base change of `M` along `R ‚Üí S`. Then any `R`-linear map from
`M` to an `S`-module factors through `f`. -/
noncomputable nonrec def IsBaseChange.lift (g : M ‚Üí‚Çó[R] Q) : N ‚Üí‚Çó[S] Q :=
  { h.lift
      (((Algebra.linearMap S <| Module.End S (M ‚Üí‚Çó[R] Q)).flip g).restrictScalars R) with
    map_smul' := fun r x => by
      let F := ((Algebra.linearMap S <| Module.End S (M ‚Üí‚Çó[R] Q)).flip g).restrictScalars R
      -- ‚ä¢ AddHom.toFun src‚úù.toAddHom (r ‚Ä¢ x) = ‚Üë(RingHom.id S) r ‚Ä¢ AddHom.toFun src‚úù.t ‚Ä¶
      have hF : ‚àÄ (s : S) (m : M), h.lift F (s ‚Ä¢ f m) = s ‚Ä¢ g m := h.lift_eq F
      -- ‚ä¢ AddHom.toFun src‚úù.toAddHom (r ‚Ä¢ x) = ‚Üë(RingHom.id S) r ‚Ä¢ AddHom.toFun src‚úù.t ‚Ä¶
      change h.lift F (r ‚Ä¢ x) = r ‚Ä¢ h.lift F x
      -- ‚ä¢ ‚Üë(IsTensorProduct.lift h F) (r ‚Ä¢ x) = r ‚Ä¢ ‚Üë(IsTensorProduct.lift h F) x
      apply h.inductionOn x
      ¬∑ rw [smul_zero, map_zero, smul_zero]
        -- üéâ no goals
      ¬∑ intro s m
        -- ‚ä¢ ‚Üë(IsTensorProduct.lift h F) (r ‚Ä¢ ‚Üë(‚Üë(‚ÜëR (‚Üë(LinearMap.flip (Algebra.linearMap ‚Ä¶
        change h.lift F (r ‚Ä¢ s ‚Ä¢ f m) = r ‚Ä¢ h.lift F (s ‚Ä¢ f m)
        -- ‚ä¢ ‚Üë(IsTensorProduct.lift h F) (r ‚Ä¢ s ‚Ä¢ ‚Üëf m) = r ‚Ä¢ ‚Üë(IsTensorProduct.lift h F) ‚Ä¶
        rw [‚Üê mul_smul, hF, hF]
        -- ‚ä¢ (r * s) ‚Ä¢ ‚Üëg m = r ‚Ä¢ s ‚Ä¢ ‚Üëg m
        rw [mul_smul] -- Porting note: this line does nothing
        -- ‚ä¢ (r * s) ‚Ä¢ ‚Üëg m = r ‚Ä¢ s ‚Ä¢ ‚Üëg m
        apply mul_smul
        -- üéâ no goals
      ¬∑ intro x‚ÇÅ x‚ÇÇ e‚ÇÅ e‚ÇÇ
        -- ‚ä¢ ‚Üë(IsTensorProduct.lift h F) (r ‚Ä¢ (x‚ÇÅ + x‚ÇÇ)) = r ‚Ä¢ ‚Üë(IsTensorProduct.lift h F ‚Ä¶
        rw [map_add, smul_add, map_add, smul_add, e‚ÇÅ, e‚ÇÇ] }
        -- üéâ no goals
#align is_base_change.lift IsBaseChange.lift

nonrec theorem IsBaseChange.lift_eq (g : M ‚Üí‚Çó[R] Q) (x : M) : h.lift g (f x) = g x := by
  have hF : ‚àÄ (s : S) (m : M), h.lift g (s ‚Ä¢ f m) = s ‚Ä¢ g m := h.lift_eq _
  -- ‚ä¢ ‚Üë(lift h g) (‚Üëf x) = ‚Üëg x
  convert hF 1 x <;> rw [one_smul]
  -- ‚ä¢ ‚Üëf x = 1 ‚Ä¢ ‚Üëf x
                     -- üéâ no goals
                     -- üéâ no goals
#align is_base_change.lift_eq IsBaseChange.lift_eq

theorem IsBaseChange.lift_comp (g : M ‚Üí‚Çó[R] Q) : ((h.lift g).restrictScalars R).comp f = g :=
  LinearMap.ext (h.lift_eq g)
#align is_base_change.lift_comp IsBaseChange.lift_comp

end

@[elab_as_elim]
nonrec theorem IsBaseChange.inductionOn (x : N) (P : N ‚Üí Prop) (h‚ÇÅ : P 0) (h‚ÇÇ : ‚àÄ m : M, P (f m))
    (h‚ÇÉ : ‚àÄ (s : S) (n), P n ‚Üí P (s ‚Ä¢ n)) (h‚ÇÑ : ‚àÄ n‚ÇÅ n‚ÇÇ, P n‚ÇÅ ‚Üí P n‚ÇÇ ‚Üí P (n‚ÇÅ + n‚ÇÇ)) : P x :=
  h.inductionOn x h‚ÇÅ (fun _ _ => h‚ÇÉ _ _ (h‚ÇÇ _)) h‚ÇÑ
#align is_base_change.induction_on IsBaseChange.inductionOn

theorem IsBaseChange.algHom_ext (g‚ÇÅ g‚ÇÇ : N ‚Üí‚Çó[S] Q) (e : ‚àÄ x, g‚ÇÅ (f x) = g‚ÇÇ (f x)) : g‚ÇÅ = g‚ÇÇ := by
  ext x
  -- ‚ä¢ ‚Üëg‚ÇÅ x = ‚Üëg‚ÇÇ x
  refine h.inductionOn x ?_ ?_ ?_ ?_
  ¬∑ rw [map_zero, map_zero]
    -- üéâ no goals
  ¬∑ assumption
    -- üéâ no goals
  ¬∑ intro s n e'
    -- ‚ä¢ ‚Üëg‚ÇÅ (s ‚Ä¢ n) = ‚Üëg‚ÇÇ (s ‚Ä¢ n)
    rw [g‚ÇÅ.map_smul, g‚ÇÇ.map_smul, e']
    -- üéâ no goals
  ¬∑ intro x y e‚ÇÅ e‚ÇÇ
    -- ‚ä¢ ‚Üëg‚ÇÅ (x + y) = ‚Üëg‚ÇÇ (x + y)
    rw [map_add, map_add, e‚ÇÅ, e‚ÇÇ]
    -- üéâ no goals
#align is_base_change.alg_hom_ext IsBaseChange.algHom_ext

theorem IsBaseChange.algHom_ext' [Module R Q] [IsScalarTower R S Q] (g‚ÇÅ g‚ÇÇ : N ‚Üí‚Çó[S] Q)
    (e : (g‚ÇÅ.restrictScalars R).comp f = (g‚ÇÇ.restrictScalars R).comp f) : g‚ÇÅ = g‚ÇÇ :=
  h.algHom_ext g‚ÇÅ g‚ÇÇ (LinearMap.congr_fun e)
#align is_base_change.alg_hom_ext' IsBaseChange.algHom_ext'

variable (R M N S)

theorem TensorProduct.isBaseChange : IsBaseChange S (TensorProduct.mk R S M 1) := by
  delta IsBaseChange
  -- ‚ä¢ IsTensorProduct (‚ÜëR (‚Üë(LinearMap.flip (Algebra.linearMap S (Module.End S (M  ‚Ä¶
  convert TensorProduct.isTensorProduct R S M using 1
  -- ‚ä¢ ‚ÜëR (‚Üë(LinearMap.flip (Algebra.linearMap S (Module.End S (M ‚Üí‚Çó[R] S ‚äó[R] M))) ‚Ä¶
  ext s x
  -- ‚ä¢ ‚Üë(‚Üë(‚ÜëR (‚Üë(LinearMap.flip (Algebra.linearMap S (Module.End S (M ‚Üí‚Çó[R] S ‚äó[R]  ‚Ä¶
  change s ‚Ä¢ (1 : S) ‚äó‚Çú[R] x = s ‚äó‚Çú[R] x
  -- ‚ä¢ s ‚Ä¢ 1 ‚äó‚Çú[R] x = s ‚äó‚Çú[R] x
  rw [TensorProduct.smul_tmul']
  -- ‚ä¢ (s ‚Ä¢ 1) ‚äó‚Çú[R] x = s ‚äó‚Çú[R] x
  congr 1
  -- ‚ä¢ s ‚Ä¢ 1 = s
  exact mul_one _
  -- üéâ no goals
#align tensor_product.is_base_change TensorProduct.isBaseChange

variable {R M N S}

/-- The base change of `M` along `R ‚Üí S` is linearly equivalent to `S ‚äó[R] M`. -/
noncomputable nonrec def IsBaseChange.equiv : S ‚äó[R] M ‚âÉ‚Çó[S] N :=
  { h.equiv with
    map_smul' := fun r x => by
      change h.equiv (r ‚Ä¢ x) = r ‚Ä¢ h.equiv x
      -- ‚ä¢ ‚Üë(IsTensorProduct.equiv h) (r ‚Ä¢ x) = r ‚Ä¢ ‚Üë(IsTensorProduct.equiv h) x
      refine TensorProduct.induction_on x ?_ ?_ ?_
      ¬∑ rw [smul_zero, map_zero, smul_zero]
        -- üéâ no goals
      ¬∑ intro x y
        -- ‚ä¢ ‚Üë(IsTensorProduct.equiv h) (r ‚Ä¢ x ‚äó‚Çú[R] y) = r ‚Ä¢ ‚Üë(IsTensorProduct.equiv h)  ‚Ä¶
        -- Porting note: was simp [smul_tmul', Algebra.ofId_apply]
        simp only [Algebra.linearMap_apply, lift.tmul, smul_eq_mul,
          LinearMap.mul_apply, LinearMap.smul_apply, IsTensorProduct.equiv_apply,
          Module.algebraMap_end_apply, _root_.map_mul, smul_tmul', eq_self_iff_true,
          LinearMap.coe_restrictScalars, LinearMap.flip_apply]
      ¬∑ intro x y hx hy
        -- ‚ä¢ ‚Üë(IsTensorProduct.equiv h) (r ‚Ä¢ (x + y)) = r ‚Ä¢ ‚Üë(IsTensorProduct.equiv h) (x ‚Ä¶
        rw [map_add, smul_add, map_add, smul_add, hx, hy] }
        -- üéâ no goals
#align is_base_change.equiv IsBaseChange.equiv

theorem IsBaseChange.equiv_tmul (s : S) (m : M) : h.equiv (s ‚äó‚Çú m) = s ‚Ä¢ f m :=
  TensorProduct.lift.tmul s m
#align is_base_change.equiv_tmul IsBaseChange.equiv_tmul

theorem IsBaseChange.equiv_symm_apply (m : M) : h.equiv.symm (f m) = 1 ‚äó‚Çú m := by
  rw [h.equiv.symm_apply_eq, h.equiv_tmul, one_smul]
  -- üéâ no goals
#align is_base_change.equiv_symm_apply IsBaseChange.equiv_symm_apply

variable (f)

theorem IsBaseChange.of_lift_unique
    (h : ‚àÄ (Q : Type max v‚ÇÅ v‚ÇÇ v‚ÇÉ) [AddCommMonoid Q],
      ‚àÄ [Module R Q] [Module S Q], ‚àÄ [IsScalarTower R S Q],
        ‚àÄ g : M ‚Üí‚Çó[R] Q, ‚àÉ! g' : N ‚Üí‚Çó[S] Q, (g'.restrictScalars R).comp f = g) :
    IsBaseChange S f := by
  obtain ‚ü®g, hg, -‚ü© :=
    h (ULift.{v‚ÇÇ} <| S ‚äó[R] M)
      (ULift.moduleEquiv.symm.toLinearMap.comp <| TensorProduct.mk R S M 1)
  let f' : S ‚äó[R] M ‚Üí‚Çó[R] N :=
    TensorProduct.lift (((LinearMap.flip (AlgHom.toLinearMap (Algebra.ofId S
      (Module.End S (M ‚Üí‚Çó[R] N))))) f).restrictScalars R)
  change Function.Bijective f'
  -- ‚ä¢ Function.Bijective ‚Üëf'
  let f'' : S ‚äó[R] M ‚Üí‚Çó[S] N := by
    refine'
      { f' with
        toFun := f'
        map_smul' := fun s x =>
          TensorProduct.induction_on x _ (fun s' y => smul_assoc s s' _) fun x y hx hy => _ }
    ¬∑ dsimp; rw [map_zero, smul_zero, map_zero, smul_zero]
    ¬∑ dsimp at *; rw [smul_add, map_add, map_add, smul_add, hx, hy]
  simp_rw [FunLike.ext_iff, LinearMap.comp_apply, LinearMap.restrictScalars_apply] at hg
  -- ‚ä¢ Function.Bijective ‚Üëf'
  let fe : S ‚äó[R] M ‚âÉ‚Çó[S] N :=
    LinearEquiv.ofLinear f'' (ULift.moduleEquiv.toLinearMap.comp g) ?_ ?_
  ¬∑ exact fe.bijective
    -- üéâ no goals
  ¬∑ rw [‚Üê LinearMap.cancel_left (ULift.moduleEquiv : ULift.{max v‚ÇÅ v‚ÇÉ} N ‚âÉ‚Çó[S] N).symm.injective]
    -- ‚ä¢ LinearMap.comp (‚Üë(LinearEquiv.symm ULift.moduleEquiv)) (LinearMap.comp f'' ( ‚Ä¶
    refine' (h (ULift.{max v‚ÇÅ v‚ÇÉ} N) <| ULift.moduleEquiv.symm.toLinearMap.comp f).unique _ rfl
    -- ‚ä¢ LinearMap.comp (‚ÜëR (LinearMap.comp (‚Üë(LinearEquiv.symm ULift.moduleEquiv)) ( ‚Ä¶
    ext x
    -- ‚ä¢ (‚Üë(LinearMap.comp (‚ÜëR (LinearMap.comp (‚Üë(LinearEquiv.symm ULift.moduleEquiv) ‚Ä¶
    simp only [LinearMap.comp_apply, LinearMap.restrictScalars_apply, hg]
    -- ‚ä¢ (‚Üë‚Üë(LinearEquiv.symm ULift.moduleEquiv) (‚Üë{ toAddHom := { toFun := ‚Üë(TensorP ‚Ä¶
    apply one_smul
    -- üéâ no goals
  ¬∑ ext x
    -- ‚ä¢ ‚Üë(‚Üë(AlgebraTensorModule.curry (LinearMap.comp (LinearMap.comp (‚ÜëULift.module ‚Ä¶
    change (g <| (1 : S) ‚Ä¢ f x).down = _
    -- ‚ä¢ (‚Üëg (1 ‚Ä¢ ‚Üëf x)).down = ‚Üë(‚Üë(AlgebraTensorModule.curry LinearMap.id) 1) x
    rw [one_smul, hg]
    -- ‚ä¢ (‚Üë‚Üë(LinearEquiv.symm ULift.moduleEquiv) (‚Üë(‚Üë(mk R S M) 1) x)).down = ‚Üë(‚Üë(Alg ‚Ä¶
    rfl
    -- üéâ no goals
#align is_base_change.of_lift_unique IsBaseChange.of_lift_unique

variable {f}

theorem IsBaseChange.iff_lift_unique :
    IsBaseChange S f ‚Üî
      ‚àÄ (Q : Type max v‚ÇÅ v‚ÇÇ v‚ÇÉ) [AddCommMonoid Q],
        ‚àÄ [Module R Q] [Module S Q],
          ‚àÄ [IsScalarTower R S Q],
            ‚àÄ g : M ‚Üí‚Çó[R] Q, ‚àÉ! g' : N ‚Üí‚Çó[S] Q, (g'.restrictScalars R).comp f = g :=
  ‚ü®fun h => by
    intros Q _ _ _ _ g
    -- ‚ä¢ ‚àÉ! g', LinearMap.comp (‚ÜëR g') f = g
    exact ‚ü®h.lift g, h.lift_comp g, fun g' e => h.algHom_ext' _ _ (e.trans (h.lift_comp g).symm)‚ü©,
    -- üéâ no goals
    IsBaseChange.of_lift_unique f‚ü©
#align is_base_change.iff_lift_unique IsBaseChange.iff_lift_unique

theorem IsBaseChange.ofEquiv (e : M ‚âÉ‚Çó[R] N) : IsBaseChange R e.toLinearMap := by
  apply IsBaseChange.of_lift_unique
  -- ‚ä¢ ‚àÄ (Q : Type (max v‚ÇÅ v‚ÇÇ u_1)) [inst : AddCommMonoid Q] [inst_1 : Module R Q]  ‚Ä¶
  intro Q I‚ÇÅ I‚ÇÇ I‚ÇÉ I‚ÇÑ g
  -- ‚ä¢ ‚àÉ! g', LinearMap.comp (‚ÜëR g') ‚Üëe = g
  have : I‚ÇÇ = I‚ÇÉ := by
    ext r q
    show (by let _ := I‚ÇÇ; exact r ‚Ä¢ q) = (by let _ := I‚ÇÉ; exact r ‚Ä¢ q)
    dsimp
    rw [‚Üê one_smul R q, smul_smul, ‚Üê @smul_assoc _ _ _ (id _) (id _) (id _) I‚ÇÑ, smul_eq_mul,
      mul_one]
  cases this
  -- ‚ä¢ ‚àÉ! g', LinearMap.comp (‚ÜëR g') ‚Üëe = g
  refine'
    ‚ü®g.comp e.symm.toLinearMap, by
      ext
      simp, _‚ü©
  rintro y (rfl : _ = _)
  -- ‚ä¢ y = LinearMap.comp (LinearMap.comp (‚ÜëR y) ‚Üëe) ‚Üë(LinearEquiv.symm e)
  ext
  -- ‚ä¢ ‚Üëy x‚úù = ‚Üë(LinearMap.comp (LinearMap.comp (‚ÜëR y) ‚Üëe) ‚Üë(LinearEquiv.symm e)) x‚úù
  simp
  -- üéâ no goals
#align is_base_change.of_equiv IsBaseChange.ofEquiv

variable {T O : Type*} [CommRing T] [Algebra R T] [Algebra S T] [IsScalarTower R S T]

variable [AddCommMonoid O] [Module R O] [Module S O] [Module T O] [IsScalarTower S T O]

variable [IsScalarTower R S O] [IsScalarTower R T O]

theorem IsBaseChange.comp {f : M ‚Üí‚Çó[R] N} (hf : IsBaseChange S f) {g : N ‚Üí‚Çó[S] O}
    (hg : IsBaseChange T g) : IsBaseChange T ((g.restrictScalars R).comp f) := by
  apply IsBaseChange.of_lift_unique
  -- ‚ä¢ ‚àÄ (Q : Type (max v‚ÇÅ u_5 u_4)) [inst : AddCommMonoid Q] [inst_1 : Module R Q] ‚Ä¶
  intro Q _ _ _ _ i
  -- ‚ä¢ ‚àÉ! g', LinearMap.comp (‚ÜëR g') (LinearMap.comp (‚ÜëR g) f) = i
  letI := Module.compHom Q (algebraMap S T)
  -- ‚ä¢ ‚àÉ! g', LinearMap.comp (‚ÜëR g') (LinearMap.comp (‚ÜëR g) f) = i
  haveI : IsScalarTower S T Q :=
    ‚ü®fun x y z => by
      rw [Algebra.smul_def, mul_smul]
      rfl‚ü©
  have : IsScalarTower R S Q := by
    refine' ‚ü®fun x y z => _‚ü©
    change (IsScalarTower.toAlgHom R S T) (x ‚Ä¢ y) ‚Ä¢ z = x ‚Ä¢ algebraMap S T y ‚Ä¢ z
    rw [AlgHom.map_smul, smul_assoc]
    rfl
  refine'
    ‚ü®hg.lift (hf.lift i), by
      ext
      simp [IsBaseChange.lift_eq], _‚ü©
  rintro g' (e : _ = _)
  -- ‚ä¢ g' = lift hg (lift hf i)
  refine' hg.algHom_ext' _ _ (hf.algHom_ext' _ _ _)
  -- ‚ä¢ LinearMap.comp (‚ÜëR (LinearMap.comp (‚ÜëS g') g)) f = LinearMap.comp (‚ÜëR (Linea ‚Ä¶
  rw [IsBaseChange.lift_comp, IsBaseChange.lift_comp, ‚Üê e]
  -- ‚ä¢ LinearMap.comp (‚ÜëR (LinearMap.comp (‚ÜëS g') g)) f = LinearMap.comp (‚ÜëR g') (L ‚Ä¶
  ext
  -- ‚ä¢ ‚Üë(LinearMap.comp (‚ÜëR (LinearMap.comp (‚ÜëS g') g)) f) x‚úù = ‚Üë(LinearMap.comp (‚Üë ‚Ä¶
  rfl
  -- üéâ no goals
#align is_base_change.comp IsBaseChange.comp

variable {R' S' : Type*} [CommRing R'] [CommRing S']

variable [Algebra R R'] [Algebra S S'] [Algebra R' S'] [Algebra R S']

variable [IsScalarTower R R' S'] [IsScalarTower R S S']

open IsScalarTower (toAlgHom)

variable (R S R' S')

/-- A type-class stating that the following diagram of scalar towers
R  ‚Üí  S
‚Üì     ‚Üì
R' ‚Üí  S'
is a pushout diagram (i.e. `S' = S ‚äó[R] R'`)
-/
@[mk_iff]
class Algebra.IsPushout : Prop where
  out : IsBaseChange S (toAlgHom R R' S').toLinearMap
#align algebra.is_pushout Algebra.IsPushout

variable {R S R' S'}

@[symm]
theorem Algebra.IsPushout.symm (h : Algebra.IsPushout R S R' S') : Algebra.IsPushout R R' S S' := by
  let _ := (Algebra.TensorProduct.includeRight : R' ‚Üí‚Çê[R] S ‚äó R').toRingHom.toAlgebra
  -- ‚ä¢ IsPushout R R' S S'
  let e : R' ‚äó[R] S ‚âÉ‚Çó[R'] S' := by
    refine' { (_root_.TensorProduct.comm R R' S).trans <|
      h.1.equiv.restrictScalars R with map_smul' := _ }
    intro r x
    change
      h.1.equiv (TensorProduct.comm R R' S (r ‚Ä¢ x)) = r ‚Ä¢ h.1.equiv (TensorProduct.comm R R' S x)
    refine TensorProduct.induction_on x ?_ ?_ ?_
    ¬∑ simp only [smul_zero, map_zero]
    ¬∑ intro x y
      simp [smul_tmul', Algebra.smul_def, RingHom.algebraMap_toAlgebra, h.1.equiv_tmul]
      ring
    ¬∑ intro x y hx hy
      rw [map_add, map_add, smul_add, map_add, map_add, hx, hy, smul_add]
  have :
    (toAlgHom R S S').toLinearMap =
      (e.toLinearMap.restrictScalars R).comp (TensorProduct.mk R R' S 1) := by
    ext
    simp [h.1.equiv_tmul, Algebra.smul_def]
  constructor
  -- ‚ä¢ IsBaseChange R' (AlgHom.toLinearMap (toAlgHom R S S'))
  rw [this]
  -- ‚ä¢ IsBaseChange R' (LinearMap.comp (‚ÜëR ‚Üëe) (‚Üë(TensorProduct.mk R R' S) 1))
  exact (TensorProduct.isBaseChange R S R').comp (IsBaseChange.ofEquiv e)
  -- üéâ no goals
#align algebra.is_pushout.symm Algebra.IsPushout.symm

variable (R S R' S')

theorem Algebra.IsPushout.comm : Algebra.IsPushout R S R' S' ‚Üî Algebra.IsPushout R R' S S' :=
  ‚ü®Algebra.IsPushout.symm, Algebra.IsPushout.symm‚ü©
#align algebra.is_pushout.comm Algebra.IsPushout.comm

variable {R S R'}

attribute [local instance] Algebra.TensorProduct.rightAlgebra

instance TensorProduct.isPushout {R S T : Type*} [CommRing R] [CommRing S] [CommRing T]
    [Algebra R S] [Algebra R T] : Algebra.IsPushout R S T (TensorProduct R S T) :=
  ‚ü®TensorProduct.isBaseChange R T S‚ü©
#align tensor_product.is_pushout TensorProduct.isPushout

instance TensorProduct.isPushout' {R S T : Type*} [CommRing R] [CommRing S] [CommRing T]
    [Algebra R S] [Algebra R T] : Algebra.IsPushout R T S (TensorProduct R S T) :=
  Algebra.IsPushout.symm inferInstance
#align tensor_product.is_pushout' TensorProduct.isPushout'

/-- If `S' = S ‚äó[R] R'`, then any pair of `R`-algebra homomorphisms `f : S ‚Üí A` and `g : R' ‚Üí A`
such that `f x` and `g y` commutes for all `x, y` descends to a (unique) homomoprhism `S' ‚Üí A`.
-/
--@[simps (config := { isSimp := false }) apply] --Porting note: removed and added by hand
noncomputable def Algebra.pushoutDesc [H : Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]
    [Algebra R A] (f : S ‚Üí‚Çê[R] A) (g : R' ‚Üí‚Çê[R] A) (hf : ‚àÄ x y, f x * g y = g y * f x) :
    S' ‚Üí‚Çê[R] A := by
  letI := Module.compHom A f.toRingHom
  -- ‚ä¢ S' ‚Üí‚Çê[R] A
  haveI : IsScalarTower R S A :=
    { smul_assoc := fun r s a =>
        show f (r ‚Ä¢ s) * a = r ‚Ä¢ (f s * a) by rw [f.map_smul, smul_mul_assoc] }
  haveI : IsScalarTower S A A := { smul_assoc := fun r a b => mul_assoc _ _ _ }
  -- ‚ä¢ S' ‚Üí‚Çê[R] A
  have : ‚àÄ x, H.out.lift g.toLinearMap (algebraMap R' S' x) = g x := H.out.lift_eq _
  -- ‚ä¢ S' ‚Üí‚Çê[R] A
  refine' AlgHom.ofLinearMap ((H.out.lift g.toLinearMap).restrictScalars R) _ _
  -- ‚ä¢ ‚Üë(‚ÜëR (IsBaseChange.lift (_ : IsBaseChange S (AlgHom.toLinearMap (toAlgHom R  ‚Ä¶
  ¬∑ dsimp only [LinearMap.restrictScalars_apply]
    -- ‚ä¢ ‚Üë(IsBaseChange.lift (_ : IsBaseChange S (AlgHom.toLinearMap (toAlgHom R R' S ‚Ä¶
    rw [‚Üê (algebraMap R' S').map_one, this, g.map_one]
    -- üéâ no goals
  ¬∑ intro x y
    -- ‚ä¢ ‚Üë(‚ÜëR (IsBaseChange.lift (_ : IsBaseChange S (AlgHom.toLinearMap (toAlgHom R  ‚Ä¶
    refine H.out.inductionOn x ?_ ?_ ?_ ?_
    ¬∑ rw [zero_mul, map_zero, zero_mul]
      -- üéâ no goals
    rotate_left
    ¬∑ intro s s' e
      -- ‚ä¢ ‚Üë(‚ÜëR (IsBaseChange.lift (_ : IsBaseChange S (AlgHom.toLinearMap (toAlgHom R  ‚Ä¶
      dsimp only [LinearMap.restrictScalars_apply] at e ‚ä¢
      -- ‚ä¢ ‚Üë(IsBaseChange.lift (_ : IsBaseChange S (AlgHom.toLinearMap (toAlgHom R R' S ‚Ä¶
      rw [LinearMap.map_smul, smul_mul_assoc, LinearMap.map_smul, e, smul_mul_assoc]
      -- üéâ no goals
    ¬∑ intro s s' e‚ÇÅ e‚ÇÇ
      -- ‚ä¢ ‚Üë(‚ÜëR (IsBaseChange.lift (_ : IsBaseChange S (AlgHom.toLinearMap (toAlgHom R  ‚Ä¶
      dsimp only [LinearMap.restrictScalars_apply] at e‚ÇÅ e‚ÇÇ ‚ä¢
      -- ‚ä¢ ‚Üë(IsBaseChange.lift (_ : IsBaseChange S (AlgHom.toLinearMap (toAlgHom R R' S ‚Ä¶
      rw [add_mul, map_add, map_add, add_mul, e‚ÇÅ, e‚ÇÇ]
      -- üéâ no goals
    intro x
    -- ‚ä¢ ‚Üë(‚ÜëR (IsBaseChange.lift (_ : IsBaseChange S (AlgHom.toLinearMap (toAlgHom R  ‚Ä¶
    dsimp
    -- ‚ä¢ ‚Üë(IsBaseChange.lift (_ : IsBaseChange S (AlgHom.toLinearMap (toAlgHom R R' S ‚Ä¶
    rw [this]
    -- ‚ä¢ ‚Üë(IsBaseChange.lift (_ : IsBaseChange S (AlgHom.toLinearMap (toAlgHom R R' S ‚Ä¶
    refine H.out.inductionOn y ?_ ?_ ?_ ?_
    ¬∑ rw [mul_zero, map_zero, mul_zero]
      -- üéâ no goals
    ¬∑ intro y
      -- ‚ä¢ ‚Üë(IsBaseChange.lift (_ : IsBaseChange S (AlgHom.toLinearMap (toAlgHom R R' S ‚Ä¶
      dsimp
      -- ‚ä¢ ‚Üë(IsBaseChange.lift (_ : IsBaseChange S (AlgHom.toLinearMap (toAlgHom R R' S ‚Ä¶
      rw [‚Üê _root_.map_mul, this, this, _root_.map_mul]
      -- üéâ no goals
    ¬∑ intro s s' e
      -- ‚ä¢ ‚Üë(IsBaseChange.lift (_ : IsBaseChange S (AlgHom.toLinearMap (toAlgHom R R' S ‚Ä¶
      rw [mul_comm, smul_mul_assoc, LinearMap.map_smul, LinearMap.map_smul, mul_comm, e]
      -- ‚ä¢ s ‚Ä¢ (‚Üëg x * ‚Üë(IsBaseChange.lift (_ : IsBaseChange S (AlgHom.toLinearMap (toA ‚Ä¶
      change f s * (g x * _) = g x * (f s * _)
      -- ‚ä¢ ‚Üëf s * (‚Üëg x * ‚Üë(IsBaseChange.lift (_ : IsBaseChange S (AlgHom.toLinearMap ( ‚Ä¶
      rw [‚Üê mul_assoc, ‚Üê mul_assoc, hf]
      -- üéâ no goals
    ¬∑ intro s s' e‚ÇÅ e‚ÇÇ
      -- ‚ä¢ ‚Üë(IsBaseChange.lift (_ : IsBaseChange S (AlgHom.toLinearMap (toAlgHom R R' S ‚Ä¶
      rw [mul_add, map_add, map_add, mul_add, e‚ÇÅ, e‚ÇÇ]
      -- üéâ no goals
#align algebra.pushout_desc Algebra.pushoutDesc

--Porting note: was generated by `simps` attribute in Lean3.
theorem Algebra.pushoutDesc_apply [H : Algebra.IsPushout R S R' S'] {A : Type*}
    [Semiring A] [Algebra R A] (f : S ‚Üí‚Çê[R] A) (g : R' ‚Üí‚Çê[R] A) (hf : ‚àÄ x y, f x * g y = g y * f x)
    (s : S') : by
  letI := Module.compHom A f.toRingHom
  -- ‚ä¢ Sort ?u.1234021
  haveI : IsScalarTower R S A :=
    { smul_assoc := fun r s a =>
      show f (r ‚Ä¢ s) * a = r ‚Ä¢ (f s * a) by rw [f.map_smul, smul_mul_assoc] }
  exact Algebra.pushoutDesc S' f g hf s = H.out.lift g.toLinearMap s := rfl
  -- üéâ no goals

@[simp]
theorem Algebra.pushoutDesc_left [H : Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]
    [Algebra R A] (f : S ‚Üí‚Çê[R] A) (g : R' ‚Üí‚Çê[R] A) (H) (x : S) :
    Algebra.pushoutDesc S' f g H (algebraMap S S' x) = f x := by
  letI := Module.compHom A f.toRingHom
  -- ‚ä¢ ‚Üë(pushoutDesc S' f g H) (‚Üë(algebraMap S S') x) = ‚Üëf x
  haveI : IsScalarTower R S A :=
    { smul_assoc := fun r s a =>
        show f (r ‚Ä¢ s) * a = r ‚Ä¢ (f s * a) by rw [f.map_smul, smul_mul_assoc] }
  haveI : IsScalarTower S A A := { smul_assoc := fun r a b => mul_assoc _ _ _ }
  -- ‚ä¢ ‚Üë(pushoutDesc S' f g H) (‚Üë(algebraMap S S') x) = ‚Üëf x
  rw [Algebra.algebraMap_eq_smul_one, pushoutDesc_apply, map_smul, ‚Üê
    Algebra.pushoutDesc_apply S' f g H, _root_.map_one]
  exact mul_one (f x)
  -- üéâ no goals
#align algebra.pushout_desc_left Algebra.pushoutDesc_left

theorem Algebra.lift_algHom_comp_left [Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]
    [Algebra R A] (f : S ‚Üí‚Çê[R] A) (g : R' ‚Üí‚Çê[R] A) (H) :
    (Algebra.pushoutDesc S' f g H).comp (toAlgHom R S S') = f :=
  AlgHom.ext fun x => (Algebra.pushoutDesc_left S' f g H x : _)
#align algebra.lift_alg_hom_comp_left Algebra.lift_algHom_comp_left

@[simp]
theorem Algebra.pushoutDesc_right [H : Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]
    [Algebra R A] (f : S ‚Üí‚Çê[R] A) (g : R' ‚Üí‚Çê[R] A) (H) (x : R') :
    Algebra.pushoutDesc S' f g H (algebraMap R' S' x) = g x :=
  letI := Module.compHom A f.toRingHom
  haveI : IsScalarTower R S A :=
    { smul_assoc := fun r s a =>
        show f (r ‚Ä¢ s) * a = r ‚Ä¢ (f s * a) by rw [f.map_smul, smul_mul_assoc] }
                                              -- üéâ no goals
  IsBaseChange.lift_eq _ _ _
#align algebra.pushout_desc_right Algebra.pushoutDesc_right

theorem Algebra.lift_algHom_comp_right [Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]
    [Algebra R A] (f : S ‚Üí‚Çê[R] A) (g : R' ‚Üí‚Çê[R] A) (H) :
    (Algebra.pushoutDesc S' f g H).comp (toAlgHom R R' S') = g :=
  AlgHom.ext fun x => (Algebra.pushoutDesc_right S' f g H x : _)
#align algebra.lift_alg_hom_comp_right Algebra.lift_algHom_comp_right

@[ext]
theorem Algebra.IsPushout.algHom_ext [H : Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]
    [Algebra R A] {f g : S' ‚Üí‚Çê[R] A} (h‚ÇÅ : f.comp (toAlgHom R R' S') = g.comp (toAlgHom R R' S'))
    (h‚ÇÇ : f.comp (toAlgHom R S S') = g.comp (toAlgHom R S S')) : f = g := by
  ext x
  -- ‚ä¢ ‚Üëf x = ‚Üëg x
  refine H.1.inductionOn x ?_ ?_ ?_ ?_
  ¬∑ simp only [map_zero]
    -- üéâ no goals
  ¬∑ exact AlgHom.congr_fun h‚ÇÅ
    -- üéâ no goals
  ¬∑ intro s s' e
    -- ‚ä¢ ‚Üëf (s ‚Ä¢ s') = ‚Üëg (s ‚Ä¢ s')
    rw [Algebra.smul_def, f.map_mul, g.map_mul, e]
    -- ‚ä¢ ‚Üëf (‚Üë(algebraMap S S') s) * ‚Üëg s' = ‚Üëg (‚Üë(algebraMap S S') s) * ‚Üëg s'
    congr 1
    -- ‚ä¢ ‚Üëf (‚Üë(algebraMap S S') s) = ‚Üëg (‚Üë(algebraMap S S') s)
    exact (AlgHom.congr_fun h‚ÇÇ s : _)
    -- üéâ no goals
  ¬∑ intro s‚ÇÅ s‚ÇÇ e‚ÇÅ e‚ÇÇ
    -- ‚ä¢ ‚Üëf (s‚ÇÅ + s‚ÇÇ) = ‚Üëg (s‚ÇÅ + s‚ÇÇ)
    rw [map_add, map_add, e‚ÇÅ, e‚ÇÇ]
    -- üéâ no goals
#align algebra.is_pushout.alg_hom_ext Algebra.IsPushout.algHom_ext

end IsBaseChange
