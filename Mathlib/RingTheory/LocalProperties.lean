/-
Copyright (c) 2021 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import Mathlib.RingTheory.FiniteType
import Mathlib.RingTheory.Localization.AtPrime
import Mathlib.RingTheory.Localization.Away.Basic
import Mathlib.RingTheory.Localization.Integer
import Mathlib.RingTheory.Localization.Submodule
import Mathlib.RingTheory.Nilpotent
import Mathlib.RingTheory.RingHomProperties

#align_import ring_theory.local_properties from "leanprover-community/mathlib"@"a7c017d750512a352b623b1824d75da5998457d0"

/-!
# Local properties of commutative rings

In this file, we provide the proofs of various local properties.

## Naming Conventions

* `localization_P` : `P` holds for `S‚Åª¬πR` if `P` holds for `R`.
* `P_of_localization_maximal` : `P` holds for `R` if `P` holds for `R‚Çò` for all maximal `m`.
* `P_of_localization_prime` : `P` holds for `R` if `P` holds for `R‚Çò` for all prime `m`.
* `P_ofLocalizationSpan` : `P` holds for `R` if given a spanning set `{f·µ¢}`, `P` holds for all
  `R_{f·µ¢}`.

## Main results

The following properties are covered:

* The triviality of an ideal or an element:
  `ideal_eq_bot_of_localization`, `eq_zero_of_localization`
* `isReduced` : `localization_isReduced`, `isReduced_of_localization_maximal`.
* `finite`: `localization_finite`, `finite_ofLocalizationSpan`
* `finiteType`: `localization_finiteType`, `finiteType_ofLocalizationSpan`

-/

local macro_rules | `($x ^ $y) => `(HPow.hPow $x $y) -- Porting note: See issue lean4#2220

open scoped Pointwise Classical BigOperators

universe u

variable {R S : Type u} [CommRing R] [CommRing S] (M : Submonoid R)

variable (N : Submonoid S) (R' S' : Type u) [CommRing R'] [CommRing S'] (f : R ‚Üí+* S)

variable [Algebra R R'] [Algebra S S']

section Properties

section CommRing

variable (P : ‚àÄ (R : Type u) [CommRing R], Prop)

/-- A property `P` of comm rings is said to be preserved by localization
  if `P` holds for `M‚Åª¬πR` whenever `P` holds for `R`. -/
def LocalizationPreserves : Prop :=
  ‚àÄ {R : Type u} [hR : CommRing R] (M : Submonoid R) (S : Type u) [hS : CommRing S] [Algebra R S]
    [IsLocalization M S], @P R hR ‚Üí @P S hS
#align localization_preserves LocalizationPreserves

/-- A property `P` of comm rings satisfies `OfLocalizationMaximal`
  if `P` holds for `R` whenever `P` holds for `R‚Çò` for all maximal ideal `m`. -/
def OfLocalizationMaximal : Prop :=
  ‚àÄ (R : Type u) [CommRing R],
    (‚àÄ (J : Ideal R) (_ : J.IsMaximal), P (Localization.AtPrime J)) ‚Üí P R
#align of_localization_maximal OfLocalizationMaximal

end CommRing

section RingHom

variable (P : ‚àÄ {R S : Type u} [CommRing R] [CommRing S] (_ : R ‚Üí+* S), Prop)

/-- A property `P` of ring homs is said to be preserved by localization
 if `P` holds for `M‚Åª¬πR ‚Üí+* M‚Åª¬πS` whenever `P` holds for `R ‚Üí+* S`. -/
def RingHom.LocalizationPreserves :=
  ‚àÄ ‚¶ÉR S : Type u‚¶Ñ [CommRing R] [CommRing S] (f : R ‚Üí+* S) (M : Submonoid R) (R' S' : Type u)
    [CommRing R'] [CommRing S'] [Algebra R R'] [Algebra S S'] [IsLocalization M R']
    [IsLocalization (M.map f) S'],
    P f ‚Üí P (IsLocalization.map S' f (Submonoid.le_comap_map M) : R' ‚Üí+* S')
#align ring_hom.localization_preserves RingHom.LocalizationPreserves

/-- A property `P` of ring homs satisfies `RingHom.OfLocalizationFiniteSpan`
if `P` holds for `R ‚Üí+* S` whenever there exists a finite set `{ r }` that spans `R` such that
`P` holds for `R·µ£ ‚Üí+* S·µ£`.

Note that this is equivalent to `RingHom.OfLocalizationSpan` via
`RingHom.ofLocalizationSpan_iff_finite`, but this is easier to prove. -/
def RingHom.OfLocalizationFiniteSpan :=
  ‚àÄ ‚¶ÉR S : Type u‚¶Ñ [CommRing R] [CommRing S] (f : R ‚Üí+* S) (s : Finset R)
    (_ : Ideal.span (s : Set R) = ‚ä§) (_ : ‚àÄ r : s, P (Localization.awayMap f r)), P f
#align ring_hom.of_localization_finite_span RingHom.OfLocalizationFiniteSpan

/-- A property `P` of ring homs satisfies `RingHom.OfLocalizationFiniteSpan`
if `P` holds for `R ‚Üí+* S` whenever there exists a set `{ r }` that spans `R` such that
`P` holds for `R·µ£ ‚Üí+* S·µ£`.

Note that this is equivalent to `RingHom.OfLocalizationFiniteSpan` via
`RingHom.ofLocalizationSpan_iff_finite`, but this has less restrictions when applying. -/
def RingHom.OfLocalizationSpan :=
  ‚àÄ ‚¶ÉR S : Type u‚¶Ñ [CommRing R] [CommRing S] (f : R ‚Üí+* S) (s : Set R) (_ : Ideal.span s = ‚ä§)
    (_ : ‚àÄ r : s, P (Localization.awayMap f r)), P f
#align ring_hom.of_localization_span RingHom.OfLocalizationSpan

/-- A property `P` of ring homs satisfies `RingHom.HoldsForLocalizationAway`
 if `P` holds for each localization map `R ‚Üí+* R·µ£`. -/
def RingHom.HoldsForLocalizationAway : Prop :=
  ‚àÄ ‚¶ÉR : Type u‚¶Ñ (S : Type u) [CommRing R] [CommRing S] [Algebra R S] (r : R)
    [IsLocalization.Away r S], P (algebraMap R S)
#align ring_hom.holds_for_localization_away RingHom.HoldsForLocalizationAway

/-- A property `P` of ring homs satisfies `RingHom.OfLocalizationFiniteSpanTarget`
if `P` holds for `R ‚Üí+* S` whenever there exists a finite set `{ r }` that spans `S` such that
`P` holds for `R ‚Üí+* S·µ£`.

Note that this is equivalent to `RingHom.OfLocalizationSpanTarget` via
`RingHom.ofLocalizationSpanTarget_iff_finite`, but this is easier to prove. -/
def RingHom.OfLocalizationFiniteSpanTarget : Prop :=
  ‚àÄ ‚¶ÉR S : Type u‚¶Ñ [CommRing R] [CommRing S] (f : R ‚Üí+* S) (s : Finset S)
    (_ : Ideal.span (s : Set S) = ‚ä§)
    (_ : ‚àÄ r : s, P ((algebraMap S (Localization.Away (r : S))).comp f)), P f
#align ring_hom.of_localization_finite_span_target RingHom.OfLocalizationFiniteSpanTarget

/-- A property `P` of ring homs satisfies `RingHom.OfLocalizationSpanTarget`
if `P` holds for `R ‚Üí+* S` whenever there exists a set `{ r }` that spans `S` such that
`P` holds for `R ‚Üí+* S·µ£`.

Note that this is equivalent to `RingHom.OfLocalizationFiniteSpanTarget` via
`RingHom.ofLocalizationSpanTarget_iff_finite`, but this has less restrictions when applying. -/
def RingHom.OfLocalizationSpanTarget : Prop :=
  ‚àÄ ‚¶ÉR S : Type u‚¶Ñ [CommRing R] [CommRing S] (f : R ‚Üí+* S) (s : Set S) (_ : Ideal.span s = ‚ä§)
    (_ : ‚àÄ r : s, P ((algebraMap S (Localization.Away (r : S))).comp f)), P f
#align ring_hom.of_localization_span_target RingHom.OfLocalizationSpanTarget

/-- A property `P` of ring homs satisfies `RingHom.OfLocalizationPrime`
if `P` holds for `R` whenever `P` holds for `R‚Çò` for all prime ideals `p`. -/
def RingHom.OfLocalizationPrime : Prop :=
  ‚àÄ ‚¶ÉR S : Type u‚¶Ñ [CommRing R] [CommRing S] (f : R ‚Üí+* S),
    (‚àÄ (J : Ideal S) (_ : J.IsPrime), P (Localization.localRingHom _ J f rfl)) ‚Üí P f
#align ring_hom.of_localization_prime RingHom.OfLocalizationPrime

/-- A property of ring homs is local if it is preserved by localizations and compositions, and for
each `{ r }` that spans `S`, we have `P (R ‚Üí+* S) ‚Üî ‚àÄ r, P (R ‚Üí+* S·µ£)`. -/
structure RingHom.PropertyIsLocal : Prop where
  LocalizationPreserves : RingHom.LocalizationPreserves @P
  OfLocalizationSpanTarget : RingHom.OfLocalizationSpanTarget @P
  StableUnderComposition : RingHom.StableUnderComposition @P
  HoldsForLocalizationAway : RingHom.HoldsForLocalizationAway @P
#align ring_hom.property_is_local RingHom.PropertyIsLocal

theorem RingHom.ofLocalizationSpan_iff_finite :
    RingHom.OfLocalizationSpan @P ‚Üî RingHom.OfLocalizationFiniteSpan @P := by
  delta RingHom.OfLocalizationSpan RingHom.OfLocalizationFiniteSpan
  -- ‚ä¢ (‚àÄ ‚¶ÉR S : Type u‚¶Ñ [inst : CommRing R] [inst_1 : CommRing S] (f : R ‚Üí+* S) (s ‚Ä¶
  apply forall‚ÇÖ_congr
  -- ‚ä¢ ‚àÄ (a b : Type u) (c : CommRing a) (d : CommRing b) (e : a ‚Üí+* b), (‚àÄ (s : Se ‚Ä¶
  -- TODO: Using `refine` here breaks `resetI`.
  intros
  -- ‚ä¢ (‚àÄ (s : Set a‚úù), Ideal.span s = ‚ä§ ‚Üí (‚àÄ (r : ‚Üës), P (Localization.awayMap e‚úù  ‚Ä¶
  constructor
  -- ‚ä¢ (‚àÄ (s : Set a‚úù), Ideal.span s = ‚ä§ ‚Üí (‚àÄ (r : ‚Üës), P (Localization.awayMap e‚úù  ‚Ä¶
  ¬∑ intro h s; exact h s
    -- ‚ä¢ Ideal.span ‚Üës = ‚ä§ ‚Üí (‚àÄ (r : { x // x ‚àà s }), P (Localization.awayMap e‚úù ‚Üër)) ‚Ä¶
               -- üéâ no goals
  ¬∑ intro h s hs hs'
    -- ‚ä¢ P e‚úù
    obtain ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© := (Ideal.span_eq_top_iff_finite s).mp hs
    -- ‚ä¢ P e‚úù
    exact h s' h‚ÇÇ fun x => hs' ‚ü®_, h‚ÇÅ x.prop‚ü©
    -- üéâ no goals
#align ring_hom.of_localization_span_iff_finite RingHom.ofLocalizationSpan_iff_finite

theorem RingHom.ofLocalizationSpanTarget_iff_finite :
    RingHom.OfLocalizationSpanTarget @P ‚Üî RingHom.OfLocalizationFiniteSpanTarget @P := by
  delta RingHom.OfLocalizationSpanTarget RingHom.OfLocalizationFiniteSpanTarget
  -- ‚ä¢ (‚àÄ ‚¶ÉR S : Type u‚¶Ñ [inst : CommRing R] [inst_1 : CommRing S] (f : R ‚Üí+* S) (s ‚Ä¶
  apply forall‚ÇÖ_congr
  -- ‚ä¢ ‚àÄ (a b : Type u) (c : CommRing a) (d : CommRing b) (e : a ‚Üí+* b), (‚àÄ (s : Se ‚Ä¶
  -- TODO: Using `refine` here breaks `resetI`.
  intros
  -- ‚ä¢ (‚àÄ (s : Set b‚úù), Ideal.span s = ‚ä§ ‚Üí (‚àÄ (r : ‚Üës), P (comp (algebraMap b‚úù (Loc ‚Ä¶
  constructor
  -- ‚ä¢ (‚àÄ (s : Set b‚úù), Ideal.span s = ‚ä§ ‚Üí (‚àÄ (r : ‚Üës), P (comp (algebraMap b‚úù (Loc ‚Ä¶
  ¬∑ intro h s; exact h s
    -- ‚ä¢ Ideal.span ‚Üës = ‚ä§ ‚Üí (‚àÄ (r : { x // x ‚àà s }), P (comp (algebraMap b‚úù (Localiz ‚Ä¶
               -- üéâ no goals
  ¬∑ intro h s hs hs'
    -- ‚ä¢ P e‚úù
    obtain ‚ü®s', h‚ÇÅ, h‚ÇÇ‚ü© := (Ideal.span_eq_top_iff_finite s).mp hs
    -- ‚ä¢ P e‚úù
    exact h s' h‚ÇÇ fun x => hs' ‚ü®_, h‚ÇÅ x.prop‚ü©
    -- üéâ no goals
#align ring_hom.of_localization_span_target_iff_finite RingHom.ofLocalizationSpanTarget_iff_finite

variable {P f R' S'}

theorem RingHom.PropertyIsLocal.respectsIso (hP : RingHom.PropertyIsLocal @P) :
    RingHom.RespectsIso @P := by
  apply hP.StableUnderComposition.respectsIso
  -- ‚ä¢ ‚àÄ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (e : R ‚âÉ+* S), P  ‚Ä¶
  introv
  -- ‚ä¢ P (RingEquiv.toRingHom e)
  letI := e.toRingHom.toAlgebra
  -- ‚ä¢ P (RingEquiv.toRingHom e)
  -- Porting note: was `apply_with hP.holds_for_localization_away { instances := ff }`
  have : IsLocalization.Away (1 : R) S := by
    apply IsLocalization.away_of_isUnit_of_bijective _ isUnit_one e.bijective
  exact RingHom.PropertyIsLocal.HoldsForLocalizationAway hP S (1 : R)
  -- üéâ no goals
#align ring_hom.property_is_local.respects_iso RingHom.PropertyIsLocal.respectsIso

-- Almost all arguments are implicit since this is not intended to use mid-proof.
theorem RingHom.LocalizationPreserves.away (H : RingHom.LocalizationPreserves @P) (r : R)
    [IsLocalization.Away r R'] [IsLocalization.Away (f r) S'] (hf : P f) :
    P (IsLocalization.Away.map R' S' f r) := by
  have : IsLocalization ((Submonoid.powers r).map f) S' := by rw [Submonoid.map_powers]; assumption
  -- ‚ä¢ P (IsLocalization.Away.map R' S' f r)
  exact H f (Submonoid.powers r) R' S' hf
  -- üéâ no goals
#align ring_hom.localization_preserves.away RingHom.LocalizationPreserves.away

theorem RingHom.PropertyIsLocal.ofLocalizationSpan (hP : RingHom.PropertyIsLocal @P) :
    RingHom.OfLocalizationSpan @P := by
  introv R hs hs'
  -- ‚ä¢ P f
  apply_fun Ideal.map f at hs
  -- ‚ä¢ P f
  rw [Ideal.map_span, Ideal.map_top] at hs
  -- ‚ä¢ P f
  apply hP.OfLocalizationSpanTarget _ _ hs
  -- ‚ä¢ ‚àÄ (r : ‚Üë(‚Üëf '' s)), P (comp (algebraMap S (Localization.Away ‚Üër)) f)
  rintro ‚ü®_, r, hr, rfl‚ü©
  -- ‚ä¢ P (comp (algebraMap S (Localization.Away ‚Üë{ val := ‚Üëf r, property := (_ : ‚àÉ  ‚Ä¶
  convert hP.StableUnderComposition
    _ _ (hP.HoldsForLocalizationAway (Localization.Away r) r) (hs' ‚ü®r, hr‚ü©) using 1
  exact (IsLocalization.map_comp _).symm
  -- üéâ no goals
#align ring_hom.property_is_local.of_localization_span RingHom.PropertyIsLocal.ofLocalizationSpan

end RingHom

end Properties

section Ideal

open scoped nonZeroDivisors

/-- Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is included in
the localization of `J` at `P`, then `I ‚â§ J`. -/
theorem Ideal.le_of_localization_maximal {I J : Ideal R}
    (h : ‚àÄ (P : Ideal R) (hP : P.IsMaximal),
      Ideal.map (algebraMap R (Localization.AtPrime P)) I ‚â§
        Ideal.map (algebraMap R (Localization.AtPrime P)) J) :
    I ‚â§ J := by
  intro x hx
  -- ‚ä¢ x ‚àà J
  suffices J.colon (Ideal.span {x}) = ‚ä§ by
    simpa using Submodule.mem_colon.mp
      (show (1 : R) ‚àà J.colon (Ideal.span {x}) from this.symm ‚ñ∏ Submodule.mem_top) x
      (Ideal.mem_span_singleton_self x)
  refine' Not.imp_symm (J.colon (Ideal.span {x})).exists_le_maximal _
  -- ‚ä¢ ¬¨‚àÉ M, IsMaximal M ‚àß Submodule.colon J (span {x}) ‚â§ M
  push_neg
  -- ‚ä¢ ‚àÄ (M : Ideal R), IsMaximal M ‚Üí ¬¨Submodule.colon J (span {x}) ‚â§ M
  intro P hP le
  -- ‚ä¢ False
  obtain ‚ü®‚ü®‚ü®a, ha‚ü©, ‚ü®s, hs‚ü©‚ü©, eq‚ü© :=
    (IsLocalization.mem_map_algebraMap_iff P.primeCompl _).mp (h P hP (Ideal.mem_map_of_mem _ hx))
  rw [‚Üê _root_.map_mul, ‚Üê sub_eq_zero, ‚Üê map_sub] at eq
  -- ‚ä¢ False
  obtain ‚ü®‚ü®m, hm‚ü©, eq‚ü© := (IsLocalization.map_eq_zero_iff P.primeCompl _ _).mp eq
  -- ‚ä¢ False
  refine' hs ((hP.isPrime.mem_or_mem (le (Ideal.mem_colon_singleton.mpr _))).resolve_right hm)
  -- ‚ä¢ s * m * x ‚àà J
  simp only [Subtype.coe_mk, mul_sub, sub_eq_zero, mul_comm x s, mul_left_comm] at eq
  -- ‚ä¢ s * m * x ‚àà J
  simpa only [mul_assoc, eq] using J.mul_mem_left m ha
  -- üéâ no goals
#align ideal.le_of_localization_maximal Ideal.le_of_localization_maximal

/-- Let `I J : Ideal R`. If the localization of `I` at each maximal ideal `P` is equal to
the localization of `J` at `P`, then `I = J`. -/
theorem Ideal.eq_of_localization_maximal {I J : Ideal R}
    (h : ‚àÄ (P : Ideal R) (_ : P.IsMaximal),
      Ideal.map (algebraMap R (Localization.AtPrime P)) I =
        Ideal.map (algebraMap R (Localization.AtPrime P)) J) :
    I = J :=
  le_antisymm (Ideal.le_of_localization_maximal fun P hP => (h P hP).le)
    (Ideal.le_of_localization_maximal fun P hP => (h P hP).ge)
#align ideal.eq_of_localization_maximal Ideal.eq_of_localization_maximal

/-- An ideal is trivial if its localization at every maximal ideal is trivial. -/
theorem ideal_eq_bot_of_localization' (I : Ideal R)
    (h : ‚àÄ (J : Ideal R) (hJ : J.IsMaximal),
      Ideal.map (algebraMap R (Localization.AtPrime J)) I = ‚ä•) :
    I = ‚ä• :=
  Ideal.eq_of_localization_maximal fun P hP => by simpa using h P hP
                                                  -- üéâ no goals
#align ideal_eq_bot_of_localization' ideal_eq_bot_of_localization'

-- TODO: This proof should work for all modules, once we have enough material on submodules of
-- localized modules.
/-- An ideal is trivial if its localization at every maximal ideal is trivial. -/
theorem ideal_eq_bot_of_localization (I : Ideal R)
    (h : ‚àÄ (J : Ideal R) (hJ : J.IsMaximal),
      IsLocalization.coeSubmodule (Localization.AtPrime J) I = ‚ä•) :
    I = ‚ä• :=
  ideal_eq_bot_of_localization' _ fun P hP =>
    (Ideal.map_eq_bot_iff_le_ker _).mpr fun x hx => by
      rw [RingHom.mem_ker, ‚Üê Submodule.mem_bot R, ‚Üê h P hP, IsLocalization.mem_coeSubmodule]
      -- ‚ä¢ ‚àÉ y, y ‚àà I ‚àß ‚Üë(algebraMap R ((fun x => Localization.AtPrime P) x)) y = ‚Üë(alg ‚Ä¶
      exact ‚ü®x, hx, rfl‚ü©
      -- üéâ no goals
#align ideal_eq_bot_of_localization ideal_eq_bot_of_localization

theorem eq_zero_of_localization (r : R)
    (h : ‚àÄ (J : Ideal R) (hJ : J.IsMaximal), algebraMap R (Localization.AtPrime J) r = 0) :
    r = 0 := by
  rw [‚Üê Ideal.span_singleton_eq_bot]
  -- ‚ä¢ Ideal.span {r} = ‚ä•
  apply ideal_eq_bot_of_localization
  -- ‚ä¢ ‚àÄ (J : Ideal R) (hJ : Ideal.IsMaximal J), IsLocalization.coeSubmodule (Local ‚Ä¶
  intro J hJ
  -- ‚ä¢ IsLocalization.coeSubmodule (Localization.AtPrime J) (Ideal.span {r}) = ‚ä•
  delta IsLocalization.coeSubmodule
  -- ‚ä¢ Submodule.map (Algebra.linearMap R (Localization.AtPrime J)) (Ideal.span {r} ‚Ä¶
  erw [Submodule.map_span, Submodule.span_eq_bot]
  -- ‚ä¢ ‚àÄ (x : Localization.AtPrime J), x ‚àà ‚Üë(Algebra.linearMap R (Localization.AtPr ‚Ä¶
  rintro _ ‚ü®_, h', rfl‚ü©
  -- ‚ä¢ ‚Üë(Algebra.linearMap R (Localization.AtPrime J)) w‚úù = 0
  cases Set.mem_singleton_iff.mpr h'
  -- ‚ä¢ ‚Üë(Algebra.linearMap R (Localization.AtPrime J)) r = 0
  exact h J hJ
  -- üéâ no goals
#align eq_zero_of_localization eq_zero_of_localization

end Ideal

section Reduced

theorem localization_isReduced : LocalizationPreserves fun R hR => IsReduced R := by
  introv R _ _
  -- ‚ä¢ IsReduced S
  constructor
  -- ‚ä¢ ‚àÄ (x : S), IsNilpotent x ‚Üí x = 0
  rintro x ‚ü®_ | n, e‚ü©
  -- ‚ä¢ x = 0
  ¬∑ simpa using congr_arg (¬∑ * x) e
    -- üéâ no goals
  obtain ‚ü®‚ü®y, m‚ü©, hx‚ü© := IsLocalization.surj M x
  -- ‚ä¢ x = 0
  dsimp only at hx
  -- ‚ä¢ x = 0
  let hx' := congr_arg (¬∑ ^ n.succ) hx
  -- ‚ä¢ x = 0
  simp only [mul_pow, e, zero_mul, ‚Üê RingHom.map_pow] at hx'
  -- ‚ä¢ x = 0
  rw [‚Üê (algebraMap R S).map_zero] at hx'
  -- ‚ä¢ x = 0
  obtain ‚ü®m', hm'‚ü© := (IsLocalization.eq_iff_exists M S).mp hx'
  -- ‚ä¢ x = 0
  apply_fun (¬∑ * (m' : R) ^ n) at hm'
  -- ‚ä¢ x = 0
  simp only [mul_assoc, zero_mul, mul_zero] at hm'
  -- ‚ä¢ x = 0
  rw [‚Üê mul_left_comm, ‚Üê pow_succ, ‚Üê mul_pow] at hm'
  -- ‚ä¢ x = 0
  replace hm' := IsNilpotent.eq_zero ‚ü®_, hm'.symm‚ü©
  -- ‚ä¢ x = 0
  rw [‚Üê (IsLocalization.map_units S m).mul_left_inj, hx, zero_mul,
    IsLocalization.map_eq_zero_iff M]
  exact ‚ü®m', by rw [‚Üê hm', mul_comm]‚ü©
  -- üéâ no goals
#align localization_is_reduced localization_isReduced

instance [IsReduced R] : IsReduced (Localization M) :=
  localization_isReduced M _ inferInstance

theorem isReduced_ofLocalizationMaximal : OfLocalizationMaximal fun R hR => IsReduced R := by
  introv R h
  -- ‚ä¢ IsReduced R
  constructor
  -- ‚ä¢ ‚àÄ (x : R), IsNilpotent x ‚Üí x = 0
  intro x hx
  -- ‚ä¢ x = 0
  apply eq_zero_of_localization
  -- ‚ä¢ ‚àÄ (J : Ideal R) (hJ : Ideal.IsMaximal J), ‚Üë(algebraMap R (Localization.AtPri ‚Ä¶
  intro J hJ
  -- ‚ä¢ ‚Üë(algebraMap R (Localization.AtPrime J)) x = 0
  specialize h J hJ
  -- ‚ä¢ ‚Üë(algebraMap R (Localization.AtPrime J)) x = 0
  exact (hx.map <| algebraMap R <| Localization.AtPrime J).eq_zero
  -- üéâ no goals
#align is_reduced_of_localization_maximal isReduced_ofLocalizationMaximal

end Reduced

section Surjective

theorem localizationPreserves_surjective :
    RingHom.LocalizationPreserves fun {R S} _ _ f => Function.Surjective f := by
  introv R H x
  -- ‚ä¢ ‚àÉ a, ‚Üë(IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Submonoid.map f M ‚Ä¶
  obtain ‚ü®x, ‚ü®_, s, hs, rfl‚ü©, rfl‚ü© := IsLocalization.mk'_surjective (M.map f) x
  -- ‚ä¢ ‚àÉ a, ‚Üë(IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Submonoid.map f M ‚Ä¶
  obtain ‚ü®y, rfl‚ü© := H x
  -- ‚ä¢ ‚àÉ a, ‚Üë(IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Submonoid.map f M ‚Ä¶
  use IsLocalization.mk' R' y ‚ü®s, hs‚ü©
  -- ‚ä¢ ‚Üë(IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Submonoid.map f M))) ( ‚Ä¶
  rw [IsLocalization.map_mk']
  -- üéâ no goals
#align localization_preserves_surjective localizationPreserves_surjective

theorem surjective_ofLocalizationSpan :
    RingHom.OfLocalizationSpan fun {R S} _ _ f => Function.Surjective f := by
  introv R e H
  -- ‚ä¢ Function.Surjective ‚Üëf
  rw [‚Üê Set.range_iff_surjective, Set.eq_univ_iff_forall]
  -- ‚ä¢ ‚àÄ (x : S), x ‚àà Set.range ‚Üëf
  letI := f.toAlgebra
  -- ‚ä¢ ‚àÄ (x : S), x ‚àà Set.range ‚Üëf
  intro x
  -- ‚ä¢ x ‚àà Set.range ‚Üëf
  apply Submodule.mem_of_span_eq_top_of_smul_pow_mem
    (LinearMap.range (Algebra.linearMap R S)) s e
  intro r
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà LinearMap.range (Algebra.linearMap R S)
  obtain ‚ü®a, e'‚ü© := H r (algebraMap _ _ x)
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà LinearMap.range (Algebra.linearMap R S)
  obtain ‚ü®b, ‚ü®_, n, rfl‚ü©, rfl‚ü© := IsLocalization.mk'_surjective (Submonoid.powers (r : R)) a
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà LinearMap.range (Algebra.linearMap R S)
  erw [IsLocalization.map_mk'] at e'
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà LinearMap.range (Algebra.linearMap R S)
  rw [eq_comm, IsLocalization.eq_mk'_iff_mul_eq, Subtype.coe_mk, Subtype.coe_mk, ‚Üê map_mul] at e'
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà LinearMap.range (Algebra.linearMap R S)
  obtain ‚ü®‚ü®_, n', rfl‚ü©, e''‚ü© := (IsLocalization.eq_iff_exists (Submonoid.powers (f r)) _).mp e'
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà LinearMap.range (Algebra.linearMap R S)
  dsimp only at e''
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà LinearMap.range (Algebra.linearMap R S)
  rw [mul_comm x, ‚Üê mul_assoc, ‚Üê map_pow, ‚Üê map_mul, ‚Üê map_mul, ‚Üê pow_add] at e''
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà LinearMap.range (Algebra.linearMap R S)
  exact ‚ü®n' + n, _, e''.symm‚ü©
  -- üéâ no goals
#align surjective_of_localization_span surjective_ofLocalizationSpan

end Surjective

section Finite

/-- If `S` is a finite `R`-algebra, then `S' = M‚Åª¬πS` is a finite `R' = M‚Åª¬πR`-algebra. -/
theorem localization_finite : RingHom.LocalizationPreserves @RingHom.Finite := by
  introv R hf
  -- ‚ä¢ RingHom.Finite (IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Submonoi ‚Ä¶
  -- Setting up the `algebra` and `is_scalar_tower` instances needed
  letI := f.toAlgebra
  -- ‚ä¢ RingHom.Finite (IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Submonoi ‚Ä¶
  letI := ((algebraMap S S').comp f).toAlgebra
  -- ‚ä¢ RingHom.Finite (IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Submonoi ‚Ä¶
  let f' : R' ‚Üí+* S' := IsLocalization.map S' f (Submonoid.le_comap_map M)
  -- ‚ä¢ RingHom.Finite (IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Submonoi ‚Ä¶
  letI := f'.toAlgebra
  -- ‚ä¢ RingHom.Finite (IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Submonoi ‚Ä¶
  haveI : IsScalarTower R R' S' := IsScalarTower.of_algebraMap_eq'
    (IsLocalization.map_comp M.le_comap_map).symm
  let f‚Çê : S ‚Üí‚Çê[R] S' := AlgHom.mk' (algebraMap S S') fun c x => RingHom.map_mul _ _ _
  -- ‚ä¢ RingHom.Finite (IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Submonoi ‚Ä¶
  -- We claim that if `S` is generated by `T` as an `R`-module,
  -- then `S'` is generated by `T` as an `R'`-module.
  obtain ‚ü®T, hT‚ü© := hf
  -- ‚ä¢ RingHom.Finite (IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Submonoi ‚Ä¶
  use T.image (algebraMap S S')
  -- ‚ä¢ Submodule.span R' ‚Üë(Finset.image (‚Üë(algebraMap S S')) T) = ‚ä§
  rw [eq_top_iff]
  -- ‚ä¢ ‚ä§ ‚â§ Submodule.span R' ‚Üë(Finset.image (‚Üë(algebraMap S S')) T)
  rintro x -
  -- ‚ä¢ x ‚àà Submodule.span R' ‚Üë(Finset.image (‚Üë(algebraMap S S')) T)
  -- By the hypotheses, for each `x : S'`, we have `x = y / (f r)` for some `y : S` and `r : M`.
  -- Since `S` is generated by `T`, the image of `y` should fall in the span of the image of `T`.
  obtain ‚ü®y, ‚ü®_, ‚ü®r, hr, rfl‚ü©‚ü©, rfl‚ü© := IsLocalization.mk'_surjective (M.map f) x
  -- ‚ä¢ IsLocalization.mk' S' y { val := ‚Üëf r, property := (_ : ‚àÉ a, a ‚àà ‚ÜëM ‚àß ‚Üëf a = ‚Ä¶
  rw [IsLocalization.mk'_eq_mul_mk'_one, mul_comm, Finset.coe_image]
  -- ‚ä¢ IsLocalization.mk' S' 1 { val := ‚Üëf r, property := (_ : ‚àÉ a, a ‚àà ‚ÜëM ‚àß ‚Üëf a = ‚Ä¶
  have hy : y ‚àà Submodule.span R ‚ÜëT := by rw [hT]; trivial
  -- ‚ä¢ IsLocalization.mk' S' 1 { val := ‚Üëf r, property := (_ : ‚àÉ a, a ‚àà ‚ÜëM ‚àß ‚Üëf a = ‚Ä¶
  replace hy : algebraMap S S' y ‚àà Submodule.map f‚Çê.toLinearMap (Submodule.span R (T : Set S)) :=
    Submodule.mem_map_of_mem hy
  rw [Submodule.map_span f‚Çê.toLinearMap T] at hy
  -- ‚ä¢ IsLocalization.mk' S' 1 { val := ‚Üëf r, property := (_ : ‚àÉ a, a ‚àà ‚ÜëM ‚àß ‚Üëf a = ‚Ä¶
  have H : Submodule.span R (algebraMap S S' '' T) ‚â§
      (Submodule.span R' (algebraMap S S' '' T)).restrictScalars R := by
    rw [Submodule.span_le]; exact Submodule.subset_span
  -- Now, since `y ‚àà span T`, and `(f r)‚Åª¬π ‚àà R'`, `x / (f r)` is in `span T` as well.
  convert (Submodule.span R' (algebraMap S S' '' T)).smul_mem
    (IsLocalization.mk' R' (1 : R) ‚ü®r, hr‚ü©) (H hy) using 1
  rw [Algebra.smul_def]
  -- ‚ä¢ IsLocalization.mk' S' 1 { val := ‚Üëf r, property := (_ : ‚àÉ a, a ‚àà ‚ÜëM ‚àß ‚Üëf a = ‚Ä¶
  erw [IsLocalization.map_mk' M.le_comap_map]
  -- ‚ä¢ IsLocalization.mk' S' 1 { val := ‚Üëf r, property := (_ : ‚àÉ a, a ‚àà ‚ÜëM ‚àß ‚Üëf a = ‚Ä¶
  rw [map_one]
  -- üéâ no goals
#align localization_finite localization_finite

theorem localization_away_map_finite (r : R) [IsLocalization.Away r R']
    [IsLocalization.Away (f r) S'] (hf : f.Finite) : (IsLocalization.Away.map R' S' f r).Finite :=
  localization_finite.away r hf
#align localization_away_map_finite localization_away_map_finite

/-- Let `S` be an `R`-algebra, `M` a submonoid of `R`, and `S' = M‚Åª¬πS`.
If the image of some `x : S` falls in the span of some finite `s ‚äÜ S'` over `R`,
then there exists some `m : M` such that `m ‚Ä¢ x` falls in the
span of `IsLocalization.finsetIntegerMultiple _ s` over `R`.
-/
theorem IsLocalization.smul_mem_finsetIntegerMultiple_span [Algebra R S] [Algebra R S']
    [IsScalarTower R S S'] [IsLocalization (M.map (algebraMap R S)) S'] (x : S) (s : Finset S')
    (hx : algebraMap S S' x ‚àà Submodule.span R (s : Set S')) :
    ‚àÉ m : M, m ‚Ä¢ x ‚àà
      Submodule.span R
        (IsLocalization.finsetIntegerMultiple (M.map (algebraMap R S)) s : Set S) := by
  let g : S ‚Üí‚Çê[R] S' :=
    AlgHom.mk' (algebraMap S S') fun c x => by simp [Algebra.algebraMap_eq_smul_one]
  -- We first obtain the `y' ‚àà M` such that `s' = y' ‚Ä¢ s` is falls in the image of `S` in `S'`.
  let y := IsLocalization.commonDenomOfFinset (M.map (algebraMap R S)) s
  -- ‚ä¢ ‚àÉ m, m ‚Ä¢ x ‚àà Submodule.span R ‚Üë(finsetIntegerMultiple (Submonoid.map (algebr ‚Ä¶
  have hx‚ÇÅ : (y : S) ‚Ä¢ (s : Set S') = g '' _ :=
    (IsLocalization.finsetIntegerMultiple_image _ s).symm
  obtain ‚ü®y', hy', e : algebraMap R S y' = y‚ü© := y.prop
  -- ‚ä¢ ‚àÉ m, m ‚Ä¢ x ‚àà Submodule.span R ‚Üë(finsetIntegerMultiple (Submonoid.map (algebr ‚Ä¶
  have : algebraMap R S y' ‚Ä¢ (s : Set S') = y' ‚Ä¢ (s : Set S') := by
    simp_rw [Algebra.algebraMap_eq_smul_one, smul_assoc, one_smul]
  rw [‚Üê e, this] at hx‚ÇÅ
  -- ‚ä¢ ‚àÉ m, m ‚Ä¢ x ‚àà Submodule.span R ‚Üë(finsetIntegerMultiple (Submonoid.map (algebr ‚Ä¶
  replace hx‚ÇÅ := congr_arg (Submodule.span R) hx‚ÇÅ
  -- ‚ä¢ ‚àÉ m, m ‚Ä¢ x ‚àà Submodule.span R ‚Üë(finsetIntegerMultiple (Submonoid.map (algebr ‚Ä¶
  rw [Submodule.span_smul] at hx‚ÇÅ
  -- ‚ä¢ ‚àÉ m, m ‚Ä¢ x ‚àà Submodule.span R ‚Üë(finsetIntegerMultiple (Submonoid.map (algebr ‚Ä¶
  replace hx : _ ‚àà y' ‚Ä¢ Submodule.span R (s : Set S') := Set.smul_mem_smul_set hx
  -- ‚ä¢ ‚àÉ m, m ‚Ä¢ x ‚àà Submodule.span R ‚Üë(finsetIntegerMultiple (Submonoid.map (algebr ‚Ä¶
  rw [hx‚ÇÅ] at hx
  -- ‚ä¢ ‚àÉ m, m ‚Ä¢ x ‚àà Submodule.span R ‚Üë(finsetIntegerMultiple (Submonoid.map (algebr ‚Ä¶
  erw [‚Üê g.map_smul, ‚Üê Submodule.map_span (g : S ‚Üí‚Çó[R] S')] at hx
  -- ‚ä¢ ‚àÉ m, m ‚Ä¢ x ‚àà Submodule.span R ‚Üë(finsetIntegerMultiple (Submonoid.map (algebr ‚Ä¶
  -- Since `x` falls in the span of `s` in `S'`, `y' ‚Ä¢ x : S` falls in the span of `s'` in `S'`.
  -- That is, there exists some `x' : S` in the span of `s'` in `S` and `x' = y' ‚Ä¢ x` in `S'`.
  -- Thus `a ‚Ä¢ (y' ‚Ä¢ x) = a ‚Ä¢ x' ‚àà span s'` in `S` for some `a ‚àà M`.
  obtain ‚ü®x', hx', hx'' : algebraMap _ _ _ = _‚ü© := hx
  -- ‚ä¢ ‚àÉ m, m ‚Ä¢ x ‚àà Submodule.span R ‚Üë(finsetIntegerMultiple (Submonoid.map (algebr ‚Ä¶
  obtain ‚ü®‚ü®_, a, ha‚ÇÅ, rfl‚ü©, ha‚ÇÇ‚ü© :=
    (IsLocalization.eq_iff_exists (M.map (algebraMap R S)) S').mp hx''
  use (‚ü®a, ha‚ÇÅ‚ü© : M) * (‚ü®y', hy'‚ü© : M)
  -- ‚ä¢ ({ val := a, property := ha‚ÇÅ } * { val := y', property := hy' }) ‚Ä¢ x ‚àà Submo ‚Ä¶
  convert (Submodule.span R
    (IsLocalization.finsetIntegerMultiple (Submonoid.map (algebraMap R S) M) s : Set S)).smul_mem
      a hx' using 1
  convert ha‚ÇÇ.symm using 1
  -- ‚ä¢ ({ val := a, property := ha‚ÇÅ } * { val := y', property := hy' }) ‚Ä¢ x = ‚Üë{ va ‚Ä¶
  ¬∑ rw [Subtype.coe_mk, Submonoid.smul_def, Submonoid.coe_mul, ‚Üê smul_smul]
    -- ‚ä¢ ‚Üë{ val := a, property := ha‚ÇÅ } ‚Ä¢ ‚Üë{ val := y', property := hy' } ‚Ä¢ x = ‚Üë(alg ‚Ä¶
    exact Algebra.smul_def _ _
    -- üéâ no goals
  ¬∑ exact Algebra.smul_def _ _
    -- üéâ no goals
#align is_localization.smul_mem_finset_integer_multiple_span IsLocalization.smul_mem_finsetIntegerMultiple_span

/-- If `S` is an `R' = M‚Åª¬πR` algebra, and `x ‚àà span R' s`,
then `t ‚Ä¢ x ‚àà span R s` for some `t : M`.-/
theorem multiple_mem_span_of_mem_localization_span [Algebra R' S] [Algebra R S]
    [IsScalarTower R R' S] [IsLocalization M R'] (s : Set S) (x : S)
    (hx : x ‚àà Submodule.span R' s) : ‚àÉ t : M, t ‚Ä¢ x ‚àà Submodule.span R s := by
  obtain ‚ü®s', hss', hs'‚ü© := Submodule.mem_span_finite_of_mem_span hx
  -- ‚ä¢ ‚àÉ t, t ‚Ä¢ x ‚àà Submodule.span R s
  rsuffices ‚ü®t, ht‚ü© : ‚àÉ t : M, t ‚Ä¢ x ‚àà Submodule.span R (s' : Set S)
  -- ‚ä¢ ‚àÉ t, t ‚Ä¢ x ‚àà Submodule.span R s
  ¬∑ exact ‚ü®t, Submodule.span_mono hss' ht‚ü©
    -- üéâ no goals
  clear hx hss' s
  -- ‚ä¢ ‚àÉ t, t ‚Ä¢ x ‚àà Submodule.span R ‚Üës'
  induction s' using Finset.induction_on generalizing x
  -- ‚ä¢ ‚àÉ t, t ‚Ä¢ x ‚àà Submodule.span R ‚Üë‚àÖ
  ¬∑ use 1; simpa using hs'
    -- ‚ä¢ 1 ‚Ä¢ x ‚àà Submodule.span R ‚Üë‚àÖ
           -- üéâ no goals
  rename_i a s _ hs
  -- ‚ä¢ ‚àÉ t, t ‚Ä¢ x ‚àà Submodule.span R ‚Üë(insert a s)
  simp only [Finset.coe_insert, Finset.image_insert, Finset.coe_image, Subtype.coe_mk,
    Submodule.mem_span_insert] at hs' ‚ä¢
  rcases hs' with ‚ü®y, z, hz, rfl‚ü©
  -- ‚ä¢ ‚àÉ t a_1 z_1, z_1 ‚àà Submodule.span R ‚Üës ‚àß t ‚Ä¢ (y ‚Ä¢ a + z) = a_1 ‚Ä¢ a + z_1
  rcases IsLocalization.surj M y with ‚ü®‚ü®y', s'‚ü©, e‚ü©
  -- ‚ä¢ ‚àÉ t a_1 z_1, z_1 ‚àà Submodule.span R ‚Üës ‚àß t ‚Ä¢ (y ‚Ä¢ a + z) = a_1 ‚Ä¢ a + z_1
  replace e : _ * a = _ * a := (congr_arg (fun x => algebraMap R' S x * a) e : _)
  -- ‚ä¢ ‚àÉ t a_1 z_1, z_1 ‚àà Submodule.span R ‚Üës ‚àß t ‚Ä¢ (y ‚Ä¢ a + z) = a_1 ‚Ä¢ a + z_1
  simp_rw [RingHom.map_mul, ‚Üê IsScalarTower.algebraMap_apply, mul_comm (algebraMap R' S y),
    mul_assoc, ‚Üê Algebra.smul_def] at e
  rcases hs _ hz with ‚ü®t, ht‚ü©
  -- ‚ä¢ ‚àÉ t a_1 z_1, z_1 ‚àà Submodule.span R ‚Üës ‚àß t ‚Ä¢ (y ‚Ä¢ a + z) = a_1 ‚Ä¢ a + z_1
  refine' ‚ü®t * s', t * y', _, (Submodule.span R (s : Set S)).smul_mem s' ht, _‚ü©
  -- ‚ä¢ (t * s') ‚Ä¢ (y ‚Ä¢ a + z) = (‚Üët * y') ‚Ä¢ a + ‚Üës' ‚Ä¢ t ‚Ä¢ z
  rw [smul_add, ‚Üê smul_smul, mul_comm, ‚Üê smul_smul, ‚Üê smul_smul, ‚Üê e]
  -- ‚ä¢ t ‚Ä¢ s' ‚Ä¢ y ‚Ä¢ a + s' ‚Ä¢ t ‚Ä¢ z = ‚Üët ‚Ä¢ ‚Üës' ‚Ä¢ y ‚Ä¢ a + ‚Üës' ‚Ä¢ t ‚Ä¢ z
  rfl
  -- üéâ no goals
#align multiple_mem_span_of_mem_localization_span multiple_mem_span_of_mem_localization_span

/-- If `S` is an `R' = M‚Åª¬πR` algebra, and `x ‚àà adjoin R' s`,
then `t ‚Ä¢ x ‚àà adjoin R s` for some `t : M`.-/
theorem multiple_mem_adjoin_of_mem_localization_adjoin [Algebra R' S] [Algebra R S]
    [IsScalarTower R R' S] [IsLocalization M R'] (s : Set S) (x : S)
    (hx : x ‚àà Algebra.adjoin R' s) : ‚àÉ t : M, t ‚Ä¢ x ‚àà Algebra.adjoin R s := by
  change ‚àÉ t : M, t ‚Ä¢ x ‚àà Subalgebra.toSubmodule (Algebra.adjoin R s)
  -- ‚ä¢ ‚àÉ t, t ‚Ä¢ x ‚àà ‚ÜëSubalgebra.toSubmodule (Algebra.adjoin R s)
  change x ‚àà Subalgebra.toSubmodule (Algebra.adjoin R' s) at hx
  -- ‚ä¢ ‚àÉ t, t ‚Ä¢ x ‚àà ‚ÜëSubalgebra.toSubmodule (Algebra.adjoin R s)
  simp_rw [Algebra.adjoin_eq_span] at hx ‚ä¢
  -- ‚ä¢ ‚àÉ t, t ‚Ä¢ x ‚àà Submodule.span R ‚Üë(Submonoid.closure s)
  exact multiple_mem_span_of_mem_localization_span M R' _ _ hx
  -- üéâ no goals
#align multiple_mem_adjoin_of_mem_localization_adjoin multiple_mem_adjoin_of_mem_localization_adjoin

theorem finite_ofLocalizationSpan : RingHom.OfLocalizationSpan @RingHom.Finite := by
  rw [RingHom.ofLocalizationSpan_iff_finite]
  -- ‚ä¢ RingHom.OfLocalizationFiniteSpan @RingHom.Finite
  introv R hs H
  -- ‚ä¢ RingHom.Finite f
  -- We first setup the instances
  letI := f.toAlgebra
  -- ‚ä¢ RingHom.Finite f
  letI := fun r : s => (Localization.awayMap f r).toAlgebra
  -- ‚ä¢ RingHom.Finite f
  have : ‚àÄ r : s,
      IsLocalization ((Submonoid.powers (r : R)).map (algebraMap R S)) (Localization.Away (f r)) :=
    by intro r; rw [Submonoid.map_powers]; exact Localization.isLocalization
  haveI : ‚àÄ r : s, IsScalarTower R (Localization.Away (r : R)) (Localization.Away (f r)) :=
    fun r => IsScalarTower.of_algebraMap_eq'
      (IsLocalization.map_comp (Submonoid.powers (r : R)).le_comap_map).symm
  -- By the hypothesis, we may find a finite generating set for each `S·µ£`. This set can then be
  -- lifted into `R` by multiplying a sufficiently large power of `r`. I claim that the union of
  -- these generates `S`.
  constructor
  -- ‚ä¢ Submodule.FG ‚ä§
  replace H := fun r => (H r).1
  -- ‚ä¢ Submodule.FG ‚ä§
  choose s‚ÇÅ s‚ÇÇ using H
  -- ‚ä¢ Submodule.FG ‚ä§
  let sf := fun x : s => IsLocalization.finsetIntegerMultiple (Submonoid.powers (f x)) (s‚ÇÅ x)
  -- ‚ä¢ Submodule.FG ‚ä§
  use s.attach.biUnion sf
  -- ‚ä¢ Submodule.span R ‚Üë(Finset.biUnion (Finset.attach s) sf) = ‚ä§
  rw [Submodule.span_attach_biUnion, eq_top_iff]
  -- ‚ä¢ ‚ä§ ‚â§ ‚®Ü (x : { x // x ‚àà s }), Submodule.span R ‚Üë(sf x)
  -- It suffices to show that `r ^ n ‚Ä¢ x ‚àà span T` for each `r : s`, since `{ r ^ n }` spans `R`.
  -- This then follows from the fact that each `x : R` is a linear combination of the generating set
  -- of `S·µ£`. By multiplying a sufficiently large power of `r`, we can cancel out the `r`s in the
  -- denominators of both the generating set and the coefficients.
  rintro x -
  -- ‚ä¢ x ‚àà ‚®Ü (x : { x // x ‚àà s }), Submodule.span R ‚Üë(sf x)
  apply Submodule.mem_of_span_eq_top_of_smul_pow_mem _ (s : Set R) hs _ _
  -- ‚ä¢ ‚àÄ (r : ‚Üë‚Üës), ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà ‚®Ü (x : { x // x ‚àà s }), Submodule.span R ‚Üë(sf ‚Ä¶
  intro r
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà ‚®Ü (x : { x // x ‚àà s }), Submodule.span R ‚Üë(sf x)
  obtain ‚ü®‚ü®_, n‚ÇÅ, rfl‚ü©, hn‚ÇÅ‚ü© :=
    multiple_mem_span_of_mem_localization_span (Submonoid.powers (r : R))
      (Localization.Away (r : R)) (s‚ÇÅ r : Set (Localization.Away (f r))) (algebraMap S _ x)
      (by rw [s‚ÇÇ r]; trivial)
  dsimp only at hn‚ÇÅ
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà ‚®Ü (x : { x // x ‚àà s }), Submodule.span R ‚Üë(sf x)
  rw [Submonoid.smul_def, Algebra.smul_def, IsScalarTower.algebraMap_apply R S, ‚Üê map_mul] at hn‚ÇÅ
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà ‚®Ü (x : { x // x ‚àà s }), Submodule.span R ‚Üë(sf x)
  obtain ‚ü®‚ü®_, n‚ÇÇ, rfl‚ü©, hn‚ÇÇ‚ü© :=
    IsLocalization.smul_mem_finsetIntegerMultiple_span (Submonoid.powers (r : R))
      (Localization.Away (f r)) _ (s‚ÇÅ r) hn‚ÇÅ
  rw [Submonoid.smul_def, ‚Üê Algebra.smul_def, smul_smul, Subtype.coe_mk, ‚Üê pow_add] at hn‚ÇÇ
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà ‚®Ü (x : { x // x ‚àà s }), Submodule.span R ‚Üë(sf x)
  simp_rw [Submonoid.map_powers] at hn‚ÇÇ
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà ‚®Ü (x : { x // x ‚àà s }), Submodule.span R ‚Üë(sf x)
  use n‚ÇÇ + n‚ÇÅ
  -- ‚ä¢ ‚Üër ^ (n‚ÇÇ + n‚ÇÅ) ‚Ä¢ x ‚àà ‚®Ü (x : { x // x ‚àà s }), Submodule.span R ‚Üë(sf x)
  exact le_iSup (fun x : s => Submodule.span R (sf x : Set S)) r hn‚ÇÇ
  -- üéâ no goals
#align finite_of_localization_span finite_ofLocalizationSpan

end Finite

section FiniteType

theorem localization_finiteType : RingHom.LocalizationPreserves @RingHom.FiniteType := by
  introv R hf
  -- ‚ä¢ RingHom.FiniteType (IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Subm ‚Ä¶
  -- mirrors the proof of `localization_map_finite`
  letI := f.toAlgebra
  -- ‚ä¢ RingHom.FiniteType (IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Subm ‚Ä¶
  letI := ((algebraMap S S').comp f).toAlgebra
  -- ‚ä¢ RingHom.FiniteType (IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Subm ‚Ä¶
  let f' : R' ‚Üí+* S' := IsLocalization.map S' f (Submonoid.le_comap_map M)
  -- ‚ä¢ RingHom.FiniteType (IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Subm ‚Ä¶
  letI := f'.toAlgebra
  -- ‚ä¢ RingHom.FiniteType (IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Subm ‚Ä¶
  haveI : IsScalarTower R R' S' :=
    IsScalarTower.of_algebraMap_eq' (IsLocalization.map_comp M.le_comap_map).symm
  let f‚Çê : S ‚Üí‚Çê[R] S' := AlgHom.mk' (algebraMap S S') fun c x => RingHom.map_mul _ _ _
  -- ‚ä¢ RingHom.FiniteType (IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Subm ‚Ä¶
  obtain ‚ü®T, hT‚ü© := id hf
  -- ‚ä¢ RingHom.FiniteType (IsLocalization.map S' f (_ : M ‚â§ Submonoid.comap f (Subm ‚Ä¶
  use T.image (algebraMap S S')
  -- ‚ä¢ Algebra.adjoin R' ‚Üë(Finset.image (‚Üë(algebraMap S S')) T) = ‚ä§
  rw [eq_top_iff]
  -- ‚ä¢ ‚ä§ ‚â§ Algebra.adjoin R' ‚Üë(Finset.image (‚Üë(algebraMap S S')) T)
  rintro x -
  -- ‚ä¢ x ‚àà Algebra.adjoin R' ‚Üë(Finset.image (‚Üë(algebraMap S S')) T)
  obtain ‚ü®y, ‚ü®_, ‚ü®r, hr, rfl‚ü©‚ü©, rfl‚ü© := IsLocalization.mk'_surjective (M.map f) x
  -- ‚ä¢ IsLocalization.mk' S' y { val := ‚Üëf r, property := (_ : ‚àÉ a, a ‚àà ‚ÜëM ‚àß ‚Üëf a = ‚Ä¶
  rw [IsLocalization.mk'_eq_mul_mk'_one, mul_comm, Finset.coe_image]
  -- ‚ä¢ IsLocalization.mk' S' 1 { val := ‚Üëf r, property := (_ : ‚àÉ a, a ‚àà ‚ÜëM ‚àß ‚Üëf a = ‚Ä¶
  have hy : y ‚àà Algebra.adjoin R (T : Set S) := by rw [hT]; trivial
  -- ‚ä¢ IsLocalization.mk' S' 1 { val := ‚Üëf r, property := (_ : ‚àÉ a, a ‚àà ‚ÜëM ‚àß ‚Üëf a = ‚Ä¶
  replace hy : algebraMap S S' y ‚àà (Algebra.adjoin R (T : Set S)).map f‚Çê :=
    Subalgebra.mem_map.mpr ‚ü®_, hy, rfl‚ü©
  rw [f‚Çê.map_adjoin T] at hy
  -- ‚ä¢ IsLocalization.mk' S' 1 { val := ‚Üëf r, property := (_ : ‚àÉ a, a ‚àà ‚ÜëM ‚àß ‚Üëf a = ‚Ä¶
  have H : Algebra.adjoin R (algebraMap S S' '' T) ‚â§
      (Algebra.adjoin R' (algebraMap S S' '' T)).restrictScalars R := by
    rw [Algebra.adjoin_le_iff]; exact Algebra.subset_adjoin
  convert (Algebra.adjoin R' (algebraMap S S' '' T)).smul_mem (H hy)
    (IsLocalization.mk' R' (1 : R) ‚ü®r, hr‚ü©) using 1
  rw [Algebra.smul_def]
  -- ‚ä¢ IsLocalization.mk' S' 1 { val := ‚Üëf r, property := (_ : ‚àÉ a, a ‚àà ‚ÜëM ‚àß ‚Üëf a = ‚Ä¶
  erw [IsLocalization.map_mk' M.le_comap_map]
  -- ‚ä¢ IsLocalization.mk' S' 1 { val := ‚Üëf r, property := (_ : ‚àÉ a, a ‚àà ‚ÜëM ‚àß ‚Üëf a = ‚Ä¶
  rw [map_one]
  -- üéâ no goals
#align localization_finite_type localization_finiteType

theorem localization_away_map_finiteType (r : R) [IsLocalization.Away r R']
    [IsLocalization.Away (f r) S'] (hf : f.FiniteType) :
    (IsLocalization.Away.map R' S' f r).FiniteType :=
  localization_finiteType.away r hf
#align localization_away_map_finite_type localization_away_map_finiteType

variable {S'}

/-- Let `S` be an `R`-algebra, `M` a submonoid of `S`, `S' = M‚Åª¬πS`.
Suppose the image of some `x : S` falls in the adjoin of some finite `s ‚äÜ S'` over `R`,
and `A` is an `R`-subalgebra of `S` containing both `M` and the numerators of `s`.
Then, there exists some `m : M` such that `m ‚Ä¢ x` falls in `A`.
-/
theorem IsLocalization.exists_smul_mem_of_mem_adjoin [Algebra R S] [Algebra R S']
    [IsScalarTower R S S'] (M : Submonoid S) [IsLocalization M S'] (x : S) (s : Finset S')
    (A : Subalgebra R S) (hA‚ÇÅ : (IsLocalization.finsetIntegerMultiple M s : Set S) ‚äÜ A)
    (hA‚ÇÇ : M ‚â§ A.toSubmonoid) (hx : algebraMap S S' x ‚àà Algebra.adjoin R (s : Set S')) :
    ‚àÉ m : M, m ‚Ä¢ x ‚àà A := by
  let g : S ‚Üí‚Çê[R] S' := IsScalarTower.toAlgHom R S S'
  -- ‚ä¢ ‚àÉ m, m ‚Ä¢ x ‚àà A
  let y := IsLocalization.commonDenomOfFinset M s
  -- ‚ä¢ ‚àÉ m, m ‚Ä¢ x ‚àà A
  have hx‚ÇÅ : (y : S) ‚Ä¢ (s : Set S') = g '' _ :=
    (IsLocalization.finsetIntegerMultiple_image _ s).symm
  obtain ‚ü®n, hn‚ü© :=
    Algebra.pow_smul_mem_of_smul_subset_of_mem_adjoin (y : S) (s : Set S') (A.map g)
      (by rw [hx‚ÇÅ]; exact Set.image_subset _ hA‚ÇÅ) hx (Set.mem_image_of_mem _ (hA‚ÇÇ y.2))
  obtain ‚ü®x', hx', hx''‚ü© := hn n (le_of_eq rfl)
  -- ‚ä¢ ‚àÉ m, m ‚Ä¢ x ‚àà A
  rw [Algebra.smul_def, ‚Üê _root_.map_mul] at hx''
  -- ‚ä¢ ‚àÉ m, m ‚Ä¢ x ‚àà A
  obtain ‚ü®a, ha‚ÇÇ‚ü© := (IsLocalization.eq_iff_exists M S').mp hx''
  -- ‚ä¢ ‚àÉ m, m ‚Ä¢ x ‚àà A
  use a * y ^ n
  -- ‚ä¢ (a * y ^ n) ‚Ä¢ x ‚àà A
  convert A.mul_mem hx' (hA‚ÇÇ a.prop) using 1
  -- ‚ä¢ (a * y ^ n) ‚Ä¢ x = x' * ‚Üëa
  rw [Submonoid.smul_def, smul_eq_mul, Submonoid.coe_mul, SubmonoidClass.coe_pow, mul_assoc, ‚Üê ha‚ÇÇ,
    mul_comm]
#align is_localization.exists_smul_mem_of_mem_adjoin IsLocalization.exists_smul_mem_of_mem_adjoin

/-- Let `S` be an `R`-algebra, `M` a submonoid of `R`, and `S' = M‚Åª¬πS`.
If the image of some `x : S` falls in the adjoin of some finite `s ‚äÜ S'` over `R`,
then there exists some `m : M` such that `m ‚Ä¢ x` falls in the
adjoin of `IsLocalization.finsetIntegerMultiple _ s` over `R`.
-/
theorem IsLocalization.lift_mem_adjoin_finsetIntegerMultiple [Algebra R S] [Algebra R S']
    [IsScalarTower R S S'] [IsLocalization (M.map (algebraMap R S)) S'] (x : S) (s : Finset S')
    (hx : algebraMap S S' x ‚àà Algebra.adjoin R (s : Set S')) :
    ‚àÉ m : M, m ‚Ä¢ x ‚àà
      Algebra.adjoin R
        (IsLocalization.finsetIntegerMultiple (M.map (algebraMap R S)) s : Set S) := by
  obtain ‚ü®‚ü®_, a, ha, rfl‚ü©, e‚ü© :=
    IsLocalization.exists_smul_mem_of_mem_adjoin (M.map (algebraMap R S)) x s (Algebra.adjoin R _)
      Algebra.subset_adjoin (by rintro _ ‚ü®a, _, rfl‚ü©; exact Subalgebra.algebraMap_mem _ a) hx
  refine' ‚ü®‚ü®a, ha‚ü©, _‚ü©
  -- ‚ä¢ { val := a, property := ha } ‚Ä¢ x ‚àà Algebra.adjoin R ‚Üë(finsetIntegerMultiple  ‚Ä¶
  simpa only [Submonoid.smul_def, algebraMap_smul] using e
  -- üéâ no goals
#align is_localization.lift_mem_adjoin_finset_integer_multiple IsLocalization.lift_mem_adjoin_finsetIntegerMultiple

theorem finiteType_ofLocalizationSpan : RingHom.OfLocalizationSpan @RingHom.FiniteType := by
  rw [RingHom.ofLocalizationSpan_iff_finite]
  -- ‚ä¢ RingHom.OfLocalizationFiniteSpan @RingHom.FiniteType
  introv R hs H
  -- ‚ä¢ RingHom.FiniteType f
  -- mirrors the proof of `finite_ofLocalizationSpan`
  letI := f.toAlgebra
  -- ‚ä¢ RingHom.FiniteType f
  letI := fun r : s => (Localization.awayMap f r).toAlgebra
  -- ‚ä¢ RingHom.FiniteType f
  have : ‚àÄ r : s,
      IsLocalization ((Submonoid.powers (r : R)).map (algebraMap R S)) (Localization.Away (f r)) :=
    by intro r; rw [Submonoid.map_powers]; exact Localization.isLocalization
  haveI : ‚àÄ r : s, IsScalarTower R (Localization.Away (r : R)) (Localization.Away (f r)) :=
    fun r => IsScalarTower.of_algebraMap_eq'
      (IsLocalization.map_comp (Submonoid.powers (r : R)).le_comap_map).symm
  constructor
  -- ‚ä¢ Subalgebra.FG ‚ä§
  replace H := fun r => (H r).1
  -- ‚ä¢ Subalgebra.FG ‚ä§
  choose s‚ÇÅ s‚ÇÇ using H
  -- ‚ä¢ Subalgebra.FG ‚ä§
  let sf := fun x : s => IsLocalization.finsetIntegerMultiple (Submonoid.powers (f x)) (s‚ÇÅ x)
  -- ‚ä¢ Subalgebra.FG ‚ä§
  use s.attach.biUnion sf
  -- ‚ä¢ Algebra.adjoin R ‚Üë(Finset.biUnion (Finset.attach s) sf) = ‚ä§
  convert (Algebra.adjoin_attach_biUnion (R := R) sf).trans _
  -- ‚ä¢ ‚®Ü (x : { x // x ‚àà s }), Algebra.adjoin R ‚Üë(sf x) = ‚ä§
  rw [eq_top_iff]
  -- ‚ä¢ ‚ä§ ‚â§ ‚®Ü (x : { x // x ‚àà s }), Algebra.adjoin R ‚Üë(sf x)
  rintro x -
  -- ‚ä¢ x ‚àà ‚®Ü (x : { x // x ‚àà s }), Algebra.adjoin R ‚Üë(sf x)
  apply (‚®Ü x : s, Algebra.adjoin R (sf x : Set S)).toSubmodule.mem_of_span_eq_top_of_smul_pow_mem
    _ hs _ _
  intro r
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà ‚ÜëSubalgebra.toSubmodule (‚®Ü (x : { x // x ‚àà s }), Algebra.a ‚Ä¶
  obtain ‚ü®‚ü®_, n‚ÇÅ, rfl‚ü©, hn‚ÇÅ‚ü© :=
    multiple_mem_adjoin_of_mem_localization_adjoin (Submonoid.powers (r : R))
      (Localization.Away (r : R)) (s‚ÇÅ r : Set (Localization.Away (f r)))
      (algebraMap S (Localization.Away (f r)) x) (by rw [s‚ÇÇ r]; trivial)
  rw [Submonoid.smul_def, Algebra.smul_def, IsScalarTower.algebraMap_apply R S, ‚Üê map_mul] at hn‚ÇÅ
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà ‚ÜëSubalgebra.toSubmodule (‚®Ü (x : { x // x ‚àà s }), Algebra.a ‚Ä¶
  obtain ‚ü®‚ü®_, n‚ÇÇ, rfl‚ü©, hn‚ÇÇ‚ü© :=
    IsLocalization.lift_mem_adjoin_finsetIntegerMultiple (Submonoid.powers (r : R)) _ (s‚ÇÅ r) hn‚ÇÅ
  rw [Submonoid.smul_def, ‚Üê Algebra.smul_def, smul_smul, Subtype.coe_mk, ‚Üê pow_add] at hn‚ÇÇ
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà ‚ÜëSubalgebra.toSubmodule (‚®Ü (x : { x // x ‚àà s }), Algebra.a ‚Ä¶
  simp_rw [Submonoid.map_powers] at hn‚ÇÇ
  -- ‚ä¢ ‚àÉ n, ‚Üër ^ n ‚Ä¢ x ‚àà ‚ÜëSubalgebra.toSubmodule (‚®Ü (x : { x // x ‚àà s }), Algebra.a ‚Ä¶
  use n‚ÇÇ + n‚ÇÅ
  -- ‚ä¢ ‚Üër ^ (n‚ÇÇ + n‚ÇÅ) ‚Ä¢ x ‚àà ‚ÜëSubalgebra.toSubmodule (‚®Ü (x : { x // x ‚àà s }), Algebr ‚Ä¶
  exact le_iSup (fun x : s => Algebra.adjoin R (sf x : Set S)) r hn‚ÇÇ
  -- üéâ no goals
#align finite_type_of_localization_span finiteType_ofLocalizationSpan

end FiniteType
