/-
Copyright (c) 2025 Jingting Wang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zhixuan Dai, Yiming Fu, Zhenyan Fu, Raphael Douglas Giles, Jiedong Jiang, Jingting Wang
-/
import Mathlib.Algebra.RingQuot
import Mathlib.RingTheory.GradedAlgebra.Basic

/-!
# Homogeneous Relation

In this file, we define the property of an ideal being homogeneous.

## Main Definitions

* `IsHomogeneousRelation`: a relation `r : A → A → Prop` is homogeneous with respect to the grading
  `𝒜` if `r x y` implies that for every index `i`, the projection of `x` and `y` onto the `i`-th
  grading piece satisfies the equivalence relation generated by `r`.

## Main Results

* We proved that taking `RingQuot` of a graded ring (or graded algebra) by a homogeneous relation
  gives a graded strucutre on the quotient ring.
-/

variable {ι : Type*} [DecidableEq ι] [AddMonoid ι]
variable {A : Type*} [Semiring A]

/-- a relation `r : A → A → Prop` is homogeneous with respect to the grading `𝒜` if `r x y` implies
  that for every index `i`, the projection of `x` and `y` onto the `i`-th grading piece satisfies
  the equivalence relation generated by `r`. -/
class IsHomogeneousRelation {σ : Type*} [SetLike σ A] [AddSubmonoidClass σ A] (𝒜 : ι → σ)
  [GradedRing 𝒜] (r : A → A → Prop) : Prop where
  is_homogeneous' : ∀ {x y : A}, r x y →
  ∀ i : ι, (Relation.EqvGen r) ((GradedRing.proj 𝒜 i) x) ((GradedRing.proj 𝒜 i) y)

namespace HomogeneousRelation

section RingCon

variable {σ : Type*} [SetLike σ A] [AddSubmonoidClass σ A]
variable (𝒜 : ι → σ) [GradedRing 𝒜] (rel : A → A → Prop)

open Relation GradedRing

lemma eqvGen_ringQuot_of_eqvGen {a b : A} (h : EqvGen rel a b) :
    EqvGen (RingQuot.Rel rel) a b := Relation.EqvGen.mono (fun _ _ h' ↦ RingQuot.Rel.of h') h

lemma eqvGen_ringQuot_add_right {a b c : A} (h : EqvGen (RingQuot.Rel rel) a b) :
    EqvGen (RingQuot.Rel rel) (a + c) (b + c) := by
  induction h with
  | rel x y hxy =>
    apply EqvGen.rel
    exact RingQuot.Rel.add_left hxy
  | refl x =>
    exact Quot.eqvGen_exact rfl
  | symm x y h1 h2 =>
    exact EqvGen.symm (x + c) (y + c) h2
  | trans x y z _ _ h1 h2 =>
    exact EqvGen.trans (x + c) (y + c) (z + c) h1 h2

lemma eqvGen_ringQuot_mul_left {a b c : A} (h : EqvGen (RingQuot.Rel rel) a b) :
    EqvGen (RingQuot.Rel rel) (a * c) (b * c) := by
  induction h with
  | rel x y hxy =>
    apply EqvGen.rel
    exact RingQuot.Rel.mul_left hxy
  | refl x =>
    exact Quot.eqvGen_exact rfl
  | symm x y h1 h2 =>
    exact EqvGen.symm (x * c) (y * c) h2
  | trans x y z _ _ h1 h2 =>
    exact EqvGen.trans (x * c) (y * c) (z * c) h1 h2

lemma eqvGen_ringQuot_mul_right {a b c : A} (h : EqvGen (RingQuot.Rel rel) a b) :
    EqvGen (RingQuot.Rel rel) (c * a) (c * b) := by
  induction h with
  | rel x y hxy =>
    apply EqvGen.rel
    exact RingQuot.Rel.mul_right hxy
  | refl x =>
    exact Quot.eqvGen_exact rfl
  | symm x y h1 h2 =>
    exact EqvGen.symm (c * x) (c * y) h2
  | trans x y z _ _ h1 h2 =>
    exact EqvGen.trans (c * x) (c * y) (c * z) h1 h2

/-- To prove a relation between two products, it suffices to prove that
the relation is multiplicative and holds on factors. -/
@[to_additive "To prove a relation between two sums, it suffices to prove that
the relation is additive and holds on summands."]
lemma Finset.relation_prod_induction {α : Type*} {s : Finset α} [DecidableEq α]
    {M : Type*} [CommMonoid M] (f : α → M) (g : α → M) (r : M → M → Prop)
    (hom : ∀ (a b c d : M), r a b → r c d → r (a * c) (b * d)) (unit : r 1 1)
    (base : ∀ x ∈ s, r (f x) (g x)) :
    r (∏ x ∈ s, f x) (∏ x ∈ s, g x) := by
  induction s using Finset.induction with
  | empty => simpa
  | insert _ _ => simp_all

lemma coe_mul_sum_support_subset {ι : Type*} {σ : Type*} {R : Type*} [DecidableEq ι]
    [Semiring R] [SetLike σ R] [AddSubmonoidClass σ R] (A : ι → σ)
    [(i : ι) → (x : ↥(A i)) → Decidable (x ≠ 0)] (r r' : DirectSum ι fun i ↦ ↥(A i))
    {S T: Finset ι} (hS : DFinsupp.support r ⊆ S) (hT : DFinsupp.support r' ⊆ T)
    (p : ι × ι → Prop) [DecidablePred p] :
    ∑ ij ∈ Finset.filter p (DFinsupp.support r ×ˢ DFinsupp.support r'), ((r ij.1) * (r' ij.2) : R) =
    ∑ ij ∈ Finset.filter p (S ×ˢ T), ((r ij.1) * (r' ij.2) : R) := by
  rw [Finset.sum_filter, Finset.sum_filter]
  apply Finset.sum_subset (Finset.product_subset_product hS hT)
  intro x _ hx
  simp only [Finset.mem_product, DFinsupp.mem_support_toFun, ne_eq, not_and, not_not] at hx
  have : ((r x.1) * (r' x.2) : R) = 0 := by
    by_cases h : r x.1 = 0
    · simp [h]
    · simp [hx h]
  simp [this]

private noncomputable instance : (i : ι) → (x : ↥(𝒜 i)) → Decidable (x ≠ 0) :=
    fun _ x ↦ Classical.propDecidable (x ≠ 0)

theorem eqvGen_proj_mul_right {a b c : A} (n : ι)
    (h : ∀ (i : ι), EqvGen (RingQuot.Rel rel) ((proj 𝒜 i) a) ((proj 𝒜 i) b)) :
    EqvGen (RingQuot.Rel rel) ((proj 𝒜 n) (a * c)) ((proj 𝒜 n) (b * c)) := by
  simp only [proj_apply] at h
  simp only [proj_apply, DirectSum.decompose_mul, DirectSum.coe_mul_apply]
  rw [coe_mul_sum_support_subset 𝒜 _ _ Finset.subset_union_left (Set.Subset.refl _),
    coe_mul_sum_support_subset 𝒜 _ _ Finset.subset_union_right (Set.Subset.refl _)]
  apply Finset.relation_sum_induction
  · intro _ _ _ _ hab hcd
    rw [RingQuot.eqvGen_rel_eq] at hab hcd ⊢
    exact RingConGen.Rel.add hab hcd
  · rw [RingQuot.eqvGen_rel_eq]
    exact RingConGen.Rel.refl 0
  · exact fun x _ => eqvGen_ringQuot_mul_left rel (h x.1)

theorem eqvGen_proj_mul_left {a b c : A} (n : ι)
    (h : ∀ (i : ι), EqvGen (RingQuot.Rel rel) ((proj 𝒜 i) a) ((proj 𝒜 i) b)) :
    EqvGen (RingQuot.Rel rel) ((proj 𝒜 n) (c * a)) ((proj 𝒜 n) (c * b)) := by
  simp only [proj_apply] at h
  simp only [proj_apply, DirectSum.decompose_mul, DirectSum.coe_mul_apply]
  rw [coe_mul_sum_support_subset 𝒜 _ _ (Set.Subset.refl _) Finset.subset_union_left,
    coe_mul_sum_support_subset 𝒜 _ _ (Set.Subset.refl _) Finset.subset_union_right]
  apply Finset.relation_sum_induction
  · intro _ _ _ _ hab hcd
    rw [RingQuot.eqvGen_rel_eq] at hab hcd ⊢
    exact RingConGen.Rel.add hab hcd
  · rw [RingQuot.eqvGen_rel_eq]
    exact RingConGen.Rel.refl 0
  · exact fun x _ => eqvGen_ringQuot_mul_right rel (h x.2)

variable [IsHomogeneousRelation 𝒜 rel]

instance : IsHomogeneousRelation 𝒜 (RingQuot.Rel rel) := ⟨by
  intro x y h; induction h
  case of x y h_rel =>
    intro n
    apply eqvGen_ringQuot_of_eqvGen
    exact IsHomogeneousRelation.is_homogeneous' h_rel n
  case add_left a b c h_rel h =>
    intro n
    rw [map_add, map_add]
    exact eqvGen_ringQuot_add_right rel (h n)
  case mul_left a b c h_rel h =>
    intro n
    exact eqvGen_proj_mul_right 𝒜 rel n h
  case mul_right c a b h_rel h =>
    intro n
    exact eqvGen_proj_mul_left 𝒜 rel n h⟩

instance : IsHomogeneousRelation 𝒜 (Relation.EqvGen rel) := by
  apply IsHomogeneousRelation.mk
  rw [Equivalence.eqvGen_eq (Relation.EqvGen.is_equivalence rel)]
  intro x y h
  induction h with
  | refl => exact fun i ↦ Quot.eqvGen_exact rfl
  | symm x y _ h1 =>
    exact fun i ↦ EqvGen.symm ((proj 𝒜 i) x) ((proj 𝒜 i) y) (h1 i)
  | trans j k l _ _ h2 h3 =>
    exact fun i ↦
      EqvGen.trans ((proj 𝒜 i) j) ((proj 𝒜 i) k) ((proj 𝒜 i) l)
        (h2 i) (h3 i)
  | rel _ _ h4 =>
    exact fun i ↦ IsHomogeneousRelation.is_homogeneous' h4 i

instance : IsHomogeneousRelation 𝒜 (RingConGen.Rel rel) :=
  (RingQuot.eqvGen_rel_eq rel) ▸ inferInstance

end RingCon

section GradedRing

variable (𝒜 : ι → AddSubmonoid A) [inst : GradedRing 𝒜] (rel : A → A → Prop)

instance : SetLike.GradedMonoid ((AddSubmonoid.map (RingQuot.mkRingHom rel)).comp 𝒜) where
  one_mem := by
    use 1
    constructor
    · exact SetLike.GradedOne.one_mem
    · exact map_one (RingQuot.mkRingHom rel)
  mul_mem := by
    intro x y gi gj hi hj
    simp only [Function.comp_apply, Submodule.mem_map]
    rcases hi with ⟨a, ha1, ha2⟩
    rcases hj with ⟨b, hb1, hb2⟩
    use a * b
    constructor
    · exact SetLike.GradedMul.mul_mem ha1 hb1
    · rw [map_mul, ha2, hb2]

variable [IsHomogeneousRelation 𝒜 rel]

open DirectSum in
noncomputable instance : GradedRing ((AddSubmonoid.map (RingQuot.mkRingHom rel)).comp 𝒜) := by
  apply DirectSum.IsInternal.gradedRing
  set ℬ := (AddSubmonoid.map (RingQuot.mkRingHom rel) ∘ 𝒜) with hb
  set f := RingQuot.mkRingHom rel with hf
  set g' : ∀ (i : ι), 𝒜 i →+ ℬ i := fun i ↦ {
    toFun := fun x ↦ ⟨f x, by rw [hb]; exact ⟨x, ⟨x.2, rfl⟩⟩⟩
    map_zero' := by simp
    map_add' := by simp
  } with hg'
  set g := DirectSum.mapRange.addHom g' with hg
  set e := DirectSum.decomposeRingEquiv 𝒜 with he
  set u := DirectSum.coeAddMonoidHom ℬ with hu
  have h_comp : f.toAddMonoidHom.compHom e.symm.toAddMonoidHom = u.comp g := by
    ext i x
    simp [hg, hu, he, hg', decomposeRingEquiv]
  have h_g_surj : Function.Surjective g := by
    refine mapRange.addHom_surjective _ (fun i ↦ hg' ▸ ?_)
    intro x; simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Subtype.exists];
    obtain ⟨x, hx, hx'⟩ := x.2; exact ⟨x, hx, by ext; exact hx'⟩
  simp only [RingHom.toAddMonoidHom_eq_coe, RingEquiv.toRingHom_eq_coe,
    AddMonoidHom.compHom_apply_apply] at h_comp
  constructor
  · intro x y hxy
    obtain ⟨x, rfl⟩ := (h_g_surj.comp e.surjective) x
    obtain ⟨y, rfl⟩ := (h_g_surj.comp e.surjective) y
    change (u.comp g) (e x) = (u.comp g) (e y) at hxy
    simp only [← h_comp, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, RingHom.coe_coe,
      Function.comp_apply, RingEquiv.symm_apply_apply] at hxy
    ext i; simp only [hg, Function.comp_apply, mapRange.addHom_apply, SetLike.coe_eq_coe, hg']
    ext; simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk]
    show f (GradedRing.proj 𝒜 i x) = f (GradedRing.proj 𝒜 i y)
    rw [hf, RingQuot.mkRingHom_eq_iff'] at hxy ⊢
    have : IsHomogeneousRelation 𝒜 (RingConGen.Rel rel) := inferInstance
    have := this.is_homogeneous' hxy i
    rw [← RingQuot.eqvGen_rel_eq rel, Equivalence.eqvGen_eq (Relation.EqvGen.is_equivalence _),
      RingQuot.eqvGen_rel_eq] at this
    exact this
  · intro x; rw [← hu]; obtain ⟨x, rfl⟩ := RingQuot.mkRingHom_surjective rel x
    use g (e x); show (u.comp g) (e x) = (f x)
    simp [← h_comp]

end GradedRing

section GradedAlgebra

variable {R : Type*} [CommSemiring R] [Algebra R A]
variable (𝒜 : ι → Submodule R A) [inst : GradedAlgebra 𝒜] (rel : A → A → Prop)

instance : SetLike.GradedMonoid ((Submodule.map (RingQuot.mkAlgHom R rel)).comp 𝒜) where
  one_mem := by
    use 1
    constructor
    · exact SetLike.GradedOne.one_mem
    · exact map_one (RingQuot.mkAlgHom R rel)
  mul_mem := by
    intro x y gi gj hi hj
    simp only [Function.comp_apply, Submodule.mem_map]
    rcases hi with ⟨a, ha1, ha2⟩
    rcases hj with ⟨b, hb1, hb2⟩
    use a * b
    constructor
    · exact SetLike.GradedMul.mul_mem ha1 hb1
    · rw [map_mul, ha2, hb2]

variable [IsHomogeneousRelation 𝒜 rel]

open DirectSum in
noncomputable instance : GradedAlgebra ((Submodule.map (RingQuot.mkAlgHom R rel)).comp 𝒜) := by
  apply DirectSum.IsInternal.gradedRing
  set ℬ := (Submodule.map (RingQuot.mkAlgHom R rel)).comp 𝒜 with hb
  set f := RingQuot.mkAlgHom R rel with hf
  set g' : ∀ (i : ι), 𝒜 i →+ ℬ i := fun i ↦ {
    toFun := fun x ↦ ⟨f x, by rw [hb]; exact ⟨x, ⟨x.2, rfl⟩⟩⟩
    map_zero' := by simp
    map_add' := by simp
  } with hg'
  set g := DirectSum.mapRange.addHom g' with hg
  set e := DirectSum.decomposeRingEquiv 𝒜 with he
  set u := DirectSum.coeAddMonoidHom ℬ with hu
  have h_comp : f.toAddMonoidHom.compHom e.symm.toAddMonoidHom = u.comp g := by
    ext i x
    simp [hg, hu, he, hg', decomposeRingEquiv]
  have h_g_surj : Function.Surjective g := by
    refine mapRange.addHom_surjective _ (fun i ↦ hg' ▸ ?_)
    intro x; simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk, Subtype.exists];
    obtain ⟨x, hx, hx'⟩ := x.2; exact ⟨x, hx, by ext; exact hx'⟩
  simp only [RingHom.toAddMonoidHom_eq_coe, RingEquiv.toRingHom_eq_coe,
    AddMonoidHom.compHom_apply_apply] at h_comp
  constructor
  · intro x y hxy
    obtain ⟨x, rfl⟩ := (h_g_surj.comp e.surjective) x
    obtain ⟨y, rfl⟩ := (h_g_surj.comp e.surjective) y
    change (u.comp g) (e x) = (u.comp g) (e y) at hxy
    simp only [← h_comp, AddMonoidHom.coe_comp, AddMonoidHom.coe_coe, RingHom.coe_coe,
      Function.comp_apply, RingEquiv.symm_apply_apply] at hxy
    change f x = f y at hxy
    ext i; simp only [hg, Function.comp_apply, mapRange.addHom_apply, SetLike.coe_eq_coe, hg']
    ext; simp only [AddMonoidHom.coe_mk, ZeroHom.coe_mk]
    show f (GradedRing.proj 𝒜 i x) = f (GradedRing.proj 𝒜 i y)
    rw [hf, RingQuot.mkAlgHom_eq_iff' R] at hxy ⊢
    have : IsHomogeneousRelation 𝒜 (RingConGen.Rel rel) := inferInstance
    have := this.is_homogeneous' hxy i
    rw [← RingQuot.eqvGen_rel_eq rel, Equivalence.eqvGen_eq (Relation.EqvGen.is_equivalence _),
      RingQuot.eqvGen_rel_eq] at this
    exact this
  · intro x; rw [← hu]; obtain ⟨x, rfl⟩ := RingQuot.mkAlgHom_surjective R rel x
    use g (e x); show (u.comp g) (e x) = (f x)
    simp [← h_comp]

end GradedAlgebra

end HomogeneousRelation
