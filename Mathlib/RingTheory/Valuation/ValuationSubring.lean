/-
Copyright (c) 2022 Adam Topaz. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Adam Topaz, Junyan Xu, Jack McKoen
-/
import Mathlib.RingTheory.Valuation.ValuationRing
import Mathlib.RingTheory.Localization.AsSubring
import Mathlib.RingTheory.Subring.Pointwise
import Mathlib.AlgebraicGeometry.PrimeSpectrum.Basic

#align_import ring_theory.valuation.valuation_subring from "leanprover-community/mathlib"@"2196ab363eb097c008d4497125e0dde23fb36db2"

/-!

# Valuation subrings of a field

## Projects

The order structure on `ValuationSubring K`.

-/


universe u

open scoped Classical

noncomputable section

variable (K : Type u) [Field K]

/-- A valuation subring of a field `K` is a subring `A` such that for every `x : K`,
either `x ‚àà A` or `x‚Åª¬π ‚àà A`. -/
structure ValuationSubring extends Subring K where
  mem_or_inv_mem' : ‚àÄ x : K, x ‚àà carrier ‚à® x‚Åª¬π ‚àà carrier
#align valuation_subring ValuationSubring

namespace ValuationSubring

variable {K}
variable (A : ValuationSubring K)

instance : SetLike (ValuationSubring K) K where
  coe A := A.toSubring
  coe_injective' := by
    intro ‚ü®_, _‚ü© ‚ü®_, _‚ü© h
    -- ‚ä¢ { toSubring := toSubring‚úù¬π, mem_or_inv_mem' := mem_or_inv_mem'‚úù¬π } = { toSub ‚Ä¶
    replace h := SetLike.coe_injective' h
    -- ‚ä¢ { toSubring := toSubring‚úù¬π, mem_or_inv_mem' := mem_or_inv_mem'‚úù¬π } = { toSub ‚Ä¶
    congr
    -- üéâ no goals

@[simp, nolint simpNF] -- Porting note: simp cannot prove that
theorem mem_carrier (x : K) : x ‚àà A.carrier ‚Üî x ‚àà A := Iff.refl _
#align valuation_subring.mem_carrier ValuationSubring.mem_carrier

@[simp]
theorem mem_toSubring (x : K) : x ‚àà A.toSubring ‚Üî x ‚àà A := Iff.refl _
#align valuation_subring.mem_to_subring ValuationSubring.mem_toSubring

@[ext]
theorem ext (A B : ValuationSubring K) (h : ‚àÄ x, x ‚àà A ‚Üî x ‚àà B) : A = B := SetLike.ext h
#align valuation_subring.ext ValuationSubring.ext

theorem zero_mem : (0 : K) ‚àà A := A.toSubring.zero_mem
#align valuation_subring.zero_mem ValuationSubring.zero_mem

theorem one_mem : (1 : K) ‚àà A := A.toSubring.one_mem
#align valuation_subring.one_mem ValuationSubring.one_mem

theorem add_mem (x y : K) : x ‚àà A ‚Üí y ‚àà A ‚Üí x + y ‚àà A := A.toSubring.add_mem
#align valuation_subring.add_mem ValuationSubring.add_mem

theorem mul_mem (x y : K) : x ‚àà A ‚Üí y ‚àà A ‚Üí x * y ‚àà A := A.toSubring.mul_mem
#align valuation_subring.mul_mem ValuationSubring.mul_mem

theorem neg_mem (x : K) : x ‚àà A ‚Üí -x ‚àà A := A.toSubring.neg_mem
#align valuation_subring.neg_mem ValuationSubring.neg_mem

theorem mem_or_inv_mem (x : K) : x ‚àà A ‚à® x‚Åª¬π ‚àà A := A.mem_or_inv_mem' _
#align valuation_subring.mem_or_inv_mem ValuationSubring.mem_or_inv_mem

instance : SubringClass (ValuationSubring K) K where
  zero_mem := zero_mem
  add_mem {_} a b := add_mem _ a b
  one_mem := one_mem
  mul_mem {_} a b := mul_mem _ a b
  neg_mem {_} x := neg_mem _ x

theorem toSubring_injective : Function.Injective (toSubring : ValuationSubring K ‚Üí Subring K) :=
  fun x y h => by cases x; cases y; congr
                  -- ‚ä¢ { toSubring := toSubring‚úù, mem_or_inv_mem' := mem_or_inv_mem'‚úù } = y
                           -- ‚ä¢ { toSubring := toSubring‚úù¬π, mem_or_inv_mem' := mem_or_inv_mem'‚úù¬π } = { toSub ‚Ä¶
                                    -- üéâ no goals
#align valuation_subring.to_subring_injective ValuationSubring.toSubring_injective

instance : CommRing A :=
  show CommRing A.toSubring by infer_instance
                               -- üéâ no goals

instance : IsDomain A :=
  show IsDomain A.toSubring by infer_instance
                               -- üéâ no goals

instance : Top (ValuationSubring K) :=
  Top.mk <| { (‚ä§ : Subring K) with mem_or_inv_mem' := fun _ => Or.inl trivial }

theorem mem_top (x : K) : x ‚àà (‚ä§ : ValuationSubring K) :=
  trivial
#align valuation_subring.mem_top ValuationSubring.mem_top

theorem le_top : A ‚â§ ‚ä§ := fun _a _ha => mem_top _
#align valuation_subring.le_top ValuationSubring.le_top

instance : OrderTop (ValuationSubring K) where
  top := ‚ä§
  le_top := le_top

instance : Inhabited (ValuationSubring K) :=
  ‚ü®‚ä§‚ü©

instance : ValuationRing A where
  cond' a b := by
    by_cases (b : K) = 0
    -- ‚ä¢ ‚àÉ c, a * c = b ‚à® b * c = a
    -- ‚ä¢ ‚àÉ c, a * c = b ‚à® b * c = a
    ¬∑ use 0
      -- ‚ä¢ a * 0 = b ‚à® b * 0 = a
      left
      -- ‚ä¢ a * 0 = b
      ext
      -- ‚ä¢ ‚Üë(a * 0) = ‚Üëb
      simp [h]
      -- üéâ no goals
    by_cases (a : K) = 0
    -- ‚ä¢ ‚àÉ c, a * c = b ‚à® b * c = a
    -- ‚ä¢ ‚àÉ c, a * c = b ‚à® b * c = a
    ¬∑ use 0; right
      -- ‚ä¢ a * 0 = b ‚à® b * 0 = a
             -- ‚ä¢ b * 0 = a
      ext
      -- ‚ä¢ ‚Üë(b * 0) = ‚Üëa
      simp [h]
      -- üéâ no goals
    cases' A.mem_or_inv_mem (a / b) with hh hh
    -- ‚ä¢ ‚àÉ c, a * c = b ‚à® b * c = a
    ¬∑ use ‚ü®a / b, hh‚ü©
      -- ‚ä¢ a * { val := ‚Üëa / ‚Üëb, property := hh } = b ‚à® b * { val := ‚Üëa / ‚Üëb, property  ‚Ä¶
      right
      -- ‚ä¢ b * { val := ‚Üëa / ‚Üëb, property := hh } = a
      ext
      -- ‚ä¢ ‚Üë(b * { val := ‚Üëa / ‚Üëb, property := hh }) = ‚Üëa
      field_simp
      -- ‚ä¢ ‚Üëb * ‚Üëa = ‚Üëa * ‚Üëb
      ring
      -- üéâ no goals
    ¬∑ rw [show (a / b : K)‚Åª¬π = b / a by field_simp] at hh
      -- ‚ä¢ ‚àÉ c, a * c = b ‚à® b * c = a
      use ‚ü®b / a, hh‚ü©;
      -- ‚ä¢ a * { val := ‚Üëb / ‚Üëa, property := hh } = b ‚à® b * { val := ‚Üëb / ‚Üëa, property  ‚Ä¶
      left
      -- ‚ä¢ a * { val := ‚Üëb / ‚Üëa, property := hh } = b
      ext
      -- ‚ä¢ ‚Üë(a * { val := ‚Üëb / ‚Üëa, property := hh }) = ‚Üëb
      field_simp
      -- ‚ä¢ ‚Üëa * ‚Üëb = ‚Üëb * ‚Üëa
      ring
      -- üéâ no goals

instance : Algebra A K :=
  show Algebra A.toSubring K by infer_instance
                                -- üéâ no goals

-- Porting note: Somehow it cannot find this instance and I'm too lazy to debug. wrong prio?
instance localRing : LocalRing A := ValuationRing.localRing A

@[simp]
theorem algebraMap_apply (a : A) : algebraMap A K a = a := rfl
#align valuation_subring.algebra_map_apply ValuationSubring.algebraMap_apply

instance : IsFractionRing A K where
  map_units' := fun ‚ü®y, hy‚ü© =>
    (Units.mk0 (y : K) fun c => nonZeroDivisors.ne_zero hy <| Subtype.ext c).isUnit
  surj' z := by
    by_cases z = 0; ¬∑ use (0, 1); simp [h]
    -- ‚ä¢ ‚àÉ x, z * ‚Üë(algebraMap { x // x ‚àà A } K) ‚Üëx.snd = ‚Üë(algebraMap { x // x ‚àà A } ‚Ä¶
    -- ‚ä¢ ‚àÉ x, z * ‚Üë(algebraMap { x // x ‚àà A } K) ‚Üëx.snd = ‚Üë(algebraMap { x // x ‚àà A } ‚Ä¶
                      -- ‚ä¢ z * ‚Üë(algebraMap { x // x ‚àà A } K) ‚Üë(0, 1).snd = ‚Üë(algebraMap { x // x ‚àà A } ‚Ä¶
                                  -- üéâ no goals
    cases' A.mem_or_inv_mem z with hh hh
    -- ‚ä¢ ‚àÉ x, z * ‚Üë(algebraMap { x // x ‚àà A } K) ‚Üëx.snd = ‚Üë(algebraMap { x // x ‚àà A } ‚Ä¶
    ¬∑ use (‚ü®z, hh‚ü©, 1); simp
      -- ‚ä¢ z * ‚Üë(algebraMap { x // x ‚àà A } K) ‚Üë({ val := z, property := hh }, 1).snd =  ‚Ä¶
                        -- üéâ no goals
    ¬∑ refine ‚ü®‚ü®1, ‚ü®‚ü®_, hh‚ü©, ?_‚ü©‚ü©, mul_inv_cancel h‚ü©
      -- ‚ä¢ { val := z‚Åª¬π, property := hh } ‚àà nonZeroDivisors { x // x ‚àà A }
      exact mem_nonZeroDivisors_iff_ne_zero.2 fun c => h (inv_eq_zero.mp (congr_arg Subtype.val c))
      -- üéâ no goals
  eq_iff_exists' {a b} :=
    ‚ü®fun h => ‚ü®1, by ext; simpa using h‚ü©, fun ‚ü®c, h‚ü© =>
                     -- ‚ä¢ ‚Üë(‚Üë1 * a) = ‚Üë(‚Üë1 * b)
                          -- üéâ no goals
      congr_arg Subtype.val ((mul_eq_mul_left_iff.1 h).resolve_right (nonZeroDivisors.ne_zero c.2))‚ü©

/-- The value group of the valuation associated to `A`. Note: it is actually a group with zero. -/
def ValueGroup :=
  ValuationRing.ValueGroup A K
-- deriving LinearOrderedCommGroupWithZero
#align valuation_subring.value_group ValuationSubring.ValueGroup

-- Porting note: see https://github.com/leanprover-community/mathlib4/issues/5020
instance : LinearOrderedCommGroupWithZero (ValueGroup A) := by
  unfold ValueGroup
  -- ‚ä¢ LinearOrderedCommGroupWithZero (ValuationRing.ValueGroup { x // x ‚àà A } K)
  infer_instance
  -- üéâ no goals

/-- Any valuation subring of `K` induces a natural valuation on `K`. -/
def valuation : Valuation K A.ValueGroup :=
  ValuationRing.valuation A K
#align valuation_subring.valuation ValuationSubring.valuation

instance inhabitedValueGroup : Inhabited A.ValueGroup := ‚ü®A.valuation 0‚ü©
#align valuation_subring.inhabited_value_group ValuationSubring.inhabitedValueGroup

theorem valuation_le_one (a : A) : A.valuation a ‚â§ 1 :=
  (ValuationRing.mem_integer_iff A K _).2 ‚ü®a, rfl‚ü©
#align valuation_subring.valuation_le_one ValuationSubring.valuation_le_one

theorem mem_of_valuation_le_one (x : K) (h : A.valuation x ‚â§ 1) : x ‚àà A :=
  let ‚ü®a, ha‚ü© := (ValuationRing.mem_integer_iff A K x).1 h
  ha ‚ñ∏ a.2
#align valuation_subring.mem_of_valuation_le_one ValuationSubring.mem_of_valuation_le_one

theorem valuation_le_one_iff (x : K) : A.valuation x ‚â§ 1 ‚Üî x ‚àà A :=
  ‚ü®mem_of_valuation_le_one _ _, fun ha => A.valuation_le_one ‚ü®x, ha‚ü©‚ü©
#align valuation_subring.valuation_le_one_iff ValuationSubring.valuation_le_one_iff

theorem valuation_eq_iff (x y : K) : A.valuation x = A.valuation y ‚Üî ‚àÉ a : AÀ£, (a : K) * y = x :=
  Quotient.eq''
#align valuation_subring.valuation_eq_iff ValuationSubring.valuation_eq_iff

theorem valuation_le_iff (x y : K) : A.valuation x ‚â§ A.valuation y ‚Üî ‚àÉ a : A, (a : K) * y = x :=
  Iff.rfl
#align valuation_subring.valuation_le_iff ValuationSubring.valuation_le_iff

theorem valuation_surjective : Function.Surjective A.valuation := surjective_quot_mk _
#align valuation_subring.valuation_surjective ValuationSubring.valuation_surjective

theorem valuation_unit (a : AÀ£) : A.valuation a = 1 := by
  rw [‚Üê A.valuation.map_one, valuation_eq_iff]; use a; simp
  -- ‚ä¢ ‚àÉ a_1, ‚Üë‚Üëa_1 * 1 = ‚Üë‚Üëa
                                                -- ‚ä¢ ‚Üë‚Üëa * 1 = ‚Üë‚Üëa
                                                       -- üéâ no goals
#align valuation_subring.valuation_unit ValuationSubring.valuation_unit

theorem valuation_eq_one_iff (a : A) : IsUnit a ‚Üî A.valuation a = 1 :=
  ‚ü®fun h => A.valuation_unit h.unit, fun h => by
    have ha : (a : K) ‚â† 0
    -- ‚ä¢ ‚Üëa ‚â† 0
    ¬∑ intro c
      -- ‚ä¢ False
      rw [c, A.valuation.map_zero] at h
      -- ‚ä¢ False
      exact zero_ne_one h
      -- üéâ no goals
    have ha' : (a : K)‚Åª¬π ‚àà A := by rw [‚Üê valuation_le_one_iff, map_inv‚ÇÄ, h, inv_one]
    -- ‚ä¢ IsUnit a
    apply isUnit_of_mul_eq_one a ‚ü®a‚Åª¬π, ha'‚ü©; ext; field_simp‚ü©
    -- ‚ä¢ a * { val := (‚Üëa)‚Åª¬π, property := ha' } = 1
                                             -- ‚ä¢ ‚Üë(a * { val := (‚Üëa)‚Åª¬π, property := ha' }) = ‚Üë1
                                                  -- üéâ no goals
#align valuation_subring.valuation_eq_one_iff ValuationSubring.valuation_eq_one_iff

theorem valuation_lt_one_or_eq_one (a : A) : A.valuation a < 1 ‚à® A.valuation a = 1 :=
  lt_or_eq_of_le (A.valuation_le_one a)
#align valuation_subring.valuation_lt_one_or_eq_one ValuationSubring.valuation_lt_one_or_eq_one

theorem valuation_lt_one_iff (a : A) : a ‚àà LocalRing.maximalIdeal A ‚Üî A.valuation a < 1 := by
  rw [LocalRing.mem_maximalIdeal]
  -- ‚ä¢ a ‚àà nonunits { x // x ‚àà A } ‚Üî ‚Üë(valuation A) ‚Üëa < 1
  dsimp [nonunits]; rw [valuation_eq_one_iff]
  -- ‚ä¢ ¬¨IsUnit a ‚Üî ‚Üë(valuation A) ‚Üëa < 1
                    -- ‚ä¢ ¬¨‚Üë(valuation A) ‚Üëa = 1 ‚Üî ‚Üë(valuation A) ‚Üëa < 1
  exact (A.valuation_le_one a).lt_iff_ne.symm
  -- üéâ no goals
#align valuation_subring.valuation_lt_one_iff ValuationSubring.valuation_lt_one_iff

/-- A subring `R` of `K` such that for all `x : K` either `x ‚àà R` or `x‚Åª¬π ‚àà R` is
  a valuation subring of `K`. -/
def ofSubring (R : Subring K) (hR : ‚àÄ x : K, x ‚àà R ‚à® x‚Åª¬π ‚àà R) : ValuationSubring K :=
  { R with mem_or_inv_mem' := hR }
#align valuation_subring.of_subring ValuationSubring.ofSubring

@[simp]
theorem mem_ofSubring (R : Subring K) (hR : ‚àÄ x : K, x ‚àà R ‚à® x‚Åª¬π ‚àà R) (x : K) :
    x ‚àà ofSubring R hR ‚Üî x ‚àà R :=
  Iff.refl _
#align valuation_subring.mem_of_subring ValuationSubring.mem_ofSubring

/-- An overring of a valuation ring is a valuation ring. -/
def ofLE (R : ValuationSubring K) (S : Subring K) (h : R.toSubring ‚â§ S) : ValuationSubring K :=
  { S with mem_or_inv_mem' := fun x => (R.mem_or_inv_mem x).imp (@h x) (@h _) }
#align valuation_subring.of_le ValuationSubring.ofLE

section Order

instance : SemilatticeSup (ValuationSubring K) :=
  { (inferInstance : PartialOrder (ValuationSubring K)) with
    sup := fun R S => ofLE R (R.toSubring ‚äî S.toSubring) <| le_sup_left
    le_sup_left := fun R S _ hx => (le_sup_left : R.toSubring ‚â§ R.toSubring ‚äî S.toSubring) hx
    le_sup_right := fun R S _ hx => (le_sup_right : S.toSubring ‚â§ R.toSubring ‚äî S.toSubring) hx
    sup_le := fun R S T hR hT _ hx => (sup_le hR hT : R.toSubring ‚äî S.toSubring ‚â§ T.toSubring) hx }

/-- The ring homomorphism induced by the partial order. -/
def inclusion (R S : ValuationSubring K) (h : R ‚â§ S) : R ‚Üí+* S :=
  Subring.inclusion h
#align valuation_subring.inclusion ValuationSubring.inclusion

/-- The canonical ring homomorphism from a valuation ring to its field of fractions. -/
def subtype (R : ValuationSubring K) : R ‚Üí+* K :=
  Subring.subtype R.toSubring
#align valuation_subring.subtype ValuationSubring.subtype

/-- The canonical map on value groups induced by a coarsening of valuation rings. -/
def mapOfLE (R S : ValuationSubring K) (h : R ‚â§ S) : R.ValueGroup ‚Üí*‚ÇÄ S.ValueGroup where
  toFun := Quotient.map' id fun x y ‚ü®u, hu‚ü© => ‚ü®Units.map (R.inclusion S h).toMonoidHom u, hu‚ü©
  map_zero' := rfl
  map_one' := rfl
  map_mul' := by rintro ‚ü®‚ü© ‚ü®‚ü©; rfl
                 -- ‚ä¢ ZeroHom.toFun { toFun := Quotient.map' id (_ : ‚àÄ (x y : K), Setoid.r x y ‚Üí S ‚Ä¶
                               -- üéâ no goals
#align valuation_subring.map_of_le ValuationSubring.mapOfLE

@[mono]
theorem monotone_mapOfLE (R S : ValuationSubring K) (h : R ‚â§ S) : Monotone (R.mapOfLE S h) := by
  rintro ‚ü®‚ü© ‚ü®‚ü© ‚ü®a, ha‚ü©; exact ‚ü®R.inclusion S h a, ha‚ü©
  -- ‚ä¢ ‚Üë(mapOfLE R S h) (Quot.mk Setoid.r a‚úù¬π) ‚â§ ‚Üë(mapOfLE R S h) (Quot.mk Setoid.r ‚Ä¶
                        -- üéâ no goals
#align valuation_subring.monotone_map_of_le ValuationSubring.monotone_mapOfLE

@[simp]
theorem mapOfLE_comp_valuation (R S : ValuationSubring K) (h : R ‚â§ S) :
    R.mapOfLE S h ‚àò R.valuation = S.valuation := by ext; rfl
                                                    -- ‚ä¢ (‚Üë(mapOfLE R S h) ‚àò ‚Üë(valuation R)) x‚úù = ‚Üë(valuation S) x‚úù
                                                         -- üéâ no goals
#align valuation_subring.map_of_le_comp_valuation ValuationSubring.mapOfLE_comp_valuation

@[simp]
theorem mapOfLE_valuation_apply (R S : ValuationSubring K) (h : R ‚â§ S) (x : K) :
    R.mapOfLE S h (R.valuation x) = S.valuation x := rfl
#align valuation_subring.map_of_le_valuation_apply ValuationSubring.mapOfLE_valuation_apply

/-- The ideal corresponding to a coarsening of a valuation ring. -/
def idealOfLE (R S : ValuationSubring K) (h : R ‚â§ S) : Ideal R :=
  (LocalRing.maximalIdeal S).comap (R.inclusion S h)
#align valuation_subring.ideal_of_le ValuationSubring.idealOfLE

instance prime_idealOfLE (R S : ValuationSubring K) (h : R ‚â§ S) : (idealOfLE R S h).IsPrime :=
  (LocalRing.maximalIdeal S).comap_isPrime _
#align valuation_subring.prime_ideal_of_le ValuationSubring.prime_idealOfLE

/-- The coarsening of a valuation ring associated to a prime ideal. -/
def ofPrime (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] : ValuationSubring K :=
  ofLE A (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors).toSubring
    -- Porting note: added `Subalgebra.mem_toSubring.mpr`
    fun a ha => Subalgebra.mem_toSubring.mpr <|
      Subalgebra.algebraMap_mem
        (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors) (‚ü®a, ha‚ü© : A)
#align valuation_subring.of_prime ValuationSubring.ofPrime

instance ofPrimeAlgebra (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :
    Algebra A (A.ofPrime P) :=
  -- Porting note: filled in the argument
  Subalgebra.algebra (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors)
#align valuation_subring.of_prime_algebra ValuationSubring.ofPrimeAlgebra

instance ofPrime_scalar_tower (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :
    -- Porting note: added instance
    letI : SMul A (A.ofPrime P) := SMulZeroClass.toSMul
    IsScalarTower A (A.ofPrime P) K :=
  IsScalarTower.subalgebra' A K K
    -- Porting note: filled in the argument
    (Localization.subalgebra.ofField K _ P.primeCompl_le_nonZeroDivisors)
#align valuation_subring.of_prime_scalar_tower ValuationSubring.ofPrime_scalar_tower

instance ofPrime_localization (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :
    IsLocalization.AtPrime (A.ofPrime P) P := by
  apply
    Localization.subalgebra.isLocalization_ofField K P.primeCompl
      P.primeCompl_le_nonZeroDivisors
#align valuation_subring.of_prime_localization ValuationSubring.ofPrime_localization

theorem le_ofPrime (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] : A ‚â§ ofPrime A P :=
  -- Porting note: added `Subalgebra.mem_toSubring.mpr`
  fun a ha => Subalgebra.mem_toSubring.mpr <| Subalgebra.algebraMap_mem _ (‚ü®a, ha‚ü© : A)
#align valuation_subring.le_of_prime ValuationSubring.le_ofPrime

theorem ofPrime_valuation_eq_one_iff_mem_primeCompl (A : ValuationSubring K) (P : Ideal A)
    [P.IsPrime] (x : A) : (ofPrime A P).valuation x = 1 ‚Üî x ‚àà P.primeCompl := by
  rw [‚Üê IsLocalization.AtPrime.isUnit_to_map_iff (A.ofPrime P) P x, valuation_eq_one_iff]; rfl
  -- ‚ä¢ ‚Üë(valuation (ofPrime A P)) ‚Üëx = 1 ‚Üî ‚Üë(valuation (ofPrime A P)) ‚Üë(‚Üë(algebraMa ‚Ä¶
                                                                                           -- üéâ no goals
#align valuation_subring.of_prime_valuation_eq_one_iff_mem_prime_compl ValuationSubring.ofPrime_valuation_eq_one_iff_mem_primeCompl

@[simp]
theorem idealOfLE_ofPrime (A : ValuationSubring K) (P : Ideal A) [P.IsPrime] :
    idealOfLE A (ofPrime A P) (le_ofPrime A P) = P := by
  refine Ideal.ext (fun x => ?_)
  -- ‚ä¢ x ‚àà idealOfLE A (ofPrime A P) (_ : A ‚â§ ofPrime A P) ‚Üî x ‚àà P
  apply IsLocalization.AtPrime.to_map_mem_maximal_iff
  -- ‚ä¢ optParam (LocalRing { x // x ‚àà ofPrime A P }) (_ : LocalRing { x // x ‚àà ofPr ‚Ä¶
  exact localRing (ofPrime A P)
  -- üéâ no goals
#align valuation_subring.ideal_of_le_of_prime ValuationSubring.idealOfLE_ofPrime

@[simp]
theorem ofPrime_idealOfLE (R S : ValuationSubring K) (h : R ‚â§ S) :
    ofPrime R (idealOfLE R S h) = S := by
  ext x; constructor
  -- ‚ä¢ x ‚àà ofPrime R (idealOfLE R S h) ‚Üî x ‚àà S
         -- ‚ä¢ x ‚àà ofPrime R (idealOfLE R S h) ‚Üí x ‚àà S
  ¬∑ rintro ‚ü®a, r, hr, rfl‚ü©; apply mul_mem; ¬∑ exact h a.2
    -- ‚ä¢ ‚Üë(algebraMap { x // x ‚àà R } K) a * (‚Üë(algebraMap { x // x ‚àà R } K) r)‚Åª¬π ‚àà S
                            -- ‚ä¢ ‚Üë(algebraMap { x // x ‚àà R } K) a ‚àà S
                                             -- üéâ no goals
    ¬∑ rw [‚Üê valuation_le_one_iff, map_inv‚ÇÄ, ‚Üê inv_one, inv_le_inv‚ÇÄ]
      ¬∑ exact not_lt.1 ((not_iff_not.2 <| valuation_lt_one_iff S _).1 hr)
        -- üéâ no goals
      ¬∑ intro hh; erw [Valuation.zero_iff, Subring.coe_eq_zero_iff] at hh
        -- ‚ä¢ False
                  -- ‚ä¢ False
        apply hr; rw [hh]; apply Ideal.zero_mem (R.idealOfLE S h)
        -- ‚ä¢ r ‚àà ‚Üë(idealOfLE R S h)
                  -- ‚ä¢ 0 ‚àà ‚Üë(idealOfLE R S h)
                           -- üéâ no goals
      ¬∑ exact one_ne_zero
        -- üéâ no goals
  ¬∑ intro hx; by_cases hr : x ‚àà R; ¬∑ exact R.le_ofPrime _ hr
    -- ‚ä¢ x ‚àà ofPrime R (idealOfLE R S h)
              -- ‚ä¢ x ‚àà ofPrime R (idealOfLE R S h)
                                     -- üéâ no goals
    have : x ‚â† 0 := fun h => hr (by rw [h]; exact R.zero_mem)
    -- ‚ä¢ x ‚àà ofPrime R (idealOfLE R S h)
    replace hr := (R.mem_or_inv_mem x).resolve_left hr
    -- ‚ä¢ x ‚àà ofPrime R (idealOfLE R S h)
    ¬∑ -- Porting note: added `‚ü®‚ü©` brackets and reordered goals
      use 1, ‚ü®x‚Åª¬π, hr‚ü©; constructor
      -- ‚ä¢ ‚àÉ x_1, x = ‚Üë(algebraMap { x // x ‚àà R } K) 1 * (‚Üë(algebraMap { x // x ‚àà R } K ‚Ä¶
                        -- ‚ä¢ x = ‚Üë(algebraMap { x // x ‚àà R } K) 1 * (‚Üë(algebraMap { x // x ‚àà R } K) { val ‚Ä¶
      ¬∑ field_simp
        -- üéâ no goals
      ¬∑ change (‚ü®x‚Åª¬π, h hr‚ü© : S) ‚àâ nonunits S
        -- ‚ä¢ ¬¨{ val := x‚Åª¬π, property := (_ : x‚Åª¬π ‚àà S) } ‚àà nonunits { x // x ‚àà S }
        rw [mem_nonunits_iff, Classical.not_not]
        -- ‚ä¢ IsUnit { val := x‚Åª¬π, property := (_ : x‚Åª¬π ‚àà S) }
        apply isUnit_of_mul_eq_one _ (‚ü®x, hx‚ü© : S)
        -- ‚ä¢ { val := x‚Åª¬π, property := (_ : x‚Åª¬π ‚àà S) } * { val := x, property := hx } = 1
        ext; field_simp
        -- ‚ä¢ ‚Üë({ val := x‚Åª¬π, property := (_ : x‚Åª¬π ‚àà S) } * { val := x, property := hx })  ‚Ä¶
             -- üéâ no goals
#align valuation_subring.of_prime_ideal_of_le ValuationSubring.ofPrime_idealOfLE

theorem ofPrime_le_of_le (P Q : Ideal A) [P.IsPrime] [Q.IsPrime] (h : P ‚â§ Q) :
    ofPrime A Q ‚â§ ofPrime A P := fun _x ‚ü®a, s, hs, he‚ü© => ‚ü®a, s, fun c => hs (h c), he‚ü©
#align valuation_subring.of_prime_le_of_le ValuationSubring.ofPrime_le_of_le

theorem idealOfLE_le_of_le (R S : ValuationSubring K) (hR : A ‚â§ R) (hS : A ‚â§ S) (h : R ‚â§ S) :
    idealOfLE A S hS ‚â§ idealOfLE A R hR := fun x hx =>
  (valuation_lt_one_iff R _).2
    (by
      by_contra c; push_neg at c; replace c := monotone_mapOfLE R S h c
      -- ‚ä¢ False
                   -- ‚ä¢ False
                                  -- ‚ä¢ False
      rw [(mapOfLE _ _ _).map_one, mapOfLE_valuation_apply] at c
      -- ‚ä¢ False
      apply not_le_of_lt ((valuation_lt_one_iff S _).1 hx) c)
      -- üéâ no goals
#align valuation_subring.ideal_of_le_le_of_le ValuationSubring.idealOfLE_le_of_le

/-- The equivalence between coarsenings of a valuation ring and its prime ideals.-/
@[simps]
def primeSpectrumEquiv : PrimeSpectrum A ‚âÉ {S | A ‚â§ S} where
  toFun P := ‚ü®ofPrime A P.asIdeal, le_ofPrime _ _‚ü©
  invFun S := ‚ü®idealOfLE _ S S.2, inferInstance‚ü©
  left_inv P := by ext1; simp
                   -- ‚ä¢ ((fun S => { asIdeal := idealOfLE A ‚ÜëS (_ : ‚ÜëS ‚àà {S | A ‚â§ S}), IsPrime := (_ ‚Ä¶
                         -- üéâ no goals
  right_inv S := by ext1; simp
                    -- ‚ä¢ ‚Üë((fun P => { val := ofPrime A P.asIdeal, property := (_ : A ‚â§ ofPrime A P.a ‚Ä¶
                          -- üéâ no goals
#align valuation_subring.prime_spectrum_equiv ValuationSubring.primeSpectrumEquiv

/-- An ordered variant of `primeSpectrumEquiv`. -/
@[simps]
def primeSpectrumOrderEquiv : (PrimeSpectrum A)·µí·µà ‚âÉo {S | A ‚â§ S} :=
  { primeSpectrumEquiv A with
    map_rel_iff' :=
      ‚ü®fun h => by
        dsimp at h
        -- ‚ä¢ a‚úù ‚â§ b‚úù
        have := idealOfLE_le_of_le A _ _ ?_ ?_ h
        iterate 2 erw [idealOfLE_ofPrime] at this
        exact this
        all_goals exact le_ofPrime A (PrimeSpectrum.asIdeal _),
        -- üéâ no goals
      fun h => by apply ofPrime_le_of_le; exact h‚ü© }
                  -- ‚ä¢ b‚úù.asIdeal ‚â§ a‚úù.asIdeal
                                          -- üéâ no goals
#align valuation_subring.prime_spectrum_order_equiv ValuationSubring.primeSpectrumOrderEquiv

instance linearOrderOverring : LinearOrder {S | A ‚â§ S} :=
  { (inferInstance : PartialOrder _) with
    le_total :=
      let i : IsTotal (PrimeSpectrum A) (¬∑ ‚â§ ¬∑) := ‚ü®fun ‚ü®x, _‚ü© ‚ü®y, _‚ü© => LE.isTotal.total x y‚ü©
      (primeSpectrumOrderEquiv A).symm.toRelEmbedding.isTotal.total
    decidableLE := inferInstance }
#align valuation_subring.linear_order_overring ValuationSubring.linearOrderOverring

end Order

end ValuationSubring

namespace Valuation

variable {K}
variable {Œì Œì‚ÇÅ Œì‚ÇÇ : Type*} [LinearOrderedCommGroupWithZero Œì]
  [LinearOrderedCommGroupWithZero Œì‚ÇÅ] [LinearOrderedCommGroupWithZero Œì‚ÇÇ] (v : Valuation K Œì)
  (v‚ÇÅ : Valuation K Œì‚ÇÅ) (v‚ÇÇ : Valuation K Œì‚ÇÇ)

/-- The valuation subring associated to a valuation. -/
def valuationSubring : ValuationSubring K :=
  { v.integer with
    mem_or_inv_mem' := by
      intro x
      -- ‚ä¢ x ‚àà { toSubsemiring := src‚úù.toSubsemiring, neg_mem' := (_ : ‚àÄ {x : K}, x ‚àà s ‚Ä¶
      cases' le_or_lt (v x) 1 with h h
      -- ‚ä¢ x ‚àà { toSubsemiring := src‚úù.toSubsemiring, neg_mem' := (_ : ‚àÄ {x : K}, x ‚àà s ‚Ä¶
      ¬∑ left; exact h
        -- ‚ä¢ x ‚àà { toSubsemiring := src‚úù.toSubsemiring, neg_mem' := (_ : ‚àÄ {x : K}, x ‚àà s ‚Ä¶
              -- üéâ no goals
      ¬∑ right; change v x‚Åª¬π ‚â§ 1
        -- ‚ä¢ x‚Åª¬π ‚àà { toSubsemiring := src‚úù.toSubsemiring, neg_mem' := (_ : ‚àÄ {x : K}, x ‚àà ‚Ä¶
               -- ‚ä¢ ‚Üëv x‚Åª¬π ‚â§ 1
        rw [map_inv‚ÇÄ v, ‚Üê inv_one, inv_le_inv‚ÇÄ]
        ¬∑ exact le_of_lt h
          -- üéâ no goals
        ¬∑ intro c; simp [c] at h
          -- ‚ä¢ False
                   -- üéâ no goals
        ¬∑ exact one_ne_zero }
          -- üéâ no goals
#align valuation.valuation_subring Valuation.valuationSubring

@[simp]
theorem mem_valuationSubring_iff (x : K) : x ‚àà v.valuationSubring ‚Üî v x ‚â§ 1 := Iff.refl _
#align valuation.mem_valuation_subring_iff Valuation.mem_valuationSubring_iff

theorem isEquiv_iff_valuationSubring :
    v‚ÇÅ.IsEquiv v‚ÇÇ ‚Üî v‚ÇÅ.valuationSubring = v‚ÇÇ.valuationSubring := by
  constructor
  -- ‚ä¢ IsEquiv v‚ÇÅ v‚ÇÇ ‚Üí valuationSubring v‚ÇÅ = valuationSubring v‚ÇÇ
  ¬∑ intro h; ext x; specialize h x 1; simpa using h
    -- ‚ä¢ valuationSubring v‚ÇÅ = valuationSubring v‚ÇÇ
             -- ‚ä¢ x ‚àà valuationSubring v‚ÇÅ ‚Üî x ‚àà valuationSubring v‚ÇÇ
                    -- ‚ä¢ x ‚àà valuationSubring v‚ÇÅ ‚Üî x ‚àà valuationSubring v‚ÇÇ
                                      -- üéâ no goals
  ¬∑ intro h; apply isEquiv_of_val_le_one
    -- ‚ä¢ IsEquiv v‚ÇÅ v‚ÇÇ
             -- ‚ä¢ ‚àÄ {x : K}, ‚Üëv‚ÇÅ x ‚â§ 1 ‚Üî ‚Üëv‚ÇÇ x ‚â§ 1
    intro x
    -- ‚ä¢ ‚Üëv‚ÇÅ x ‚â§ 1 ‚Üî ‚Üëv‚ÇÇ x ‚â§ 1
    have : x ‚àà v‚ÇÅ.valuationSubring ‚Üî x ‚àà v‚ÇÇ.valuationSubring := by rw [h]
    -- ‚ä¢ ‚Üëv‚ÇÅ x ‚â§ 1 ‚Üî ‚Üëv‚ÇÇ x ‚â§ 1
    simpa using this
    -- üéâ no goals
#align valuation.is_equiv_iff_valuation_subring Valuation.isEquiv_iff_valuationSubring

theorem isEquiv_valuation_valuationSubring : v.IsEquiv v.valuationSubring.valuation := by
  rw [isEquiv_iff_val_le_one]
  -- ‚ä¢ ‚àÄ {x : K}, ‚Üëv x ‚â§ 1 ‚Üî ‚Üë(ValuationSubring.valuation (valuationSubring v)) x ‚â§ 1
  intro x
  -- ‚ä¢ ‚Üëv x ‚â§ 1 ‚Üî ‚Üë(ValuationSubring.valuation (valuationSubring v)) x ‚â§ 1
  rw [ValuationSubring.valuation_le_one_iff]
  -- ‚ä¢ ‚Üëv x ‚â§ 1 ‚Üî x ‚àà valuationSubring v
  rfl
  -- üéâ no goals
#align valuation.is_equiv_valuation_valuation_subring Valuation.isEquiv_valuation_valuationSubring

end Valuation

namespace ValuationSubring

variable {K}
variable (A : ValuationSubring K)

@[simp]
theorem valuationSubring_valuation : A.valuation.valuationSubring = A := by
  ext; rw [‚Üê A.valuation_le_one_iff]; rfl
  -- ‚ä¢ x‚úù ‚àà Valuation.valuationSubring (valuation A) ‚Üî x‚úù ‚àà A
       -- ‚ä¢ x‚úù ‚àà Valuation.valuationSubring (valuation A) ‚Üî ‚Üë(valuation A) x‚úù ‚â§ 1
                                      -- üéâ no goals
#align valuation_subring.valuation_subring_valuation ValuationSubring.valuationSubring_valuation

section UnitGroup

/-- The unit group of a valuation subring, as a subgroup of `KÀ£`. -/
def unitGroup : Subgroup KÀ£ :=
  (A.valuation.toMonoidWithZeroHom.toMonoidHom.comp (Units.coeHom K)).ker
#align valuation_subring.unit_group ValuationSubring.unitGroup

@[simp]
theorem mem_unitGroup_iff (x : KÀ£) : x ‚àà A.unitGroup ‚Üî A.valuation x = 1 := Iff.rfl
#align valuation_subring.mem_unit_group_iff ValuationSubring.mem_unitGroup_iff

/-- For a valuation subring `A`, `A.unitGroup` agrees with the units of `A`. -/
def unitGroupMulEquiv : A.unitGroup ‚âÉ* AÀ£ where
  toFun x :=
    { val := ‚ü®(x : KÀ£), mem_of_valuation_le_one A _ x.prop.le‚ü©
      inv := ‚ü®((x‚Åª¬π : A.unitGroup) : KÀ£), mem_of_valuation_le_one _ _ x‚Åª¬π.prop.le‚ü©
      -- Porting note: was `Units.mul_inv x`
      val_inv := Subtype.ext (by simp)
                                 -- üéâ no goals
      -- Porting note: was `Units.inv_mul x`
      inv_val := Subtype.ext (by simp) }
                                 -- üéâ no goals
  invFun x := ‚ü®Units.map A.subtype.toMonoidHom x, A.valuation_unit x‚ü©
  left_inv a := by ext; rfl
                   -- ‚ä¢ ‚Üë‚Üë((fun x => { val := ‚Üë(Units.map ‚Üë(subtype A)) x, property := (_ : ‚Üë(valuat ‚Ä¶
                        -- üéâ no goals
  right_inv a := by ext; rfl
                    -- ‚ä¢ ‚Üë‚Üë((fun x => { val := { val := ‚Üë‚Üëx, property := (_ : ‚Üë‚Üëx ‚àà A) }, inv := { va ‚Ä¶
                         -- üéâ no goals
  map_mul' a b := by ext; rfl
                     -- ‚ä¢ ‚Üë‚Üë(Equiv.toFun { toFun := fun x => { val := { val := ‚Üë‚Üëx, property := (_ : ‚Üë ‚Ä¶
                          -- üéâ no goals
#align valuation_subring.unit_group_mul_equiv ValuationSubring.unitGroupMulEquiv

@[simp]
theorem coe_unitGroupMulEquiv_apply (a : A.unitGroup) :
    ((A.unitGroupMulEquiv a : A) : K) = ((a : KÀ£) : K) := rfl
#align valuation_subring.coe_unit_group_mul_equiv_apply ValuationSubring.coe_unitGroupMulEquiv_apply

@[simp]
theorem coe_unitGroupMulEquiv_symm_apply (a : AÀ£) : ((A.unitGroupMulEquiv.symm a : KÀ£) : K) = a :=
  rfl
#align valuation_subring.coe_unit_group_mul_equiv_symm_apply ValuationSubring.coe_unitGroupMulEquiv_symm_apply

theorem unitGroup_le_unitGroup {A B : ValuationSubring K} : A.unitGroup ‚â§ B.unitGroup ‚Üî A ‚â§ B := by
  constructor
  -- ‚ä¢ unitGroup A ‚â§ unitGroup B ‚Üí A ‚â§ B
  ¬∑ intro h x hx
    -- ‚ä¢ x ‚àà B
    rw [‚Üê A.valuation_le_one_iff x, le_iff_lt_or_eq] at hx
    -- ‚ä¢ x ‚àà B
    by_cases h_1 : x = 0; ¬∑ simp only [h_1, zero_mem]
    -- ‚ä¢ x ‚àà B
                            -- üéâ no goals
    by_cases h_2 : 1 + x = 0
    -- ‚ä¢ x ‚àà B
    ¬∑ simp only [‚Üê add_eq_zero_iff_neg_eq.1 h_2, neg_mem _ _ (one_mem _)]
      -- üéâ no goals
    cases' hx with hx hx
    -- ‚ä¢ x ‚àà B
    ¬∑ have := h (show Units.mk0 _ h_2 ‚àà A.unitGroup from A.valuation.map_one_add_of_lt hx)
      -- ‚ä¢ x ‚àà B
      simpa using
        B.add_mem _ _ (show 1 + x ‚àà B from SetLike.coe_mem (B.unitGroupMulEquiv ‚ü®_, this‚ü© : B))
          (B.neg_mem _ B.one_mem)
    ¬∑ have := h (show Units.mk0 x h_1 ‚àà A.unitGroup from hx)
      -- ‚ä¢ x ‚àà B
      refine' SetLike.coe_mem (B.unitGroupMulEquiv ‚ü®_, this‚ü© : B)
      -- üéâ no goals
  ¬∑ rintro h x (hx : A.valuation x = 1)
    -- ‚ä¢ x ‚àà unitGroup B
    apply_fun A.mapOfLE B h at hx
    -- ‚ä¢ x ‚àà unitGroup B
    simpa using hx
    -- üéâ no goals
#align valuation_subring.unit_group_le_unit_group ValuationSubring.unitGroup_le_unitGroup

theorem unitGroup_injective : Function.Injective (unitGroup : ValuationSubring K ‚Üí Subgroup _) :=
  fun A B h => by simpa only [le_antisymm_iff, unitGroup_le_unitGroup] using h
                  -- üéâ no goals
#align valuation_subring.unit_group_injective ValuationSubring.unitGroup_injective

theorem eq_iff_unitGroup {A B : ValuationSubring K} : A = B ‚Üî A.unitGroup = B.unitGroup :=
  unitGroup_injective.eq_iff.symm
#align valuation_subring.eq_iff_unit_group ValuationSubring.eq_iff_unitGroup

/-- The map on valuation subrings to their unit groups is an order embedding. -/
def unitGroupOrderEmbedding : ValuationSubring K ‚Ü™o Subgroup KÀ£ where
  toFun A := A.unitGroup
  inj' := unitGroup_injective
  map_rel_iff' {_A _B} := unitGroup_le_unitGroup
#align valuation_subring.unit_group_order_embedding ValuationSubring.unitGroupOrderEmbedding

theorem unitGroup_strictMono : StrictMono (unitGroup : ValuationSubring K ‚Üí Subgroup _) :=
  unitGroupOrderEmbedding.strictMono
#align valuation_subring.unit_group_strict_mono ValuationSubring.unitGroup_strictMono

end UnitGroup

section nonunits

/-- The nonunits of a valuation subring of `K`, as a subsemigroup of `K`-/
def nonunits : Subsemigroup K where
  carrier := {x | A.valuation x < 1}
  -- Porting note: added `Set.mem_setOf.mp`
  mul_mem' ha hb := (mul_lt_mul‚ÇÄ (Set.mem_setOf.mp ha) (Set.mem_setOf.mp hb)).trans_eq <| mul_one _
#align valuation_subring.nonunits ValuationSubring.nonunits

theorem mem_nonunits_iff {x : K} : x ‚àà A.nonunits ‚Üî A.valuation x < 1 :=
  Iff.rfl
#align valuation_subring.mem_nonunits_iff ValuationSubring.mem_nonunits_iff

theorem nonunits_le_nonunits {A B : ValuationSubring K} : B.nonunits ‚â§ A.nonunits ‚Üî A ‚â§ B := by
  constructor
  -- ‚ä¢ nonunits B ‚â§ nonunits A ‚Üí A ‚â§ B
  ¬∑ intro h x hx
    -- ‚ä¢ x ‚àà B
    by_cases h_1 : x = 0; ¬∑ simp only [h_1, zero_mem]
    -- ‚ä¢ x ‚àà B
                            -- üéâ no goals
    rw [‚Üê valuation_le_one_iff, ‚Üê not_lt, Valuation.one_lt_val_iff _ h_1] at hx ‚ä¢
    -- ‚ä¢ ¬¨‚Üë(valuation B) x‚Åª¬π < 1
    by_contra h_2; exact hx (h h_2)
    -- ‚ä¢ False
                   -- üéâ no goals
  ¬∑ intro h x hx
    -- ‚ä¢ x ‚àà nonunits A
    by_contra h_1; exact not_lt.2 (monotone_mapOfLE _ _ h (not_lt.1 h_1)) hx
    -- ‚ä¢ False
                   -- üéâ no goals
#align valuation_subring.nonunits_le_nonunits ValuationSubring.nonunits_le_nonunits

theorem nonunits_injective : Function.Injective (nonunits : ValuationSubring K ‚Üí Subsemigroup _) :=
  fun A B h => by simpa only [le_antisymm_iff, nonunits_le_nonunits] using h.symm
                  -- üéâ no goals
#align valuation_subring.nonunits_injective ValuationSubring.nonunits_injective

theorem nonunits_inj {A B : ValuationSubring K} : A.nonunits = B.nonunits ‚Üî A = B :=
  nonunits_injective.eq_iff
#align valuation_subring.nonunits_inj ValuationSubring.nonunits_inj

/-- The map on valuation subrings to their nonunits is a dual order embedding. -/
def nonunitsOrderEmbedding : ValuationSubring K ‚Ü™o (Subsemigroup K)·µí·µà where
  toFun A := A.nonunits
  inj' := nonunits_injective
  map_rel_iff' {_A _B} := nonunits_le_nonunits
#align valuation_subring.nonunits_order_embedding ValuationSubring.nonunitsOrderEmbedding

variable {A}

/-- The elements of `A.nonunits` are those of the maximal ideal of `A` after coercion to `K`.

See also `mem_nonunits_iff_exists_mem_maximalIdeal`, which gets rid of the coercion to `K`,
at the expense of a more complicated right hand side.
 -/
theorem coe_mem_nonunits_iff {a : A} : (a : K) ‚àà A.nonunits ‚Üî a ‚àà LocalRing.maximalIdeal A :=
  (valuation_lt_one_iff _ _).symm
#align valuation_subring.coe_mem_nonunits_iff ValuationSubring.coe_mem_nonunits_iff

theorem nonunits_le : A.nonunits ‚â§ A.toSubring.toSubmonoid.toSubsemigroup := fun _a ha =>
  (A.valuation_le_one_iff _).mp (A.mem_nonunits_iff.mp ha).le
#align valuation_subring.nonunits_le ValuationSubring.nonunits_le

theorem nonunits_subset : (A.nonunits : Set K) ‚äÜ A :=
  nonunits_le
#align valuation_subring.nonunits_subset ValuationSubring.nonunits_subset

/-- The elements of `A.nonunits` are those of the maximal ideal of `A`.

See also `coe_mem_nonunits_iff`, which has a simpler right hand side but requires the element
to be in `A` already.
 -/
theorem mem_nonunits_iff_exists_mem_maximalIdeal {a : K} :
    a ‚àà A.nonunits ‚Üî ‚àÉ ha, (‚ü®a, ha‚ü© : A) ‚àà LocalRing.maximalIdeal A :=
  ‚ü®fun h => ‚ü®nonunits_subset h, coe_mem_nonunits_iff.mp h‚ü©, fun ‚ü®_, h‚ü© =>
    coe_mem_nonunits_iff.mpr h‚ü©
#align valuation_subring.mem_nonunits_iff_exists_mem_maximal_ideal ValuationSubring.mem_nonunits_iff_exists_mem_maximalIdeal

/-- `A.nonunits` agrees with the maximal ideal of `A`, after taking its image in `K`. -/
theorem image_maximalIdeal : ((‚Üë) : A ‚Üí K) '' LocalRing.maximalIdeal A = A.nonunits := by
  ext a
  -- ‚ä¢ a ‚àà Subtype.val '' ‚Üë(LocalRing.maximalIdeal { x // x ‚àà A }) ‚Üî a ‚àà ‚Üë(nonunits ‚Ä¶
  simp only [Set.mem_image, SetLike.mem_coe, mem_nonunits_iff_exists_mem_maximalIdeal]
  -- ‚ä¢ (‚àÉ x, x ‚àà LocalRing.maximalIdeal { x // x ‚àà A } ‚àß ‚Üëx = a) ‚Üî ‚àÉ ha, { val := a ‚Ä¶
  erw [Subtype.exists]
  -- ‚ä¢ (‚àÉ a_1 b, { val := a_1, property := b } ‚àà LocalRing.maximalIdeal { x // x ‚àà  ‚Ä¶
  simp_rw [exists_and_right, exists_eq_right]
  -- ‚ä¢ (‚àÉ x, { val := a, property := (_ : a ‚àà ‚ÜëA) } ‚àà LocalRing.maximalIdeal { x // ‚Ä¶
  -- Porting note: added
  simp
  -- üéâ no goals
#align valuation_subring.image_maximal_ideal ValuationSubring.image_maximalIdeal

end nonunits

section PrincipalUnitGroup

/-- The principal unit group of a valuation subring, as a subgroup of `KÀ£`. -/
def principalUnitGroup : Subgroup KÀ£ where
  carrier := {x | A.valuation (x - 1) < 1}
  mul_mem' := by
    intro a b ha hb
    -- ‚ä¢ a * b ‚àà {x | ‚Üë(valuation A) (‚Üëx - 1) < 1}
    -- Porting note: added
    rw [Set.mem_setOf] at ha hb
    -- ‚ä¢ a * b ‚àà {x | ‚Üë(valuation A) (‚Üëx - 1) < 1}
    refine' lt_of_le_of_lt _ (max_lt hb ha)
    -- ‚ä¢ ‚Üë(valuation A) (‚Üë(a * b) - 1) ‚â§ max (‚Üë(valuation A) (‚Üëb - 1)) (‚Üë(valuation A ‚Ä¶
    -- Porting note: `sub_add_sub_cancel` needed some help
    rw [‚Üê one_mul (A.valuation (b - 1)), ‚Üê A.valuation.map_one_add_of_lt ha, add_sub_cancel'_right,
      ‚Üê Valuation.map_mul, mul_sub_one, ‚Üê sub_add_sub_cancel (‚Üë(a * b) : K) _ 1]
    exact A.valuation.map_add _ _
    -- üéâ no goals
  one_mem' := by simp
                 -- üéâ no goals
  inv_mem' := by
    dsimp
    -- ‚ä¢ ‚àÄ {x : KÀ£}, ‚Üë(valuation A) (‚Üëx - 1) < 1 ‚Üí ‚Üë(valuation A) (‚Üëx‚Åª¬π - 1) < 1
    intro a ha
    -- ‚ä¢ ‚Üë(valuation A) (‚Üëa‚Åª¬π - 1) < 1
    conv =>
      lhs
      rw [‚Üê mul_one (A.valuation _), ‚Üê A.valuation.map_one_add_of_lt ha]
    rwa [add_sub_cancel'_right, ‚Üê Valuation.map_mul, sub_mul, Units.inv_mul, ‚Üê neg_sub, one_mul,
      Valuation.map_neg]
#align valuation_subring.principal_unit_group ValuationSubring.principalUnitGroup

theorem principal_units_le_units : A.principalUnitGroup ‚â§ A.unitGroup := fun a h => by
  simpa only [add_sub_cancel'_right] using A.valuation.map_one_add_of_lt h
  -- üéâ no goals
#align valuation_subring.principal_units_le_units ValuationSubring.principal_units_le_units

theorem mem_principalUnitGroup_iff (x : KÀ£) :
    x ‚àà A.principalUnitGroup ‚Üî A.valuation ((x : K) - 1) < 1 :=
  Iff.rfl
#align valuation_subring.mem_principal_unit_group_iff ValuationSubring.mem_principalUnitGroup_iff

theorem principalUnitGroup_le_principalUnitGroup {A B : ValuationSubring K} :
    B.principalUnitGroup ‚â§ A.principalUnitGroup ‚Üî A ‚â§ B := by
  constructor
  -- ‚ä¢ principalUnitGroup B ‚â§ principalUnitGroup A ‚Üí A ‚â§ B
  ¬∑ intro h x hx
    -- ‚ä¢ x ‚àà B
    by_cases h_1 : x = 0; ¬∑ simp only [h_1, zero_mem]
    -- ‚ä¢ x ‚àà B
                            -- üéâ no goals
    by_cases h_2 : x‚Åª¬π + 1 = 0
    -- ‚ä¢ x ‚àà B
    ¬∑ rw [add_eq_zero_iff_eq_neg, inv_eq_iff_eq_inv, inv_neg, inv_one] at h_2
      -- ‚ä¢ x ‚àà B
      simpa only [h_2] using B.neg_mem _ B.one_mem
      -- üéâ no goals
    ¬∑ rw [‚Üê valuation_le_one_iff, ‚Üê not_lt, Valuation.one_lt_val_iff _ h_1, ‚Üê add_sub_cancel x‚Åª¬π, ‚Üê
        Units.val_mk0 h_2, ‚Üê mem_principalUnitGroup_iff] at hx ‚ä¢
      simpa only [hx] using @h (Units.mk0 (x‚Åª¬π + 1) h_2)
      -- üéâ no goals
  ¬∑ intro h x hx
    -- ‚ä¢ x ‚àà principalUnitGroup A
    by_contra h_1; exact not_lt.2 (monotone_mapOfLE _ _ h (not_lt.1 h_1)) hx
    -- ‚ä¢ False
                   -- üéâ no goals
#align valuation_subring.principal_unit_group_le_principal_unit_group ValuationSubring.principalUnitGroup_le_principalUnitGroup

theorem principalUnitGroup_injective :
    Function.Injective (principalUnitGroup : ValuationSubring K ‚Üí Subgroup _) := fun A B h => by
  simpa [le_antisymm_iff, principalUnitGroup_le_principalUnitGroup] using h.symm
  -- üéâ no goals
#align valuation_subring.principal_unit_group_injective ValuationSubring.principalUnitGroup_injective

theorem eq_iff_principalUnitGroup {A B : ValuationSubring K} :
    A = B ‚Üî A.principalUnitGroup = B.principalUnitGroup :=
  principalUnitGroup_injective.eq_iff.symm
#align valuation_subring.eq_iff_principal_unit_group ValuationSubring.eq_iff_principalUnitGroup

/-- The map on valuation subrings to their principal unit groups is an order embedding. -/
def principalUnitGroupOrderEmbedding : ValuationSubring K ‚Ü™o (Subgroup KÀ£)·µí·µà where
  toFun A := A.principalUnitGroup
  inj' := principalUnitGroup_injective
  map_rel_iff' {_A _B} := principalUnitGroup_le_principalUnitGroup
#align valuation_subring.principal_unit_group_order_embedding ValuationSubring.principalUnitGroupOrderEmbedding

theorem coe_mem_principalUnitGroup_iff {x : A.unitGroup} :
    (x : KÀ£) ‚àà A.principalUnitGroup ‚Üî
      A.unitGroupMulEquiv x ‚àà (Units.map (LocalRing.residue A).toMonoidHom).ker := by
  rw [MonoidHom.mem_ker, Units.ext_iff]
  -- ‚ä¢ ‚Üëx ‚àà principalUnitGroup A ‚Üî ‚Üë(‚Üë(Units.map ‚Üë(LocalRing.residue { x // x ‚àà A } ‚Ä¶
  let œÄ := Ideal.Quotient.mk (LocalRing.maximalIdeal A); convert_to _ ‚Üî œÄ _ = 1
  -- ‚ä¢ ‚Üëx ‚àà principalUnitGroup A ‚Üî ‚Üë(‚Üë(Units.map ‚Üë(LocalRing.residue { x // x ‚àà A } ‚Ä¶
                                                         -- ‚ä¢ ‚Üëx ‚àà principalUnitGroup A ‚Üî ‚ÜëœÄ ‚Üë(‚Üë(unitGroupMulEquiv A) x) = 1
  rw [‚Üê œÄ.map_one, ‚Üê sub_eq_zero, ‚Üê œÄ.map_sub, Ideal.Quotient.eq_zero_iff_mem, valuation_lt_one_iff]
  -- ‚ä¢ ‚Üëx ‚àà principalUnitGroup A ‚Üî ‚Üë(valuation A) ‚Üë(‚Üë(‚Üë(unitGroupMulEquiv A) x) - 1 ‚Ä¶
  simp [mem_principalUnitGroup_iff]
  -- üéâ no goals
#align valuation_subring.coe_mem_principal_unit_group_iff ValuationSubring.coe_mem_principalUnitGroup_iff

/-- The principal unit group agrees with the kernel of the canonical map from
the units of `A` to the units of the residue field of `A`. -/
def principalUnitGroupEquiv :
    A.principalUnitGroup ‚âÉ* (Units.map (LocalRing.residue A).toMonoidHom).ker where
  toFun x :=
    ‚ü®A.unitGroupMulEquiv ‚ü®_, A.principal_units_le_units x.2‚ü©,
      A.coe_mem_principalUnitGroup_iff.1 x.2‚ü©
  invFun x :=
    ‚ü®A.unitGroupMulEquiv.symm x, by
      rw [A.coe_mem_principalUnitGroup_iff]; simpa using SetLike.coe_mem x‚ü©
      -- ‚ä¢ ‚Üë(unitGroupMulEquiv A) (‚Üë(MulEquiv.symm (unitGroupMulEquiv A)) ‚Üëx) ‚àà MonoidH ‚Ä¶
                                             -- üéâ no goals
  left_inv x := by simp
                   -- üéâ no goals
  right_inv x := by simp
                    -- üéâ no goals
  map_mul' x y := by rfl
                     -- üéâ no goals
#align valuation_subring.principal_unit_group_equiv ValuationSubring.principalUnitGroupEquiv

@[simp]
theorem principalUnitGroupEquiv_apply (a : A.principalUnitGroup) :
    (((principalUnitGroupEquiv A a : AÀ£) : A) : K) = (a : KÀ£) :=
  rfl
#align valuation_subring.principal_unit_group_equiv_apply ValuationSubring.principalUnitGroupEquiv_apply

@[simp]
theorem principalUnitGroup_symm_apply (a : (Units.map (LocalRing.residue A).toMonoidHom).ker) :
    ((A.principalUnitGroupEquiv.symm a : KÀ£) : K) = ((a : AÀ£) : A) :=
  rfl
#align valuation_subring.principal_unit_group_symm_apply ValuationSubring.principalUnitGroup_symm_apply

/-- The canonical map from the unit group of `A` to the units of the residue field of `A`. -/
def unitGroupToResidueFieldUnits : A.unitGroup ‚Üí* (LocalRing.ResidueField A)À£ :=
  MonoidHom.comp (Units.map <| (Ideal.Quotient.mk _).toMonoidHom) A.unitGroupMulEquiv.toMonoidHom
#align valuation_subring.unit_group_to_residue_field_units ValuationSubring.unitGroupToResidueFieldUnits

@[simp]
theorem coe_unitGroupToResidueFieldUnits_apply (x : A.unitGroup) :
    (A.unitGroupToResidueFieldUnits x : LocalRing.ResidueField A) =
      Ideal.Quotient.mk _ (A.unitGroupMulEquiv x : A) :=
  rfl
#align valuation_subring.coe_unit_group_to_residue_field_units_apply ValuationSubring.coe_unitGroupToResidueFieldUnits_apply

theorem ker_unitGroupToResidueFieldUnits :
    A.unitGroupToResidueFieldUnits.ker = A.principalUnitGroup.comap A.unitGroup.subtype := by
  ext
  -- ‚ä¢ x‚úù ‚àà MonoidHom.ker (unitGroupToResidueFieldUnits A) ‚Üî x‚úù ‚àà Subgroup.comap (S ‚Ä¶
  -- Porting note: simp fails but rw works
  -- See https://github.com/leanprover-community/mathlib4/issues/5026
  -- simp [Subgroup.mem_comap, Subgroup.coeSubtype, coe_mem_principalUnitGroup_iff]
  rw [Subgroup.mem_comap, Subgroup.coeSubtype, coe_mem_principalUnitGroup_iff]
  -- ‚ä¢ x‚úù ‚àà MonoidHom.ker (unitGroupToResidueFieldUnits A) ‚Üî ‚Üë(unitGroupMulEquiv A) ‚Ä¶
  rfl
  -- üéâ no goals
  -- simp [Subgroup.mem_comap, Subgroup.coeSubtype, coe_mem_principalUnitGroup_iff]
#align valuation_subring.ker_unit_group_to_residue_field_units ValuationSubring.ker_unitGroupToResidueFieldUnits

theorem surjective_unitGroupToResidueFieldUnits :
    Function.Surjective A.unitGroupToResidueFieldUnits :=
  (LocalRing.surjective_units_map_of_local_ringHom _ Ideal.Quotient.mk_surjective
        LocalRing.isLocalRingHom_residue).comp
    (MulEquiv.surjective _)
#align valuation_subring.surjective_unit_group_to_residue_field_units ValuationSubring.surjective_unitGroupToResidueFieldUnits

/-- The quotient of the unit group of `A` by the principal unit group of `A` agrees with
the units of the residue field of `A`. -/
def unitsModPrincipalUnitsEquivResidueFieldUnits :
    A.unitGroup ‚ß∏ A.principalUnitGroup.comap A.unitGroup.subtype ‚âÉ* (LocalRing.ResidueField A)À£ :=
  (QuotientGroup.quotientMulEquivOfEq A.ker_unitGroupToResidueFieldUnits.symm).trans
    (QuotientGroup.quotientKerEquivOfSurjective _ A.surjective_unitGroupToResidueFieldUnits)
#align valuation_subring.units_mod_principal_units_equiv_residue_field_units ValuationSubring.unitsModPrincipalUnitsEquivResidueFieldUnits

-- Porting note: Lean needs to be reminded of this instance
local instance : MulOneClass ({ x // x ‚àà unitGroup A } ‚ß∏
  Subgroup.comap (Subgroup.subtype (unitGroup A)) (principalUnitGroup A)) := inferInstance

-- @[simp] -- Porting note: not in simpNF
theorem unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk :
    A.unitsModPrincipalUnitsEquivResidueFieldUnits.toMonoidHom.comp (QuotientGroup.mk' _) =
      A.unitGroupToResidueFieldUnits := rfl
#align valuation_subring.units_mod_principal_units_equiv_residue_field_units_comp_quotient_group_mk ValuationSubring.unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk

@[simp]
theorem unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk_apply
    (x : A.unitGroup) :
    A.unitsModPrincipalUnitsEquivResidueFieldUnits.toMonoidHom (QuotientGroup.mk x) =
      A.unitGroupToResidueFieldUnits x := rfl
#align valuation_subring.units_mod_principal_units_equiv_residue_field_units_comp_quotient_group_mk_apply ValuationSubring.unitsModPrincipalUnitsEquivResidueFieldUnits_comp_quotientGroup_mk_apply

end PrincipalUnitGroup

/-! ### Pointwise actions

This transfers the action from `Subring.pointwiseMulAction`, noting that it only applies when
the action is by a group. Notably this provides an instances when `G` is `K ‚âÉ+* K`.

These instances are in the `Pointwise` locale.

The lemmas in this section are copied from `RingTheory/Subring/Pointwise.lean`; try to keep these
in sync.
-/


section PointwiseActions

open scoped Pointwise

variable {G : Type*} [Group G] [MulSemiringAction G K]

/-- The action on a valuation subring corresponding to applying the action to every element.

This is available as an instance in the `Pointwise` locale. -/
def pointwiseHasSMul : SMul G (ValuationSubring K) where
  smul g S :=-- TODO: if we add `ValuationSubring.map` at a later date, we should use it here
    { g ‚Ä¢ S.toSubring with
      mem_or_inv_mem' := fun x =>
        (mem_or_inv_mem S (g‚Åª¬π ‚Ä¢ x)).imp Subring.mem_pointwise_smul_iff_inv_smul_mem.mpr fun h =>
          Subring.mem_pointwise_smul_iff_inv_smul_mem.mpr <| by rwa [smul_inv''] }
                                                                -- üéâ no goals
#align valuation_subring.pointwise_has_smul ValuationSubring.pointwiseHasSMul

scoped[Pointwise] attribute [instance] ValuationSubring.pointwiseHasSMul

open scoped Pointwise

@[simp]
theorem coe_pointwise_smul (g : G) (S : ValuationSubring K) : ‚Üë(g ‚Ä¢ S) = g ‚Ä¢ (S : Set K) := rfl
#align valuation_subring.coe_pointwise_smul ValuationSubring.coe_pointwise_smul

@[simp]
theorem pointwise_smul_toSubring (g : G) (S : ValuationSubring K) :
    (g ‚Ä¢ S).toSubring = g ‚Ä¢ S.toSubring := rfl
#align valuation_subring.pointwise_smul_to_subring ValuationSubring.pointwise_smul_toSubring

/-- The action on a valuation subring corresponding to applying the action to every element.

This is available as an instance in the `pointwise` locale.

This is a stronger version of `ValuationSubring.pointwiseSMul`. -/
def pointwiseMulAction : MulAction G (ValuationSubring K) :=
  toSubring_injective.mulAction toSubring pointwise_smul_toSubring
#align valuation_subring.pointwise_mul_action ValuationSubring.pointwiseMulAction

scoped[Pointwise] attribute [instance] ValuationSubring.pointwiseMulAction

open scoped Pointwise

theorem smul_mem_pointwise_smul (g : G) (x : K) (S : ValuationSubring K) : x ‚àà S ‚Üí g ‚Ä¢ x ‚àà g ‚Ä¢ S :=
  (Set.smul_mem_smul_set : _ ‚Üí _ ‚àà g ‚Ä¢ (S : Set K))
#align valuation_subring.smul_mem_pointwise_smul ValuationSubring.smul_mem_pointwise_smul

theorem mem_smul_pointwise_iff_exists (g : G) (x : K) (S : ValuationSubring K) :
    x ‚àà g ‚Ä¢ S ‚Üî ‚àÉ s : K, s ‚àà S ‚àß g ‚Ä¢ s = x :=
  (Set.mem_smul_set : x ‚àà g ‚Ä¢ (S : Set K) ‚Üî _)
#align valuation_subring.mem_smul_pointwise_iff_exists ValuationSubring.mem_smul_pointwise_iff_exists

instance pointwise_central_scalar [MulSemiringAction G·µê·µí·µñ K] [IsCentralScalar G K] :
    IsCentralScalar G (ValuationSubring K) :=
  ‚ü®fun g S => toSubring_injective <| op_smul_eq_smul g S.toSubring‚ü©
#align valuation_subring.pointwise_central_scalar ValuationSubring.pointwise_central_scalar

@[simp]
theorem smul_mem_pointwise_smul_iff {g : G} {S : ValuationSubring K} {x : K} :
    g ‚Ä¢ x ‚àà g ‚Ä¢ S ‚Üî x ‚àà S := Set.smul_mem_smul_set_iff
#align valuation_subring.smul_mem_pointwise_smul_iff ValuationSubring.smul_mem_pointwise_smul_iff

theorem mem_pointwise_smul_iff_inv_smul_mem {g : G} {S : ValuationSubring K} {x : K} :
    x ‚àà g ‚Ä¢ S ‚Üî g‚Åª¬π ‚Ä¢ x ‚àà S := Set.mem_smul_set_iff_inv_smul_mem
#align valuation_subring.mem_pointwise_smul_iff_inv_smul_mem ValuationSubring.mem_pointwise_smul_iff_inv_smul_mem

theorem mem_inv_pointwise_smul_iff {g : G} {S : ValuationSubring K} {x : K} :
    x ‚àà g‚Åª¬π ‚Ä¢ S ‚Üî g ‚Ä¢ x ‚àà S := Set.mem_inv_smul_set_iff
#align valuation_subring.mem_inv_pointwise_smul_iff ValuationSubring.mem_inv_pointwise_smul_iff

@[simp]
theorem pointwise_smul_le_pointwise_smul_iff {g : G} {S T : ValuationSubring K} :
    g ‚Ä¢ S ‚â§ g ‚Ä¢ T ‚Üî S ‚â§ T := Set.set_smul_subset_set_smul_iff
#align valuation_subring.pointwise_smul_le_pointwise_smul_iff ValuationSubring.pointwise_smul_le_pointwise_smul_iff

theorem pointwise_smul_subset_iff {g : G} {S T : ValuationSubring K} : g ‚Ä¢ S ‚â§ T ‚Üî S ‚â§ g‚Åª¬π ‚Ä¢ T :=
  Set.set_smul_subset_iff
#align valuation_subring.pointwise_smul_subset_iff ValuationSubring.pointwise_smul_subset_iff

theorem subset_pointwise_smul_iff {g : G} {S T : ValuationSubring K} : S ‚â§ g ‚Ä¢ T ‚Üî g‚Åª¬π ‚Ä¢ S ‚â§ T :=
  Set.subset_set_smul_iff
#align valuation_subring.subset_pointwise_smul_iff ValuationSubring.subset_pointwise_smul_iff

end PointwiseActions

section

variable {L J : Type*} [Field L] [Field J]

/-- The pullback of a valuation subring `A` along a ring homomorphism `K ‚Üí+* L`. -/
def comap (A : ValuationSubring L) (f : K ‚Üí+* L) : ValuationSubring K :=
  { A.toSubring.comap f with mem_or_inv_mem' := fun k => by simp [ValuationSubring.mem_or_inv_mem] }
                                                            -- üéâ no goals
#align valuation_subring.comap ValuationSubring.comap

@[simp]
theorem coe_comap (A : ValuationSubring L) (f : K ‚Üí+* L) : (A.comap f : Set K) = f ‚Åª¬π' A := rfl
#align valuation_subring.coe_comap ValuationSubring.coe_comap

@[simp]
theorem mem_comap {A : ValuationSubring L} {f : K ‚Üí+* L} {x : K} : x ‚àà A.comap f ‚Üî f x ‚àà A :=
  Iff.rfl
#align valuation_subring.mem_comap ValuationSubring.mem_comap

theorem comap_comap (A : ValuationSubring J) (g : L ‚Üí+* J) (f : K ‚Üí+* L) :
    (A.comap g).comap f = A.comap (g.comp f) := rfl
#align valuation_subring.comap_comap ValuationSubring.comap_comap

end

end ValuationSubring

namespace Valuation

variable {Œì : Type*} [LinearOrderedCommGroupWithZero Œì] (v : Valuation K Œì) (x : KÀ£)

-- @[simp] -- Porting note: not in simpNF
theorem mem_unitGroup_iff : x ‚àà v.valuationSubring.unitGroup ‚Üî v x = 1 :=
  (Valuation.isEquiv_iff_val_eq_one _ _).mp (Valuation.isEquiv_valuation_valuationSubring _).symm
#align valuation.mem_unit_group_iff Valuation.mem_unitGroup_iff

end Valuation
