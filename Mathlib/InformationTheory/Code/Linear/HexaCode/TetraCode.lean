import Mathlib.InformationTheory.Code.Linear.HexaCode.F4
import Mathlib.InformationTheory.Code.HammingCode
import Mathlib.LinearAlgebra.Determinant
import Mathlib.Data.Matrix.Reflection

open BigOperators

abbrev F_3_4 := Fin 4 → ZMod 3

def b₁ : F_3_4 := ![0,1,1,1]
def b₂ : F_3_4 := ![1,0,1,2]

def tetraCode_basis : Fin 2 → F_3_4 := ![b₁,b₂]

abbrev MiniMog_index := Fin 4 × ZMod 3
abbrev MiniMog_index' := Fin 4 × F4ˣ

-- i'd like to somehow use both ZMod 3 and F4ˣ at the same time...

-- #synth AddAction (Fin 4 → (ZMod 3)ᵈᵃᵃ) (Fin 4 → ZMod 3 → ZMod 2)
-- #synth DistribMulAction (Fin 4 → (F4ˣ)ᵈᵐᵃ) (Fin 4 → F4ˣ → ZMod 2)

-- #synth Module (ZMod 3) F_3_4

/-
the automorphism group (of the tetracode) is generated by:
- ⟨(1,2,3),![1,1,1,1]⟩ : LinearCodeAut (ZMod 3) F_3_4
- ⟨(1,2),![1,1,1,2]⟩ : LinearCodeAut (ZMod 3) F_3_4

supposedly, this group is isomorphic to GL₂(3)
-/

abbrev MiniMog_space := MiniMog_index → ZMod 2
abbrev MiniMog_space' := MiniMog_index' → ZMod 2

def to_tetracode_cast (m: MiniMog_space') : (Fin 4) → F4 := fun i => ∑ x, m (i,x) • x
