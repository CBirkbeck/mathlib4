import Mathlib.InformationTheory.Code.Linear.Mathieu.BGolay
import Mathlib.InformationTheory.Code.Linear.Mathieu.GolayActions

abbrev weird_aut' (x: golay_code_space') : golay_code_space' :=
  to_gc !![x (0,0), x (1,0), x (2,0), x (3,0), x (5,0), x (4,0);
           x (0,1), x (1,1), x (2,1), x (3,1), x (5,1), x (4,1);
           x (0,ω⁻¹), x (1,ω⁻¹), x (2,ω⁻¹), x (3,ω⁻¹), x (5,ω⁻¹), x (4,ω⁻¹);
           x (0,ω), x (1,ω), x (2,ω), x (3,ω), x (5,ω), x (4,ω)]

@[simps]
def weird_aut'' : golay_code_space' ≃ golay_code_space' where
  toFun := weird_aut'
  invFun := weird_aut'
  left_inv := fun x => by
    ext i
    fin_cases i <;> rfl
  right_inv := fun x => by
    ext i
    fin_cases i <;> rfl

@[simps]
def weird_aut_lin : golay_code_space' ≃ₗ[ZMod 2] golay_code_space' := {
  weird_aut'' with
  map_add' := fun x y => by
    ext i
    simp only [Pi.add_apply]
    fin_cases i <;> rfl
  map_smul' := fun r x => by
    ext i
    simp only [RingHom.id_apply, Pi.smul_apply, smul_eq_mul]
    fin_cases i <;> rfl
}

lemma weird_aut_lin_map_code ⦃x:golay_code_space'⦄ (hx : x ∈ GolayCode):
    weird_aut_lin x ∈ GolayCode := by
  rw [gc_span_is_gc.symm] at hx
  refine Submodule.span_induction hx ?basis ?zero ?add ?smul
  . simp only [Matrix.range_cons, Matrix.range_empty, Set.union_empty, Set.union_singleton,
    Set.union_insert, Set.mem_insert_iff, Set.mem_singleton_iff, forall_eq_or_imp, forall_eq]
    decide
  . decide
  . intro x y hx hy
    rw [map_add]
    exact add_mem hx hy
  . intro r x hx
    rw [weird_aut_lin.map_smul]
    exact GolayCode.smul_mem r hx

lemma weird_aut_lin_auto_symm (x:golay_code_space'): weird_aut_lin (weird_aut_lin x) = x := by
  ext i
  fin_cases i <;> rfl

def weird_aut : LinearCodeAut (ZMod 2) trivdist hdist GolayCode := {
  weird_aut_lin with
  map_dist := sorry
  map_code := by
    simp only [SetLike.mem_coe, AddHom.toFun_eq_coe, LinearMap.coe_toAddHom, LinearEquiv.coe_coe]
    intro x hx
    exact weird_aut_lin_map_code hx
  invMap_code := by
    simp only [AddHom.toFun_eq_coe, LinearMap.coe_toAddHom, LinearEquiv.coe_coe, SetLike.mem_coe]
    intro x hx
    rw [← weird_aut_lin_auto_symm x]
    exact weird_aut_lin_map_code hx
}

/-
(2^6 ⋊ 3)•S₆? (2^6) ⋊ (3 • S₆)?
fancygroup is generated by:
- ![0,1,0,1,ω,ω⁻¹] : Fin 6 → F4
- ⟨(1,2,3,4,5), ![↑ω,1,↑ω⁻¹,↑ω,?,1]⟩ : LinearCodeAut ...
- ⟨(5,6), 1⟩ ∘ (λ x. x⁻¹) : GolayCode ≃ₛₗc[(λ x. x⁻¹)]


to extend to M₂₄ :
- apply ⟨(1,2)(3,4),1⟩, then apply
  λ ⟨i,x⟩, ⟨if i ∈ {5,6} then (5,6) i else i,if i ∈ {5,6} then x + 1 else x⟩

turns out, M₂₄ is 5-transitive on (Fin 6) × F4

take subgroups to other groups:
- Stabiliser of a single point, (Fin 6) × F4: M₂₃
- Stabiliser of two points: M₂₂
- Stabiliser of three points: M₂₁ ≃* PSL₃(4)
  (the remaining 21 points form a projective plane of order 4)


lemma : M₂₄ acts transitively on words of weight 12 (dodecad)

- Stabiliser of a dodecad in GolayCode : M₁₂


- Fix a dodecad, and a point in it: M₁₁
-/
