-- import Mathlib.InformationTheory.Code.Linear.Mathieu.HexaCode
import Mathlib.InformationTheory.Code.Linear.Mathieu.F4
-- import Mathlib.InformationTheory.Code.HammingCode
-- import Mathlib.LinearAlgebra.Determinant
import Mathlib.Data.ZMod.Defs
import Mathlib.Data.Matrix.Reflection

open BigOperators
def to_F4 : (Multiplicative (ZMod 3)) →* (F4) where
  toFun := fun x => match x with
    | ⟨0,_⟩ => 1
    | ⟨1,_⟩ => ω
    | ⟨2,_⟩ => ω⁻¹
  map_one' := rfl
  map_mul' := fun x y => by
    simp only
    fin_cases x <;> fin_cases y
    all_goals simp
    all_goals rfl

-- lemma to_F4.inj : Function.Injective to_F4 := fun x => _

namespace TetraCode
abbrev F_3_4 := Fin 4 → ZMod 3

def b₁ : F_3_4 := ![1,0,1,2]
def b₂ : F_3_4 := ![0,1,1,1]

def tetraCode_basis' : Fin 2 → F_3_4 := ![b₁,b₂]

def TetraCode := Submodule.span (ZMod 3) (Set.range tetraCode_basis')

abbrev MiniMog_index := Fin 4 × ZMod 3


abbrev MiniMog_space := MiniMog_index → ZMod 2

def mmog_to_F4 (m:MiniMog_space): (Fin 4 → F4) := fun i => ∑ x, m (i,x) • to_F4 x

abbrev cast_mem_tetracode (m:MiniMog_space): Prop :=
  ∃ f ∈ TetraCode,∀ i, mmog_to_F4 m i = 0 ∨ mmog_to_F4 m i = to_F4 (f i)

def MiniMogCode : Submodule (ZMod 2) (MiniMog_space) where
  carrier := {m|cast_mem_tetracode m}
  add_mem' := by
    intro a b ha hb
    simp only [Set.mem_setOf_eq] at ha hb ⊢
    simp_rw [cast_mem_tetracode,mmog_to_F4] at ha hb ⊢
    obtain ⟨fa,hfa,hfa'⟩ := ha
    obtain ⟨fb,hfb,hfb'⟩ := hb
    use fa + fb
    use TetraCode.add_mem hfa hfb
    intro i
    simp only [Pi.add_apply]
    simp_rw [add_smul,Finset.sum_add_distrib]
    obtain hfa₁|hfa₁ := hfa' i <;> rw [hfa₁] <;> obtain hfb₁|hfb₁ := hfb' i <;> rw [hfb₁]
    . simp only [add_zero, true_or]
    . simp only [zero_add]
      simp_rw [to_F4]
      simp only [MonoidHom.coe_mk, OneHom.coe_mk]

      sorry
    . simp only [add_zero]
    .


    sorry
  zero_mem' := by
    simp only [Set.mem_setOf_eq]
    use 0
    simp only [Submodule.zero_mem, Pi.zero_apply, true_and]
    simp_rw [mmog_to_F4]
    simp only [Pi.zero_apply, zero_smul, Finset.sum_const_zero, true_or, forall_const]
  smul_mem' := sorry



-- #synth Module (ZMod 3) (Fin 4 → ZMod 3)
-- i'd like to somehow use both ZMod 3 and F4ˣ at the same time...

-- #synth AddAction (Fin 4 → (ZMod 3)ᵈᵃᵃ) (Fin 4 → ZMod 3 → ZMod 2)
-- #synth DistribMulAction (Fin 4 → (F4ˣ)ᵈᵐᵃ) (Fin 4 → F4ˣ → ZMod 2)

-- #synth Module (ZMod 3) F_3_4

/-
the automorphism group (of the tetracode) is generated by:
- ⟨(1,2,3),![1,1,1,1]⟩ : LinearCodeAut (ZMod 3) F_3_4
- ⟨(1,2),![1,1,1,2]⟩ : LinearCodeAut (ZMod 3) F_3_4

supposedly, this group is isomorphic to GL₂(3)
-/
