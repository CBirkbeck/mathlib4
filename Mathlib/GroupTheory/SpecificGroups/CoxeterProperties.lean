/-
Copyright (c) 2024 Mitchell Lee. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mitchell Lee
-/
import Mathlib.GroupTheory.SpecificGroups.Coxeter
import Mathlib.Data.ZMod.Defs
import Mathlib.RepresentationTheory.Basic
import Mathlib.Data.Real.Basic
import Mathlib.Data.Complex.Exponential
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Basic
import Mathlib.LinearAlgebra.BilinearMap

/-!
# Properties of Coxeter groups
This file states and proves some properties of Coxeter systems.

Throughout this file, `B` is a type and `M : Matrix B B ℕ` is a Coxeter matrix.
`cs : CoxeterSystem M W` is a Coxeter system; that is, `W` is a group, and `cs` holds the data
of a group isomorphism `W ≃* Matrix.CoxeterGroup M`, where `Matrix.CoxeterGroup M` refers to
the quotient of the free group on `B` by the Coxeter relations given by the matrix `M`. See
`Mathlib.GroupTheory.SpecificGroups.Coxeter` for more details.

We define the simple reflections $s_i$ of the Coxeter group $W$ for `i : B`. Using this, we define
the length function $\ell : W → \mathbb{N}$, and we prove that
$\ell (w_1 w_2) \leq \ell (w_1) + \ell (w_2)$
and that $\ell (w_1 w_2)$ and $\ell (w_1) + \ell (w_2)$ have the same parity.

We define a *reduced word* for an element $w \in W$ to be a way of writing $w$ as a product
of exactly $\ell(w)$ simple reflections. We define a *reflection* to be an element of the form
$t = u s_i u^{-1}$, where $u \in W$ and $s_i$ is a simple reflection. We say that a reflection $t$
is a *left inversion* of an element $w \in W$ if $\ell(t w) < \ell (w)$, and we say it is a
*right inversion* of $w$ if $\ell(w t) > \ell(w)$.

We prove that, given a reduced word for $w$, one can recover the set of left inversions or right
inversions by taking the *inversion sequence* of the reduced word. We prove that $\ell(w)$ is
equal to the number of left inversions of $w$ and equal to the number of right inversions of $w$.
We also prove the *deletion property*: every non-reduced word for an element $w$ can be decreased
in length by deleting two of its simple reflections.

Central to our approach is the *standard geometric representation* of $W$, which is a faithful
representation of $W$ on the free vector space over `B`. Every reflection of $W$ acts by a
reflection in the standard geometric representation. We also define the associated set of *roots*
(which is not necessarily a root system in the sense of `Mathlib.LinearAlgebra.RootSystem`),
and prove that they correspond two-to-one to the reflections of $W$.

## Main definitions
* `cs.simpleReflection `: The simple reflection corresponding to an index `i : B`.
* `cs.lift`: Given `f : B → G`, where `G` is a monoid and `f` is a function whose values satisfy
the Coxeter relations, extend it to a monoid homomorphism `f' : W → G` satisfying
`f' (s i) = f i` for all `i`.
* `cs.wordProd`: Given a `List B`, returns the product of the corresponding simple reflections.
* `cs.length`
* `cs.IsReflection`
* `cs.IsLeftInversion`
* `cs.IsRightInversion`
* `cs.standardBilinForm`: The invariant bilinear form associated to the standard geometric
representation.
* `cs.standardGeometricRepresentation`: The standard geometric representation of `W`. This has type
`Representation ℝ W (B →₀ ℝ)`.
* `cs.roots`
* `cs.posRoots`
* `cs.negRoots`
* `cs.leftInvSeq`
* `cs.rightInvSeq`

## Implementation notes
In most texts on Coxeter groups, each entry $M_{i,i'}$ of the Coxeter matrix can be either a positive
integer or $\infty$. A value of $\infty$ indicates that there is no relation between the
corresponding simple reflections. In our treatment of Coxeter groups, we use the value $0$ instead
of $\infty$. This decision has two fortunate consequences. First, the Coxeter relation
$(s_i s_{i'})^{M_{i, i'}}$ is automatically the identity if $M_{i, i'} = 0$. Second, when we define
the standard bilinear form by $\langle \alpha_i, \alpha_{i'}\rangle = - \cos(\pi / M_{i,i'})$, Lean
computes $- \cos(\pi / M_{i,i'})$ to have the correct value of $-1$ if $M_{i, i'} = 0$.

## References
* [A. Björner and F. Brenti, *Combinatorics of Coxeter Groups*][bjorner2005]

## TODO
* Introduce some ways to actually construct some Coxeter groups. For example, given a Coxeter matrix
$M : B \times B \to \mathbb{N}$, a real vector space $V$, a basis $\{\alpha_i : i \in B\}$
and a bilinear form $\langle \cdot, \cdot \rangle \colon V \times V \to \mathbb{R}$ satisfying
$$\langle \alpha_i, \alpha_{i'}\rangle = - \cos(\pi / M_{i,i'}),$$ one can form the subgroup of
$GL(V)$ generated by the reflections in the $\alpha_i$, and it is a Coxeter group. We can use this
to combinatorially describe the Coxeter groups of type $A$, $B$, $D$, and $I$.
* State and prove Matsumoto's theorem.
* Classify the finite Coxeter groups.
-/

noncomputable section

namespace CoxeterSystem

open List Matrix Function Real

variable {B : Type*} [DecidableEq B]
variable {M : Matrix B B ℕ}
variable {W : Type*} [Group W]
variable (cs : CoxeterSystem M W)

/-! ### Simple reflections and lifting homomorphisms -/

/-- The simple reflection of `W` corresponding to the index `i`. -/
def simpleReflection (i : B) : W := cs.mulEquiv.symm (PresentedGroup.of i)

local prefix:100 "s" => cs.simpleReflection

private lemma coxeterGroup_simple_mul_self (i : B) :
    (QuotientGroup.mk ((FreeGroup.of i) * (FreeGroup.of i)) : CoxeterGroup M) = 1 := by
  have : (FreeGroup.of i) * (FreeGroup.of i) ∈ CoxeterGroup.Relations.toSet M := by
    use (i, i)
    dsimp [CoxeterGroup.Relations.ofMatrix]
    rw [cs.isCoxeter.diagonal i, pow_one]
  apply (QuotientGroup.eq_one_iff _).mpr
  exact Subgroup.subset_normalClosure this

@[simp] theorem simple_mul_self (i : B) : (s i) * (s i) = 1 := by
  dsimp [simpleReflection]
  rw [← _root_.map_mul, PresentedGroup.of, ← QuotientGroup.mk_mul]
  rw [cs.coxeterGroup_simple_mul_self i]
  simp

@[simp] theorem simple_sqr (i : B) : (s i) ^ 2 = 1 := by
  rw [pow_two]
  exact cs.simple_mul_self i

@[simp] theorem simple_inv (i : B) : (s i)⁻¹ = s i :=
  (eq_inv_of_mul_eq_one_right (cs.simple_mul_self i)).symm

@[simp] theorem simple_mul_pow (i i' : B) : ((s i) * (s i')) ^ M i i' = 1 := by
  dsimp [simpleReflection]
  rw [← _root_.map_mul, ← map_pow, PresentedGroup.of, PresentedGroup.of,
      ← QuotientGroup.mk_mul, ← QuotientGroup.mk_pow]
  have : (FreeGroup.of i * FreeGroup.of i') ^ M i i' ∈ CoxeterGroup.Relations.toSet M := by
    use (i, i')
    rfl
  have : (QuotientGroup.mk ((FreeGroup.of i * FreeGroup.of i') ^ M i i') : CoxeterGroup M) = 1 := by
    apply (QuotientGroup.eq_one_iff _).mpr
    exact Subgroup.subset_normalClosure this
  rw [this]
  simp

/-- The proposition that the values of the function `f : B → G` satisfy the Coxeter relations
corresponding to the matrix `M`. -/
def IsLiftable {G : Type*} [Monoid G] (M : Matrix B B ℕ) (f : B → G) : Prop :=
    ∀ i i' : B, (f i * f i') ^ M i i' = 1

private theorem relations_liftable {G : Type*} [Group G] {f : B → G} (hf : IsLiftable M f) :
    ∀ r ∈ CoxeterGroup.Relations.toSet M, (FreeGroup.lift f) r = 1 := by
  rintro r ⟨⟨i, i'⟩, rfl⟩
  dsimp [CoxeterGroup.Relations.ofMatrix]
  rw [map_pow, _root_.map_mul, FreeGroup.lift.of, FreeGroup.lift.of]
  exact hf i i'

private def groupLift {G : Type*} [Group G] {f : B → G} (hf : IsLiftable M f) : W →* G :=
  MonoidHom.comp (PresentedGroup.toGroup (relations_liftable hf)) cs.mulEquiv.toMonoidHom

private def restrictUnit {G : Type*} [Monoid G] {f : B → G} (hf : IsLiftable M f) : B → Gˣ :=
  fun i ↦ {
    val := f i,
    inv := f i,
    val_inv := by
      have := hf i i
      rwa [cs.isCoxeter.diagonal, pow_one] at this,
    inv_val := by
      have := hf i i
      rwa [cs.isCoxeter.diagonal, pow_one] at this
  }
/-- Extend the function `f : B → G` to a monoid homomorphism
`f' : W → G` satisfying `f' (s i) = f i` for all `i`.
-/
def lift {G : Type*} [Monoid G] {f : B → G} (hf : IsLiftable M f) : W →* G :=
  MonoidHom.comp (Units.coeHom G) (cs.groupLift
      (show ∀ i i' : B, ((cs.restrictUnit hf) i * (cs.restrictUnit hf) i') ^ M i i' = 1 by
    intro i i'
    apply Units.ext
    simp
    exact hf i i'))

private theorem toMonoidHom_symm (a : PresentedGroup (CoxeterGroup.Relations.toSet M)):
    (MulEquiv.toMonoidHom cs.mulEquiv : W →* PresentedGroup (CoxeterGroup.Relations.toSet M))
    ((MulEquiv.symm cs.mulEquiv) a) = a := calc
  _ = cs.mulEquiv ((MulEquiv.symm cs.mulEquiv) a) := by rfl
  _ = _                                           := by simp

theorem lift_apply_simple {G : Type*} [Monoid G] {f : B → G}
    (hf : IsLiftable M f) (i : B) : cs.lift hf (s i) = f i := by
  dsimp only [simpleReflection, lift, groupLift, MonoidHom.comp_apply]
  rw [← MonoidHom.toFun_eq_coe]
  rw [toMonoidHom_symm cs (PresentedGroup.of i)]
  simp
  rfl

/-! ### Words and length -/
/-- The product of the simple reflections of `W` corresponding to the indices in `ω`.-/
def wordProd (ω : List B) : W := prod (map cs.simpleReflection ω)

local prefix:100 "π" => cs.wordProd

@[simp] theorem wordProd_nil :
    π [] = 1 := by simp [wordProd]

@[simp] theorem wordProd_cons (i : B) (ω : List B) :
    π (i :: ω) = s i * π ω := by simp [wordProd]

@[simp] theorem wordProd_concat (i : B) (ω : List B) :
    π (ω.concat i) = π ω * s i := by simp [wordProd]

@[simp] theorem wordProd_append (ω ω' : List B) :
    π (ω ++ ω') = π ω * π ω' := by simp [wordProd]

@[simp] theorem wordProd_rev (ω : List B) :
    π (reverse ω) = (π ω)⁻¹ := by
  induction' ω with x ω' ih
  · simp
  · simp; exact ih

private lemma freeGroup_wordProd (ω : List (B × Bool)) :
    prod (map ((@PresentedGroup.of B (CoxeterGroup.Relations.toSet M)) ∘ Prod.fst) ω)
    = QuotientGroup.mk (FreeGroup.mk ω) := by
  induction' ω with x ω' ih
  · simp [← FreeGroup.one_eq_mk]
  · rw [← List.singleton_append, ← FreeGroup.mul_mk, QuotientGroup.mk_mul, ← ih]
    simp
    rcases x with ⟨i, b⟩
    rcases b
    · have : [(i, false)] = FreeGroup.invRev [(i, true)] := by simp [FreeGroup.invRev]
      rw [this, ← FreeGroup.inv_mk, ← FreeGroup.of, QuotientGroup.mk_inv]
      simp
      rw [PresentedGroup.of]
      apply eq_inv_of_mul_eq_one_right
      rw [← QuotientGroup.mk_mul]
      exact cs.coxeterGroup_simple_mul_self i
    · rfl

theorem wordProd_surjective : Surjective (cs.wordProd) := by
  intro u
  let v : CoxeterGroup M := cs.mulEquiv.toFun u
  rcases (QuotientGroup.mk'_surjective _) v with ⟨w, hw⟩
  simp at hw -- hw: ↑w = v
  let ω := List.map Prod.fst w.toWord
  use ω
  simp [ω, wordProd]
  calc
    prod (List.map (simpleReflection cs ∘ Prod.fst) (FreeGroup.toWord w))
    _ = prod (List.map (
          cs.mulEquiv.symm
          ∘ (@PresentedGroup.of B (CoxeterGroup.Relations.toSet M))
          ∘ Prod.fst)
        (FreeGroup.toWord w))           := by congr
    _ = prod (List.map (
          cs.mulEquiv.symm
          ∘ ((@PresentedGroup.of B (CoxeterGroup.Relations.toSet M))
          ∘ Prod.fst))
        (FreeGroup.toWord w))           := by congr
    _ = prod (List.map cs.mulEquiv.symm
        (List.map ((@PresentedGroup.of B (CoxeterGroup.Relations.toSet M)) ∘ Prod.fst)
          (FreeGroup.toWord w)))        := by rw[List.map_map]
    _ = cs.mulEquiv.symm (prod (List.map
            ((@PresentedGroup.of B (CoxeterGroup.Relations.toSet M)) ∘ Prod.fst)
        (FreeGroup.toWord w)))          := by rw[map_list_prod]
    _ = cs.mulEquiv.symm (QuotientGroup.mk (FreeGroup.mk (FreeGroup.toWord w)))
                                        := by rw[cs.freeGroup_wordProd]
    _ = cs.mulEquiv.symm (QuotientGroup.mk w)
                                        := by rw[FreeGroup.mk_toWord]
    _ = u                               := by rw[hw]; dsimp [v]; simp


instance (w : W) : DecidablePred (fun n ↦ ∃ ω : List B, ω.length = n ∧ π ω = w)
  := Classical.decPred _

private theorem exists_word_with_prod (w : W) : ∃ n : ℕ, ∃ ω : List B, ω.length = n ∧ π ω = w := by
  rcases cs.wordProd_surjective w with ⟨ω, rfl⟩
  use ω.length, ω

/-- The length of `w`; i.e., the minimum number of simple reflections that
must be multiplied to form `w`. -/
def length (w : W) : ℕ := Nat.find (cs.exists_word_with_prod w)

local prefix:100 "ℓ" => cs.length

theorem exists_reduced_word (w : W) : ∃ ω : List B, ω.length = ℓ w ∧ w = π ω := by
  have := Nat.find_spec (cs.exists_word_with_prod w)
  tauto

theorem wordProd_length_le (ω : List B) : ℓ (π ω) ≤ ω.length := by
  apply Nat.find_min' (cs.exists_word_with_prod (π ω))
  use ω

@[simp] theorem length_one : ℓ (1 : W) = 0 := Nat.eq_zero_of_le_zero (cs.wordProd_length_le [])

theorem length_eq_zero_iff {w : W} : ℓ w = 0 ↔ w = 1 := by
  constructor
  · intro h
    rcases cs.exists_reduced_word w with ⟨ω, hω, rfl⟩
    have : ω = [] := eq_nil_of_length_eq_zero (hω.trans h)
    rw [this]
    simp
  · rintro rfl
    exact cs.length_one

@[simp] theorem length_inv (w : W) : ℓ (w⁻¹) = ℓ w := by
  apply Nat.le_antisymm
  · rcases cs.exists_reduced_word w with ⟨ω, hω, rfl⟩
    have := cs.wordProd_length_le (List.reverse ω)
    simp at this
    rwa [hω] at this
  · rcases cs.exists_reduced_word w⁻¹ with ⟨ω, hω, h'ω⟩
    have := cs.wordProd_length_le (List.reverse ω)
    simp at this
    rwa [← h'ω, hω, inv_inv] at this

theorem length_mul_le (w₁ w₂ : W) :
    ℓ (w₁ * w₂) ≤ ℓ w₁ + ℓ w₂ := by
  rcases cs.exists_reduced_word w₁ with ⟨ω₁, hω₁, rfl⟩
  rcases cs.exists_reduced_word w₂ with ⟨ω₂, hω₂, rfl⟩
  have := cs.wordProd_length_le (ω₁ ++ ω₂)
  simp at this
  rwa [hω₁, hω₂] at this

theorem length_mul_ge (w₁ w₂ : W) :
    ℓ (w₁ * w₂) ≥ max (ℓ w₁ - ℓ w₂) (ℓ w₂ - ℓ w₁) := by
  apply max_le_iff.mpr
  constructor
  · apply Nat.sub_le_of_le_add
    have := cs.length_mul_le (w₁ * w₂) w₂⁻¹
    simp at this
    assumption
  · apply Nat.sub_le_of_le_add
    have := cs.length_mul_le (w₁ * w₂)⁻¹ w₁
    simp only [length_inv] at this
    simp at this
    assumption

private def lengthParity (cs : CoxeterSystem M W) : W →* Multiplicative (ZMod 2) := cs.lift (
    show IsLiftable M (fun _ ↦ Multiplicative.ofAdd 1) by
      intro i i'
      dsimp
      rw [← ofAdd_add, one_add_one_eq_two, (by decide : (2 : ZMod 2) = 0)]
      simp
  )

private theorem lengthParity_simple :
    ⇑(CoxeterSystem.lengthParity cs) ∘ simpleReflection cs = fun _ ↦ Multiplicative.ofAdd 1 := by
  ext x
  simp
  rw [lengthParity, lift_apply_simple]

private theorem parity_length_eq' (w : W) :
    Multiplicative.toAdd (cs.lengthParity w) = ((↑) : ℕ → ZMod 2) (ℓ w) := by
  rcases cs.exists_reduced_word w with ⟨ω, hω, rfl⟩
  nth_rw 1 [wordProd]
  rw [MonoidHom.map_list_prod, List.map_map, lengthParity_simple]
  simp
  tauto

theorem length_mul_mod_two (w₁ w₂ : W) : ℓ (w₁ * w₂) % 2 = (ℓ w₁ + ℓ w₂) % 2 := by
  rw [← ZMod.nat_cast_eq_nat_cast_iff']
  rw [(by simp : (↑(length cs w₁ + length cs w₂) : ZMod 2) = ↑(length cs w₁) + ↑(length cs w₂))]
  repeat rw [← parity_length_eq']
  simp

@[simp] theorem length_simple (i : B) : ℓ (s i) = 1 := by
  apply Nat.le_antisymm
  · show length cs (s i) ≤ 1
    have := cs.wordProd_length_le [i]
    simp at this
    tauto
  · show 1 ≤ length cs (s i)
    by_contra! length_lt_1
    have := congrArg Multiplicative.toAdd (congrFun cs.lengthParity_simple i)
    simp [parity_length_eq'] at this
    rw [Nat.lt_one_iff.mp length_lt_1] at this
    contradiction

theorem length_eq_one_iff {w : W} : ℓ w = 1 ↔ ∃ i : B, w = s i := by
  constructor
  · intro h
    rcases cs.exists_reduced_word w with ⟨ω, hω, rfl⟩
    rcases List.length_eq_one.mp (hω.trans h) with ⟨i, rfl⟩
    use i
    simp
  · rintro ⟨i, rfl⟩
    exact cs.length_simple i

theorem length_mul_simple (w : W) (i : B) :
    ℓ (w * s i) = ℓ w + 1 ∨ ℓ (w * s i) + 1 = ℓ w := by
  have length_le := cs.length_mul_le w (s i)
  simp at length_le
  have length_ge := (max_le_iff.mp (cs.length_mul_ge w (s i))).left
  simp at length_ge
  have length_mod_two := cs.length_mul_mod_two w (s i)

  have h : ℓ (w * s i) ≠ ℓ w := by
    intro eq
    rw [eq] at length_mod_two
    simp at length_mod_two
    rcases Nat.mod_two_eq_zero_or_one (ℓ w) with even | odd
    · rw [even, Nat.succ_mod_two_eq_one_iff.mpr even] at length_mod_two
      contradiction
    · rw [odd, Nat.succ_mod_two_eq_zero_iff.mpr odd] at length_mod_two
      contradiction

  rcases Nat.ne_iff_lt_or_gt.mp h with less | greater
  · right
    linarith
  · left
    linarith

theorem length_simple_mul (w : W) (i : B) :
    ℓ (s i * w) = ℓ w + 1 ∨ ℓ (s i * w) + 1 = ℓ w := by
  have := cs.length_mul_simple w⁻¹ i
  rwa [(by simp : w⁻¹ * (s i) = ((s i) * w)⁻¹), length_inv, length_inv] at this

/-- The word of length `m` that alternates between `i` and `i'`, ending with `i'`.-/
def alternatingWord (i i' : B) (m : ℕ) : List B := sorry

theorem length_alternatingWord (i i' : B) (m : ℕ) : List.length (alternatingWord i i' m) = m := by
  sorry

theorem prod_alternatingWord_eq (i i' : B) (m : ℕ) (hm : m ≤ 2 * (M i i')) :
    π (alternatingWord i i' m) = π (alternatingWord i' i (2 * M i i' - m)) := by
  sorry

/-! ### Reduced words -/

def IsReduced (ω : List B) : Prop := ℓ (π ω) = ω.length

theorem exists_reduced_word' (w : W) : ∃ ω : List B, cs.IsReduced ω ∧ w = π ω := by
  rcases cs.exists_reduced_word w with ⟨ω, hω, rfl⟩
  use ω
  tauto

theorem isReduced_take (ω : List B) (rω : cs.IsReduced ω) (j : ℕ) : cs.IsReduced (ω.take j) := by
  sorry

theorem isReduced_drop (ω : List B) (rω : cs.IsReduced ω) (j : ℕ) : cs.IsReduced (ω.drop j) := by
  sorry

theorem alternatingWord_not_reduced (i i' : B) (m : ℕ) (hM : M i i' ≠ 0) (hm : m > M i i') :
    ¬ cs.IsReduced (alternatingWord i i' m) := by
  sorry

/-! ### Reflections, inversions, and inversion sequences -/

/-- The proposition that `t` is a reflection of the Coxeter system `cs`; i.e., it is of the form
$w s_i w^{-1}$, where $w \in W$ and $s_i$ is a simple reflection. -/
def IsReflection (t : W) : Prop := ∃ w : W, ∃ i : B, t = w * s i * w⁻¹

def reflections : Set W := {t : W | cs.IsReflection t}

theorem isInvolution_of_isReflection (t : W) (rt : cs.IsReflection t) : t ^ 2 = 1 := by
  sorry

theorem length_reflection_odd (t : W) (rt : cs.IsReflection t) : Odd (ℓ t) := by
  sorry

/-- The proposition that `t` is a left inversion of `w`; i.e., `t` is a reflection and
$\ell (t w) < \ell(w)$. -/
def IsLeftInversion (w t : W) : Prop := cs.IsReflection t ∧ ℓ (t * w) < ℓ w
/-- The proposition that `t` is a right inversion of `w`; i.e., `t` is a reflection and
$\ell (w t) < \ell(w)$. -/
def IsRightInversion (w t : W) : Prop := cs.IsReflection t ∧ ℓ (w * t) < ℓ w

/-- The left inversion sequence of `ω`. The left inversion sequence of a word
$s_{i_1} \cdots s_{i_\ell}$ is the sequence
$$s_{i_1}, s_{i_1}s_{i_2}s_{i_1}, s_{i_1}s_{i_2}s_{i_3}s_{i_2}s_{i_1}, \ldots,
    s_{i_1}\cdots s_{i_\ell}\cdots s_{i_1}.$$
-/
def leftInvSeq (cs : CoxeterSystem M W) (ω : List B) : List W := sorry
/-- The right inversion sequence of `ω`. The right inversion sequence of a word
$s_{i_1} \cdots s_{i_\ell}$ is the sequence
$$s_{i_\ell}\cdots s_{i_1}\cdots s_{i_\ell}, \ldots,
    s_{i_{\ell}}s_{i_{\ell - 1}}s_{i_{\ell - 2}}s_{i_{\ell - 1}}s_{i_\ell}, \ldots,
    s_{i_{\ell}}s_{i_{\ell - 1}}s_{i_\ell}, s_{i_\ell}.$$
-/
def rightInvSeq (cs : CoxeterSystem M W) (ω : List B) : List W := sorry

local prefix:100 "lis" => cs.leftInvSeq
local prefix:100 "ris" => cs.rightInvSeq

@[simp] theorem length_leftInvSeq (ω : List B) : (lis ω).length = ω.length := by
  sorry

@[simp] theorem length_rightInvSeq (ω : List B) : (ris ω).length = ω.length := by
  sorry

theorem all_leftInvSeq_isReflection (ω : List B) : ∀ t ∈ lis ω, cs.IsReflection t := by
  sorry

theorem all_rightInvSeq_isReflection (ω : List B) : ∀ t ∈ ris ω, cs.IsReflection t := by
  sorry

@[simp] theorem leftInvSeq_rev (ω : List B) :
    lis (ω.reverse) = (ris ω).reverse := by
  sorry

@[simp] theorem rightInvSeq_rev (ω : List B) :
    ris (ω.reverse) = (lis ω).reverse := by
  sorry

@[simp] theorem leftInvSeq_take (ω : List B) (j : ℕ) :
    lis (ω.take j) = (lis ω).take j := by
  sorry

@[simp] theorem rightInvSeq_drop (ω : List B) (j : ℕ) :
    ris (ω.drop j) = (ris ω).drop j := by
  sorry

theorem leftInvSeq_i_mul (ω : List B) (j : Fin (lis ω).length) :
    (lis ω)[j] * π ω = π (ω.eraseIdx j) := by
  sorry

theorem rightInvSeq_i_mul (ω : List B) (j : Fin (ris ω).length) :
    π ω * (ris ω)[j] = π (ω.eraseIdx j) := by
  sorry

theorem prod_leftInvSeq (ω : List B) : prod (lis ω) = (π ω)⁻¹ := by
  sorry

theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = (π ω)⁻¹ := by
  sorry

private lemma nodup_leftInvSeq_of_reduced (ω : List B) (rω : cs.IsReduced ω) :
    List.Nodup (lis ω) := by
  sorry

private lemma nodup_rightInvSeq_of_reduced (ω : List B) (rω : cs.IsReduced ω) :
    List.Nodup (ris ω) := by
  sorry

/-! ### The standard geometric representation
Given a Coxeter group `W` whose simple reflections are indexed by a set `B`, we define
the standard geometric representation of `W`, which is a representation of `W` with underlying
vector space `B →₀ ℝ`. We then use this to define the set of roots, which is a subset of
`B →₀ ℝ`. The roots correspond two-to-one to the reflections of `W`.
-/

def simpleRoot (i : B) : B →₀ ℝ := Finsupp.single i 1
local prefix:100 "α" => simpleRoot

/-- The standard bilinear form on `B →₀ ℝ`. Given by `⟪αᵢ, αⱼ⟫ = -cos (π / Mᵢⱼ)`
for `i j : B`, where {αᵢ} is the standard basis of `B →₀ ℝ` and `M` is the Coxeter matrix.
This is positive definite if and only if the associated Coxeter group is finite. -/
def standardBilinForm (M : Matrix B B ℕ) : LinearMap.BilinForm ℝ (B →₀ ℝ) := sorry

local notation:max "⟪"  a  ","  b  "⟫" => standardBilinForm M a b

theorem standardBilinForm_symm (M : Matrix B B ℕ) : LinearMap.IsSymm (standardBilinForm M) := by
  sorry

@[simp] theorem standardBilinForm_simpleRoots (i i' : B) :
    ⟪α i, α i'⟫ = Real.cos (Real.pi / M i i') := by
  sorry

/-- The orthogonal reflection in the vector `v` under the standard bilinear form.
-/
def orthoReflection (M : Matrix B B ℕ) (v : B →₀ ℝ) : (B →₀ ℝ) →ₗ[ℝ] (B →₀ ℝ) := sorry

theorem orthoReflection_sqr_eq_id (M : Matrix B B ℕ) (v : B →₀ ℝ) :
    (orthoReflection M v) * (orthoReflection M v) = LinearMap.id := by
  sorry

theorem orthoReflection_eq_iff (M : Matrix B B ℕ) (v v' : B →₀ ℝ) (hv : ⟪v, v⟫ ≠ 0):
    orthoReflection M v = orthoReflection M v' ↔ ∃ μ : ℝ, v' = μ • v := by
  sorry

/-- The standard geometric representation on `B →₀ ℝ`. For `i : B`, the simple reflection `sᵢ`
acts by `sᵢ v = v - 2 ⟪αᵢ, v⟫ * αᵢ`, where {αᵢ} is the standard basis of `B →₀ ℝ`.
-/
def standardGeometricRepresentation (cs : CoxeterSystem M W) : Representation ℝ W (B →₀ ℝ) := sorry

alias SGR := standardGeometricRepresentation

theorem SGR_simple (i : B) : cs.SGR (s i) = orthoReflection M (α i) := by
  sorry

theorem SGR_simple_simpleRoot (i i' : B) :
    cs.SGR (s i) (α i') = α i' - ((2 : ℝ) * cos (Real.pi / M i i')) • α i := by
  sorry

theorem SGR_simple_simpleRoot_self (i : B) : cs.SGR (s i) (α i) = -α i := by
  sorry


theorem SGR_bilin_eq_bilin (w : W) (v v' : B →₀ ℝ) : ⟪cs.SGR w v, cs.SGR w v'⟫ = ⟪v, v'⟫ := by
  sorry

theorem SGR_alternatingWord_simpleRoot (i i' : B) (m : ℕ) (hM : M i i' ≠ 0) :
    cs.SGR (π (alternatingWord i i' m)) (α i) = if Even m
      then (sin ((m + 1) * Real.pi / M i i') / sin (Real.pi / M i i')) • (α i)
        + (sin (m * Real.pi / M i i') / sin (Real.pi / M i i')) • (α i')
      else (sin (m * Real.pi / M i i') / sin (Real.pi / M i i')) • (α i)
        + (sin ((m + 1) * Real.pi / M i i') / sin (Real.pi / M i i')) • (α i') := by
  sorry

theorem SGR_alternatingWord_simpleRoot' (i i' : B) (m : ℕ) (hM : M i i' = 0) :
    cs.SGR (π (alternatingWord i i' m)) (α i) = if Even m
      then (m + 1) • (α i) + m • (α i')
      else m • (α i) + (m + 1) • (α i') := by
  sorry

/-- The roots of the standard geometric representation; i.e. the vectors that can be written
in the form w αᵢ, where `w : W` and {αᵢ} is the standard basis of `B →₀ ℝ`. If `W` is infinite,
then this is not a root system in the sense of `Mathlib.LinearAlgebra.RootSystem` because it is
infinite and because `B →₀ ℝ` is not an inner product space.
-/
def roots : Set (B →₀ ℝ) := {v : B →₀ ℝ | ∃ w : W, ∃ i : B, v = cs.SGR w (α i)}

/-- The roots that can be written as a nonnegative linear combination of the standard basis vectors
`αᵢ`.-/
def posRoots : Set (B →₀ ℝ) := cs.roots ∩ {v : B →₀ ℝ | ∀ i : B, v i ≥ 0}
/-- The roots that can be written as a nonpositive linear combination of the standard basis vectors
`αᵢ`.-/
def negRoots : Set (B →₀ ℝ) := cs.roots ∩ {v : B →₀ ℝ | ∀ i : B, v i ≤ 0}


@[simp] theorem roots_invariant (w : W) (v : B →₀ ℝ) : cs.SGR w v ∈ cs.roots ↔ v ∈ cs.roots := by
  sorry

@[simp] theorem roots_eq_neg_roots : -cs.roots = cs.roots := by
  sorry

theorem negRoots_eq_neg_posRoots : cs.negRoots = -cs.posRoots := by
  sorry

theorem SGR_simpleRoot_mem_posRoot_of (w : W) (i : B) :
    ℓ (w * s i) = ℓ w + 1 → cs.SGR w (α i) ∈ cs.posRoots := by
  sorry

theorem SGR_simpleRoot_mem_negRoot_of (w : W) (i : B) :
    ℓ (w * s i) + 1 = ℓ w → cs.SGR w (α i) ∈ cs.negRoots := by
  sorry

theorem SGR_simpleRoot_mem_posRoot_iff (w : W) (i : B) :
    ℓ (w * s i) = ℓ w + 1 ↔ cs.SGR w (α i) ∈ cs.posRoots := by
  sorry

theorem SGR_simpleRoot_mem_negRoot_iff (w : W) (i : B) :
    ℓ (w * s i) + 1 = ℓ w ↔ cs.SGR w (α i) ∈ cs.negRoots := by
  sorry

theorem root_pos_or_neg : cs.roots = cs.posRoots ∪ cs.negRoots := by
  sorry

theorem root_not_pos_and_neg : cs.posRoots ∩ cs.negRoots = ∅ := by
  sorry

theorem SGR_injective : Injective cs.SGR := by
  sorry

def reflectionToRoot : cs.reflections ≃ cs.posRoots := sorry

theorem reflection_by_smul (w : W) (v : B →₀ ℝ) :
    orthoReflection M (cs.SGR w v) = (cs.SGR w) ∘ (orthoReflection M v) ∘ (cs.SGR w⁻¹) := by
  sorry

theorem reflection_by_root (γ : cs.posRoots) :
    orthoReflection M γ = cs.SGR (cs.reflectionToRoot.invFun γ) := by
  sorry

theorem isRightInversion_iff (w : W) (t : cs.reflections) : cs.IsRightInversion w t ↔
    cs.SGR w (cs.reflectionToRoot.toFun t) ∈ cs.negRoots := by
  sorry

/-! ### The (strong) exchange properties and deletion property -/

/-- The (strong) left exchange property:
Let $w = s_{i_1} \cdots s_{i_\ell}$ be a reduced expression for an element $w \in W$
and let $t \in W$.
The following are equivalent:

* $t$ is a left inversion of $w$.
* $t$ appears in the left inversion sequence of the word $s_{i_1} \cdots s_{i_\ell}$.
* There exists $j$ with $1 \leq j \leq \ell$ such that
  $$tw = s_{i_1} \cdots \widehat{s_{i_j}} \cdots s_{i_\ell}$$
  (i.e. the result of multiplying all of the simple reflections $s_{i_1}, \ldots, s_{i_\ell}$
  except $s_{i_j}$).
-/
theorem left_exchange_property (ω : List B) (t : W) (rω : cs.IsReduced ω) :
    List.TFAE [
      cs.IsLeftInversion (π ω) t,
      t ∈ lis ω,
      ∃ j < ω.length, t * (π ω) = π (ω.eraseIdx j)
    ] := by
  sorry

/-- The (strong) right exchange property:
Let $w = s_{i_1} \cdots s_{i_\ell}$ be a reduced expression for an element $w \in W$
and let $t \in W$.
The following are equivalent:

* $t$ is a right inversion of $w$.
* $t$ appears in the right inversion sequence of the word $s_{i_1} \cdots s_{i_\ell}$.
* There exists $j$ with $1 \leq j \leq \ell$ such that
  $$wt = s_{i_1} \cdots \widehat{s_{i_j}} \cdots s_{i_\ell}$$
  (i.e. the result of multiplying all of the simple reflections $s_{i_1}, \ldots, s_{i_\ell}$
  except $s_{i_j}$).
\end{enumerate}
-/
theorem right_exchange_property (ω : List B) (t : W) (rω : cs.IsReduced ω) :
    List.TFAE [
      cs.IsRightInversion (π ω) t,
      t ∈ ris ω,
      ∃ j < ω.length, (π ω) * t = π (ω.eraseIdx j)
    ] := by
  sorry

theorem nodup_leftInvSeq_iff (ω : List B) :
    List.Nodup (lis ω) ↔ cs.IsReduced ω := by
  sorry

theorem nodup_rightInvSeq_iff (ω : List B) :
    List.Nodup (ris ω) ↔ cs.IsReduced ω := by
  sorry

/-- The deletion property:
If $s_{i_1} \cdots s_{i_\ell}$ is not a reduced expression, then there are $i, j$ with
$1 \leq j < j' \leq \ell$ such that
$$s_{i_1} \cdots s_{i_\ell} =
s_{i_1} \cdots \widehat{s_{i_j}} \cdots \widehat{s_{i_{j'}}} \cdots s_{i_\ell}$$.
-/
theorem deletion_property (ω : List B) (nrω : ¬ cs.IsReduced ω) :
    ∃ j' < ω.length, ∃ j < j', π ((ω.eraseIdx j').eraseIdx j) = π ω := by
  sorry

end CoxeterSystem
/-
TODO: Inversion set is finite. Size of inversion set = length.
Matsumoto's theorem.
Simple reflections are distinct.
Order of s_i s_j is exactly M i j.

Eₙ for n > 8.

Irreducibility. Irreducible components.
Parabolic subgroups.
Poincare series.

The standard geometric representation. It is faithful.
Height of a root.
Standard geometric representation is orthogonal if and only if W is finite.
Classification of irreducible finite Coxeter groups.
Classification of irreducible affine Coxeter groups.

Small roots.
Coxeter groups are automatic.

Long element has all reflections as inversions. Long element is an involution.
Properties of Coxeter number.

The weak order. Ungar moves. Ungar's problem.

Bruhat order.

Combinatorially describe finite and affine Coxeter groups of types A, B, C, D.
Interpret inversions, descents, length, convex sets, parabolic subgroups, Bruhat order.

Schubert polynomials.

Associated hyperplane arrangements and partition lattices and their characteristic polynomials.
Folding.
Convex sets.
Coxeter elements, c-sorting words.
Powers of Coxeter elements in infinite groups are reduced.
Futuristic Coxeter groups.
-/
end
