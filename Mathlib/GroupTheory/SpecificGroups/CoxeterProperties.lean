/-
Copyright (c) 2024 Mitchell Lee. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Mitchell Lee
-/
import Mathlib.GroupTheory.SpecificGroups.Coxeter
import Mathlib.Data.ZMod.Defs
import Mathlib.RepresentationTheory.Basic
import Mathlib.Data.Real.Basic
import Mathlib.Data.Complex.Exponential
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Basic
import Mathlib.LinearAlgebra.BilinearMap
import Mathlib.Data.Int.Parity

/-!
# Properties of Coxeter groups
This file states and proves some properties of Coxeter systems.

Throughout this file, `B` is a type and `M : Matrix B B ℕ` is a Coxeter matrix.
`cs : CoxeterSystem M W` is a Coxeter system; that is, `W` is a group, and `cs` holds the data
of a group isomorphism `W ≃* Matrix.CoxeterGroup M`, where `Matrix.CoxeterGroup M` refers to
the quotient of the free group on `B` by the Coxeter relations given by the matrix `M`. See
`Mathlib.GroupTheory.SpecificGroups.Coxeter` for more details.

We define the simple reflections $s_i$ of the Coxeter group $W$ for `i : B`. Using this, we define
the length function $\ell : W → \mathbb{N}$, and we prove that
$\ell (w_1 w_2) \leq \ell (w_1) + \ell (w_2)$
and that $\ell (w_1 w_2)$ and $\ell (w_1) + \ell (w_2)$ have the same parity.

We define a *reduced word* for an element $w \in W$ to be a way of writing $w$ as a product
of exactly $\ell(w)$ simple reflections. We define a *reflection* to be an element of the form
$t = u s_i u^{-1}$, where $u \in W$ and $s_i$ is a simple reflection. We say that a reflection $t$
is a *left inversion* of an element $w \in W$ if $\ell(t w) < \ell (w)$, and we say it is a
*right inversion* of $w$ if $\ell(w t) > \ell(w)$.

We prove that, given a reduced word for $w$, one can recover the set of left inversions or right
inversions by taking the *inversion sequence* of the reduced word. We prove that $\ell(w)$ is
equal to the number of left inversions of $w$ and equal to the number of right inversions of $w$.
We also prove the *deletion property*: every non-reduced word for an element $w$ can be decreased
in length by deleting two of its simple reflections.

Central to our approach is the *standard geometric representation* of $W$, which is a faithful
representation of $W$ on the free vector space over `B`. Every reflection of $W$ acts by a
reflection in the standard geometric representation. We also define the associated set of *roots*
(which is not necessarily a root system in the sense of `Mathlib.LinearAlgebra.RootSystem`),
and prove that they correspond two-to-one to the reflections of $W$.

## Main definitions
* `cs.simpleReflection `: The simple reflection corresponding to an index `i : B`.
* `cs.lift`: Given `f : B → G`, where `G` is a monoid and `f` is a function whose values satisfy
the Coxeter relations, extend it to a monoid homomorphism `f' : W → G` satisfying
`f' (s i) = f i` for all `i`.
* `cs.wordProd`: Given a `List B`, returns the product of the corresponding simple reflections.
* `cs.length`
* `cs.IsReflection`
* `cs.IsLeftInversion`
* `cs.IsRightInversion`
* `cs.standardBilinForm`: The invariant bilinear form associated to the standard geometric
representation.
* `cs.standardGeometricRepresentation`: The standard geometric representation of `W`. This has type
`Representation ℝ W (B →₀ ℝ)`.
* `cs.roots`
* `cs.posRoots`
* `cs.negRoots`
* `cs.leftInvSeq`
* `cs.rightInvSeq`

## Implementation notes
In most texts on Coxeter groups, each entry $M_{i,i'}$ of the Coxeter matrix can be either a positive
integer or $\infty$. A value of $\infty$ indicates that there is no relation between the
corresponding simple reflections. In our treatment of Coxeter groups, we use the value $0$ instead
of $\infty$. This decision has two fortunate consequences. First, the Coxeter relation
$(s_i s_{i'})^{M_{i, i'}}$ is automatically the identity if $M_{i, i'} = 0$. Second, when we define
the standard bilinear form by $\langle \alpha_i, \alpha_{i'}\rangle = - \cos(\pi / M_{i,i'})$, Lean
computes $- \cos(\pi / M_{i,i'})$ to have the correct value of $-1$ if $M_{i, i'} = 0$.

## References
* [A. Björner and F. Brenti, *Combinatorics of Coxeter Groups*][bjorner2005]

## TODO
* Introduce some ways to actually construct some Coxeter groups. For example, given a Coxeter matrix
$M : B \times B \to \mathbb{N}$, a real vector space $V$, a basis $\{\alpha_i : i \in B\}$
and a bilinear form $\langle \cdot, \cdot \rangle \colon V \times V \to \mathbb{R}$ satisfying
$$\langle \alpha_i, \alpha_{i'}\rangle = - \cos(\pi / M_{i,i'}),$$ one can form the subgroup of
$GL(V)$ generated by the reflections in the $\alpha_i$, and it is a Coxeter group. We can use this
to combinatorially describe the Coxeter groups of type $A$, $B$, $D$, and $I$.
* State and prove Matsumoto's theorem.
* Classify the finite Coxeter groups.
-/

noncomputable section

namespace CoxeterSystem

open List Matrix Function Real

variable {B : Type*} [DecidableEq B]
variable {M : Matrix B B ℕ}
variable {W : Type*} [Group W]
variable (cs : CoxeterSystem M W)

/-! ### Simple reflections and lifting homomorphisms -/

/-- The simple reflection of `W` corresponding to the index `i`. -/
def simpleReflection (i : B) : W := cs.mulEquiv.symm (PresentedGroup.of i)

local prefix:100 "s" => cs.simpleReflection

private lemma coxeterGroup_simple_mul_self (i : B) :
    (QuotientGroup.mk ((FreeGroup.of i) * (FreeGroup.of i)) : CoxeterGroup M) = 1 := by
  have : (FreeGroup.of i) * (FreeGroup.of i) ∈ CoxeterGroup.Relations.toSet M := by
    use (i, i)
    dsimp [CoxeterGroup.Relations.ofMatrix]
    rw [cs.isCoxeter.diagonal i, pow_one]
  apply (QuotientGroup.eq_one_iff _).mpr
  exact Subgroup.subset_normalClosure this

@[simp] theorem simple_mul_self (i : B) : (s i) * (s i) = 1 := by
  dsimp [simpleReflection]
  rw [← _root_.map_mul, PresentedGroup.of, ← QuotientGroup.mk_mul]
  rw [cs.coxeterGroup_simple_mul_self i]
  simp

@[simp] theorem simple_sqr (i : B) : (s i) ^ 2 = 1 := by
  rw [pow_two]
  exact cs.simple_mul_self i

@[simp] theorem simple_inv (i : B) : (s i)⁻¹ = s i :=
  (eq_inv_of_mul_eq_one_right (cs.simple_mul_self i)).symm

@[simp] theorem simple_mul_pow (i i' : B) : ((s i) * (s i')) ^ M i i' = 1 := by
  dsimp [simpleReflection]
  rw [← _root_.map_mul, ← map_pow, PresentedGroup.of, PresentedGroup.of,
      ← QuotientGroup.mk_mul, ← QuotientGroup.mk_pow]
  have : (FreeGroup.of i * FreeGroup.of i') ^ M i i' ∈ CoxeterGroup.Relations.toSet M := by
    use (i, i')
    rfl
  have : (QuotientGroup.mk ((FreeGroup.of i * FreeGroup.of i') ^ M i i') : CoxeterGroup M) = 1 := by
    apply (QuotientGroup.eq_one_iff _).mpr
    exact Subgroup.subset_normalClosure this
  rw [this]
  simp

@[simp] theorem simple_mul_pow' (i i' : B) : ((s i') * (s i)) ^ M i i' = 1 := by
  rw [cs.isCoxeter.symmetric.apply i' i]
  exact cs.simple_mul_pow i' i

/-- The proposition that the values of the function `f : B → G` satisfy the Coxeter relations
corresponding to the matrix `M`. -/
def IsLiftable {G : Type*} [Monoid G] (M : Matrix B B ℕ) (f : B → G) : Prop :=
    ∀ i i' : B, (f i * f i') ^ M i i' = 1

private theorem relations_liftable {G : Type*} [Group G] {f : B → G} (hf : IsLiftable M f) :
    ∀ r ∈ CoxeterGroup.Relations.toSet M, (FreeGroup.lift f) r = 1 := by
  rintro r ⟨⟨i, i'⟩, rfl⟩
  dsimp [CoxeterGroup.Relations.ofMatrix]
  rw [map_pow, _root_.map_mul, FreeGroup.lift.of, FreeGroup.lift.of]
  exact hf i i'

private def groupLift {G : Type*} [Group G] {f : B → G} (hf : IsLiftable M f) : W →* G :=
  MonoidHom.comp (PresentedGroup.toGroup (relations_liftable hf)) cs.mulEquiv.toMonoidHom

private def restrictUnit {G : Type*} [Monoid G] {f : B → G} (hf : IsLiftable M f) : B → Gˣ :=
  fun i ↦ {
    val := f i,
    inv := f i,
    val_inv := by
      have := hf i i
      rwa [cs.isCoxeter.diagonal, pow_one] at this,
    inv_val := by
      have := hf i i
      rwa [cs.isCoxeter.diagonal, pow_one] at this
  }
/-- Extend the function `f : B → G` to a monoid homomorphism
`f' : W → G` satisfying `f' (s i) = f i` for all `i`.
-/
def lift {G : Type*} [Monoid G] {f : B → G} (hf : IsLiftable M f) : W →* G :=
  MonoidHom.comp (Units.coeHom G) (cs.groupLift
      (show ∀ i i' : B, ((cs.restrictUnit hf) i * (cs.restrictUnit hf) i') ^ M i i' = 1 by
    intro i i'
    apply Units.ext
    simp
    exact hf i i'))

private theorem toMonoidHom_symm (a : PresentedGroup (CoxeterGroup.Relations.toSet M)):
    (MulEquiv.toMonoidHom cs.mulEquiv : W →* PresentedGroup (CoxeterGroup.Relations.toSet M))
    ((MulEquiv.symm cs.mulEquiv) a) = a := calc
  _ = cs.mulEquiv ((MulEquiv.symm cs.mulEquiv) a) := by rfl
  _ = _                                           := by simp

theorem lift_apply_simple {G : Type*} [Monoid G] {f : B → G}
    (hf : IsLiftable M f) (i : B) : cs.lift hf (s i) = f i := by
  dsimp only [simpleReflection, lift, groupLift, MonoidHom.comp_apply]
  rw [← MonoidHom.toFun_eq_coe]
  rw [toMonoidHom_symm cs (PresentedGroup.of i)]
  simp
  rfl

/-! ### Words and length -/
/-- The product of the simple reflections of `W` corresponding to the indices in `ω`.-/
def wordProd (ω : List B) : W := prod (map cs.simpleReflection ω)

local prefix:100 "π" => cs.wordProd

@[simp] theorem wordProd_nil :
    π [] = 1 := by simp [wordProd]

@[simp] theorem wordProd_cons (i : B) (ω : List B) :
    π (i :: ω) = s i * π ω := by simp [wordProd]

@[simp] theorem wordProd_concat (i : B) (ω : List B) :
    π (ω.concat i) = π ω * s i := by simp [wordProd]

@[simp] theorem wordProd_append (ω ω' : List B) :
    π (ω ++ ω') = π ω * π ω' := by simp [wordProd]

@[simp] theorem wordProd_reverse (ω : List B) :
    π (reverse ω) = (π ω)⁻¹ := by
  induction' ω with x ω' ih
  · simp
  · simp; exact ih

private lemma freeGroup_wordProd (ω : List (B × Bool)) :
    prod (map ((@PresentedGroup.of B (CoxeterGroup.Relations.toSet M)) ∘ Prod.fst) ω)
    = QuotientGroup.mk (FreeGroup.mk ω) := by
  induction' ω with x ω' ih
  · simp [← FreeGroup.one_eq_mk]
  · rw [← List.singleton_append, ← FreeGroup.mul_mk, QuotientGroup.mk_mul, ← ih]
    simp
    rcases x with ⟨i, b⟩
    rcases b
    · have : [(i, false)] = FreeGroup.invRev [(i, true)] := by simp [FreeGroup.invRev]
      rw [this, ← FreeGroup.inv_mk, ← FreeGroup.of, QuotientGroup.mk_inv]
      simp
      rw [PresentedGroup.of]
      apply eq_inv_of_mul_eq_one_right
      rw [← QuotientGroup.mk_mul]
      exact cs.coxeterGroup_simple_mul_self i
    · rfl

theorem wordProd_surjective : Surjective (cs.wordProd) := by
  intro u
  let v : CoxeterGroup M := cs.mulEquiv.toFun u
  rcases (QuotientGroup.mk'_surjective _) v with ⟨w, hw⟩
  simp at hw -- hw: ↑w = v
  let ω := List.map Prod.fst w.toWord
  use ω
  simp [ω, wordProd]
  calc
    prod (List.map (simpleReflection cs ∘ Prod.fst) (FreeGroup.toWord w))
    _ = prod (List.map (
          cs.mulEquiv.symm
          ∘ (@PresentedGroup.of B (CoxeterGroup.Relations.toSet M))
          ∘ Prod.fst)
        (FreeGroup.toWord w))           := by congr
    _ = prod (List.map (
          cs.mulEquiv.symm
          ∘ ((@PresentedGroup.of B (CoxeterGroup.Relations.toSet M))
          ∘ Prod.fst))
        (FreeGroup.toWord w))           := by congr
    _ = prod (List.map cs.mulEquiv.symm
        (List.map ((@PresentedGroup.of B (CoxeterGroup.Relations.toSet M)) ∘ Prod.fst)
          (FreeGroup.toWord w)))        := by rw[List.map_map]
    _ = cs.mulEquiv.symm (prod (List.map
            ((@PresentedGroup.of B (CoxeterGroup.Relations.toSet M)) ∘ Prod.fst)
        (FreeGroup.toWord w)))          := by rw[map_list_prod]
    _ = cs.mulEquiv.symm (QuotientGroup.mk (FreeGroup.mk (FreeGroup.toWord w)))
                                        := by rw[cs.freeGroup_wordProd]
    _ = cs.mulEquiv.symm (QuotientGroup.mk w)
                                        := by rw[FreeGroup.mk_toWord]
    _ = u                               := by rw[hw]; dsimp [v]; simp


instance (w : W) : DecidablePred (fun n ↦ ∃ ω : List B, ω.length = n ∧ π ω = w)
  := Classical.decPred _

private theorem exists_word_with_prod (w : W) : ∃ n : ℕ, ∃ ω : List B, ω.length = n ∧ π ω = w := by
  rcases cs.wordProd_surjective w with ⟨ω, rfl⟩
  use ω.length, ω

/-- The length of `w`; i.e., the minimum number of simple reflections that
must be multiplied to form `w`. -/
def length (w : W) : ℕ := Nat.find (cs.exists_word_with_prod w)

local prefix:100 "ℓ" => cs.length

theorem exists_reduced_word (w : W) : ∃ ω : List B, ω.length = ℓ w ∧ w = π ω := by
  have := Nat.find_spec (cs.exists_word_with_prod w)
  tauto

theorem length_wordProd_le (ω : List B) : ℓ (π ω) ≤ ω.length := by
  apply Nat.find_min' (cs.exists_word_with_prod (π ω))
  use ω

@[simp] theorem length_one : ℓ (1 : W) = 0 := Nat.eq_zero_of_le_zero (cs.length_wordProd_le [])

theorem length_eq_zero_iff {w : W} : ℓ w = 0 ↔ w = 1 := by
  constructor
  · intro h
    rcases cs.exists_reduced_word w with ⟨ω, hω, rfl⟩
    have : ω = [] := eq_nil_of_length_eq_zero (hω.trans h)
    rw [this]
    simp
  · rintro rfl
    exact cs.length_one

@[simp] theorem length_inv (w : W) : ℓ (w⁻¹) = ℓ w := by
  apply Nat.le_antisymm
  · rcases cs.exists_reduced_word w with ⟨ω, hω, rfl⟩
    have := cs.length_wordProd_le (List.reverse ω)
    simp at this
    rwa [hω] at this
  · rcases cs.exists_reduced_word w⁻¹ with ⟨ω, hω, h'ω⟩
    have := cs.length_wordProd_le (List.reverse ω)
    simp at this
    rwa [← h'ω, hω, inv_inv] at this

theorem length_mul_le (w₁ w₂ : W) :
    ℓ (w₁ * w₂) ≤ ℓ w₁ + ℓ w₂ := by
  rcases cs.exists_reduced_word w₁ with ⟨ω₁, hω₁, rfl⟩
  rcases cs.exists_reduced_word w₂ with ⟨ω₂, hω₂, rfl⟩
  have := cs.length_wordProd_le (ω₁ ++ ω₂)
  simp at this
  rwa [hω₁, hω₂] at this

theorem length_mul_ge (w₁ w₂ : W) :
    ℓ (w₁ * w₂) ≥ max (ℓ w₁ - ℓ w₂) (ℓ w₂ - ℓ w₁) := by
  apply max_le_iff.mpr
  constructor
  · apply Nat.sub_le_of_le_add
    have := cs.length_mul_le (w₁ * w₂) w₂⁻¹
    simp at this
    assumption
  · apply Nat.sub_le_of_le_add
    have := cs.length_mul_le (w₁ * w₂)⁻¹ w₁
    simp only [length_inv] at this
    simp at this
    assumption

private def lengthParity (cs : CoxeterSystem M W) : W →* Multiplicative (ZMod 2) := cs.lift (
    show IsLiftable M (fun _ ↦ Multiplicative.ofAdd 1) by
      intro i i'
      dsimp
      rw [← ofAdd_add, one_add_one_eq_two, (by decide : (2 : ZMod 2) = 0)]
      simp
  )

private theorem lengthParity_simple :
    ⇑(CoxeterSystem.lengthParity cs) ∘ simpleReflection cs = fun _ ↦ Multiplicative.ofAdd 1 := by
  ext x
  simp
  rw [lengthParity, lift_apply_simple]

private theorem parity_length_eq' (w : W) :
    Multiplicative.toAdd (cs.lengthParity w) = ((↑) : ℕ → ZMod 2) (ℓ w) := by
  rcases cs.exists_reduced_word w with ⟨ω, hω, rfl⟩
  nth_rw 1 [wordProd]
  rw [MonoidHom.map_list_prod, List.map_map, lengthParity_simple]
  simp
  tauto

theorem length_mul_mod_two (w₁ w₂ : W) : ℓ (w₁ * w₂) % 2 = (ℓ w₁ + ℓ w₂) % 2 := by
  rw [← ZMod.nat_cast_eq_nat_cast_iff']
  rw [(by simp : (↑(length cs w₁ + length cs w₂) : ZMod 2) = ↑(length cs w₁) + ↑(length cs w₂))]
  repeat rw [← parity_length_eq']
  simp

@[simp] theorem length_simple (i : B) : ℓ (s i) = 1 := by
  apply Nat.le_antisymm
  · show length cs (s i) ≤ 1
    have := cs.length_wordProd_le [i]
    simp at this
    tauto
  · show 1 ≤ length cs (s i)
    by_contra! length_lt_1
    have := congrArg Multiplicative.toAdd (congrFun cs.lengthParity_simple i)
    simp [parity_length_eq'] at this
    rw [Nat.lt_one_iff.mp length_lt_1] at this
    contradiction

theorem length_eq_one_iff {w : W} : ℓ w = 1 ↔ ∃ i : B, w = s i := by
  constructor
  · intro h
    rcases cs.exists_reduced_word w with ⟨ω, hω, rfl⟩
    rcases List.length_eq_one.mp (hω.trans h) with ⟨i, rfl⟩
    use i
    simp
  · rintro ⟨i, rfl⟩
    exact cs.length_simple i

theorem length_mul_simple (w : W) (i : B) :
    ℓ (w * s i) = ℓ w + 1 ∨ ℓ (w * s i) + 1 = ℓ w := by
  have length_le := cs.length_mul_le w (s i)
  simp at length_le
  have length_ge := (max_le_iff.mp (cs.length_mul_ge w (s i))).left
  simp at length_ge
  have length_mod_two := cs.length_mul_mod_two w (s i)

  have h : ℓ (w * s i) ≠ ℓ w := by
    intro eq
    rw [eq] at length_mod_two
    simp at length_mod_two
    rcases Nat.mod_two_eq_zero_or_one (ℓ w) with even | odd
    · rw [even, Nat.succ_mod_two_eq_one_iff.mpr even] at length_mod_two
      contradiction
    · rw [odd, Nat.succ_mod_two_eq_zero_iff.mpr odd] at length_mod_two
      contradiction

  rcases Nat.ne_iff_lt_or_gt.mp h with less | greater
  · right
    linarith
  · left
    linarith

theorem length_simple_mul (w : W) (i : B) :
    ℓ (s i * w) = ℓ w + 1 ∨ ℓ (s i * w) + 1 = ℓ w := by
  have := cs.length_mul_simple w⁻¹ i
  rwa [(by simp : w⁻¹ * (s i) = ((s i) * w)⁻¹), length_inv, length_inv] at this

/-- The word of length `m` that alternates between `i` and `i'`, ending with `i'`.-/
def alternatingWord (i i' : B) (m : ℕ) : List B :=
  match m with
  | 0    => []
  | m+1  => (alternatingWord i' i m).concat i'

theorem alternatingWord_succ (i i' : B) (m : ℕ) :
    alternatingWord i i' (m + 1) = (alternatingWord i' i m).concat i' := by
  rfl

theorem alternatingWord_succ' (i i' : B) (m : ℕ) :
    alternatingWord i i' (m + 1) = (if Even m then i' else i) :: alternatingWord i i' m := by
  induction' m with m ih generalizing i i'
  · simp [alternatingWord]
  · rw [alternatingWord]
    nth_rw 1 [ih i' i]
    rw [alternatingWord]
    simp [Nat.even_add_one]

@[simp] theorem length_alternatingWord (i i' : B) (m : ℕ) :
    List.length (alternatingWord i i' m) = m := by
  induction' m with m ih generalizing i i'
  · dsimp [alternatingWord]
  · simp [alternatingWord]
    exact ih i' i

theorem prod_alternatingWord_eq_pow (i i' : B) (m : ℕ) :
    π (alternatingWord i i' m) = (if Even m then 1 else s i') * (s i * s i') ^ (m / 2) := by
  induction' m with m ih
  · simp [alternatingWord]
  · rw [alternatingWord_succ', wordProd_cons, ih, Nat.succ_eq_add_one]
    rcases Nat.even_or_odd m with even | odd
    · rcases even with ⟨k, rfl⟩
      ring_nf
      have : Odd (1 + k * 2) := by use k; ring
      simp [← two_mul, Nat.odd_iff_not_even.mp this]
      rw [Nat.add_mul_div_right _ _ (by norm_num : 0 < 2)]
      norm_num
    · rcases odd with ⟨k, rfl⟩
      ring_nf
      have h₁ : Odd (1 + k * 2) := by use k; ring
      have h₂ : Even (2 + k * 2) := by use (k + 1); ring
      simp [Nat.odd_iff_not_even.mp h₁, h₂]
      rw [Nat.add_mul_div_right _ _ (by norm_num : 0 < 2)]
      norm_num
      rw [pow_succ, mul_assoc]

theorem prod_alternatingWord_eq_prod_alternatingWord (i i' : B) (m : ℕ) (hm : m ≤ M i i' * 2) :
    π (alternatingWord i i' m) = π (alternatingWord i' i (M i i' * 2 - m)) := by
  rw [prod_alternatingWord_eq_pow, prod_alternatingWord_eq_pow]
  simp_rw [← Int.even_coe_nat]
  -- Rewrite everything in terms of an integer m' which is equal to m.
  rw [← zpow_coe_nat, ← zpow_coe_nat, Int.ofNat_ediv, Int.ofNat_ediv, Int.ofNat_sub hm]
  let m' : ℤ := m
  rw [← (by rfl : m' = m)]
  -- The resulting equation holds for all integers m'.
  generalize m' = m'

  rw [Int.ofNat_mul, (by norm_num : (↑(2 : ℕ) : ℤ) = 2)]
  clear hm

  rcases Int.even_or_odd m' with even | odd
  · rcases even with ⟨k, rfl⟩
    ring_nf
    have : Even (k * 2) := by use k; ring
    rw [if_pos this]
    have : Even (-(k * 2) + ↑(M i i') * 2) := by use -k + (M i i'); ring
    rw [if_pos this]
    rw [(by ring : -(k * 2) + ↑(M i i') * 2 = (-k + ↑(M i i')) * 2)]
    rw [Int.mul_ediv_cancel _ (by norm_num), Int.mul_ediv_cancel _ (by norm_num)]
    rw [zpow_add, zpow_coe_nat]
    rw [simple_mul_pow']
    rw [zpow_neg, ← inv_zpow]
    simp
  · rcases odd with ⟨k, rfl⟩
    ring_nf
    have : ¬Even (1 + k * 2) := by apply Int.odd_iff_not_even.mp; use k; ring
    rw [if_neg this]
    have : ¬Even (-1 - k * 2 + ↑(M i i') * 2) := by
      apply Int.odd_iff_not_even.mp
      use ↑(M i i') - k - 1
      ring
    rw [if_neg this]
    rw [(by ring : -1 - k * 2 + ↑(M i i') * 2 = -1 + (-k + ↑(M i i')) * 2)]
    rw [Int.add_mul_ediv_right _ _ (by norm_num), Int.add_mul_ediv_right _ _ (by norm_num)]
    norm_num
    rw [zpow_add, zpow_add, zpow_coe_nat]
    rw [simple_mul_pow']
    rw [zpow_neg, ← inv_zpow, zpow_neg, ← inv_zpow]
    simp [← mul_assoc]

/-! ### Reduced words -/

def IsReduced (ω : List B) : Prop := ℓ (π ω) = ω.length

theorem isReduced_reverse (ω : List B) : cs.IsReduced (ω.reverse) ↔ cs.IsReduced ω := by
  simp [IsReduced]

theorem exists_reduced_word' (w : W) : ∃ ω : List B, cs.IsReduced ω ∧ w = π ω := by
  rcases cs.exists_reduced_word w with ⟨ω, hω, rfl⟩
  use ω
  tauto

private theorem isReduced_take_and_drop {ω : List B} (rω : cs.IsReduced ω) (j : ℕ) :
    cs.IsReduced (ω.take j) ∧ cs.IsReduced (ω.drop j) := by
  have take_append_drop : ω = ω.take j ++ ω.drop j           := (List.take_append_drop _ _).symm
  have mul_take_drop : π ω = π (ω.take j) * π (ω.drop j)     := by
    rw [← wordProd_append]
    nth_rw 1 [take_append_drop]

  have take_length : ℓ (π (ω.take j)) ≤ (ω.take j).length    := cs.length_wordProd_le (ω.take j)
  have drop_length : ℓ (π (ω.drop j)) ≤ (ω.drop j).length    := cs.length_wordProd_le (ω.drop j)

  have length_add_ge := calc
    ℓ (π (ω.take j)) + ℓ (π (ω.drop j))
    _ ≥ ℓ (π ω)                                              := by
        rw[mul_take_drop]
        exact cs.length_mul_le _ _
    _ = ω.length                                             := rω
    _ = (ω.take j).length + (ω.drop j).length                := by
        nth_rw 1 [take_append_drop]
        exact List.length_append _ _

  constructor
  · unfold IsReduced
    linarith
  · unfold IsReduced
    linarith

theorem isReduced_take {ω : List B} (rω : cs.IsReduced ω) (j : ℕ) : cs.IsReduced (ω.take j) := by
  exact (isReduced_take_and_drop _ rω _).1

theorem isReduced_drop {ω : List B} (rω : cs.IsReduced ω) (j : ℕ) : cs.IsReduced (ω.drop j) := by
  exact (isReduced_take_and_drop _ rω _).2

theorem alternatingWord_not_reduced (i i' : B) (m : ℕ) (hM : M i i' ≠ 0) (hm : m > M i i') :
    ¬ cs.IsReduced (alternatingWord i i' m) := by
  induction' hm with m _ ih
  · -- Base case; m = M i i' + 1
    suffices h : ℓ (π (alternatingWord i i' (M i i' + 1))) < M i i' + 1 by
      unfold IsReduced
      simp
      linarith
    have : M i i' + 1 ≤ M i i' * 2 := by
      rw [mul_two]
      apply add_le_add_left
      exact Nat.one_le_iff_ne_zero.mpr hM
    rw [cs.prod_alternatingWord_eq_prod_alternatingWord i i' _ this]

    have : M i i' * 2 - (M i i' + 1) = M i i' - 1 := by
      apply (Nat.sub_eq_iff_eq_add' this).mpr
      rw [add_assoc, add_comm 1, Nat.sub_add_cancel (Nat.one_le_iff_ne_zero.mpr hM)]
      exact mul_two _
    rw [this]

    calc
      ℓ (π (alternatingWord i' i (M i i' - 1)))
      _ ≤ (alternatingWord i' i (M i i' - 1)).length  := cs.length_wordProd_le _
      _ = M i i' - 1                                  := length_alternatingWord _ _ _
      _ ≤ M i i'                                      := Nat.sub_le _ _
      _ < M i i' + 1                                  := Nat.lt_succ_self _
  · -- Inductive step
    contrapose! ih
    rw [alternatingWord_succ'] at ih
    apply isReduced_drop (j := 1) at ih
    simp at ih
    assumption

/-! ### Reflections, inversions, and inversion sequences -/

/-- The proposition that `t` is a reflection of the Coxeter system `cs`; i.e., it is of the form
$w s_i w^{-1}$, where $w \in W$ and $s_i$ is a simple reflection. -/
def IsReflection (t : W) : Prop := ∃ w : W, ∃ i : B, t = w * s i * w⁻¹

def reflections : Set W := {t : W | cs.IsReflection t}

theorem isReflection_simple (i : B) : cs.IsReflection (s i) := by use 1, i; simp

theorem pow_two_eq_one_of_isReflection {t : W} (rt : cs.IsReflection t) : t ^ 2 = 1 := by
  rcases rt with ⟨w, i, rfl⟩
  rw [pow_two]
  group
  rw [mul_assoc w]
  simp

theorem inv_reflection_eq {t : W} (rt : cs.IsReflection t) : t⁻¹ = t := by
  apply inv_eq_of_mul_eq_one_right
  rw [← pow_two]
  exact cs.pow_two_eq_one_of_isReflection rt

alias inv_eq_self_of_isReflection := inv_reflection_eq

theorem length_reflection_odd {t : W} (rt : cs.IsReflection t) : Odd (ℓ t) := by
  rw [Nat.odd_iff]
  rcases rt with ⟨w, i, rfl⟩
  rw [length_mul_mod_two, Nat.add_mod, length_mul_mod_two, ← Nat.add_mod]
  simp
  rw [add_comm, ← add_assoc, ← two_mul, Nat.mul_add_mod]
  norm_num

alias odd_length_of_isReflection := length_reflection_odd

theorem isReflection_conjugate_iff (w t : W) :
    cs.IsReflection (w * t * w⁻¹) ↔ cs.IsReflection t := by
  constructor
  · rintro ⟨u, i, hi⟩
    use w⁻¹ * u, i
    rw [mul_inv_rev (w⁻¹) u, inv_inv, ← mul_assoc]
    repeat rw [mul_assoc w⁻¹]
    rw [← hi]
    group
  · rintro ⟨u, i, rfl⟩
    use w * u, i
    group

/-- The proposition that `t` is a right inversion of `w`; i.e., `t` is a reflection and
$\ell (w t) < \ell(w)$. -/
def IsRightInversion (w t : W) : Prop := cs.IsReflection t ∧ ℓ (w * t) < ℓ w
/-- The proposition that `t` is a left inversion of `w`; i.e., `t` is a reflection and
$\ell (t w) < \ell(w)$. -/
def IsLeftInversion (w t : W) : Prop := cs.IsReflection t ∧ ℓ (t * w) < ℓ w

/-- The right inversion sequence of `ω`. The right inversion sequence of a word
$s_{i_1} \cdots s_{i_\ell}$ is the sequence
$$s_{i_\ell}\cdots s_{i_1}\cdots s_{i_\ell}, \ldots,
    s_{i_{\ell}}s_{i_{\ell - 1}}s_{i_{\ell - 2}}s_{i_{\ell - 1}}s_{i_\ell}, \ldots,
    s_{i_{\ell}}s_{i_{\ell - 1}}s_{i_\ell}, s_{i_\ell}.$$
-/
def rightInvSeq (ω : List B) : List W :=
  match ω with
  | []          => []
  | i :: ω      => MulAut.conj (π ω)⁻¹ (s i) :: rightInvSeq ω

/-- The left inversion sequence of `ω`. The left inversion sequence of a word
$s_{i_1} \cdots s_{i_\ell}$ is the sequence
$$s_{i_1}, s_{i_1}s_{i_2}s_{i_1}, s_{i_1}s_{i_2}s_{i_3}s_{i_2}s_{i_1}, \ldots,
    s_{i_1}\cdots s_{i_\ell}\cdots s_{i_1}.$$
-/
def leftInvSeq (ω : List B) : List W :=
  match ω with
  | []          => []
  | i :: ω      => s i :: List.map (MulAut.conj (s i)) (leftInvSeq ω)

local prefix:100 "ris" => cs.rightInvSeq
local prefix:100 "lis" => cs.leftInvSeq

@[simp] theorem rightInvSeq_nil : ris [] = [] := rfl
@[simp] theorem leftInvSeq_nil : lis [] = [] := rfl
@[simp] theorem rightInvSeq_singleton (i : B) : ris [i] = [s i] := by simp [rightInvSeq]
@[simp] theorem leftInvSeq_singleton (i : B) : lis [i] = [s i] := rfl

theorem rightInvSeq_concat (ω : List B) (i : B) :
    ris (ω.concat i) = (List.map (MulAut.conj (s i)) (ris ω)).concat (s i) := by
  induction' ω with j ω ih
  · simp
  · dsimp [rightInvSeq]
    rw [ih]
    simp
    group

theorem leftInvSeq_concat (ω : List B) (i : B) :
    lis (ω.concat i) = (lis ω).concat (MulAut.conj (π ω) (s i)) := by
  induction' ω with j ω ih
  · simp
  · dsimp [leftInvSeq]
    rw [ih]
    simp
    group
    simp [mul_assoc]

@[local simp] private theorem leftInvSeq_eq_reverse_rightInvSeq_reverse (ω : List B) :
    lis ω = (ris ω.reverse).reverse := by
  induction' ω with i ω ih
  · simp
  · rw [leftInvSeq, reverse_cons, ← concat_eq_append, rightInvSeq_concat, ih]
    simp [map_reverse]

theorem rightInvSeq_reverse (ω : List B) :
    ris (ω.reverse) = (lis ω).reverse := by
  simp

theorem leftInvSeq_reverse (ω : List B) :
    lis (ω.reverse) = (ris ω).reverse := by
  simp

@[simp] theorem length_rightInvSeq (ω : List B) : (ris ω).length = ω.length := by
  induction' ω with i ω ih
  · simp
  · simpa [rightInvSeq]

@[simp] theorem length_leftInvSeq (ω : List B) : (lis ω).length = ω.length := by
  simp

theorem isReflection_of_mem_rightInvSeq (ω : List B) (t : W) (ht : t ∈ ris ω) :
    cs.IsReflection t := by
  induction' ω with i ω ih
  · simp at ht
  · dsimp [rightInvSeq] at ht
    rcases ht with _ | ⟨_, mem⟩
    · use (π ω)⁻¹, i
    · exact ih mem

theorem isReflection_of_mem_leftInvSeq (ω : List B) (t : W) (ht : t ∈ lis ω) :
    cs.IsReflection t := by
  simp at ht
  exact cs.isReflection_of_mem_rightInvSeq ω.reverse t ht

theorem rightInvSeq_drop (ω : List B) (j : ℕ) :
    ris (ω.drop j) = (ris ω).drop j := by
  induction' j with j ih₁ generalizing ω
  · simp
  · induction' ω with k ω _
    · simp
    · rw [drop_succ_cons, ih₁ ω, rightInvSeq, drop_succ_cons]

theorem leftInvSeq_take (ω : List B) (j : ℕ) :
    lis (ω.take j) = (lis ω).take j := by
  rcases em (j ≤ ω.length) with le | gt
  · simp
    rw [List.reverse_take j (by simpa)]
    nth_rw 1 [← List.reverse_reverse ω]
    rw [List.reverse_take j (by simpa)]
    simp [rightInvSeq_drop]
  · have : ω.length ≤ j := by linarith
    rw [take_length_le this, take_length_le (by simpa)]

theorem wordProd_mul_rightInvSeq_get (ω : List B) (j : Fin (ris ω).length) :
    π ω * ((ris ω).get j) = π (ω.eraseIdx j) := by
  have lpos : 0 < ((ris ω).drop j).length                                       := by
    rw [length_drop, Nat.sub_pos_iff_lt]
    exact Fin.isLt j

  have : (ris ω).get j = ((ris ω).drop j).get { val := 0, isLt := lpos }  := calc
    (ris ω).get j = (ris ω).get {
        val := j + 0,
        isLt := by rw[add_zero]; exact Fin.isLt j }                             := rfl
    _             = ((ris ω).drop j).get { val := 0, isLt := lpos }             := List.get_drop _ _

  rw [this]

  have := get_of_eq (cs.rightInvSeq_drop ω (↑j)).symm { val := 0, isLt := lpos }
  rw [this]
  simp
  rw [eraseIdx_eq_take_drop_succ]
  nth_rw 1 [← List.take_append_drop j ω]
  rw [wordProd_append, wordProd_append]
  rw [mul_assoc]
  apply congrArg (wordProd cs (take (↑j) ω) * ·)
  rw [Nat.succ_eq_one_add, List.drop_add]

  let ω' := drop ↑j ω
  have hω' : ω' = drop ↑j ω := rfl

  have : rightInvSeq cs (drop (↑j) ω) = rightInvSeq cs ω'                := by congr
  rw [get_of_eq this { val := 0, isLt := _ }]
  nth_rw 1 [hω'.symm]
  -- I feel like I need to apologize for this
  nth_rw 15 [hω'.symm]
  simp

  have : ω' ≠ [] := by
    intro h
    rw [hω'] at h
    apply congr_arg List.length at h
    simp at h
    apply Nat.sub_eq_zero_iff_le.mp at h
    simp at lpos
    linarith

  rcases ω' with _ | ⟨i, ω''⟩
  · contradiction
  · simp [rightInvSeq]
    group
    simp

theorem leftInvSeq_get_mul_wordProd (ω : List B) (j : Fin (lis ω).length) :
    ((lis ω).get j) * π ω = π (ω.eraseIdx j) := by
  have := j.isLt
  have j_lt : j < ω.length := by simp at this; assumption
  have length_sub_one_sub_j_lt : List.length ω - 1 - ↑j < List.length ω := Nat.sub_one_sub_lt j_lt
  have length_sub_length_sub : List.length ω - (List.length ω - 1 - ↑j) = ↑j + 1 := by
    rw [add_comm, Nat.sub_sub]
    apply Nat.sub_sub_self
    linarith
  have succ_length_sub : Nat.succ (List.length ω - 1 - ↑j) = List.length ω - ↑j := by
    rw [Nat.sub_sub, add_comm, ← Nat.sub_sub, Nat.succ_eq_add_one]
    apply Nat.sub_add_cancel
    apply Nat.le_sub_of_add_le'
    linarith
  have drop_reverse : drop (List.length ω - ↑j) (reverse ω) = reverse (take ↑j ω) := by
    apply reverse_injective
    rw [(by simp : List.length ω = List.length (reverse ω))]
    rw [reverse_reverse, ← reverse_take _ (by simp; exact le_of_lt j_lt)]
    simp
  have h : π ω = π (take ↑j ω) * (s ω[j]) * π (drop (↑j + 1) ω) := by
    nth_rw 1 [← List.take_append_drop ↑j ω]
    let i : Fin (List.length ω) := { val := ↑j, isLt := j_lt }
    nth_rw 2 [(by rfl : (↑j : ℕ) = ↑i)]
    rw [← get_cons_drop]
    rw [(by rfl : (↑i : ℕ) = ↑j)]
    simp
    group

  rw [get_of_eq (cs.leftInvSeq_eq_reverse_rightInvSeq_reverse _) j]
  rw [get_reverse' _ _ (by simpa)]
  simp
  apply @mul_left_cancel _ _ _ (π (ω.reverse))
  rw [← mul_assoc]
  rw [cs.wordProd_mul_rightInvSeq_get ω.reverse _]
  simp [eraseIdx_eq_take_drop_succ]
  rw [reverse_take _ (Nat.le_of_lt length_sub_one_sub_j_lt)]
  rw [length_sub_length_sub, succ_length_sub, Nat.succ_eq_add_one]
  rw [drop_reverse]
  simp
  rw [h]
  group
  simp

theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = (π ω)⁻¹ := by
  induction' ω with i ω ih
  · simp
  · simp [rightInvSeq, ih]

theorem prod_leftInvSeq (ω : List B) : prod (lis ω) = (π ω)⁻¹ := by
  simp [prod_reverse_noncomm]
  have : List.map (fun x ↦ x⁻¹) (ris ω.reverse) = ris ω.reverse := calc
    List.map (fun x ↦ x⁻¹) (ris ω.reverse)
    _ = List.map id (ris ω.reverse)             := by
        apply List.map_congr
        intro t ht
        exact cs.inv_reflection_eq (cs.isReflection_of_mem_rightInvSeq _ t ht)
    _ = ris ω.reverse                           := map_id _
  rw [this]
  nth_rw 2 [← reverse_reverse ω]
  rw [wordProd_reverse]
  exact cs.prod_rightInvSeq _

private lemma nodup_rightInvSeq_of_reduced {ω : List B} (rω : cs.IsReduced ω) :
    List.Nodup (ris ω) := by
  apply List.nodup_iff_get?_ne_get?.mpr
  intro j j' j_lt_j' j'_lt_length dup
  -- dup : get? (rightInvSeq cs ω) j = get? (rightInvSeq cs ω) j'
  -- ⊢ False

  have h₀ : j < (ris ω).length                        := lt_trans j_lt_j' j'_lt_length
  let t := get (ris ω) { val := j, isLt := h₀ }

  have h₁ : j' < ω.length                             := by simp at j'_lt_length; assumption
  have h₂ : j' - 1 < (ris (ω.eraseIdx j)).length      := by
    simp
    apply (add_lt_add_iff_right 1).mp
    rw [length_eraseIdx_add_one (lt_trans j_lt_j' h₁)]
    rwa [Nat.sub_add_cancel (by linarith)]
  let t' := get (ris (ω.eraseIdx j)) { val := j' - 1, isLt := h₂ }

  have h₃ : t = t'                                    := by apply Option.some_injective; calc
    some t = get? (ris ω) j                                     := (get?_eq_get h₀).symm
    _      = get? (ris ω) j'                                    := dup
    _      = get? ((ris ω).drop (j + 1)) (j' - (j + 1))         := by
        symm
        rw [get?_drop]
        congr
        rw [add_comm, Nat.sub_add_cancel (by linarith)]
    _      = get? (ris (ω.drop (j + 1))) (j' - (j + 1))         := by
        congr
        symm
        exact rightInvSeq_drop _ _ _
    _      = get? (ris ((ω.eraseIdx j).drop j)) (j' - (j + 1))  := by
        congr 2
        show ω.drop (j + 1) = (ω.eraseIdx j).drop j
        rw [eraseIdx_eq_take_drop_succ, drop_left' (length_take_of_le (by linarith))]
    _      = get? ((ris (ω.eraseIdx j)).drop j) (j' - (j + 1))  := by
        congr
        exact rightInvSeq_drop _ _ _
    _      = get? (ris (ω.eraseIdx j)) (j' - 1)                 := by
        rw [get?_drop]
        congr
        show j + (j' - (j + 1)) = j' - 1
        apply @Nat.add_left_cancel 1
        rw [← add_assoc 1, add_comm 1]
        rw [Nat.add_sub_cancel' (by linarith), Nat.add_sub_cancel' (by linarith)]
    _      = t'                                                 := get?_eq_get h₂

  have h₄ : t * t' = 1                                := by
    rw [← h₃, ← pow_two]
    apply cs.pow_two_eq_one_of_isReflection
    apply cs.isReflection_of_mem_rightInvSeq ω
    apply List.mem_iff_get.mpr
    use { val := j, isLt := h₀ }

  have h₅ := calc
    π ω   = π ω * t * t'                              := by rw [mul_assoc, h₄]; group
    _     = (π (ω.eraseIdx j)) * t'                   :=
        congrArg (· * t') (cs.wordProd_mul_rightInvSeq_get _ _)
    _     = π ((ω.eraseIdx j).eraseIdx (j' - 1))      :=
        cs.wordProd_mul_rightInvSeq_get _ _

  have h₆ := calc
    ω.length = ℓ (π ω)                                    := rω.symm
    _        = ℓ (π ((ω.eraseIdx j).eraseIdx (j' - 1)))   := congrArg cs.length h₅
    _        ≤ ((ω.eraseIdx j).eraseIdx (j' - 1)).length  := cs.length_wordProd_le _

  have h₇ := add_le_add_right (add_le_add_right h₆ 1) 1
  rw [length_eraseIdx_add_one (by simp at h₂; assumption)] at h₇
  rw [length_eraseIdx_add_one (lt_trans j_lt_j' h₁)] at h₇
  linarith


/-! ### The standard geometric representation
Given a Coxeter group `W` whose simple reflections are indexed by a set `B`, we define
the standard geometric representation of `W`, which is a representation of `W` with underlying
vector space `B →₀ ℝ`. We then use this to define the set of roots, which is a subset of
`B →₀ ℝ`. The roots correspond two-to-one to the reflections of `W`.
-/

def simpleRoot (i : B) : B →₀ ℝ := Finsupp.single i 1
local prefix:100 "α" => simpleRoot

/-- The standard bilinear form on `B →₀ ℝ`. Given by `⟪αᵢ, αⱼ⟫ = -cos (π / Mᵢⱼ)`
for `i j : B`, where {αᵢ} is the standard basis of `B →₀ ℝ` and `M` is the Coxeter matrix.
This is positive definite if and only if the associated Coxeter group is finite. -/
def standardBilinForm (M : Matrix B B ℕ) : LinearMap.BilinForm ℝ (B →₀ ℝ) :=
    (Finsupp.lift ((B →₀ ℝ) →ₗ[ℝ] ℝ) ℝ B)
        (fun i ↦ ((Finsupp.lift ℝ ℝ B)
            (fun i' ↦ -cos (Real.pi / M i i'))))

local notation:max "⟪"  a  ","  b  "⟫" => standardBilinForm M a b

@[simp] theorem standardBilinForm_simpleRoots (i i' : B) :
    ⟪α i, α i'⟫ = - cos (Real.pi / M i i') := by simp [standardBilinForm, simpleRoot]

theorem standardBilinForm_symm :
    LinearMap.IsSymm (standardBilinForm M) := by
  apply LinearMap.isSymm_iff_eq_flip.mpr
  apply (Finsupp.basisSingleOne).ext
  intro i
  apply (Finsupp.basisSingleOne).ext
  intro i'
  simp [standardBilinForm]
  rw [cs.isCoxeter.symmetric.apply i i']

/-- The orthogonal reflection in the vector `v` under the standard bilinear form.
-/
def orthoReflection (M : Matrix B B ℕ) (v : B →₀ ℝ) : (B →₀ ℝ) →ₗ[ℝ] (B →₀ ℝ) := sorry

theorem orthoReflection_sqr_eq_id (M : Matrix B B ℕ) (v : B →₀ ℝ) :
    (orthoReflection M v) * (orthoReflection M v) = LinearMap.id := by
  sorry

theorem orthoReflection_eq_iff (M : Matrix B B ℕ) (v v' : B →₀ ℝ) (hv : ⟪v, v⟫ ≠ 0):
    orthoReflection M v = orthoReflection M v' ↔ ∃ μ : ℝ, v' = μ • v := by
  sorry

/-- The standard geometric representation on `B →₀ ℝ`. For `i : B`, the simple reflection `sᵢ`
acts by `sᵢ v = v - 2 ⟪αᵢ, v⟫ * αᵢ`, where {αᵢ} is the standard basis of `B →₀ ℝ`.
-/
def standardGeometricRepresentation (cs : CoxeterSystem M W) : Representation ℝ W (B →₀ ℝ) := sorry

alias SGR := standardGeometricRepresentation

theorem SGR_simple (i : B) : cs.SGR (s i) = orthoReflection M (α i) := by
  sorry

theorem SGR_simple_simpleRoot (i i' : B) :
    cs.SGR (s i) (α i') = α i' + ((2 : ℝ) * cos (Real.pi / M i i')) • α i := by
  sorry

theorem SGR_simple_simpleRoot_self (i : B) : cs.SGR (s i) (α i) = -α i := by
  sorry


theorem SGR_bilin_eq_bilin (w : W) (v v' : B →₀ ℝ) : ⟪cs.SGR w v, cs.SGR w v'⟫ = ⟪v, v'⟫ := by
  sorry

theorem SGR_alternatingWord_simpleRoot (i i' : B) (m : ℕ) (hM : M i i' ≠ 0) :
    cs.SGR (π (alternatingWord i i' m)) (α i) = if Even m
      then (sin ((m + 1) * Real.pi / M i i') / sin (Real.pi / M i i')) • (α i)
        + (sin (m * Real.pi / M i i') / sin (Real.pi / M i i')) • (α i')
      else (sin (m * Real.pi / M i i') / sin (Real.pi / M i i')) • (α i)
        + (sin ((m + 1) * Real.pi / M i i') / sin (Real.pi / M i i')) • (α i') := by
  sorry

theorem SGR_alternatingWord_simpleRoot' (i i' : B) (m : ℕ) (hM : M i i' = 0) :
    cs.SGR (π (alternatingWord i i' m)) (α i) = if Even m
      then (m + 1) • (α i) + m • (α i')
      else m • (α i) + (m + 1) • (α i') := by
  sorry

theorem SGR_alternatingWord_simpleRoot_pos (i i' : B) (m : ℕ) (hM : m < M i i' ∨ M i i' = 0) :
    ∃ μ ≥ 0, ∃ μ' ≥ 0, cs.SGR (π (alternatingWord i i' m)) (α i) = μ • (α i) + μ' • (α i') := by
  sorry

/-- The roots of the standard geometric representation; i.e. the vectors that can be written
in the form w αᵢ, where `w : W` and {αᵢ} is the standard basis of `B →₀ ℝ`. If `W` is infinite,
then this is not a root system in the sense of `Mathlib.LinearAlgebra.RootSystem` because it is
infinite and because `B →₀ ℝ` is not an inner product space.
-/
def roots : Set (B →₀ ℝ) := {v : B →₀ ℝ | ∃ w : W, ∃ i : B, v = cs.SGR w (α i)}

/-- The roots that can be written as a nonnegative linear combination of the standard basis vectors
`αᵢ`.-/
def posRoots : Set (B →₀ ℝ) := cs.roots ∩ {v : B →₀ ℝ | ∀ i : B, v i ≥ 0}
/-- The roots that can be written as a nonpositive linear combination of the standard basis vectors
`αᵢ`.-/
def negRoots : Set (B →₀ ℝ) := cs.roots ∩ {v : B →₀ ℝ | ∀ i : B, v i ≤ 0}


@[simp] theorem roots_invariant (w : W) (v : B →₀ ℝ) : cs.SGR w v ∈ cs.roots ↔ v ∈ cs.roots := by
  sorry

@[simp] theorem roots_eq_neg_roots : -cs.roots = cs.roots := by
  sorry

theorem negRoots_eq_neg_posRoots : cs.negRoots = -cs.posRoots := by
  sorry

theorem SGR_simpleRoot_mem_posRoot_of (w : W) (i : B) :
    ℓ (w * s i) = ℓ w + 1 → cs.SGR w (α i) ∈ cs.posRoots := by
  sorry

theorem SGR_simpleRoot_mem_negRoot_of (w : W) (i : B) :
    ℓ (w * s i) + 1 = ℓ w → cs.SGR w (α i) ∈ cs.negRoots := by
  sorry

theorem SGR_simpleRoot_mem_posRoot_iff (w : W) (i : B) :
    ℓ (w * s i) = ℓ w + 1 ↔ cs.SGR w (α i) ∈ cs.posRoots := by
  sorry

theorem SGR_simpleRoot_mem_negRoot_iff (w : W) (i : B) :
    ℓ (w * s i) + 1 = ℓ w ↔ cs.SGR w (α i) ∈ cs.negRoots := by
  sorry

theorem root_pos_or_neg : cs.roots = cs.posRoots ∪ cs.negRoots := by
  sorry

theorem root_not_pos_and_neg : cs.posRoots ∩ cs.negRoots = ∅ := by
  sorry

theorem SGR_injective : Injective cs.SGR := by
  sorry

def reflectionToRoot : cs.reflections ≃ cs.posRoots := sorry

theorem reflection_by_smul (w : W) (v : B →₀ ℝ) :
    orthoReflection M (cs.SGR w v) = (cs.SGR w) ∘ (orthoReflection M v) ∘ (cs.SGR w⁻¹) := by
  sorry

theorem reflection_by_root (γ : cs.posRoots) :
    orthoReflection M γ = cs.SGR (cs.reflectionToRoot.invFun γ) := by
  sorry

theorem isRightInversion_iff (w : W) (t : cs.reflections) : cs.IsRightInversion w t ↔
    cs.SGR w (cs.reflectionToRoot.toFun t) ∈ cs.negRoots := by
  sorry

/-! ### The (strong) exchange properties and deletion property -/

/-- The (strong) right exchange property:
Let $w = s_{i_1} \cdots s_{i_\ell}$ be a reduced expression for an element $w \in W$
and let $t \in W$.
The following are equivalent:

* $t$ is a right inversion of $w$.
* $t$ appears in the right inversion sequence of the word $s_{i_1} \cdots s_{i_\ell}$.
* There exists $j$ with $1 \leq j \leq \ell$ such that
  $$wt = s_{i_1} \cdots \widehat{s_{i_j}} \cdots s_{i_\ell}$$
  (i.e. the result of multiplying all of the simple reflections $s_{i_1}, \ldots, s_{i_\ell}$
  except $s_{i_j}$).
\end{enumerate}
-/
theorem right_exchange_property {ω : List B} (t : W) (rω : cs.IsReduced ω) :
    List.TFAE [
      cs.IsRightInversion (π ω) t,
      t ∈ ris ω,
      ∃ j < ω.length, (π ω) * t = π (ω.eraseIdx j)
    ] := by
  sorry

/-- The (strong) left exchange property:
Let $w = s_{i_1} \cdots s_{i_\ell}$ be a reduced expression for an element $w \in W$
and let $t \in W$.
The following are equivalent:

* $t$ is a left inversion of $w$.
* $t$ appears in the left inversion sequence of the word $s_{i_1} \cdots s_{i_\ell}$.
* There exists $j$ with $1 \leq j \leq \ell$ such that
  $$tw = s_{i_1} \cdots \widehat{s_{i_j}} \cdots s_{i_\ell}$$
  (i.e. the result of multiplying all of the simple reflections $s_{i_1}, \ldots, s_{i_\ell}$
  except $s_{i_j}$).
-/
theorem left_exchange_property {ω : List B} (t : W) (rω : cs.IsReduced ω) :
    List.TFAE [
      cs.IsLeftInversion (π ω) t,
      t ∈ lis ω,
      ∃ j < ω.length, t * (π ω) = π (ω.eraseIdx j)
    ] := by
  sorry

theorem nodup_rightInvSeq_iff (ω : List B) :
    List.Nodup (ris ω) ↔ cs.IsReduced ω := by
  sorry

theorem nodup_leftInvSeq_iff (ω : List B) :
    List.Nodup (lis ω) ↔ cs.IsReduced ω := by
  sorry

/-- The deletion property:
If $s_{i_1} \cdots s_{i_\ell}$ is not a reduced expression, then there are $i, j$ with
$1 \leq j < j' \leq \ell$ such that
$$s_{i_1} \cdots s_{i_\ell} =
s_{i_1} \cdots \widehat{s_{i_j}} \cdots \widehat{s_{i_{j'}}} \cdots s_{i_\ell}.$$
-/
theorem deletion_property (ω : List B) (nrω : ¬ cs.IsReduced ω) :
    ∃ j' < ω.length, ∃ j < j', π ((ω.eraseIdx j').eraseIdx j) = π ω := by
  sorry

end CoxeterSystem
/-
TODO: Inversion set is finite. Size of inversion set = length.
Matsumoto's theorem.
Simple reflections are distinct.
Order of s_i s_j is exactly M i j.

Eₙ for n > 8.

Irreducibility. Irreducible components.
Parabolic subgroups.
Poincare series.

The standard geometric representation. It is faithful.
Height of a root.
Standard geometric representation is orthogonal if and only if W is finite.
Classification of irreducible finite Coxeter groups.
Classification of irreducible affine Coxeter groups.

Small roots.
Coxeter groups are automatic.

Long element has all reflections as inversions. Long element is an involution.
Properties of Coxeter number.

The weak order. Ungar moves. Ungar's problem.

Bruhat order.

Combinatorially describe finite and affine Coxeter groups of types A, B, C, D.
Interpret inversions, descents, length, convex sets, parabolic subgroups, Bruhat order.

Schubert polynomials.

Associated hyperplane arrangements and partition lattices and their characteristic polynomials.
Folding.
Convex sets.
Coxeter elements, c-sorting words.
Powers of Coxeter elements in infinite groups are reduced.
Futuristic Coxeter groups.
-/
end
