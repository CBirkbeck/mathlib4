/-
Copyright (c) 2024 Newell Jensen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Newell Jensen, Mitchell Lee
-/
import Mathlib.Data.Matrix.Notation
import Mathlib.GroupTheory.PresentedGroup
import Mathlib.LinearAlgebra.Matrix.Symmetric
import Mathlib.Data.ZMod.Defs
import Mathlib.RepresentationTheory.Basic
import Mathlib.Data.Real.Basic
import Mathlib.Data.Complex.Exponential
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Basic
import Mathlib.LinearAlgebra.BilinearMap

/-!
# Coxeter Systems

This file defines Coxeter systems and Coxeter groups.

A Coxeter system is a pair `(W, S)` where `W` is a group generated by a set of
reflections (involutions) `S = {s₁,s₂,...,sₙ}`, subject to relations determined
by a Coxeter matrix `M = (mᵢⱼ)`.  The Coxeter matrix is a symmetric matrix with
entries `mᵢⱼ` representing the order of the product `sᵢsⱼ` for `i ≠ j` and `mᵢᵢ = 1`.

When `(W, S)` is a Coxeter system, one also says, by abuse of language, that `W` is a
Coxeter group.  A Coxeter group `W` is determined by the presentation
`W = ⟨s₁,s₂,...,sₙ | ∀ i j, (sᵢsⱼ)^mᵢⱼ = 1⟩`, where `1` is the identity element of `W`.

The finite Coxeter groups are classified (TODO) as the four infinite families:

* `Aₙ, Bₙ, Dₙ, I₂ₘ`

And the exceptional systems:

* `E₆, E₇, E₈, F₄, G₂, H₃, H₄`

## Implementation details

In this file a Coxeter system, designated as `CoxeterSystem M W`, is implemented as a
structure which effectively records the isomorphism between a group `W` and the corresponding
group presentation derived from a Coxeter matrix `M`.  From another perspective, it serves as
a set of generators for `W`, tailored to the underlying type of `M`, while ensuring compliance
with the relations specified by the Coxeter matrix `M`.

A type class `IsCoxeterGroup` is introduced, for groups that are isomorphic to a group
presentation corresponding to a Coxeter matrix which is registered in a Coxeter system.

## Main definitions

* `Matrix.IsCoxeter` : A matrix `IsCoxeter` if it is a symmetric matrix with diagonal
  entries equal to one and off-diagonal entries distinct from one.
* `Matrix.CoxeterGroup` : The group presentation corresponding to a Coxeter matrix.
* `CoxeterSystem` : A structure recording the isomorphism between a group `W` and the
  group presentation corresponding to a Coxeter matrix, i.e. `Matrix.CoxeterGroup M`.
* `equivCoxeterGroup` : Coxeter groups of isomorphic types are isomorphic.
* `IsCoxeterGroup` : A group is a Coxeter group if it is registered in a Coxeter system.
* `CoxeterMatrix.Aₙ` : Coxeter matrix for the symmetry group of the regular n-simplex.
* `CoxeterMatrix.Bₙ` : Coxeter matrix for the symmetry group of the regular n-hypercube
  and its dual, the regular n-orthoplex (or n-cross-polytope).
* `CoxeterMatrix.Dₙ` : Coxeter matrix for the symmetry group of the n-demicube.
* `CoxeterMatrix.I₂ₘ` : Coxeter matrix for the symmetry group of the regular (m + 2)-gon.
* `CoxeterMatrix.E₆` : Coxeter matrix for the symmetry group of the E₆ root polytope.
* `CoxeterMatrix.E₇` : Coxeter matrix for the symmetry group of the E₇ root polytope.
* `CoxeterMatrix.E₈` : Coxeter matrix for the symmetry group of the E₈ root polytope.
* `CoxeterMatrix.F₄` : Coxeter matrix for the symmetry group of the regular 4-polytope,
  the 24-cell.
* `CoxeterMatrix.G₂` : Coxeter matrix for the symmetry group of the regular hexagon.
* `CoxeterMatrix.H₃` : Coxeter matrix for the symmetry group of the regular dodecahedron
  and icosahedron.
* `CoxeterMatrix.H₄` : Coxeter matrix for the symmetry group of the regular 4-polytopes,
  the 120-cell and 600-cell.

## References

* [N. Bourbaki, *Lie Groups and Lie Algebras, Chapters 4--6*](bourbaki1968) chapter IV
  pages 4--5, 13--15

* [J. Baez, *Coxeter and Dynkin Diagrams*](https://math.ucr.edu/home/baez/twf_dynkin.pdf)

## TODO

* The canonical map from the type to the Coxeter group `W` is an injection.
* A group `W` registered in a Coxeter system is a Coxeter group.
* A Coxeter group is an instance of `IsCoxeterGroup`.

## Tags

coxeter system, coxeter group
-/


universe u

noncomputable section

variable {B : Type*} [DecidableEq B]

variable (M : Matrix B B ℕ)

/-- A matrix `IsCoxeter` if it is a symmetric matrix with diagonal entries equal to one
and off-diagonal entries distinct from one. -/
structure Matrix.IsCoxeter : Prop where
  symmetric : M.IsSymm := by aesop
  diagonal : ∀ b : B, M b b  = 1 := by aesop
  off_diagonal : ∀ b₁ b₂ : B, b₁ ≠ b₂ → M b₁ b₂ ≠ 1 := by aesop

namespace CoxeterGroup

namespace Relations

/-- The relations corresponding to a Coxeter matrix. -/
def ofMatrix : B × B → FreeGroup B :=
 Function.uncurry fun b₁ b₂ => (FreeGroup.of b₁ * FreeGroup.of b₂) ^ M b₁ b₂

/-- The set of relations corresponding to a Coxeter matrix. -/
def toSet : Set (FreeGroup B) :=
  Set.range <| ofMatrix M

end Relations

end CoxeterGroup

/-- The group presentation corresponding to a Coxeter matrix. -/
def Matrix.CoxeterGroup := PresentedGroup <| CoxeterGroup.Relations.toSet M

instance : Group (Matrix.CoxeterGroup M) :=
  QuotientGroup.Quotient.group _

namespace CoxeterGroup

/-- The canonical map from `B` to the Coxeter group with generators `b : B`. The term `b`
is mapped to the equivalence class of the image of `b` in `CoxeterGroup M`. -/
def of (b : B) : Matrix.CoxeterGroup M := PresentedGroup.of b

@[simp]
theorem of_apply (b : B) : of M b = PresentedGroup.of (rels := Relations.toSet M) b :=
  rfl

end CoxeterGroup

/-- A Coxeter system `CoxeterSystem W` is a structure recording the isomorphism between
a group `W` and the group presentation corresponding to a Coxeter matrix. Equivalently, this
can be seen as a list of generators of `W` parameterized by the underlying type of `M`, which
satisfy the relations of the Coxeter matrix `M`. -/
structure CoxeterSystem (W : Type*) [Group W]  where
  /-- `CoxeterSystem.ofMulEquiv` constructs a Coxeter system given an equivalence with the group
  presentation corresponding to a Coxeter matrix `M`. -/
  ofMulEquiv ::
    /-- `mulEquiv` is the isomorphism between the group `W` and the group presentation
    corresponding to a Coxeter matrix `M`. -/
    mulEquiv : W ≃* Matrix.CoxeterGroup M

/-- A group is a Coxeter group if it admits a Coxeter system for some Coxeter matrix `M`. -/
class IsCoxeterGroup (W : Type u) [Group W] : Prop where
  nonempty_system : ∃ (B : Type u), ∃ (M : Matrix B B ℕ),
    M.IsCoxeter ∧ Nonempty (CoxeterSystem M W)

namespace CoxeterSystem

open Matrix

variable {B B' W H : Type*} [Group W] [Group H]

variable {M : Matrix B B ℕ}

/-- A Coxeter system for `W` with Coxeter matrix `M` indexed by `B`, is associated to
a map `B → W` recording the images of the indices. -/
instance funLike : FunLike (CoxeterSystem M W) B W where
  coe cs := fun b => cs.mulEquiv.symm (.of b)
  coe_injective' := by
    rintro ⟨cs⟩ ⟨cs'⟩ hcs'
    have H : (cs.symm : CoxeterGroup M →* W) = (cs'.symm : CoxeterGroup M →* W) := by
      unfold CoxeterGroup
      ext i; exact congr_fun hcs' i
    have : cs.symm = cs'.symm := by ext x; exact DFunLike.congr_fun H x
    rw [ofMulEquiv.injEq, ← MulEquiv.symm_symm cs, ← MulEquiv.symm_symm cs', this]

@[simp]
theorem mulEquiv_apply_coe (cs : CoxeterSystem M W) (b : B) : cs.mulEquiv (cs b) = .of b :=
  cs.mulEquiv.eq_symm_apply.mp rfl

/-- The map sending a Coxeter system to its associated map `B → W` is injective. -/
theorem ext' {cs₁ cs₂ : CoxeterSystem M W} (H : ⇑cs₁ = ⇑cs₂) : cs₁ = cs₂ := DFunLike.coe_injective H

/-- Extensionality rule for Coxeter systems. -/
theorem ext {cs₁ cs₂ : CoxeterSystem M W} (H : ∀ b, cs₁ b = cs₂ b) : cs₁ = cs₂ :=
  ext' <| by ext; apply H

/-- The canonical Coxeter system of the Coxeter group over `X`. -/
def ofCoxeterGroup (X : Type*) (D : Matrix X X ℕ) : CoxeterSystem D (CoxeterGroup D) where
  mulEquiv := .refl _

@[simp]
theorem ofCoxeterGroup_apply {X : Type*} (D : Matrix X X ℕ) (x : X) :
    CoxeterSystem.ofCoxeterGroup X D x = CoxeterGroup.of D x :=
  rfl

theorem map_relations_eq_reindex_relations (e : B ≃ B') :
    (MulEquiv.toMonoidHom (FreeGroup.freeGroupCongr e)) '' CoxeterGroup.Relations.toSet M =
    CoxeterGroup.Relations.toSet (reindex e e M) := by
  simp [CoxeterGroup.Relations.toSet, CoxeterGroup.Relations.ofMatrix]
  apply le_antisymm
  · rw [Set.le_iff_subset]; intro _
    simp only [Set.mem_image, Set.mem_range, Prod.exists, Function.uncurry_apply_pair,
      forall_exists_index, and_imp]
    intro _ hb b _ heq; rw [← heq]
    use (e hb); use (e b); aesop
  · rw [Set.le_iff_subset]; intro hb'
    simp only [Set.mem_range, Prod.exists, Function.uncurry_apply_pair, Set.mem_image,
      forall_exists_index]
    intro b1' b2' heq; rw [← heq]
    use ((FreeGroup.freeGroupCongr e).symm hb')
    exact ⟨by use (e.symm b1'); use (e.symm b2'); aesop, by aesop⟩

/-- Coxeter groups of isomorphic types are isomorphic. -/
def equivCoxeterGroup (e : B ≃ B') : CoxeterGroup M ≃* CoxeterGroup (reindex e e M) :=
  QuotientGroup.congr (Subgroup.normalClosure (CoxeterGroup.Relations.toSet M))
    (Subgroup.normalClosure (CoxeterGroup.Relations.toSet (reindex e e M)))
    (FreeGroup.freeGroupCongr e) (by
      have := Subgroup.map_normalClosure (CoxeterGroup.Relations.toSet M)
        (FreeGroup.freeGroupCongr e).toMonoidHom (FreeGroup.freeGroupCongr e).surjective
      rwa [map_relations_eq_reindex_relations] at this)

theorem equivCoxeterGroup_apply_of (b : B) (M : Matrix B B ℕ) (e : B ≃ B') :
    (equivCoxeterGroup e) (CoxeterGroup.of M b) = CoxeterGroup.of (reindex e e M) (e b) :=
  rfl

theorem equivCoxeterGroup_symm_apply_of (b' : B') (M : Matrix B B ℕ) (e : B ≃ B') :
    (equivCoxeterGroup e).symm (CoxeterGroup.of (reindex e e M) b') =
    CoxeterGroup.of M (e.symm b') :=
  rfl

/-- Reindex a Coxeter system through a bijection of the indexing sets. -/
@[simps]
protected def reindex (cs : CoxeterSystem M W) (e : B ≃ B') :
    CoxeterSystem (reindex e e M) W :=
  ofMulEquiv (cs.mulEquiv.trans (equivCoxeterGroup e))

@[simp]
theorem reindex_apply (cs : CoxeterSystem M W) (e : B ≃ B') (b' : B') :
    cs.reindex e b' = cs (e.symm b') :=
  rfl

/-- Pushing a Coxeter system through a group isomorphism. -/
@[simps]
protected def map (cs : CoxeterSystem M W) (e : W ≃* H) : CoxeterSystem M H :=
  ofMulEquiv (e.symm.trans cs.mulEquiv)

@[simp]
theorem map_apply (cs : CoxeterSystem M W) (e : W ≃* H) (b : B) : cs.map e b = e (cs b) :=
  rfl

end CoxeterSystem

namespace CoxeterMatrix

open Matrix

variable (n : ℕ)

/-- The Coxeter matrix of family A(n).

The corresponding Coxeter-Dynkin diagram is:
```
    o --- o --- o ⬝ ⬝ ⬝ ⬝ o --- o
```
-/
abbrev Aₙ : Matrix (Fin n) (Fin n) ℕ :=
  Matrix.of fun i j : Fin n =>
    if i = j then 1
      else (if (j : ℕ) + 1 = i ∨ (i : ℕ) + 1 = j then 3 else 2)

theorem isCoxeter_Aₙ : IsCoxeter (Aₙ n) where
  symmetric := by
    simp [Matrix.IsSymm]; aesop

/-- The Coxeter matrix of family Bₙ.

The corresponding Coxeter-Dynkin diagram is:
```
       4
    o --- o --- o ⬝ ⬝ ⬝ ⬝ o --- o
```
-/
abbrev Bₙ : Matrix (Fin n) (Fin n) ℕ :=
  Matrix.of fun i j : Fin n =>
    if i = j then 1
      else (if i = n - 1 ∧ j = n - 2 ∨ j = n - 1 ∧ i = n - 2 then 4
        else (if (j : ℕ) + 1 = i ∨ (i : ℕ) + 1 = j then 3 else 2))

theorem isCoxeter_Bₙ : IsCoxeter (Bₙ n) where
  symmetric := by simp [Matrix.IsSymm]; aesop

/-- The Coxeter matrix of family Dₙ.

The corresponding Coxeter-Dynkin diagram is:
```
    o
     \
      o --- o ⬝ ⬝ ⬝ ⬝ o --- o
     /
    o
```
-/
abbrev Dₙ : Matrix (Fin n) (Fin n) ℕ :=
  Matrix.of fun i j : Fin n =>
    if i = j then 1
      else (if i = n - 1 ∧ j = n - 3 ∨ j = n - 1 ∧ i = n - 3 then 3
        else (if (j : ℕ) + 1 = i ∨ (i : ℕ) + 1 = j then 3 else 2))

theorem isCoxeter_Dₙ : IsCoxeter (Dₙ n) where
  symmetric := by simp [Matrix.IsSymm]; aesop

/-- The Coxeter matrix of m-indexed family I₂(m).

The corresponding Coxeter-Dynkin diagram is:
```
     m + 2
    o --- o
```
-/
abbrev I₂ₘ (m : ℕ) : Matrix (Fin 2) (Fin 2) ℕ :=
  Matrix.of fun i j => if i = j then 1 else m + 2

theorem isCoxeter_I₂ₘ (m : ℕ) : IsCoxeter (I₂ₘ m) where
  symmetric := by simp [Matrix.IsSymm]; aesop

/-- The Coxeter matrix of system E₆.

The corresponding Coxeter-Dynkin diagram is:
```
                o
                |
    o --- o --- o --- o --- o
```
-/
def E₆ : Matrix (Fin 6) (Fin 6) ℕ :=
  !![1, 2, 3, 2, 2, 2;
     2, 1, 2, 3, 2, 2;
     3, 2, 1, 3, 2, 2;
     2, 3, 3, 1, 3, 2;
     2, 2, 2, 3, 1, 3;
     2, 2, 2, 2, 3, 1]

theorem isCoxeter_E₆ : IsCoxeter E₆ where
  symmetric := by simp [Matrix.IsSymm]; decide
  diagonal := by decide
  off_diagonal := by decide

/-- The Coxeter matrix of system E₇.

The corresponding Coxeter-Dynkin diagram is:
```
                o
                |
    o --- o --- o --- o --- o --- o
```
-/
def E₇ : Matrix (Fin 7) (Fin 7) ℕ :=
  !![1, 2, 3, 2, 2, 2, 2;
     2, 1, 2, 3, 2, 2, 2;
     3, 2, 1, 3, 2, 2, 2;
     2, 3, 3, 1, 3, 2, 2;
     2, 2, 2, 3, 1, 3, 2;
     2, 2, 2, 2, 3, 1, 3;
     2, 2, 2, 2, 2, 3, 1]

theorem isCoxeter_E₇ : IsCoxeter E₇ where
  symmetric := by simp [Matrix.IsSymm]; decide
  diagonal := by decide
  off_diagonal := by decide

/-- The Coxeter matrix of system E₈.

The corresponding Coxeter-Dynkin diagram is:
```
                o
                |
    o --- o --- o --- o --- o --- o --- o
```
-/
def E₈ : Matrix (Fin 8) (Fin 8) ℕ :=
  !![1, 2, 3, 2, 2, 2, 2, 2;
     2, 1, 2, 3, 2, 2, 2, 2;
     3, 2, 1, 3, 2, 2, 2, 2;
     2, 3, 3, 1, 3, 2, 2, 2;
     2, 2, 2, 3, 1, 3, 2, 2;
     2, 2, 2, 2, 3, 1, 3, 2;
     2, 2, 2, 2, 2, 3, 1, 3;
     2, 2, 2, 2, 2, 2, 3, 1]

theorem isCoxeter_E₈ : IsCoxeter E₈ where
  symmetric := by simp [Matrix.IsSymm]; decide
  diagonal := by decide
  off_diagonal := by decide

/-- The Coxeter matrix of system F₄.

The corresponding Coxeter-Dynkin diagram is:
```
             4
    o --- o --- o --- o
```
-/
def F₄ : Matrix (Fin 4) (Fin 4) ℕ :=
  !![1, 3, 2, 2;
     3, 1, 4, 2;
     2, 4, 1, 3;
     2, 2, 3, 1]

theorem isCoxeter_F₄ : IsCoxeter F₄ where
  symmetric := by simp [Matrix.IsSymm]; decide
  diagonal := by decide
  off_diagonal := by decide

/-- The Coxeter matrix of system G₂.

The corresponding Coxeter-Dynkin diagram is:
```
       6
    o --- o
```
-/
def G₂ : Matrix (Fin 2) (Fin 2) ℕ :=
  !![1, 6;
     6, 1]

theorem isCoxeter_G₂ : IsCoxeter G₂ where
  symmetric := by simp [Matrix.IsSymm]; decide
  diagonal := by decide
  off_diagonal := by decide

/-- The Coxeter matrix of system H₃.

The corresponding Coxeter-Dynkin diagram is:
```
       5
    o --- o --- o
```
-/
def H₃ : Matrix (Fin 3) (Fin 3) ℕ :=
  !![1, 3, 2;
     3, 1, 5;
     2, 5, 1]

theorem isCoxeter_H₃ : IsCoxeter H₃ where
  symmetric := by simp [Matrix.IsSymm]; decide
  diagonal := by decide
  off_diagonal := by decide

/-- The Coxeter matrix of system H₄.

The corresponding Coxeter-Dynkin diagram is:
```
       5
    o --- o --- o --- o
```
-/
def H₄ : Matrix (Fin 4) (Fin 4) ℕ :=
  !![1, 3, 2, 2;
     3, 1, 3, 2;
     2, 3, 1, 5;
     2, 2, 5, 1]

theorem isCoxeter_H₄ : IsCoxeter H₄ where
  symmetric := by simp [Matrix.IsSymm]; decide
  diagonal := by decide
  off_diagonal := by decide

end CoxeterMatrix

namespace CoxeterSystem

open List Matrix Function
variable {M : Matrix B B ℕ}
variable {W : Type*} [Group W]
variable (cs : CoxeterSystem M W)

/-- The simple reflection of `W` corresponding to the index `i`. -/
def simpleReflection (i : B) : W := cs.mulEquiv.invFun (PresentedGroup.of i)
/-- The product of the simple reflections of `W` corresponding to the indices in `ω`.-/
def wordProd (ω : List B) : W := prod (map cs.simpleReflection ω)

local prefix:100 "s" => cs.simpleReflection
local prefix:100 "π" => cs.wordProd

@[simp] theorem wordProd_append (ω ω' : List B) :
    π (ω ++ ω') = π ω * π ω' := by
  sorry

theorem wordProd_surjective : Surjective (cs.wordProd) := by
  sorry

theorem wordProd_rev (ω : List B) :
    π (reverse ω) = (π ω)⁻¹ := by
  sorry

/-- The length of `w`; i.e., the minimum number of simple reflections that
must be multiplied to form `w`. -/
def length (cs : CoxeterSystem M W) (w : W) : ℕ := sorry

local prefix:100 "ℓ" => cs.length

@[simp] theorem length_one : ℓ (1 : W) = 0 := by
  sorry

theorem length_eq_zero_iff {w : W} : ℓ w = 0 ↔ w = 1 := by
  sorry

@[simp] theorem length_simple (i : B) : ℓ (s i) = 1 := by
  sorry

theorem length_eq_one_iff {w : W} : ℓ w = 1 ↔ ∃ i : B, w = s i := by
  sorry

@[simp] theorem length_inv (w : W) : ℓ (w⁻¹) = ℓ w := by
  sorry

theorem length_mul_le (w₁ w₂ : W) :
    ℓ (w₁ * w₂) ≤ ℓ w₁ + ℓ w₂ := by
  sorry

theorem length_mul_ge (w₁ w₂ : W) :
    ℓ (w₁ * w₂) ≥ max (ℓ w₁ - ℓ w₂) (ℓ w₂ - ℓ w₁) := by
  sorry

private def lengthParity (cs : CoxeterSystem M W) : W →* Multiplicative (ZMod 2) := sorry

private theorem parity_length_eq :
    Multiplicative.toAdd ∘ cs.lengthParity.toFun = ((↑) : ℕ → ZMod 2) ∘ cs.length := by
  sorry

private theorem parity_length_eq' (w : W) :
    Multiplicative.toAdd (cs.lengthParity w) = ((↑) : ℕ → ZMod 2) (ℓ w) := by
  sorry

theorem parity_length_mul (w₁ w₂ : W) : ℓ (w₁ * w₂) % 2 = (ℓ w₁ + ℓ w₂) % 2 := by
  sorry

theorem length_mul_simple (w : W) (i : B) :
    ℓ (w * s i) = ℓ w + 1 ∨ ℓ (w * s i) + 1 = ℓ w := by
  sorry

theorem length_simple_mul (w : W) (i : B) :
    ℓ (s i * w) = ℓ w + 1 ∨ ℓ (s i * w) + 1 = ℓ w := by
  sorry

-- Reduced words

def IsReduced (ω : List B) : Prop := ℓ (π ω) = ω.length
theorem isReduced_take (ω : List B) (rω : cs.IsReduced ω) (j : ℕ) : cs.IsReduced (ω.take j) := by
  sorry

theorem isReduced_drop (ω : List B) (rω : cs.IsReduced ω) (j : ℕ) : cs.IsReduced (ω.drop j) := by
  sorry

-- Reflections, inversions, inversion sequences

/-- `t` is a reflection of the Coxeter system `cs`; i.e., it is of the form
$w s_i w^{-1}$, where $w \in W$ and $s_i$ is a simple reflection. -/
def IsReflection (t : W) : Prop := ∃ w : W, ∃ i : B, t = w * s i * w⁻¹

def reflections : Set W := {t : W | cs.IsReflection t}

theorem isInvolution_of_isReflection (t : W) (rt : cs.IsReflection t) : t ^ 2 = 1 := by
  sorry

/-- `t` is a left inversion of `w`; i.e., `t` is a reflection and $\ell (t w) < \ell(w)$.-/
def IsLeftInversion (w t : W) : Prop := cs.IsReflection t ∧ ℓ (t * w) < ℓ w
/-- `t` is a right inversion of `w`; i.e., `t` is a reflection and $\ell (w t) < \ell(w)$.-/
def IsRightInversion (w t : W) : Prop := cs.IsReflection t ∧ ℓ (w * t) < ℓ w

/-- The left inversion sequence of `ω`. The left inversion sequence of a word
$s_{i_1} \cdots s_{i_\ell}$ is the sequence
$$s_{i_1}, s_{i_1}s_{i_2}s_{i_1}, s_{i_1}s_{i_2}s_{i_3}s_{i_2}s_{i_1}, \ldots,
    s_{i_1}\cdots s_{i_\ell}\cdots s_{i_1}.$$
-/
def leftInvSeq (cs : CoxeterSystem M W) (ω : List B) : List W := sorry
/-- The right inversion sequence of `ω`. The right inversion sequence of a word
$s_{i_1} \cdots s_{i_\ell}$ is the sequence
$$s_{i_\ell}\cdots s_{i_1}\cdots s_{i_\ell}, \ldots,
    s_{i_{\ell}}s_{i_{\ell - 1}}s_{i_{\ell - 2}}s_{i_{\ell - 1}}s_{i_\ell}, \ldots,
    s_{i_{\ell}}s_{i_{\ell - 1}}s_{i_\ell}, s_{i_\ell}.$$
-/
def rightInvSeq (cs : CoxeterSystem M W) (ω : List B) : List W := sorry

local prefix:100 "reduced" => cs.IsReduced
local prefix:100 "lis" => cs.leftInvSeq
local prefix:100 "ris" => cs.rightInvSeq

@[simp] theorem length_leftInvSeq (ω : List B) : (lis ω).length = ω.length := by
  sorry

@[simp] theorem length_rightInvSeq (ω : List B) : (ris ω).length = ω.length := by
  sorry

theorem all_leftInvSeq_isReflection (ω : List B) : ∀ t ∈ lis ω, cs.IsReflection t := by
  sorry

theorem all_rightInvSeq_isReflection (ω : List B) : ∀ t ∈ ris ω, cs.IsReflection t := by
  sorry

@[simp] theorem leftInvSeq_rev (ω : List B) :
    lis (ω.reverse) = (ris ω).reverse := by
  sorry

@[simp] theorem rightInvSeq_rev (ω : List B) :
    ris (ω.reverse) = (lis ω).reverse := by
  sorry

@[simp] theorem leftInvSeq_take (ω : List B) (j : ℕ) :
    lis (ω.take j) = (lis ω).take j := by
  sorry

@[simp] theorem rightInvSeq_drop (ω : List B) (j : ℕ) :
    ris (ω.drop j) = (ris ω).drop j := by
  sorry

theorem leftInvSeq_i_mul (ω : List B) (j : Fin (lis ω).length) :
    (lis ω)[j] * π ω = π (ω.eraseIdx j) := by
  sorry

theorem rightInvSeq_i_mul (ω : List B) (j : Fin (ris ω).length) :
    π ω * (ris ω)[j] = π (ω.eraseIdx j) := by
  sorry

theorem prod_leftInvSeq (ω : List B) : prod (lis ω) = (π ω)⁻¹ := by
  sorry

theorem prod_rightInvSeq (ω : List B) : prod (ris ω) = (π ω)⁻¹ := by
  sorry

private lemma nodup_leftInvSeq_of_reduced (ω : List B) (rω : reduced ω) :
    List.Nodup (lis ω) := by
  sorry

private lemma nodup_rightInvSeq_of_reduced (ω : List B) (rω : reduced ω) :
    List.Nodup (ris ω) := by
  sorry

-- Geometric representations and the standard geometric representation.

def simpleRoot (i : B) : B →₀ ℝ := Finsupp.single i 1
local prefix:100 "α" => simpleRoot

/-- The standard bilinear form on B →₀ ℝ. Given by ⟪αᵢ, αⱼ⟫ = cos (π / Mᵢⱼ)
for i j : B, where {αᵢ} is the standard basis of B →₀ ℝ and M is the Coxeter matrix.
This is positive definite if and only if the associated Coxeter group is finite. -/
def standardBilinForm (M : Matrix B B ℕ) : LinearMap.BilinForm ℝ (B →₀ ℝ) := sorry

local notation:max "⟪"  a  ","  b  "⟫" => standardBilinForm M a b

theorem standardBilinForm_symm (M : Matrix B B ℕ) : LinearMap.IsSymm (standardBilinForm M) := by
  sorry

@[simp] theorem standardBilinForm_simpleRoots (i i' : B) :
    ⟪α i, α i'⟫ = Real.cos (Real.pi / M i i') := by
  sorry

/-- The orthogonal reflection in the vector `v` under the standard bilinear form.
-/
def reflection (M : Matrix B B ℕ) (v : B →₀ ℝ) : (B →₀ ℝ) →ₗ[ℝ] (B →₀ ℝ) := sorry

theorem reflection_sqr_eq_id (M : Matrix B B ℕ) (v : B →₀ ℝ) :
    (reflection M v) * (reflection M v) = LinearMap.id := by
  sorry

theorem reflection_eq_iff (M : Matrix B B ℕ) (v v' : B →₀ ℝ) (hv : ⟪v, v⟫ ≠ 0):
    reflection M v = reflection M v' ↔ ∃ μ : ℝ, v' = μ • v := by
  sorry

/-- The standard geometric representation on B →₀ ℝ. For i : B, the simple reflection sᵢ acts by
sᵢ v = v - 2 ⟪αᵢ, v⟫ / ⟪αᵢ, αᵢ⟫ * αᵢ, where {αᵢ} is the standard basis of B →₀ ℝ.
-/
def standardGeometricRepresentation (cs : CoxeterSystem M W) : Representation ℝ W (B →₀ ℝ) := sorry

alias SGR := standardGeometricRepresentation

theorem SGR_simpleReflection (i : B) : cs.SGR (s i) = reflection M (α i) := by
  sorry

theorem SGR_simpleReflection_simpleRoot (i : B) : cs.SGR (s i) (α i) = -α i := by
  sorry

theorem SGR_bilin_eq_bilin (w : W) (v v' : B →₀ ℝ) : ⟪cs.SGR w v, cs.SGR w v'⟫ = ⟪v, v'⟫ := by
  sorry

/-- The roots of the standard geometric representation; i.e. the vectors that can be written
in the form w αᵢ, where w : W and {αᵢ} is the standard basis of B →₀ ℝ. If W is infinite,
then this is not a root system in the traditional sense because it is infinite and
B →₀ ℝ is not an inner product space.
-/
def roots : Set (B →₀ ℝ) := {v : B →₀ ℝ | ∃ w : W, ∃ i : B, v = cs.SGR w (α i)}

/-- The roots that can be written as a nonnegative linear combination of the standard basis {αᵢ}.-/
def posRoots : Set (B →₀ ℝ) := cs.roots ∩ {v : B →₀ ℝ | ∀ i : B, v i ≥ 0}
/-- The roots that can be written as a nonpositive linear combination of the standard basis {αᵢ}.-/
def negRoots : Set (B →₀ ℝ) := cs.roots ∩ {v : B →₀ ℝ | ∀ i : B, v i ≤ 0}


@[simp] theorem roots_invariant (w : W) (v : B →₀ ℝ) : cs.SGR w v ∈ cs.roots ↔ v ∈ cs.roots := by
  sorry

@[simp] theorem roots_eq_neg_roots : -cs.roots = cs.roots := by
  sorry

theorem negRoots_eq_neg_posRoots : cs.negRoots = -cs.posRoots := by
  sorry

theorem root_pos_or_neg : cs.roots = cs.posRoots ∪ cs.negRoots  := by
  sorry

theorem root_not_pos_and_neg : cs.posRoots ∩ cs.negRoots = ∅ := by
  sorry

theorem SGR_injective : Injective cs.SGR := by
  sorry

def reflectionToRoot : cs.reflections ≃ cs.posRoots := sorry

theorem reflection_by_smul (w : W) (v : B →₀ ℝ) :
    reflection M (cs.SGR w v) = (cs.SGR w) ∘ (reflection M v) ∘ (cs.SGR w⁻¹) := by
  sorry

theorem reflection_by_root (γ : cs.posRoots) :
    reflection M γ = cs.SGR (cs.reflectionToRoot.invFun γ) := by
  sorry

theorem isRightInversion_iff (w : W) (t : cs.reflections) : cs.IsRightInversion w t ↔
    cs.SGR w (cs.reflectionToRoot.toFun t) ∈ cs.negRoots := by
  sorry


/-- The (strong) left exchange property:
Let $w = s_{i_1} \cdots s_{i_\ell}$ be a reduced expression for an element $w \in W$
and let $t \in W$.
The following are equivalent:

\begin{enumerate}
  \item $t$ is a left inversion of $w$.
  \item $t$ appears in the left inversion sequence of the word $s_{i_1} \cdots s_{i_\ell}$.
  \item There exists $j$ with $1 \leq j \leq \ell$ such that
  $$tw = s_{i_1} \cdots \widehat{s_{i_j}} \cdots s_{i_\ell}$$
  (i.e. the result of multiplying all of the simple reflections $s_{i_1}, \ldots, s_{i_\ell}$
  except $s_{i_j}$).
\end{enumerate}
-/
theorem left_exchange_property (ω : List B) (t : W) (rω : reduced ω) :
    List.TFAE [
      cs.IsLeftInversion (π ω) t,
      t ∈ lis ω,
      ∃ j < ω.length, t * (π ω) = π (ω.eraseIdx j)
    ] := by
  sorry

/-- The (strong) right exchange property:
Let $w = s_{i_1} \cdots s_{i_\ell}$ be a reduced expression for an element $w \in W$
and let $t \in W$.
The following are equivalent:

\begin{enumerate}
  \item $t$ is a right inversion of $w$.
  \item $t$ appears in the right inversion sequence of the word $s_{i_1} \cdots s_{i_\ell}$.
  \item There exists $j$ with $1 \leq j \leq \ell$ such that
  $$wt = s_{i_1} \cdots \widehat{s_{i_j}} \cdots s_{i_\ell}$$
  (i.e. the result of multiplying all of the simple reflections $s_{i_1}, \ldots, s_{i_\ell}$
  except $s_{i_j}$).
\end{enumerate}
-/
theorem right_exchange_property (ω : List B) (t : W) (rω : reduced ω) :
    List.TFAE [
      cs.IsRightInversion (π ω) t,
      t ∈ ris ω,
      ∃ j < ω.length, (π ω) * t = π (ω.eraseIdx j)
    ] := by
  sorry

theorem nodup_leftInvSeq_iff (ω : List B) :
    List.Nodup (lis ω) ↔ reduced ω := by
  sorry

theorem nodup_rightInvSeq_iff (ω : List B) :
    List.Nodup (ris ω) ↔ reduced ω := by
  sorry

/-- The deletion property:
If $s_{i_1} \cdots s_{i_\ell}$ is not a reduced expression, then there are $i, j$ with
$1 \leq j < j' \leq \ell$ such that
$$s_{i_1} \cdots s_{i_\ell} =
s_{i_1} \cdots \widehat{s_{i_j}} \cdots \widehat{s_{i_{j'}}} s_{i_\ell}.
-/
theorem deletion_property (ω : List B) (nrω : ¬ reduced ω) :
    ∃ j' < ω.length, ∃ j < j', π ((ω.eraseIdx j').eraseIdx j) = π ω := by
  sorry

/-
TODO: Inversion set is finite. Size of inversion set = length.
Matsumoto's theorem.
Simple reflections are distinct.
Order of s_i s_j is exactly M i j.

Eₙ for n > 8.

Irreducibility. Irreducible components.
Parabolic subgroups.
Poincare series.

The standard geometric representation. It is faithful.
Height of a root.
Standard geometric representation is orthogonal if and only if W is finite.
Classification of irreducible finite Coxeter groups.
Classification of irreducible affine Coxeter groups.

Small roots.
Coxeter groups are automatic.

Long element has all reflections as inversions. Long element is an involution.
Properties of Coxeter number.

The weak order. Ungar moves. Ungar's problem.

Bruhat order.

Combinatorially describe finite and affine Coxeter groups of types A, B, C, D.
Interpret inversions, descents, length, convex sets, parabolic subgroups, Bruhat order.

Schubert polynomials.

Associated hyperplane arrangements and partition lattices and their characteristic polynomials.
Folding.
Convex sets.
Coxeter elements, c-sorting words.
Powers of Coxeter elements in infinite groups are reduced.
Futuristic Coxeter groups.
-/

end CoxeterSystem
