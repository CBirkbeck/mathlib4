/-
Copyright (c) 2021 Yakov Pechersky. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Yakov Pechersky
-/
import Mathlib.Data.List.Cycle
import Mathlib.GroupTheory.Perm.Cycle.Type
import Mathlib.GroupTheory.Perm.List

#align_import group_theory.perm.cycle.concrete from "leanprover-community/mathlib"@"00638177efd1b2534fc5269363ebf42a7871df9a"

/-!

# Properties of cyclic permutations constructed from lists/cycles

In the following, `{Œ± : Type*} [Fintype Œ±] [DecidableEq Œ±]`.

## Main definitions

* `Cycle.formPerm`: the cyclic permutation created by looping over a `Cycle Œ±`
* `Equiv.Perm.toList`: the list formed by iterating application of a permutation
* `Equiv.Perm.toCycle`: the cycle formed by iterating application of a permutation
* `Equiv.Perm.isoCycle`: the equivalence between cyclic permutations `f : Perm Œ±`
  and the terms of `Cycle Œ±` that correspond to them
* `Equiv.Perm.isoCycle'`: the same equivalence as `Equiv.Perm.isoCycle`
  but with evaluation via choosing over fintypes
* The notation `c[1, 2, 3]` to emulate notation of cyclic permutations `(1 2 3)`
* A `Repr` instance for any `Perm Œ±`, by representing the `Finset` of
  `Cycle Œ±` that correspond to the cycle factors.

## Main results

* `List.isCycle_formPerm`: a nontrivial list without duplicates, when interpreted as
  a permutation, is cyclic
* `Equiv.Perm.IsCycle.existsUnique_cycle`: there is only one nontrivial `Cycle Œ±`
  corresponding to each cyclic `f : Perm Œ±`

## Implementation details

The forward direction of `Equiv.Perm.isoCycle'` uses `Fintype.choose` of the uniqueness
result, relying on the `Fintype` instance of a `Cycle.nodup` subtype.
It is unclear if this works faster than the `Equiv.Perm.toCycle`, which relies
on recursion over `Finset.univ`.
Running `#eval` on even a simple noncyclic permutation `c[(1 : Fin 7), 2, 3] * c[0, 5]`
to show it takes a long time. TODO: is this because computing the cycle factors is slow?

-/


open Equiv Equiv.Perm List

variable {Œ± : Type*}

namespace List

variable [DecidableEq Œ±] {l l' : List Œ±}

theorem formPerm_disjoint_iff (hl : Nodup l) (hl' : Nodup l') (hn : 2 ‚â§ l.length)
    (hn' : 2 ‚â§ l'.length) : Perm.Disjoint (formPerm l) (formPerm l') ‚Üî l.Disjoint l' := by
  rw [disjoint_iff_eq_or_eq, List.Disjoint]
  -- ‚ä¢ (‚àÄ (x : Œ±), ‚Üë(formPerm l) x = x ‚à® ‚Üë(formPerm l') x = x) ‚Üî ‚àÄ ‚¶Éa : Œ±‚¶Ñ, a ‚àà l ‚Üí ‚Ä¶
  constructor
  -- ‚ä¢ (‚àÄ (x : Œ±), ‚Üë(formPerm l) x = x ‚à® ‚Üë(formPerm l') x = x) ‚Üí ‚àÄ ‚¶Éa : Œ±‚¶Ñ, a ‚àà l ‚Üí ‚Ä¶
  ¬∑ rintro h x hx hx'
    -- ‚ä¢ False
    specialize h x
    -- ‚ä¢ False
    rw [formPerm_apply_mem_eq_self_iff _ hl _ hx, formPerm_apply_mem_eq_self_iff _ hl' _ hx'] at h
    -- ‚ä¢ False
    rcases h with (hl | hl') <;> linarith
    -- ‚ä¢ False
                                 -- üéâ no goals
                                 -- üéâ no goals
  ¬∑ intro h x
    -- ‚ä¢ ‚Üë(formPerm l) x = x ‚à® ‚Üë(formPerm l') x = x
    by_cases hx : x ‚àà l
    -- ‚ä¢ ‚Üë(formPerm l) x = x ‚à® ‚Üë(formPerm l') x = x
    by_cases hx' : x ‚àà l'
    ¬∑ exact (h hx hx').elim
      -- üéâ no goals
    all_goals have := formPerm_eq_self_of_not_mem _ _ ‚Äπ_‚Ä∫; tauto
    -- üéâ no goals
#align list.form_perm_disjoint_iff List.formPerm_disjoint_iff

set_option linter.deprecated false in
theorem isCycle_formPerm (hl : Nodup l) (hn : 2 ‚â§ l.length) : IsCycle (formPerm l) := by
  cases' l with x l
  -- ‚ä¢ IsCycle (formPerm [])
  ¬∑ norm_num at hn
    -- üéâ no goals
  induction' l with y l generalizing x
  -- ‚ä¢ IsCycle (formPerm [x])
  ¬∑ norm_num at hn
    -- üéâ no goals
  ¬∑ use x
    -- ‚ä¢ ‚Üë(formPerm (x :: y :: l)) x ‚â† x ‚àß ‚àÄ ‚¶Éy_1 : Œ±‚¶Ñ, ‚Üë(formPerm (x :: y :: l)) y_1 ‚Ä¶
    constructor
    -- ‚ä¢ ‚Üë(formPerm (x :: y :: l)) x ‚â† x
    ¬∑ rwa [formPerm_apply_mem_ne_self_iff _ hl _ (mem_cons_self _ _)]
      -- üéâ no goals
    ¬∑ intro w hw
      -- ‚ä¢ SameCycle (formPerm (x :: y :: l)) x w
      have : w ‚àà x::y::l := mem_of_formPerm_ne_self _ _ hw
      -- ‚ä¢ SameCycle (formPerm (x :: y :: l)) x w
      obtain ‚ü®k, hk, rfl‚ü© := nthLe_of_mem this
      -- ‚ä¢ SameCycle (formPerm (x :: y :: l)) x (nthLe (x :: y :: l) k hk)
      use k
      -- ‚ä¢ ‚Üë(formPerm (x :: y :: l) ^ ‚Üëk) x = nthLe (x :: y :: l) k hk
      simp only [zpow_ofNat, formPerm_pow_apply_head _ _ hl k, Nat.mod_eq_of_lt hk]
      -- üéâ no goals
#align list.is_cycle_form_perm List.isCycle_formPerm

theorem pairwise_sameCycle_formPerm (hl : Nodup l) (hn : 2 ‚â§ l.length) :
    Pairwise l.formPerm.SameCycle l :=
  Pairwise.imp_mem.mpr
    (pairwise_of_forall fun _ _ hx hy =>
      (isCycle_formPerm hl hn).sameCycle ((formPerm_apply_mem_ne_self_iff _ hl _ hx).mpr hn)
        ((formPerm_apply_mem_ne_self_iff _ hl _ hy).mpr hn))
#align list.pairwise_same_cycle_form_perm List.pairwise_sameCycle_formPerm

theorem cycleOf_formPerm (hl : Nodup l) (hn : 2 ‚â§ l.length) (x) :
    cycleOf l.attach.formPerm x = l.attach.formPerm :=
  have hn : 2 ‚â§ l.attach.length := by rwa [‚Üê length_attach] at hn
                                      -- üéâ no goals
  have hl : l.attach.Nodup := by rwa [‚Üê nodup_attach] at hl
                                 -- üéâ no goals
  (isCycle_formPerm hl hn).cycleOf_eq
    ((formPerm_apply_mem_ne_self_iff _ hl _ (mem_attach _ _)).mpr hn)
#align list.cycle_of_form_perm List.cycleOf_formPerm

theorem cycleType_formPerm (hl : Nodup l) (hn : 2 ‚â§ l.length) :
    cycleType l.attach.formPerm = {l.length} := by
  rw [‚Üê length_attach] at hn
  -- ‚ä¢ cycleType (formPerm (attach l)) = {length l}
  rw [‚Üê nodup_attach] at hl
  -- ‚ä¢ cycleType (formPerm (attach l)) = {length l}
  rw [cycleType_eq [l.attach.formPerm]]
  ¬∑ simp only [map, Function.comp_apply]
    -- ‚ä¢ ‚Üë[Finset.card (support (formPerm (attach l)))] = {length l}
    rw [support_formPerm_of_nodup _ hl, card_toFinset, dedup_eq_self.mpr hl]
    -- ‚ä¢ ‚Üë[length (attach l)] = {length l}
    ¬∑ simp
      -- üéâ no goals
    ¬∑ intro x h
      -- ‚ä¢ False
      simp [h, Nat.succ_le_succ_iff] at hn
      -- üéâ no goals
  ¬∑ simp
    -- üéâ no goals
  ¬∑ simpa using isCycle_formPerm hl hn
    -- üéâ no goals
  ¬∑ simp
    -- üéâ no goals
#align list.cycle_type_form_perm List.cycleType_formPerm

set_option linter.deprecated false in
theorem formPerm_apply_mem_eq_next (hl : Nodup l) (x : Œ±) (hx : x ‚àà l) :
    formPerm l x = next l x hx := by
  obtain ‚ü®k, hk, rfl‚ü© := nthLe_of_mem hx
  -- ‚ä¢ ‚Üë(formPerm l) (nthLe l k hk) = next l (nthLe l k hk) hx
  rw [next_nthLe _ hl, formPerm_apply_nthLe _ hl]
  -- üéâ no goals
#align list.form_perm_apply_mem_eq_next List.formPerm_apply_mem_eq_next

end List

namespace Cycle

variable [DecidableEq Œ±] (s s' : Cycle Œ±)

/-- A cycle `s : Cycle Œ±`, given `Nodup s` can be interpreted as an `Equiv.Perm Œ±`
where each element in the list is permuted to the next one, defined as `formPerm`.
-/
def formPerm : ‚àÄ (s : Cycle Œ±) (_ : Nodup s), Equiv.Perm Œ± :=
  fun s => Quotient.hrecOn s (fun l _ => List.formPerm l) fun l‚ÇÅ l‚ÇÇ (h : l‚ÇÅ ~r l‚ÇÇ) => by
    apply Function.hfunext
    -- ‚ä¢ Nodup (Quotient.mk (IsRotated.setoid Œ±) l‚ÇÅ) = Nodup (Quotient.mk (IsRotated. ‚Ä¶
    ext
    -- ‚ä¢ Nodup (Quotient.mk (IsRotated.setoid Œ±) l‚ÇÅ) ‚Üî Nodup (Quotient.mk (IsRotated. ‚Ä¶
    ¬∑ exact h.nodup_iff
      -- üéâ no goals
    ¬∑ intro h‚ÇÅ h‚ÇÇ _
      -- ‚ä¢ HEq (List.formPerm l‚ÇÅ) (List.formPerm l‚ÇÇ)
      exact heq_of_eq (formPerm_eq_of_isRotated h‚ÇÅ h)
      -- üéâ no goals
#align cycle.form_perm Cycle.formPerm

@[simp]
theorem formPerm_coe (l : List Œ±) (hl : l.Nodup) : formPerm (l : Cycle Œ±) hl = l.formPerm :=
  rfl
#align cycle.form_perm_coe Cycle.formPerm_coe

theorem formPerm_subsingleton (s : Cycle Œ±) (h : Subsingleton s) : formPerm s h.nodup = 1 := by
  induction' s using Quot.inductionOn with s
  -- ‚ä¢ formPerm (Quot.mk Setoid.r s) (_ : Nodup (Quot.mk Setoid.r s)) = 1
  simp only [formPerm_coe, mk_eq_coe]
  -- ‚ä¢ List.formPerm s = 1
  simp only [length_subsingleton_iff, length_coe, mk_eq_coe] at h
  -- ‚ä¢ List.formPerm s = 1
  cases' s with hd tl
  -- ‚ä¢ List.formPerm [] = 1
  ¬∑ simp
    -- üéâ no goals
  ¬∑ simp only [length_eq_zero, add_le_iff_nonpos_left, List.length, nonpos_iff_eq_zero] at h
    -- ‚ä¢ List.formPerm (hd :: tl) = 1
    simp [h]
    -- üéâ no goals
#align cycle.form_perm_subsingleton Cycle.formPerm_subsingleton

theorem isCycle_formPerm (s : Cycle Œ±) (h : Nodup s) (hn : Nontrivial s) :
    IsCycle (formPerm s h) := by
  induction s using Quot.inductionOn
  -- ‚ä¢ IsCycle (formPerm (Quot.mk Setoid.r a‚úù) h)
  exact List.isCycle_formPerm h (length_nontrivial hn)
  -- üéâ no goals
#align cycle.is_cycle_form_perm Cycle.isCycle_formPerm

theorem support_formPerm [Fintype Œ±] (s : Cycle Œ±) (h : Nodup s) (hn : Nontrivial s) :
    support (formPerm s h) = s.toFinset := by
  induction' s using Quot.inductionOn with s
  -- ‚ä¢ support (formPerm (Quot.mk Setoid.r s) h) = toFinset (Quot.mk Setoid.r s)
  refine' support_formPerm_of_nodup s h _
  -- ‚ä¢ ‚àÄ (x : Œ±), s ‚â† [x]
  rintro _ rfl
  -- ‚ä¢ False
  simpa [Nat.succ_le_succ_iff] using length_nontrivial hn
  -- üéâ no goals
#align cycle.support_form_perm Cycle.support_formPerm

theorem formPerm_eq_self_of_not_mem (s : Cycle Œ±) (h : Nodup s) (x : Œ±) (hx : x ‚àâ s) :
    formPerm s h x = x := by
  induction s using Quot.inductionOn
  -- ‚ä¢ ‚Üë(formPerm (Quot.mk Setoid.r a‚úù) h) x = x
  simpa using List.formPerm_eq_self_of_not_mem _ _ hx
  -- üéâ no goals
#align cycle.form_perm_eq_self_of_not_mem Cycle.formPerm_eq_self_of_not_mem

theorem formPerm_apply_mem_eq_next (s : Cycle Œ±) (h : Nodup s) (x : Œ±) (hx : x ‚àà s) :
    formPerm s h x = next s h x hx := by
  induction s using Quot.inductionOn
  -- ‚ä¢ ‚Üë(formPerm (Quot.mk Setoid.r a‚úù) h) x = next (Quot.mk Setoid.r a‚úù) h x hx
  simpa using List.formPerm_apply_mem_eq_next h _ (by simp_all)
  -- üéâ no goals
#align cycle.form_perm_apply_mem_eq_next Cycle.formPerm_apply_mem_eq_next

nonrec theorem formPerm_reverse (s : Cycle Œ±) (h : Nodup s) :
    formPerm s.reverse (nodup_reverse_iff.mpr h) = (formPerm s h)‚Åª¬π := by
  induction s using Quot.inductionOn
  -- ‚ä¢ formPerm (reverse (Quot.mk Setoid.r a‚úù)) (_ : Nodup (reverse (Quot.mk Setoid ‚Ä¶
  simpa using formPerm_reverse _ h
  -- üéâ no goals
#align cycle.form_perm_reverse Cycle.formPerm_reverse

nonrec theorem formPerm_eq_formPerm_iff {Œ± : Type*} [DecidableEq Œ±] {s s' : Cycle Œ±} {hs : s.Nodup}
    {hs' : s'.Nodup} :
    s.formPerm hs = s'.formPerm hs' ‚Üî s = s' ‚à® s.Subsingleton ‚àß s'.Subsingleton := by
  rw [Cycle.length_subsingleton_iff, Cycle.length_subsingleton_iff]
  -- ‚ä¢ formPerm s hs = formPerm s' hs' ‚Üî s = s' ‚à® length s ‚â§ 1 ‚àß length s' ‚â§ 1
  revert s s'
  -- ‚ä¢ ‚àÄ {s s' : Cycle Œ±} {hs : Nodup s} {hs' : Nodup s'}, formPerm s hs = formPerm ‚Ä¶
  intro s s'
  -- ‚ä¢ ‚àÄ {hs : Nodup s} {hs' : Nodup s'}, formPerm s hs = formPerm s' hs' ‚Üî s = s'  ‚Ä¶
  apply @Quotient.inductionOn‚ÇÇ' _ _ _ _ _ s s'
  -- ‚ä¢ ‚àÄ (a‚ÇÅ a‚ÇÇ : List Œ±) {hs : Nodup (Quotient.mk'' a‚ÇÅ)} {hs' : Nodup (Quotient.mk ‚Ä¶
  intro l l'
  -- ‚ä¢ ‚àÄ {hs : Nodup (Quotient.mk'' l)} {hs' : Nodup (Quotient.mk'' l')}, formPerm  ‚Ä¶
  -- Porting note: was `simpa using formPerm_eq_formPerm_iff`
  simp_all
  -- ‚ä¢ ‚àÄ {hs : List.Nodup l} {hs' : List.Nodup l'}, List.formPerm l = List.formPerm ‚Ä¶
  intro hs hs'
  -- ‚ä¢ List.formPerm l = List.formPerm l' ‚Üî l ~r l' ‚à® List.length l ‚â§ 1 ‚àß List.leng ‚Ä¶
  constructor <;> intro h <;> simp_all only [formPerm_eq_formPerm_iff]
  -- ‚ä¢ List.formPerm l = List.formPerm l' ‚Üí l ~r l' ‚à® List.length l ‚â§ 1 ‚àß List.leng ‚Ä¶
                  -- ‚ä¢ l ~r l' ‚à® List.length l ‚â§ 1 ‚àß List.length l' ‚â§ 1
                  -- ‚ä¢ List.formPerm l = List.formPerm l'
                              -- üéâ no goals
                              -- üéâ no goals
#align cycle.form_perm_eq_form_perm_iff Cycle.formPerm_eq_formPerm_iff

end Cycle

namespace Equiv.Perm

section Fintype

variable [Fintype Œ±] [DecidableEq Œ±] (p : Equiv.Perm Œ±) (x : Œ±)

/-- `Equiv.Perm.toList (f : Perm Œ±) (x : Œ±)` generates the list `[x, f x, f (f x), ...]`
until looping. That means when `f x = x`, `toList f x = []`.
-/
def toList : List Œ± :=
  (List.range (cycleOf p x).support.card).map fun k => (p ^ k) x
#align equiv.perm.to_list Equiv.Perm.toList

@[simp]
theorem toList_one : toList (1 : Perm Œ±) x = [] := by simp [toList, cycleOf_one]
                                                      -- üéâ no goals
#align equiv.perm.to_list_one Equiv.Perm.toList_one

@[simp]
theorem toList_eq_nil_iff {p : Perm Œ±} {x} : toList p x = [] ‚Üî x ‚àâ p.support := by simp [toList]
                                                                                   -- üéâ no goals
#align equiv.perm.to_list_eq_nil_iff Equiv.Perm.toList_eq_nil_iff

@[simp]
theorem length_toList : length (toList p x) = (cycleOf p x).support.card := by simp [toList]
                                                                               -- üéâ no goals
#align equiv.perm.length_to_list Equiv.Perm.length_toList

theorem toList_ne_singleton (y : Œ±) : toList p x ‚â† [y] := by
  intro H
  -- ‚ä¢ False
  simpa [card_support_ne_one] using congr_arg length H
  -- üéâ no goals
#align equiv.perm.to_list_ne_singleton Equiv.Perm.toList_ne_singleton

theorem two_le_length_toList_iff_mem_support {p : Perm Œ±} {x : Œ±} :
    2 ‚â§ length (toList p x) ‚Üî x ‚àà p.support := by simp
                                                  -- üéâ no goals
#align equiv.perm.two_le_length_to_list_iff_mem_support Equiv.Perm.two_le_length_toList_iff_mem_support

theorem length_toList_pos_of_mem_support (h : x ‚àà p.support) : 0 < length (toList p x) :=
  zero_lt_two.trans_le (two_le_length_toList_iff_mem_support.mpr h)
#align equiv.perm.length_to_list_pos_of_mem_support Equiv.Perm.length_toList_pos_of_mem_support

theorem nthLe_toList (n : ‚Ñï) (hn : n < length (toList p x)) : (toList p x).nthLe n hn = (p ^ n) x :=
  by simp [toList]
     -- üéâ no goals
#align equiv.perm.nth_le_to_list Equiv.Perm.nthLe_toList

theorem toList_nthLe_zero (h : x ‚àà p.support) :
    (toList p x).nthLe 0 (length_toList_pos_of_mem_support _ _ h) = x := by simp [toList]
                                                                            -- üéâ no goals
#align equiv.perm.to_list_nth_le_zero Equiv.Perm.toList_nthLe_zero

variable {p} {x}

theorem mem_toList_iff {y : Œ±} : y ‚àà toList p x ‚Üî SameCycle p x y ‚àß x ‚àà p.support := by
  simp only [toList, mem_range, mem_map]
  -- ‚ä¢ (‚àÉ a, a < Finset.card (support (cycleOf p x)) ‚àß ‚Üë(p ^ a) x = y) ‚Üî SameCycle  ‚Ä¶
  constructor
  -- ‚ä¢ (‚àÉ a, a < Finset.card (support (cycleOf p x)) ‚àß ‚Üë(p ^ a) x = y) ‚Üí SameCycle  ‚Ä¶
  ¬∑ rintro ‚ü®n, hx, rfl‚ü©
    -- ‚ä¢ SameCycle p x (‚Üë(p ^ n) x) ‚àß x ‚àà support p
    refine' ‚ü®‚ü®n, rfl‚ü©, _‚ü©
    -- ‚ä¢ x ‚àà support p
    contrapose! hx
    -- ‚ä¢ Finset.card (support (cycleOf p x)) ‚â§ n
    rw [‚Üê support_cycleOf_eq_nil_iff] at hx
    -- ‚ä¢ Finset.card (support (cycleOf p x)) ‚â§ n
    simp [hx]
    -- üéâ no goals
  ¬∑ rintro ‚ü®h, hx‚ü©
    -- ‚ä¢ ‚àÉ a, a < Finset.card (support (cycleOf p x)) ‚àß ‚Üë(p ^ a) x = y
    simpa using h.exists_pow_eq_of_mem_support hx
    -- üéâ no goals
#align equiv.perm.mem_to_list_iff Equiv.Perm.mem_toList_iff

set_option linter.deprecated false in
theorem nodup_toList (p : Perm Œ±) (x : Œ±) : Nodup (toList p x) := by
  by_cases hx : p x = x
  -- ‚ä¢ Nodup (toList p x)
  ¬∑ rw [‚Üê not_mem_support, ‚Üê toList_eq_nil_iff] at hx
    -- ‚ä¢ Nodup (toList p x)
    simp [hx]
    -- üéâ no goals
  have hc : IsCycle (cycleOf p x) := isCycle_cycleOf p hx
  -- ‚ä¢ Nodup (toList p x)
  rw [nodup_iff_nthLe_inj]
  -- ‚ä¢ ‚àÄ (i j : ‚Ñï) (h‚ÇÅ : i < length (toList p x)) (h‚ÇÇ : j < length (toList p x)), n ‚Ä¶
  rintro n m hn hm
  -- ‚ä¢ nthLe (toList p x) n hn = nthLe (toList p x) m hm ‚Üí n = m
  rw [length_toList, ‚Üê hc.orderOf] at hm hn
  -- ‚ä¢ nthLe (toList p x) n hn‚úù = nthLe (toList p x) m hm‚úù ‚Üí n = m
  rw [‚Üê cycleOf_apply_self, ‚Üê Ne.def, ‚Üê mem_support] at hx
  -- ‚ä¢ nthLe (toList p x) n hn‚úù = nthLe (toList p x) m hm‚úù ‚Üí n = m
  rw [nthLe_toList, nthLe_toList, ‚Üê cycleOf_pow_apply_self p x n, ‚Üê
    cycleOf_pow_apply_self p x m]
  cases' n with n <;> cases' m with m
  -- ‚ä¢ ‚Üë(cycleOf p x ^ Nat.zero) x = ‚Üë(cycleOf p x ^ m) x ‚Üí Nat.zero = m
                      -- ‚ä¢ ‚Üë(cycleOf p x ^ Nat.zero) x = ‚Üë(cycleOf p x ^ Nat.zero) x ‚Üí Nat.zero = Nat.z ‚Ä¶
                      -- ‚ä¢ ‚Üë(cycleOf p x ^ Nat.succ n) x = ‚Üë(cycleOf p x ^ Nat.zero) x ‚Üí Nat.succ n = N ‚Ä¶
  ¬∑ simp
    -- üéâ no goals
  ¬∑ rw [‚Üê hc.support_pow_of_pos_of_lt_orderOf m.zero_lt_succ hm, mem_support,
      cycleOf_pow_apply_self] at hx
    simp [hx.symm]
    -- üéâ no goals
  ¬∑ rw [‚Üê hc.support_pow_of_pos_of_lt_orderOf n.zero_lt_succ hn, mem_support,
      cycleOf_pow_apply_self] at hx
    simp [hx]
    -- üéâ no goals
  intro h
  -- ‚ä¢ Nat.succ n = Nat.succ m
  have hn' : ¬¨orderOf (p.cycleOf x) ‚à£ n.succ := Nat.not_dvd_of_pos_of_lt n.zero_lt_succ hn
  -- ‚ä¢ Nat.succ n = Nat.succ m
  have hm' : ¬¨orderOf (p.cycleOf x) ‚à£ m.succ := Nat.not_dvd_of_pos_of_lt m.zero_lt_succ hm
  -- ‚ä¢ Nat.succ n = Nat.succ m
  rw [‚Üê hc.support_pow_eq_iff] at hn' hm'
  -- ‚ä¢ Nat.succ n = Nat.succ m
  rw [‚Üê Nat.mod_eq_of_lt hn, ‚Üê Nat.mod_eq_of_lt hm, ‚Üê pow_inj_mod]
  -- ‚ä¢ cycleOf p x ^ Nat.succ n = cycleOf p x ^ Nat.succ m
  refine' support_congr _ _
  -- ‚ä¢ support (cycleOf p x ^ Nat.succ n) ‚äÜ support (cycleOf p x ^ Nat.succ m)
  ¬∑ rw [hm', hn']
    -- üéâ no goals
  ¬∑ rw [hm']
    -- ‚ä¢ ‚àÄ (x_1 : Œ±), x_1 ‚àà support (cycleOf p x) ‚Üí ‚Üë(cycleOf p x ^ Nat.succ n) x_1 = ‚Ä¶
    intro y hy
    -- ‚ä¢ ‚Üë(cycleOf p x ^ Nat.succ n) y = ‚Üë(cycleOf p x ^ Nat.succ m) y
    obtain ‚ü®k, rfl‚ü© := hc.exists_pow_eq (mem_support.mp hx) (mem_support.mp hy)
    -- ‚ä¢ ‚Üë(cycleOf p x ^ Nat.succ n) (‚Üë(cycleOf p x ^ k) x) = ‚Üë(cycleOf p x ^ Nat.suc ‚Ä¶
    rw [‚Üê mul_apply, (Commute.pow_pow_self _ _ _).eq, mul_apply, h, ‚Üê mul_apply, ‚Üê mul_apply,
      (Commute.pow_pow_self _ _ _).eq]
#align equiv.perm.nodup_to_list Equiv.Perm.nodup_toList

set_option linter.deprecated false in
theorem next_toList_eq_apply (p : Perm Œ±) (x y : Œ±) (hy : y ‚àà toList p x) :
    next (toList p x) y hy = p y := by
  rw [mem_toList_iff] at hy
  -- ‚ä¢ next (toList p x) y hy‚úù = ‚Üëp y
  obtain ‚ü®k, hk, hk'‚ü© := hy.left.exists_pow_eq_of_mem_support hy.right
  -- ‚ä¢ next (toList p x) y hy‚úù = ‚Üëp y
  rw [‚Üê nthLe_toList p x k (by simpa using hk)] at hk'
  -- ‚ä¢ next (toList p x) y hy‚úù = ‚Üëp y
  simp_rw [‚Üê hk']
  -- ‚ä¢ next (toList p x) (nthLe (toList p x) k (_ : k < length (toList p x))) (_ :  ‚Ä¶
  rw [next_nthLe _ (nodup_toList _ _), nthLe_toList, nthLe_toList, ‚Üê mul_apply, ‚Üê pow_succ,
    length_toList, pow_apply_eq_pow_mod_orderOf_cycleOf_apply p (k + 1), IsCycle.orderOf]
  exact isCycle_cycleOf _ (mem_support.mp hy.right)
  -- üéâ no goals
#align equiv.perm.next_to_list_eq_apply Equiv.Perm.next_toList_eq_apply

set_option linter.deprecated false in
theorem toList_pow_apply_eq_rotate (p : Perm Œ±) (x : Œ±) (k : ‚Ñï) :
    p.toList ((p ^ k) x) = (p.toList x).rotate k := by
  apply ext_nthLe
  -- ‚ä¢ length (toList p (‚Üë(p ^ k) x)) = length (rotate (toList p x) k)
  ¬∑ simp only [length_toList, cycleOf_self_apply_pow, length_rotate]
    -- üéâ no goals
  ¬∑ intro n hn hn'
    -- ‚ä¢ nthLe (toList p (‚Üë(p ^ k) x)) n hn = nthLe (rotate (toList p x) k) n hn'
    rw [nthLe_toList, nthLe_rotate, nthLe_toList, length_toList,
      pow_mod_card_support_cycleOf_self_apply, pow_add, mul_apply]
#align equiv.perm.to_list_pow_apply_eq_rotate Equiv.Perm.toList_pow_apply_eq_rotate

theorem SameCycle.toList_isRotated {f : Perm Œ±} {x y : Œ±} (h : SameCycle f x y) :
    toList f x ~r toList f y := by
  by_cases hx : x ‚àà f.support
  -- ‚ä¢ toList f x ~r toList f y
  ¬∑ obtain ‚ü®_ | k, _, hy‚ü© := h.exists_pow_eq_of_mem_support hx
    -- ‚ä¢ toList f x ~r toList f y
    ¬∑ simp only [coe_one, id.def, pow_zero, Nat.zero_eq] at hy
      -- ‚ä¢ toList f x ~r toList f y
      -- Porting note: added `IsRotated.refl`
      simp [hy, IsRotated.refl]
      -- üéâ no goals
    use k.succ
    -- ‚ä¢ rotate (toList f x) (Nat.succ k) = toList f y
    rw [‚Üê toList_pow_apply_eq_rotate, hy]
    -- üéâ no goals
  ¬∑ rw [toList_eq_nil_iff.mpr hx, isRotated_nil_iff', eq_comm, toList_eq_nil_iff]
    -- ‚ä¢ ¬¨y ‚àà support f
    rwa [‚Üê h.mem_support_iff]
    -- üéâ no goals
#align equiv.perm.same_cycle.to_list_is_rotated Equiv.Perm.SameCycle.toList_isRotated

theorem pow_apply_mem_toList_iff_mem_support {n : ‚Ñï} : (p ^ n) x ‚àà p.toList x ‚Üî x ‚àà p.support := by
  rw [mem_toList_iff, and_iff_right_iff_imp]
  -- ‚ä¢ x ‚àà support p ‚Üí SameCycle p x (‚Üë(p ^ n) x)
  refine' fun _ => SameCycle.symm _
  -- ‚ä¢ SameCycle p (‚Üë(p ^ n) x) x
  rw [sameCycle_pow_left]
  -- üéâ no goals
#align equiv.perm.pow_apply_mem_to_list_iff_mem_support Equiv.Perm.pow_apply_mem_toList_iff_mem_support

theorem toList_formPerm_nil (x : Œ±) : toList (formPerm ([] : List Œ±)) x = [] := by simp
                                                                                   -- üéâ no goals
#align equiv.perm.to_list_form_perm_nil Equiv.Perm.toList_formPerm_nil

theorem toList_formPerm_singleton (x y : Œ±) : toList (formPerm [x]) y = [] := by simp
                                                                                 -- üéâ no goals
#align equiv.perm.to_list_form_perm_singleton Equiv.Perm.toList_formPerm_singleton

set_option linter.deprecated false in
theorem toList_formPerm_nontrivial (l : List Œ±) (hl : 2 ‚â§ l.length) (hn : Nodup l) :
    toList (formPerm l) (l.nthLe 0 (zero_lt_two.trans_le hl)) = l := by
  have hc : l.formPerm.IsCycle := List.isCycle_formPerm hn hl
  -- ‚ä¢ toList (formPerm l) (nthLe l 0 (_ : 0 < length l)) = l
  have hs : l.formPerm.support = l.toFinset := by
    refine' support_formPerm_of_nodup _ hn _
    rintro _ rfl
    simp [Nat.succ_le_succ_iff] at hl
  rw [toList, hc.cycleOf_eq (mem_support.mp _), hs, card_toFinset, dedup_eq_self.mpr hn]
  -- ‚ä¢ map (fun k => ‚Üë(formPerm l ^ k) (nthLe l 0 (_ : 0 < length l))) (range (leng ‚Ä¶
  ¬∑ refine' ext_get (by simp) fun k hk hk' => _
    -- ‚ä¢ List.get (map (fun k => ‚Üë(formPerm l ^ k) (nthLe l 0 (_ : 0 < length l))) (r ‚Ä¶
    simp [formPerm_pow_apply_nthLe _ hn, Nat.mod_eq_of_lt hk']
    -- ‚ä¢ nthLe l k (_ : k < length l) = List.get l { val := k, isLt := hk' }
    rw [nthLe_eq]
    -- üéâ no goals
  ¬∑ simpa [hs] using get_mem _ _ _
    -- üéâ no goals
#align equiv.perm.to_list_form_perm_nontrivial Equiv.Perm.toList_formPerm_nontrivial

theorem toList_formPerm_isRotated_self (l : List Œ±) (hl : 2 ‚â§ l.length) (hn : Nodup l) (x : Œ±)
    (hx : x ‚àà l) : toList (formPerm l) x ~r l := by
  obtain ‚ü®k, hk, rfl‚ü© := get_of_mem hx
  -- ‚ä¢ toList (formPerm l) (List.get l k) ~r l
  have hr : l ~r l.rotate k := ‚ü®k, rfl‚ü©
  -- ‚ä¢ toList (formPerm l) (List.get l k) ~r l
  rw [formPerm_eq_of_isRotated hn hr]
  -- ‚ä¢ toList (formPerm (rotate l ‚Üëk)) (List.get l k) ~r l
  rw [get_eq_get_rotate l k k]
  -- ‚ä¢ toList (formPerm (rotate l ‚Üëk)) (List.get (rotate l ‚Üëk) { val := (length l - ‚Ä¶
  simp only [Nat.mod_eq_of_lt k.2, tsub_add_cancel_of_le (le_of_lt k.2), Nat.mod_self]
  -- ‚ä¢ toList (formPerm (rotate l ‚Üëk)) (List.get (rotate l ‚Üëk) { val := 0, isLt :=  ‚Ä¶
  erw [toList_formPerm_nontrivial]
  ¬∑ simp
    -- üéâ no goals
  ¬∑ simpa using hl
    -- üéâ no goals
  ¬∑ simpa using hn
    -- üéâ no goals
#align equiv.perm.to_list_form_perm_is_rotated_self Equiv.Perm.toList_formPerm_isRotated_self

theorem formPerm_toList (f : Perm Œ±) (x : Œ±) : formPerm (toList f x) = f.cycleOf x := by
  by_cases hx : f x = x
  -- ‚ä¢ formPerm (toList f x) = cycleOf f x
  ¬∑ rw [(cycleOf_eq_one_iff f).mpr hx, toList_eq_nil_iff.mpr (not_mem_support.mpr hx),
      formPerm_nil]
  ext y
  -- ‚ä¢ ‚Üë(formPerm (toList f x)) y = ‚Üë(cycleOf f x) y
  by_cases hy : SameCycle f x y
  -- ‚ä¢ ‚Üë(formPerm (toList f x)) y = ‚Üë(cycleOf f x) y
  ¬∑ obtain ‚ü®k, _, rfl‚ü© := hy.exists_pow_eq_of_mem_support (mem_support.mpr hx)
    -- ‚ä¢ ‚Üë(formPerm (toList f x)) (‚Üë(f ^ k) x) = ‚Üë(cycleOf f x) (‚Üë(f ^ k) x)
    rw [cycleOf_apply_apply_pow_self, List.formPerm_apply_mem_eq_next (nodup_toList f x),
      next_toList_eq_apply, pow_succ, mul_apply]
    rw [mem_toList_iff]
    -- ‚ä¢ SameCycle f x (‚Üë(f ^ k) x) ‚àß x ‚àà support f
    exact ‚ü®‚ü®k, rfl‚ü©, mem_support.mpr hx‚ü©
    -- üéâ no goals
  ¬∑ rw [cycleOf_apply_of_not_sameCycle hy, formPerm_apply_of_not_mem]
    -- ‚ä¢ ¬¨y ‚àà toList f x
    simp [mem_toList_iff, hy]
    -- üéâ no goals
#align equiv.perm.form_perm_to_list Equiv.Perm.formPerm_toList

/-- Given a cyclic `f : Perm Œ±`, generate the `Cycle Œ±` in the order
of application of `f`. Implemented by finding an element `x : Œ±`
in the support of `f` in `Finset.univ`, and iterating on using
`Equiv.Perm.toList f x`.
-/
def toCycle (f : Perm Œ±) (hf : IsCycle f) : Cycle Œ± :=
  Multiset.recOn (Finset.univ : Finset Œ±).val (Quot.mk _ [])
    (fun x _ l => if f x = x then l else toList f x)
    (by
      intro x y _ s
      -- ‚ä¢ HEq (if ‚Üëf x = x then if ‚Üëf y = y then s else ‚Üë(toList f y) else ‚Üë(toList f  ‚Ä¶
      refine' heq_of_eq _
      -- ‚ä¢ (if ‚Üëf x = x then if ‚Üëf y = y then s else ‚Üë(toList f y) else ‚Üë(toList f x))  ‚Ä¶
      split_ifs with hx hy hy <;> try rfl
                                  -- üéâ no goals
                                  -- üéâ no goals
                                  -- üéâ no goals
                                  -- ‚ä¢ ‚Üë(toList f x) = ‚Üë(toList f y)
      ¬∑ have hc : SameCycle f x y := IsCycle.sameCycle hf hx hy
        -- ‚ä¢ ‚Üë(toList f x) = ‚Üë(toList f y)
        exact Quotient.sound' hc.toList_isRotated)
        -- üéâ no goals
#align equiv.perm.to_cycle Equiv.Perm.toCycle

theorem toCycle_eq_toList (f : Perm Œ±) (hf : IsCycle f) (x : Œ±) (hx : f x ‚â† x) :
    toCycle f hf = toList f x := by
  have key : (Finset.univ : Finset Œ±).val = x ::‚Çò Finset.univ.val.erase x := by simp
  -- ‚ä¢ toCycle f hf = ‚Üë(toList f x)
  rw [toCycle, key]
  -- ‚ä¢ Multiset.recOn (x ::‚Çò Multiset.erase Finset.univ.val x) (Quot.mk Setoid.r [] ‚Ä¶
  simp [hx]
  -- üéâ no goals
#align equiv.perm.to_cycle_eq_to_list Equiv.Perm.toCycle_eq_toList

theorem nodup_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nodup := by
  obtain ‚ü®x, hx, -‚ü© := id hf
  -- ‚ä¢ Cycle.Nodup (toCycle f hf)
  simpa [toCycle_eq_toList f hf x hx] using nodup_toList _ _
  -- üéâ no goals
#align equiv.perm.nodup_to_cycle Equiv.Perm.nodup_toCycle

theorem nontrivial_toCycle (f : Perm Œ±) (hf : IsCycle f) : (toCycle f hf).Nontrivial := by
  obtain ‚ü®x, hx, -‚ü© := id hf
  -- ‚ä¢ Cycle.Nontrivial (toCycle f hf)
  simp [toCycle_eq_toList f hf x hx, hx, Cycle.nontrivial_coe_nodup_iff (nodup_toList _ _)]
  -- üéâ no goals
#align equiv.perm.nontrivial_to_cycle Equiv.Perm.nontrivial_toCycle

/-- Any cyclic `f : Perm Œ±` is isomorphic to the nontrivial `Cycle Œ±`
that corresponds to repeated application of `f`.
The forward direction is implemented by `Equiv.Perm.toCycle`.
-/
def isoCycle : { f : Perm Œ± // IsCycle f } ‚âÉ { s : Cycle Œ± // s.Nodup ‚àß s.Nontrivial } where
  toFun f := ‚ü®toCycle (f : Perm Œ±) f.prop, nodup_toCycle f f.prop, nontrivial_toCycle _ f.prop‚ü©
  invFun s := ‚ü®(s : Cycle Œ±).formPerm s.prop.left, (s : Cycle Œ±).isCycle_formPerm _ s.prop.right‚ü©
  left_inv f := by
    obtain ‚ü®x, hx, -‚ü© := id f.prop
    -- ‚ä¢ (fun s => { val := Cycle.formPerm ‚Üës (_ : Cycle.Nodup ‚Üës), property := (_ :  ‚Ä¶
    simpa [toCycle_eq_toList (f : Perm Œ±) f.prop x hx, formPerm_toList, Subtype.ext_iff] using
      f.prop.cycleOf_eq hx
  right_inv s := by
    rcases s with ‚ü®‚ü®s‚ü©, hn, ht‚ü©
    -- ‚ä¢ (fun f => { val := toCycle ‚Üëf (_ : IsCycle ‚Üëf), property := (_ : Cycle.Nodup ‚Ä¶
    obtain ‚ü®x, -, -, hx, -‚ü© := id ht
    -- ‚ä¢ (fun f => { val := toCycle ‚Üëf (_ : IsCycle ‚Üëf), property := (_ : Cycle.Nodup ‚Ä¶
    have hl : 2 ‚â§ s.length := by simpa using Cycle.length_nontrivial ht
    -- ‚ä¢ (fun f => { val := toCycle ‚Üëf (_ : IsCycle ‚Üëf), property := (_ : Cycle.Nodup ‚Ä¶
    simp only [Cycle.mk_eq_coe, Cycle.nodup_coe_iff, Cycle.mem_coe_iff, Subtype.coe_mk,
      Cycle.formPerm_coe] at hn hx ‚ä¢
    apply Subtype.ext
    -- ‚ä¢ ‚Üë{ val := toCycle (formPerm s) (_ : IsCycle (formPerm s)), property := (_ :  ‚Ä¶
    dsimp
    -- ‚ä¢ toCycle (formPerm s) (_ : IsCycle ‚Üë{ val := formPerm s, property := (_ : IsC ‚Ä¶
    rw [toCycle_eq_toList _ _ x]
    -- ‚ä¢ ‚Üë(toList (formPerm s) x) = ‚Üës
    ¬∑ refine' Quotient.sound' _
      -- ‚ä¢ Setoid.r (toList (formPerm s) x) s
      exact toList_formPerm_isRotated_self _ hl hn _ hx
      -- üéâ no goals
    ¬∑ rw [‚Üê mem_support, support_formPerm_of_nodup _ hn]
      -- ‚ä¢ x ‚àà toFinset s
      ¬∑ simpa using hx
        -- üéâ no goals
      ¬∑ rintro _ rfl
        -- ‚ä¢ False
        simp [Nat.succ_le_succ_iff] at hl
        -- üéâ no goals
#align equiv.perm.iso_cycle Equiv.Perm.isoCycle

end Fintype

section Finite

variable [Finite Œ±] [DecidableEq Œ±]

theorem IsCycle.existsUnique_cycle {f : Perm Œ±} (hf : IsCycle f) :
    ‚àÉ! s : Cycle Œ±, ‚àÉ h : s.Nodup, s.formPerm h = f := by
  cases nonempty_fintype Œ±
  -- ‚ä¢ ‚àÉ! s, ‚àÉ h, Cycle.formPerm s h = f
  obtain ‚ü®x, hx, hy‚ü© := id hf
  -- ‚ä¢ ‚àÉ! s, ‚àÉ h, Cycle.formPerm s h = f
  refine' ‚ü®f.toList x, ‚ü®nodup_toList f x, _‚ü©, _‚ü©
  -- ‚ä¢ Cycle.formPerm ‚Üë(toList f x) (_ : Nodup (toList f x)) = f
  ¬∑ simp [formPerm_toList, hf.cycleOf_eq hx]
    -- üéâ no goals
  ¬∑ rintro ‚ü®l‚ü© ‚ü®hn, rfl‚ü©
    -- ‚ä¢ Quot.mk Setoid.r l = ‚Üë(toList (Cycle.formPerm (Quot.mk Setoid.r l) hn) x)
    simp only [Cycle.mk_eq_coe, Cycle.coe_eq_coe, Subtype.coe_mk, Cycle.formPerm_coe]
    -- ‚ä¢ l ~r toList (formPerm l) x
    refine' (toList_formPerm_isRotated_self _ _ hn _ _).symm
    -- ‚ä¢ 2 ‚â§ length l
    ¬∑ contrapose! hx
      -- ‚ä¢ ‚Üë(Cycle.formPerm (Quot.mk Setoid.r l) hn) x = x
      suffices formPerm l = 1 by simp [this]
      -- ‚ä¢ formPerm l = 1
      rw [formPerm_eq_one_iff _ hn]
      -- ‚ä¢ length l ‚â§ 1
      exact Nat.le_of_lt_succ hx
      -- üéâ no goals
    ¬∑ rw [‚Üê mem_toFinset]
      -- ‚ä¢ x ‚àà toFinset l
      refine' support_formPerm_le l _
      -- ‚ä¢ x ‚àà support (formPerm l)
      simpa using hx
      -- üéâ no goals
#align equiv.perm.is_cycle.exists_unique_cycle Equiv.Perm.IsCycle.existsUnique_cycle

theorem IsCycle.existsUnique_cycle_subtype {f : Perm Œ±} (hf : IsCycle f) :
    ‚àÉ! s : { s : Cycle Œ± // s.Nodup }, (s : Cycle Œ±).formPerm s.prop = f := by
  obtain ‚ü®s, ‚ü®hs, rfl‚ü©, hs'‚ü© := hf.existsUnique_cycle
  -- ‚ä¢ ‚àÉ! s_1, Cycle.formPerm ‚Üës_1 (_ : Cycle.Nodup ‚Üës_1) = Cycle.formPerm s hs
  refine' ‚ü®‚ü®s, hs‚ü©, rfl, _‚ü©
  -- ‚ä¢ ‚àÄ (y : { s // Cycle.Nodup s }), (fun s_1 => Cycle.formPerm ‚Üës_1 (_ : Cycle.N ‚Ä¶
  rintro ‚ü®t, ht‚ü© ht'
  -- ‚ä¢ { val := t, property := ht } = { val := s, property := hs }
  simpa using hs' _ ‚ü®ht, ht'‚ü©
  -- üéâ no goals
#align equiv.perm.is_cycle.exists_unique_cycle_subtype Equiv.Perm.IsCycle.existsUnique_cycle_subtype

theorem IsCycle.existsUnique_cycle_nontrivial_subtype {f : Perm Œ±} (hf : IsCycle f) :
    ‚àÉ! s : { s : Cycle Œ± // s.Nodup ‚àß s.Nontrivial }, (s : Cycle Œ±).formPerm s.prop.left = f := by
  obtain ‚ü®‚ü®s, hn‚ü©, hs, hs'‚ü© := hf.existsUnique_cycle_subtype
  -- ‚ä¢ ‚àÉ! s, Cycle.formPerm ‚Üës (_ : Cycle.Nodup ‚Üës) = f
  refine' ‚ü®‚ü®s, hn, _‚ü©, _, _‚ü©
  ¬∑ rw [hn.nontrivial_iff]
    -- ‚ä¢ ¬¨Cycle.Subsingleton s
    subst f
    -- ‚ä¢ ¬¨Cycle.Subsingleton s
    intro H
    -- ‚ä¢ False
    refine' hf.ne_one _
    -- ‚ä¢ Cycle.formPerm ‚Üë{ val := s, property := hn } (_ : Cycle.Nodup ‚Üë{ val := s, p ‚Ä¶
    simpa using Cycle.formPerm_subsingleton _ H
    -- üéâ no goals
  ¬∑ simpa using hs
    -- üéâ no goals
  ¬∑ rintro ‚ü®t, ht, ht'‚ü© ht''
    -- ‚ä¢ { val := t, property := (_ : Cycle.Nodup t ‚àß Cycle.Nontrivial t) } = { val : ‚Ä¶
    simpa using hs' ‚ü®t, ht‚ü© ht''
    -- üéâ no goals
#align equiv.perm.is_cycle.exists_unique_cycle_nontrivial_subtype Equiv.Perm.IsCycle.existsUnique_cycle_nontrivial_subtype

end Finite

variable [Fintype Œ±] [DecidableEq Œ±]

/-- Any cyclic `f : Perm Œ±` is isomorphic to the nontrivial `Cycle Œ±`
that corresponds to repeated application of `f`.
The forward direction is implemented by finding this `Cycle Œ±` using `Fintype.choose`.
-/
def isoCycle' : { f : Perm Œ± // IsCycle f } ‚âÉ { s : Cycle Œ± // s.Nodup ‚àß s.Nontrivial } :=
  let f : { s : Cycle Œ± // s.Nodup ‚àß s.Nontrivial } ‚Üí { f : Perm Œ± // IsCycle f } :=
    fun s => ‚ü®(s : Cycle Œ±).formPerm s.prop.left, (s : Cycle Œ±).isCycle_formPerm _ s.prop.right‚ü©
  { toFun := Fintype.bijInv (show Function.Bijective f by
      rw [Function.bijective_iff_existsUnique]
      -- ‚ä¢ ‚àÄ (b : { f // IsCycle f }), ‚àÉ! a, f a = b
      rintro ‚ü®f, hf‚ü©
      -- ‚ä¢ ‚àÉ! a, f‚úù a = { val := f, property := hf }
      simp only [Subtype.ext_iff]
      -- ‚ä¢ ‚àÉ! a, Cycle.formPerm ‚Üëa (_ : Cycle.Nodup ‚Üëa) = f
      exact hf.existsUnique_cycle_nontrivial_subtype)
      -- üéâ no goals
    invFun := f
    left_inv := Fintype.rightInverse_bijInv _
    right_inv := Fintype.leftInverse_bijInv _ }
#align equiv.perm.iso_cycle' Equiv.Perm.isoCycle'

notation3 "c["(l", "* => foldr (h t => List.cons h t) List.nil)"]" =>
  Cycle.formPerm (Cycle.ofList l) (Iff.mpr Cycle.nodup_coe_iff _)

unsafe instance repr_perm [Repr Œ±] : Repr (Perm Œ±) :=
  ‚ü®fun f _ => repr (Multiset.pmap (fun (g : Perm Œ±) (hg : g.IsCycle) => isoCycle ‚ü®g, hg‚ü©)
    (Perm.cycleFactorsFinset f).val -- toCycle is faster?
    fun _ hg => (mem_cycleFactorsFinset_iff.mp (Finset.mem_def.mpr hg)).left)‚ü©
#align equiv.perm.repr_perm Equiv.Perm.repr_perm

end Equiv.Perm
