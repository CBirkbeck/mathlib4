/-
Copyright (c) 2022 Thomas Browning. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Thomas Browning
-/
import Mathlib.GroupTheory.Abelianization
import Mathlib.GroupTheory.Exponent
import Mathlib.GroupTheory.Transfer

#align_import group_theory.schreier from "leanprover-community/mathlib"@"8350c34a64b9bc3fc64335df8006bffcadc7baa6"

/-!
# Schreier's Lemma

In this file we prove Schreier's lemma.

## Main results

- `closure_mul_image_eq` : **Schreier's Lemma**: If `R : Set G` is a right_transversal
  of `H : Subgroup G` with `1 ‚àà R`, and if `G` is generated by `S : Set G`,
  then `H` is generated by the `Set` `(R * S).image (fun g ‚Ü¶ g * (toFun hR g)‚Åª¬π)`.
- `fg_of_index_ne_zero` : **Schreier's Lemma**: A finite index subgroup of a finitely generated
  group is finitely generated.
- `card_commutator_le_of_finite_commutatorSet`: A theorem of Schur: The size of the commutator
  subgroup is bounded in terms of the number of commutators.
-/


open scoped Pointwise

namespace Subgroup

open MemRightTransversals

variable {G : Type*} [Group G] {H : Subgroup G} {R S : Set G}

theorem closure_mul_image_mul_eq_top
    (hR : R ‚àà rightTransversals (H : Set G)) (hR1 : (1 : G) ‚àà R) (hS : closure S = ‚ä§) :
    (closure ((R * S).image fun g => g * (toFun hR g : G)‚Åª¬π)) * R = ‚ä§ := by
  let f : G ‚Üí R := fun g => toFun hR g
  -- ‚ä¢ ‚Üë(closure ((fun g => g * (‚Üë(toFun hR g))‚Åª¬π) '' (R * S))) * R = ‚ä§
  let U : Set G := (R * S).image fun g => g * (f g : G)‚Åª¬π
  -- ‚ä¢ ‚Üë(closure ((fun g => g * (‚Üë(toFun hR g))‚Åª¬π) '' (R * S))) * R = ‚ä§
  change (closure U : Set G) * R = ‚ä§
  -- ‚ä¢ ‚Üë(closure U) * R = ‚ä§
  refine' top_le_iff.mp fun g _ => _
  -- ‚ä¢ g ‚àà ‚Üë(closure U) * R
  apply closure_induction_right (eq_top_iff.mp hS (mem_top g))
  ¬∑ exact ‚ü®1, 1, (closure U).one_mem, hR1, one_mul 1‚ü©
    -- üéâ no goals
  ¬∑ rintro - s hs ‚ü®u, r, hu, hr, rfl‚ü©
    -- ‚ä¢ (fun x x_1 => x * x_1) u r * s ‚àà ‚Üë(closure U) * R
    rw [show u * r * s = u * (r * s * (f (r * s) : G)‚Åª¬π) * f (r * s) by group]
    -- ‚ä¢ u * (r * s * (‚Üë(f (r * s)))‚Åª¬π) * ‚Üë(f (r * s)) ‚àà ‚Üë(closure U) * R
    refine' Set.mul_mem_mul ((closure U).mul_mem hu _) (f (r * s)).coe_prop
    -- ‚ä¢ r * s * (‚Üë(f (r * s)))‚Åª¬π ‚àà closure U
    exact subset_closure ‚ü®r * s, Set.mul_mem_mul hr hs, rfl‚ü©
    -- üéâ no goals
  ¬∑ rintro - s hs ‚ü®u, r, hu, hr, rfl‚ü©
    -- ‚ä¢ (fun x x_1 => x * x_1) u r * s‚Åª¬π ‚àà ‚Üë(closure U) * R
    rw [show u * r * s‚Åª¬π = u * (f (r * s‚Åª¬π) * s * r‚Åª¬π)‚Åª¬π * f (r * s‚Åª¬π) by group]
    -- ‚ä¢ u * (‚Üë(f (r * s‚Åª¬π)) * s * r‚Åª¬π)‚Åª¬π * ‚Üë(f (r * s‚Åª¬π)) ‚àà ‚Üë(closure U) * R
    refine' Set.mul_mem_mul ((closure U).mul_mem hu ((closure U).inv_mem _)) (f (r * s‚Åª¬π)).2
    -- ‚ä¢ ‚Üë(f (r * s‚Åª¬π)) * s * r‚Åª¬π ‚àà closure U
    refine' subset_closure ‚ü®f (r * s‚Åª¬π) * s, Set.mul_mem_mul (f (r * s‚Åª¬π)).2 hs, _‚ü©
    -- ‚ä¢ (fun g => g * (‚Üë(f g))‚Åª¬π) (‚Üë(f (r * s‚Åª¬π)) * s) = ‚Üë(f (r * s‚Åª¬π)) * s * r‚Åª¬π
    rw [mul_right_inj, inv_inj, ‚Üê Subtype.coe_mk r hr, ‚Üê Subtype.ext_iff, Subtype.coe_mk]
    -- ‚ä¢ f (‚Üë(toFun hR (‚Üë{ val := r, property := hr } * s‚Åª¬π)) * s) = { val := r, prop ‚Ä¶
    apply (mem_rightTransversals_iff_existsUnique_mul_inv_mem.mp hR (f (r * s‚Åª¬π) * s)).unique
      (mul_inv_toFun_mem hR (f (r * s‚Åª¬π) * s))
    rw [mul_assoc, ‚Üê inv_inv s, ‚Üê mul_inv_rev, inv_inv]
    -- ‚ä¢ ‚Üë(f (r * s‚Åª¬π)) * (‚Üë{ val := r, property := hr } * s‚Åª¬π)‚Åª¬π ‚àà ‚ÜëH
    exact toFun_mul_inv_mem hR (r * s‚Åª¬π)
    -- üéâ no goals
#align subgroup.closure_mul_image_mul_eq_top Subgroup.closure_mul_image_mul_eq_top

/-- **Schreier's Lemma**: If `R : Set G` is a `rightTransversal of` `H : Subgroup G`
  with `1 ‚àà R`, and if `G` is generated by `S : Set G`, then `H` is generated by the `Set`
  `(R * S).image (fun g ‚Ü¶ g * (toFun hR g)‚Åª¬π)`. -/
theorem closure_mul_image_eq (hR : R ‚àà rightTransversals (H : Set G)) (hR1 : (1 : G) ‚àà R)
    (hS : closure S = ‚ä§) : closure ((R * S).image fun g => g * (toFun hR g : G)‚Åª¬π) = H := by
  have hU : closure ((R * S).image fun g => g * (toFun hR g : G)‚Åª¬π) ‚â§ H := by
    rw [closure_le]
    rintro - ‚ü®g, -, rfl‚ü©
    exact mul_inv_toFun_mem hR g
  refine' le_antisymm hU fun h hh => _
  -- ‚ä¢ h ‚àà closure ((fun g => g * (‚Üë(toFun hR g))‚Åª¬π) '' (R * S))
  obtain ‚ü®g, r, hg, hr, rfl‚ü© :=
    show h ‚àà _ from eq_top_iff.mp (closure_mul_image_mul_eq_top hR hR1 hS) (mem_top h)
  suffices (‚ü®r, hr‚ü© : R) = (‚ü®1, hR1‚ü© : R) by
    simpa only [show r = 1 from Subtype.ext_iff.mp this, mul_one]
  apply (mem_rightTransversals_iff_existsUnique_mul_inv_mem.mp hR r).unique
  -- ‚ä¢ r * (‚Üë{ val := r, property := hr })‚Åª¬π ‚àà ‚ÜëH
  ¬∑ rw [Subtype.coe_mk, mul_inv_self]
    -- ‚ä¢ 1 ‚àà ‚ÜëH
    exact H.one_mem
    -- üéâ no goals
  ¬∑ rw [Subtype.coe_mk, inv_one, mul_one]
    -- ‚ä¢ r ‚àà ‚ÜëH
    exact (H.mul_mem_cancel_left (hU hg)).mp hh
    -- üéâ no goals
#align subgroup.closure_mul_image_eq Subgroup.closure_mul_image_eq

/-- **Schreier's Lemma**: If `R : Set G` is a `rightTransversal` of `H : Subgroup G`
  with `1 ‚àà R`, and if `G` is generated by `S : Set G`, then `H` is generated by the `Set`
  `(R * S).image (fun g ‚Ü¶ g * (toFun hR g)‚Åª¬π)`. -/
theorem closure_mul_image_eq_top (hR : R ‚àà rightTransversals (H : Set G)) (hR1 : (1 : G) ‚àà R)
    (hS : closure S = ‚ä§) : closure ((R * S).image fun g =>
      ‚ü®g * (toFun hR g : G)‚Åª¬π, mul_inv_toFun_mem hR g‚ü© : Set H) = ‚ä§ := by
  rw [eq_top_iff, ‚Üê map_subtype_le_map_subtype, MonoidHom.map_closure, Set.image_image]
  -- ‚ä¢ map (Subgroup.subtype H) ‚ä§ ‚â§ closure ((fun x => ‚Üë(Subgroup.subtype H) { val  ‚Ä¶
  exact (map_subtype_le ‚ä§).trans (ge_of_eq (closure_mul_image_eq hR hR1 hS))
  -- üéâ no goals
#align subgroup.closure_mul_image_eq_top Subgroup.closure_mul_image_eq_top

/-- **Schreier's Lemma**: If `R : Finset G` is a `rightTransversal` of `H : Subgroup G`
  with `1 ‚àà R`, and if `G` is generated by `S : Finset G`, then `H` is generated by the `Finset`
  `(R * S).image (fun g ‚Ü¶ g * (toFun hR g)‚Åª¬π)`. -/
theorem closure_mul_image_eq_top' [DecidableEq G] {R S : Finset G}
    (hR : (R : Set G) ‚àà rightTransversals (H : Set G)) (hR1 : (1 : G) ‚àà R)
    (hS : closure (S : Set G) = ‚ä§) :
    closure (((R * S).image fun g => ‚ü®_, mul_inv_toFun_mem hR g‚ü© : Finset H) : Set H) = ‚ä§ := by
  rw [Finset.coe_image, Finset.coe_mul]
  -- ‚ä¢ closure ((fun g => { val := g * (‚Üë(toFun hR g))‚Åª¬π, property := (_ : g * (‚Üë(t ‚Ä¶
  exact closure_mul_image_eq_top hR hR1 hS
  -- üéâ no goals
#align subgroup.closure_mul_image_eq_top' Subgroup.closure_mul_image_eq_top'

variable (H)

theorem exists_finset_card_le_mul [FiniteIndex H] {S : Finset G} (hS : closure (S : Set G) = ‚ä§) :
    ‚àÉ T : Finset H, T.card ‚â§ H.index * S.card ‚àß closure (T : Set H) = ‚ä§ := by
  letI := H.fintypeQuotientOfFiniteIndex
  -- ‚ä¢ ‚àÉ T, Finset.card T ‚â§ index H * Finset.card S ‚àß closure ‚ÜëT = ‚ä§
  haveI : DecidableEq G := Classical.decEq G
  -- ‚ä¢ ‚àÉ T, Finset.card T ‚â§ index H * Finset.card S ‚àß closure ‚ÜëT = ‚ä§
  obtain ‚ü®R‚ÇÄ, hR : R‚ÇÄ ‚àà rightTransversals (H : Set G), hR1‚ü© := exists_right_transversal (1 : G)
  -- ‚ä¢ ‚àÉ T, Finset.card T ‚â§ index H * Finset.card S ‚àß closure ‚ÜëT = ‚ä§
  haveI : Fintype R‚ÇÄ := Fintype.ofEquiv _ (toEquiv hR)
  -- ‚ä¢ ‚àÉ T, Finset.card T ‚â§ index H * Finset.card S ‚àß closure ‚ÜëT = ‚ä§
  let R : Finset G := Set.toFinset R‚ÇÄ
  -- ‚ä¢ ‚àÉ T, Finset.card T ‚â§ index H * Finset.card S ‚àß closure ‚ÜëT = ‚ä§
  replace hR : (R : Set G) ‚àà rightTransversals (H : Set G) := by rwa [Set.coe_toFinset]
  -- ‚ä¢ ‚àÉ T, Finset.card T ‚â§ index H * Finset.card S ‚àß closure ‚ÜëT = ‚ä§
  replace hR1 : (1 : G) ‚àà R := by rwa [Set.mem_toFinset]
  -- ‚ä¢ ‚àÉ T, Finset.card T ‚â§ index H * Finset.card S ‚àß closure ‚ÜëT = ‚ä§
  refine' ‚ü®_, _, closure_mul_image_eq_top' hR hR1 hS‚ü©
  -- ‚ä¢ Finset.card (Finset.image (fun g => { val := g * (‚Üë(toFun hR g))‚Åª¬π, property ‚Ä¶
  calc
    _ ‚â§ (R * S).card := Finset.card_image_le
    _ ‚â§ (R √óÀ¢ S).card := Finset.card_image_le
    _ = R.card * S.card := (R.card_product S)
    _ = H.index * S.card := congr_arg (¬∑ * S.card) ?_
  calc
    R.card = Fintype.card R := (Fintype.card_coe R).symm
    _ = _ := (Fintype.card_congr (toEquiv hR)).symm
    _ = Fintype.card (G ‚ß∏ H) := (QuotientGroup.card_quotient_rightRel H)
    _ = H.index := H.index_eq_card.symm
#align subgroup.exists_finset_card_le_mul Subgroup.exists_finset_card_le_mul

/-- **Schreier's Lemma**: A finite index subgroup of a finitely generated
  group is finitely generated. -/
instance fg_of_index_ne_zero [hG : Group.FG G] [FiniteIndex H] : Group.FG H := by
  obtain ‚ü®S, hS‚ü© := hG.1
  -- ‚ä¢ Group.FG { x // x ‚àà H }
  obtain ‚ü®T, -, hT‚ü© := exists_finset_card_le_mul H hS
  -- ‚ä¢ Group.FG { x // x ‚àà H }
  exact ‚ü®‚ü®T, hT‚ü©‚ü©
  -- üéâ no goals
#align subgroup.fg_of_index_ne_zero Subgroup.fg_of_index_ne_zero

theorem rank_le_index_mul_rank [hG : Group.FG G] [FiniteIndex H] :
    Group.rank H ‚â§ H.index * Group.rank G := by
  haveI := H.fg_of_index_ne_zero
  -- ‚ä¢ Group.rank { x // x ‚àà H } ‚â§ index H * Group.rank G
  obtain ‚ü®S, hS‚ÇÄ, hS‚ü© := Group.rank_spec G
  -- ‚ä¢ Group.rank { x // x ‚àà H } ‚â§ index H * Group.rank G
  obtain ‚ü®T, hT‚ÇÄ, hT‚ü© := exists_finset_card_le_mul H hS
  -- ‚ä¢ Group.rank { x // x ‚àà H } ‚â§ index H * Group.rank G
  calc
    Group.rank H ‚â§ T.card := Group.rank_le H hT
    _ ‚â§ H.index * S.card := hT‚ÇÄ
    _ = H.index * Group.rank G := congr_arg ((¬∑ * ¬∑) H.index) hS‚ÇÄ
#align subgroup.rank_le_index_mul_rank Subgroup.rank_le_index_mul_rank

variable (G)

/-- If `G` has `n` commutators `[g‚ÇÅ, g‚ÇÇ]`, then `|G'| ‚à£ [G : Z(G)] ^ ([G : Z(G)] * n + 1)`,
where `G'` denotes the commutator of `G`. -/
theorem card_commutator_dvd_index_center_pow [Finite (commutatorSet G)] :
    Nat.card (_root_.commutator G) ‚à£
      (center G).index ^ ((center G).index * Nat.card (commutatorSet G) + 1) := by
  -- First handle the case when `Z(G)` has infinite index and `[G : Z(G)]` is defined to be `0`
  by_cases hG : (center G).index = 0
  -- ‚ä¢ Nat.card { x // x ‚àà _root_.commutator G } ‚à£ index (center G) ^ (index (cente ‚Ä¶
  ¬∑ simp_rw [hG, zero_mul, zero_add, pow_one, dvd_zero]
    -- üéâ no goals
  haveI : FiniteIndex (center G) := ‚ü®hG‚ü©
  -- ‚ä¢ Nat.card { x // x ‚àà _root_.commutator G } ‚à£ index (center G) ^ (index (cente ‚Ä¶
  -- Rewrite as `|Z(G) ‚à© G'| * [G' : Z(G) ‚à© G'] ‚à£ [G : Z(G)] ^ ([G : Z(G)] * n) * [G : Z(G)]`
  rw [‚Üê ((center G).subgroupOf (_root_.commutator G)).card_mul_index, pow_succ']
  -- ‚ä¢ Nat.card { x // x ‚àà subgroupOf (center G) (_root_.commutator G) } * index (s ‚Ä¶
  -- We have `h1 : [G' : Z(G) ‚à© G'] ‚à£ [G : Z(G)]`
  have h1 := relindex_dvd_index_of_normal (center G) (_root_.commutator G)
  -- ‚ä¢ Nat.card { x // x ‚àà subgroupOf (center G) (_root_.commutator G) } * index (s ‚Ä¶
  -- So we can reduce to proving `|Z(G) ‚à© G'| ‚à£ [G : Z(G)] ^ ([G : Z(G)] * n)`
  refine' mul_dvd_mul _ h1
  -- ‚ä¢ Nat.card { x // x ‚àà subgroupOf (center G) (_root_.commutator G) } ‚à£ index (c ‚Ä¶
  -- We know that `[G' : Z(G) ‚à© G'] < ‚àû` by `h1` and `hG`
  haveI : FiniteIndex ((center G).subgroupOf (_root_.commutator G)) :=
    ‚ü®ne_zero_of_dvd_ne_zero hG h1‚ü©
  -- We have `h2 : rank (Z(G) ‚à© G') ‚â§ [G' : Z(G) ‚à© G'] * rank G'` by Schreier's lemma
  have h2 := rank_le_index_mul_rank ((center G).subgroupOf (_root_.commutator G))
  -- ‚ä¢ Nat.card { x // x ‚àà subgroupOf (center G) (_root_.commutator G) } ‚à£ index (c ‚Ä¶
  -- We have `h3 : [G' : Z(G) ‚à© G'] * rank G' ‚â§ [G : Z(G)] * n` by `h1` and `rank G' ‚â§ n`
  have h3 := Nat.mul_le_mul (Nat.le_of_dvd (Nat.pos_of_ne_zero hG) h1) (rank_commutator_le_card G)
  -- ‚ä¢ Nat.card { x // x ‚àà subgroupOf (center G) (_root_.commutator G) } ‚à£ index (c ‚Ä¶
  -- So we can reduce to proving `|Z(G) ‚à© G'| ‚à£ [G : Z(G)] ^ rank (Z(G) ‚à© G')`
  refine' dvd_trans _ (pow_dvd_pow (center G).index (h2.trans h3))
  -- ‚ä¢ Nat.card { x // x ‚àà subgroupOf (center G) (_root_.commutator G) } ‚à£ index (c ‚Ä¶
  -- `Z(G) ‚à© G'` is abelian, so it enough to prove that `g ^ [G : Z(G)] = 1` for `g ‚àà Z(G) ‚à© G'`
  apply card_dvd_exponent_pow_rank'
  -- ‚ä¢ ‚àÄ (g : { x // x ‚àà subgroupOf (center G) (_root_.commutator G) }), g ^ index  ‚Ä¶
  intro g
  -- ‚ä¢ g ^ index (center G) = 1
  -- `Z(G)` is abelian, so `g ‚àà Z(G) ‚à© G' ‚â§ G' ‚â§ ker (transfer : G ‚Üí Z(G))`
  have := Abelianization.commutator_subset_ker (MonoidHom.transferCenterPow G) g.1.2
  -- ‚ä¢ g ^ index (center G) = 1
  -- `transfer g` is defeq to `g ^ [G : Z(G)]`, so we are done
  simpa only [MonoidHom.mem_ker, Subtype.ext_iff] using this
  -- üéâ no goals
#align subgroup.card_commutator_dvd_index_center_pow Subgroup.card_commutator_dvd_index_center_pow

/-- A bound for the size of the commutator subgroup in terms of the number of commutators. -/
def cardCommutatorBound (n : ‚Ñï) :=
  (n ^ (2 * n)) ^ (n ^ (2 * n + 1) + 1)
#align subgroup.card_commutator_bound Subgroup.cardCommutatorBound

/-- A theorem of Schur: The size of the commutator subgroup is bounded in terms of the number of
  commutators. -/
theorem card_commutator_le_of_finite_commutatorSet [Finite (commutatorSet G)] :
    Nat.card (_root_.commutator G) ‚â§ cardCommutatorBound (Nat.card (commutatorSet G)) := by
  have h1 := index_center_le_pow (closureCommutatorRepresentatives G)
  -- ‚ä¢ Nat.card { x // x ‚àà _root_.commutator G } ‚â§ cardCommutatorBound (Nat.card ‚Üë( ‚Ä¶
  have h2 := card_commutator_dvd_index_center_pow (closureCommutatorRepresentatives G)
  -- ‚ä¢ Nat.card { x // x ‚àà _root_.commutator G } ‚â§ cardCommutatorBound (Nat.card ‚Üë( ‚Ä¶
  rw [card_commutatorSet_closureCommutatorRepresentatives] at h1 h2
  -- ‚ä¢ Nat.card { x // x ‚àà _root_.commutator G } ‚â§ cardCommutatorBound (Nat.card ‚Üë( ‚Ä¶
  rw [card_commutator_closureCommutatorRepresentatives] at h2
  -- ‚ä¢ Nat.card { x // x ‚àà _root_.commutator G } ‚â§ cardCommutatorBound (Nat.card ‚Üë( ‚Ä¶
  replace h1 :=
    h1.trans
      (Nat.pow_le_pow_of_le_right Finite.card_pos (rank_closureCommutatorRepresentatives_le G))
  replace h2 := h2.trans (pow_dvd_pow _ (add_le_add_right (mul_le_mul_right' h1 _) 1))
  -- ‚ä¢ Nat.card { x // x ‚àà _root_.commutator G } ‚â§ cardCommutatorBound (Nat.card ‚Üë( ‚Ä¶
  rw [‚Üê pow_succ'] at h2
  -- ‚ä¢ Nat.card { x // x ‚àà _root_.commutator G } ‚â§ cardCommutatorBound (Nat.card ‚Üë( ‚Ä¶
  refine' (Nat.le_of_dvd _ h2).trans (Nat.pow_le_pow_of_le_left h1 _)
  -- ‚ä¢ 0 < index (center { x // x ‚àà closureCommutatorRepresentatives G }) ^ (Nat.ca ‚Ä¶
  exact pow_pos (Nat.pos_of_ne_zero FiniteIndex.finiteIndex) _
  -- üéâ no goals
#align subgroup.card_commutator_le_of_finite_commutator_set
  Subgroup.card_commutator_le_of_finite_commutatorSet

/-- A theorem of Schur: A group with finitely many commutators has finite commutator subgroup. -/
instance [Finite (commutatorSet G)] : Finite (_root_.commutator G) := by
  have h2 := card_commutator_dvd_index_center_pow (closureCommutatorRepresentatives G)
  -- ‚ä¢ Finite { x // x ‚àà _root_.commutator G }
  refine' Nat.finite_of_card_ne_zero fun h => _
  -- ‚ä¢ False
  rw [card_commutator_closureCommutatorRepresentatives, h, zero_dvd_iff] at h2
  -- ‚ä¢ False
  exact FiniteIndex.finiteIndex (pow_eq_zero h2)
  -- üéâ no goals

end Subgroup
