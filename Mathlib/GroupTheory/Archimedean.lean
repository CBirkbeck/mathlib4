/-
Copyright (c) 2020 Heather Macbeth, Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Heather Macbeth, Patrick Massot
-/
import Mathlib.Algebra.Group.Subgroup.Order
import Mathlib.Algebra.Group.Subgroup.Pointwise
import Mathlib.Algebra.Order.Archimedean.Basic
import Mathlib.Algebra.Order.Hom.Monoid

/-!
# Archimedean groups

This file proves a few facts about ordered groups which satisfy the `Archimedean` property, that is:
`class Archimedean (α) [OrderedAddCommMonoid α] : Prop :=`
`(arch : ∀ (x : α) {y}, 0 < y → ∃ n : ℕ, x ≤ n • y)`

They are placed here in a separate file (rather than incorporated as a continuation of
`Algebra.Order.Archimedean`) because they rely on some imports from `GroupTheory` -- bundled
subgroups in particular.

The main result is `AddSubgroup.cyclic_of_min`:  a subgroup of a decidable archimedean abelian
group is cyclic, if its set of positive elements has a minimal element.

This result is used in this file to deduce `Int.subgroup_cyclic`, proving that every subgroup of `ℤ`
is cyclic.  (There are several other methods one could use to prove this fact, including more purely
algebraic methods, but none seem to exist in mathlib as of writing.  The closest is
`Subgroup.is_cyclic`, but that has not been transferred to `AddSubgroup`.)

The result is also used in `Topology.Instances.Real` as an ingredient in the classification of
subgroups of `ℝ`.
-/

open Set

@[to_additive (attr := simp)]
lemma Subgroup.preimage_mabs {G : Type*} [LinearOrderedCommGroup G] (H : Subgroup G) :
    (|·|ₘ) ⁻¹' H = (H : Set G) := by
  ext x
  rcases mabs_choice x with hx|hx <;>
  simp [hx]

@[to_additive (attr := simp)]
lemma Subgroup.closure_image_mabs {G : Type*} [LinearOrderedCommGroup G] (s : Set G) :
    closure ((|·|ₘ) '' s) = closure s := by
  ext
  simp [mem_closure]

@[to_additive (attr := simp)]
lemma Subgroup.closure_singleton_mabs {G : Type*} [LinearOrderedCommGroup G] (x : G) :
    closure {|x|ₘ} = closure {x} := by
  simpa using closure_image_mabs {x}

-- no earlier file imports the necessary requirements for the next two

/-- The subgroup generated by an element of a group equals the set of
integer powers of the element, such that each power is a unique element.
This is the stronger version of `Subgroup.mem_closure_singleton`. -/
@[to_additive "The additive subgroup generated by an element of an additive group equals the set of
integer multiples of the element, such that each multiple is a unique element.
This is the stronger version of `AddSubgroup.mem_closure_singleton`."]
lemma Subgroup.mem_closure_singleton_iff_existsUnique_zpow {G : Type*}
    [LinearOrderedCommGroup G] {a b : G} (ha : a ≠ 1) :
    b ∈ closure {a} ↔ ∃! k : ℤ, a ^ k = b := by
  constructor <;> intro h
  · wlog ha : 1 < a generalizing a b
    · simp only [not_lt] at ha
      rcases ha.eq_or_lt with rfl|ha
      · contradiction
      specialize @this a⁻¹ b (by simpa) (by simpa) (by simpa)
      simp only [inv_zpow'] at this
      obtain ⟨k, rfl, hk'⟩ := this
      refine ⟨-k, rfl, ?_⟩
      intro y hy
      rw [← neg_eq_iff_eq_neg]
      exact hk' _ (by simpa using hy)
    · rw [mem_closure_singleton] at h
      obtain ⟨k, hk⟩ := h
      refine ⟨k, hk, ?_⟩
      rintro l rfl
      rwa [← zpow_right_inj ha, eq_comm]
  · rw [mem_closure_singleton]
    exact h.exists

open Subgroup in
@[to_additive]
lemma LinearOrderedCommGroup.closure_equiv_closure_strictMono_or_strictAnti {G G' : Type*}
    [LinearOrderedCommGroup G] [LinearOrderedCommGroup G'] {x : G} {y : G'}
    (f : closure ({x} : Set G) ≃* closure ({y} : Set G')) : StrictMono f ∨ StrictAnti f := by
  rcases eq_or_ne x 1 with rfl|hx
  · by_contra! H
    simp only [StrictMono, Subtype.forall, closure_singleton_one, mem_bot, Subtype.mk_lt_mk,
      not_forall, Classical.not_imp, not_lt, exists_and_left, StrictAnti] at H
    obtain ⟨⟨x, rfl, y, rfl, H, _⟩, _⟩ := H
    exact lt_irrefl _ H
  rcases eq_or_ne y 1 with rfl|hy
  · by_contra! H
    simp only [StrictMono, Subtype.forall, closure_singleton_one, mem_bot, Subtype.mk_lt_mk,
      not_forall, Classical.not_imp, not_lt, exists_and_left, StrictAnti] at H
    obtain ⟨⟨x, hx, y, hy, H, -⟩, _⟩ := H
    have hx' := (f ⟨x, hx⟩).prop
    have hy' := (f ⟨y, hy⟩).prop
    simp only [one_zpow, exists_const, mem_closure_singleton] at hx' hy'
    replace hx' : f ⟨x, hx⟩ = 1 := by
      ext
      simp [← hx']
    replace hy' : f ⟨y, hy⟩ = 1 := by
      ext
      simp [← hy']
    simp only [MulEquivClass.map_eq_one_iff, Submonoid.mk_eq_one] at hx' hy'
    simp [hx', hy'] at H
  have H : f ⟨x, by simp⟩ = ⟨y, by simp⟩ ∨ f ⟨x, by simp⟩ = ⟨y⁻¹, by simp⟩ := by
    have hx := (f ⟨x, by simp⟩).prop
    have hy := (f.symm ⟨y, by simp⟩).prop
    rw [mem_closure_singleton_iff_existsUnique_zpow ‹_›] at hx hy
    obtain ⟨k, hk, hk'⟩ := hx
    obtain ⟨l, hl, hl'⟩ := hy
    have hy' := (f.symm ⟨y ^ k, by simp [mem_closure_singleton]⟩).prop
    have hyk : (⟨y ^ k, by simp [mem_closure_singleton]⟩ : closure {y}) =
        (⟨y, by simp⟩ : closure {y}) ^ k := by
      ext
      simp
    rw [mem_closure_singleton_iff_existsUnique_zpow ‹_›] at hy'
    obtain ⟨m, hm, hm'⟩ := hy'
    have hmy := hm
    simp only [hk, Subtype.coe_eta, MulEquiv.symm_apply_apply] at hmy
    have hx' : x ∈ closure {x} := by simp
    rw [mem_closure_singleton_iff_existsUnique_zpow ‹_›] at hx'
    replace hmy : m = 1 := hx'.unique hmy (by simp)
    simp only [hyk, map_zpow, SubgroupClass.coe_zpow, ← hl, ← zpow_mul] at hm
    subst hmy
    rcases lt_trichotomy x 1 with h1|rfl|h1
    · rw [← inv_inv x, inv_zpow', inv_zpow' x⁻¹, zpow_right_inj (by simpa using h1)] at hm
      simp only [Int.reduceNeg, eq_comm, neg_inj, Int.mul_eq_one_iff_eq_one_or_neg_one] at hm
      rcases hm with ⟨rfl, rfl⟩|⟨rfl, rfl⟩ <;>
      · simp only [Int.reduceNeg, zpow_neg, zpow_one] at hk
        simp [Subtype.ext_iff, hk]
    · simp only [one_zpow] at hl
      have : ((1 : closure ({1} : Set G)) : G) = 1 := rfl
      simp_rw [← this, ← Subtype.ext_iff] at hl
      rw [eq_comm, f.symm_apply_eq] at hl
      simp only [map_one, Submonoid.mk_eq_one] at hl
      simp [hl, Subtype.ext_iff]
    · simp only [eq_comm, zpow_right_inj h1, Int.mul_eq_one_iff_eq_one_or_neg_one] at hm
      rcases hm with ⟨rfl, rfl⟩|⟨rfl, rfl⟩ <;>
      · simp only [Int.reduceNeg, zpow_neg, zpow_one] at hk
        simp [Subtype.ext_iff, hk]
  wlog hm : |x|ₘ = x generalizing x y
  · let e := (MulEquiv.subgroupCongr (closure_singleton_inv x))
    have he : StrictMono e.symm := by
      intro a b hab
      simpa only [← Subtype.coe_lt_coe, e, MulEquiv.subgroupCongr_symm_apply] using hab
    specialize @this x⁻¹ y (e.trans f) (by simp [hx]) hy (H.symm.imp _ _) _
    · have : e ⟨x⁻¹, by simp⟩ = e ⟨x, by simp⟩⁻¹ := rfl
      simpa [Subtype.ext_iff, this, inv_eq_iff_eq_inv] using id
    · have : e ⟨x⁻¹, by simp⟩ = e ⟨x, by simp⟩⁻¹ := rfl
      simpa [Subtype.ext_iff, this, inv_eq_iff_eq_inv] using id
    · simp [(mabs_choice x).resolve_left hm]
    simp only [MulEquiv.coe_trans] at this
    refine this.imp ?_ ?_ <;> intro h
    · exact h.comp he
    · exact h.comp_strictMono he
  wlog hm' : |y|ₘ = y generalizing x y
  · let e := (MulEquiv.subgroupCongr (closure_singleton_inv y))
    have he : StrictMono e := by
      intro a b hab
      simpa only [← Subtype.coe_lt_coe, e] using hab
    specialize @this x y⁻¹ (f.trans e.symm) hx (by simp [hy]) (H.symm.imp _ _) hm _
    · have : f ⟨x⁻¹, by simp⟩ = f ⟨x, by simp⟩⁻¹ := rfl
      simpa [Subtype.ext_iff, this, inv_eq_iff_eq_inv] using id
    · have : f ⟨x⁻¹, by simp⟩ = f ⟨x, by simp⟩⁻¹ := rfl
      simpa [Subtype.ext_iff, this, inv_eq_iff_eq_inv] using id
    · simp [(mabs_choice y).resolve_left hm']
    simp only [MulEquiv.coe_trans] at this
    refine this.imp ?_ ?_ <;> intro h
    · exact he.comp h
    · exact he.comp_strictAnti h
  refine H.imp ?_ ?_ <;> intro H a b hab
  · obtain ⟨k, hk⟩ := mem_closure_singleton.mp a.prop
    obtain ⟨rfl⟩ : a = ⟨x, by simp⟩ ^ k := Subtype.ext hk.symm
    obtain ⟨l, hl⟩ := mem_closure_singleton.mp b.prop
    obtain ⟨rfl⟩ : b = ⟨x, by simp⟩ ^ l := Subtype.ext hl.symm
    simp only [map_zpow, H] at hab ⊢
    rwa [(zpow_right_strictMono _).lt_iff_lt] at hab ⊢
    · rw [← hm']
      simp [← Subtype.coe_lt_coe, hy]
    · rw [← hm]
      simp [← Subtype.coe_lt_coe, hx]
  · obtain ⟨k, hk⟩ := mem_closure_singleton.mp a.prop
    obtain ⟨rfl⟩ : a = ⟨x, by simp⟩ ^ k := Subtype.ext hk.symm
    obtain ⟨l, hl⟩ := mem_closure_singleton.mp b.prop
    obtain ⟨rfl⟩ : b = ⟨x, by simp⟩ ^ l := Subtype.ext hl.symm
    replace H : f ⟨x, by simp⟩ = ⟨y, by simp⟩⁻¹ := H
    simp only [map_zpow, H, inv_zpow'] at hab ⊢
    rw [(zpow_right_strictMono _).lt_iff_lt] at hab ⊢
    · simp [hab]
    · rw [← hm']
      simp [← Subtype.coe_lt_coe, hy]
    · rw [← hm]
      simp [← Subtype.coe_lt_coe, hx]


open Subgroup in
/-- In two linearly ordered groups, the closure of an element of one group
is isomorphic (and order-isomorphic) to the closure of an element in the other group. -/
@[to_additive "In two linearly ordered additive groups, the closure of an element of one group
is isomorphic (and order-isomorphic) to the closure of an element in the other group."]
noncomputable def LinearOrderedCommGroup.closure_equiv_closure {G G' : Type*}
    [LinearOrderedCommGroup G] [LinearOrderedCommGroup G'] (x : G) (y : G') (hxy : x = 1 ↔ y = 1) :
    closure ({x} : Set G) ≃*o closure ({y} : Set G') :=
  if hx : x = 1 then by
    let e : closure ({x} : Set G) ≃* closure ({y} : Set G') :=
      ⟨⟨fun _ ↦ ⟨1, by simp [hxy.mp hx]⟩, fun _ ↦ ⟨1, by simp [hx]⟩, ?_, ?_⟩, ?_⟩
    · by_cases he : StrictMono e
      · exact ⟨e, he.le_iff_le⟩
      · replace he := ((closure_equiv_closure_strictMono_or_strictAnti e).resolve_left he)
        exact ⟨(MulEquiv.inv _).trans e, (he.comp (MulEquiv.inv_strictAnti _)).le_iff_le⟩
    · intro ⟨a, ha⟩
      simpa [hx, closure_singleton_one, eq_comm] using ha
    · intro ⟨a, ha⟩
      simpa [hxy.mp hx, closure_singleton_one, eq_comm] using ha
    · intros
      simp
  else by
    let e : closure ({x} : Set G) ≃* closure ({y} : Set G') := ⟨⟨
      fun a ↦ ⟨y ^ (mem_closure_singleton.mp a.prop).choose, by simp [mem_closure_singleton]⟩,
      fun a ↦ ⟨x ^ (mem_closure_singleton.mp a.prop).choose, by simp [mem_closure_singleton]⟩,
        ?_, ?_⟩, ?_⟩
    · by_cases he : StrictMono e
      · exact ⟨e, he.le_iff_le⟩
      · replace he := ((closure_equiv_closure_strictMono_or_strictAnti e).resolve_left he)
        exact ⟨(MulEquiv.inv _).trans e, (he.comp (MulEquiv.inv_strictAnti _)).le_iff_le⟩
    · intro a
      generalize_proofs A B C D
      rw [Subtype.ext_iff, ← (C a).choose_spec, zpow_right_inj' hx,
          ← zpow_right_inj' (hxy.not.mp hx), (A ⟨_, D a⟩).choose_spec]
    · intro a
      generalize_proofs A B C D
      rw [Subtype.ext_iff, ← (C a).choose_spec, zpow_right_inj' (hxy.not.mp hx),
          ← zpow_right_inj' hx, (A ⟨_, D a⟩).choose_spec]
    · intro a b
      generalize_proofs A B C D E F
      simp only [Submonoid.coe_mul, coe_toSubmonoid, Submonoid.mk_mul_mk, Subtype.mk.injEq]
      rw [← zpow_add, zpow_right_inj' (hxy.not.mp hx), ← zpow_right_inj' hx, zpow_add,
          (A a).choose_spec, (A b).choose_spec, (A (a * b)).choose_spec]
      simp

variable {G : Type*} [LinearOrderedAddCommGroup G] [Archimedean G]

/-- Given a subgroup `H` of a decidable linearly ordered archimedean abelian group `G`, if there
exists a minimal element `a` of `H ∩ G_{>0}` then `H` is generated by `a`. -/
theorem AddSubgroup.cyclic_of_min {H : AddSubgroup G} {a : G}
    (ha : IsLeast { g : G | g ∈ H ∧ 0 < g } a) : H = AddSubgroup.closure {a} := by
  obtain ⟨⟨a_in, a_pos⟩, a_min⟩ := ha
  refine le_antisymm ?_ (H.closure_le.mpr <| by simp [a_in])
  intro g g_in
  obtain ⟨k, ⟨nonneg, lt⟩, _⟩ := existsUnique_zsmul_near_of_pos' a_pos g
  have h_zero : g - k • a = 0 := by
    by_contra h
    have h : a ≤ g - k • a := by
      refine a_min ⟨?_, ?_⟩
      · exact AddSubgroup.sub_mem H g_in (AddSubgroup.zsmul_mem H a_in k)
      · exact lt_of_le_of_ne nonneg (Ne.symm h)
    have h' : ¬a ≤ g - k • a := not_le.mpr lt
    contradiction
  simp [sub_eq_zero.mp h_zero, AddSubgroup.mem_closure_singleton]

/-- If a nontrivial additive subgroup of a linear ordered additive commutative group is disjoint
with the interval `Set.Ioo 0 a` for some positive `a`, then the set of positive elements of this
group admits the least element. -/
theorem AddSubgroup.exists_isLeast_pos {H : AddSubgroup G} (hbot : H ≠ ⊥) {a : G} (h₀ : 0 < a)
    (hd : Disjoint (H : Set G) (Ioo 0 a)) : ∃ b, IsLeast { g : G | g ∈ H ∧ 0 < g } b := by
  -- todo: move to a lemma?
  have hex : ∀ g > 0, ∃ n : ℕ, g ∈ Ioc (n • a) ((n + 1) • a) := fun g hg => by
    rcases existsUnique_add_zsmul_mem_Ico h₀ 0 (g - a) with ⟨m, ⟨hm, hm'⟩, -⟩
    simp only [zero_add, sub_le_iff_le_add, sub_add_cancel, ← add_one_zsmul] at hm hm'
    lift m to ℕ
    · rw [← Int.lt_add_one_iff, ← zsmul_lt_zsmul_iff h₀, zero_zsmul]
      exact hg.trans_le hm
    · simp only [← Nat.cast_succ, natCast_zsmul] at hm hm'
      exact ⟨m, hm', hm⟩
  have : ∃ n : ℕ, Set.Nonempty (H ∩ Ioc (n • a) ((n + 1) • a)) := by
    rcases (bot_or_exists_ne_zero H).resolve_left hbot with ⟨g, hgH, hg₀⟩
    rcases hex |g| (abs_pos.2 hg₀) with ⟨n, hn⟩
    exact ⟨n, _, (@abs_mem_iff (AddSubgroup G) G _ _).2 hgH, hn⟩
  classical rcases Nat.findX this with ⟨n, ⟨x, hxH, hnx, hxn⟩, hmin⟩
  by_contra hxmin
  simp only [IsLeast, not_and, mem_setOf_eq, mem_lowerBounds, not_exists, not_forall,
    not_le] at hxmin
  rcases hxmin x ⟨hxH, (nsmul_nonneg h₀.le _).trans_lt hnx⟩ with ⟨y, ⟨hyH, hy₀⟩, hxy⟩
  rcases hex y hy₀ with ⟨m, hm⟩
  cases' lt_or_le m n with hmn hnm
  · exact hmin m hmn ⟨y, hyH, hm⟩
  · refine disjoint_left.1 hd (sub_mem hxH hyH) ⟨sub_pos.2 hxy, sub_lt_iff_lt_add'.2 ?_⟩
    calc x ≤ (n + 1) • a := hxn
    _ ≤ (m + 1) • a := nsmul_le_nsmul_left h₀.le (add_le_add_right hnm _)
    _ = m • a + a := succ_nsmul _ _
    _ < y + a := add_lt_add_right hm.1 _

/-- If an additive subgroup of a linear ordered additive commutative group is disjoint with the
interval `Set.Ioo 0 a` for some positive `a`, then this is a cyclic subgroup. -/
theorem AddSubgroup.cyclic_of_isolated_zero {H : AddSubgroup G} {a : G} (h₀ : 0 < a)
    (hd : Disjoint (H : Set G) (Ioo 0 a)) : ∃ b, H = closure {b} := by
  rcases eq_or_ne H ⊥ with rfl | hbot
  · exact ⟨0, closure_singleton_zero.symm⟩
  · exact (exists_isLeast_pos hbot h₀ hd).imp fun _ => cyclic_of_min

lemma AddSubgroup.isLeast_closure_iff_eq_max {a b : G} :
    IsLeast {y : G | y ∈ closure ({a} : Set G) ∧ 0 < y} b ↔ b = max a (-a) ∧ 0 < b := by
  constructor <;> intro h
  · have := cyclic_of_min h
    have ha : a ∈ closure ({b} : Set G) := by
      simp [← this]
    rw [mem_closure_singleton] at ha
    obtain ⟨n, rfl⟩ := ha
    have := h.left
    simp only [mem_closure_singleton, mem_setOf_eq, ← mul_zsmul] at this
    obtain ⟨m, hm⟩ := this.left
    have key : m * n = 1 := by
      rw [← (zsmul_strictMono_left this.right).injective.eq_iff, hm, one_zsmul]
    rw [Int.mul_eq_one_iff_eq_one_or_neg_one] at key
    rw [eq_comm]
    rcases key with ⟨rfl, rfl⟩|⟨rfl, rfl⟩ <;>
    simp [this.right.le, this.right]
  · wlog ha : 0 ≤ a generalizing a
    · convert @this (-a) ?_ (by simpa using le_of_not_le ha) using 4
      · simp
      · rwa [max_comm, neg_neg]
    rw [max_eq_left ((neg_nonpos.mpr ha).trans ha)] at h
    rcases h with ⟨rfl, h⟩
    refine ⟨?_, ?_⟩
    · simp [h]
    · intro x
      simp only [mem_closure_singleton, mem_setOf_eq, and_imp, forall_exists_index]
      rintro k rfl hk
      rw [← one_zsmul b, ← mul_zsmul, mul_one, zsmul_le_zsmul_iff h, ← zero_add 1,
          ← Int.lt_iff_add_one_le]
      contrapose! hk
      rw [← Left.nonneg_neg_iff, ← neg_zsmul]
      exact zsmul_nonneg ha (by simp [hk])

/-- Every subgroup of `ℤ` is cyclic. -/
theorem Int.subgroup_cyclic (H : AddSubgroup ℤ) : ∃ a, H = AddSubgroup.closure {a} :=
  have : Ioo (0 : ℤ) 1 = ∅ := eq_empty_of_forall_not_mem fun m hm =>
    hm.1.not_le (lt_add_one_iff.1 hm.2)
  AddSubgroup.cyclic_of_isolated_zero one_pos <| by simp [this]

lemma AddSubgroup.closure_singleton_int_one_eq_top : closure ({1} : Set ℤ) = ⊤ := by
  rw [eq_comm]
  apply cyclic_of_min
  refine ⟨?_, ?_⟩
  · simp
  · intro x
    simp only [mem_top, true_and, mem_setOf_eq]
    exact id

/-- If an element of a linearly ordered archimedean additive group is the least positive element,
then the whole group is isomorphic (and order-isomorphic) to the integers. -/
noncomputable def LinearOrderedAddCommGroup.int_addEquiv_of_isLeast_pos {x : G}
    (h : IsLeast {y : G | 0 < y} x) :
    {f : G ≃+ ℤ // StrictMono f} := by
  have : IsLeast {y : G | y ∈ (⊤ : AddSubgroup G) ∧ 0 < y} x := by simpa using h
  replace this := AddSubgroup.cyclic_of_min this
  let e : G ≃+ (⊤ : AddSubgroup G) := AddSubsemigroup.topEquiv.symm
  let e' : (⊤ : AddSubgroup G) ≃+ AddSubgroup.closure {x} :=
    AddEquiv.subsemigroupCongr (by simp [this])
  let g : ℤ ≃+ (⊤ : AddSubgroup ℤ) := AddSubsemigroup.topEquiv.symm
  let g' : (⊤ : AddSubgroup ℤ) ≃+ AddSubgroup.closure ({1} : Set ℤ) :=
    (.subsemigroupCongr (by simp [AddSubgroup.closure_singleton_int_one_eq_top]))
  let f := closure_equiv_closure x (1 : ℤ) (by simp [h.left.ne'])
  refine ⟨(((e.trans e').trans f).trans g'.symm).trans g.symm, ?_⟩
  intro a b hab
  have hab' : f (e' (e a)) < f (e' (e b)) := by
    rw [f.strictMono.lt_iff_lt]
    exact hab
  exact hab'

/-- Any linearly ordered archimedean additive group is either is isomorphic (and order-isomorphic)
to the integers, or is densely ordered. -/
lemma LinearOrderedAddCommGroup.discrete_or_denselyOrdered :
    (∃ f : G ≃+ ℤ, StrictMono f) ∨ DenselyOrdered G := by
  by_cases H : ∃ x, IsLeast {y : G | 0 < y} x
  · obtain ⟨x, hx⟩ := H
    exact Or.inl ⟨_, (LinearOrderedAddCommGroup.int_addEquiv_of_isLeast_pos hx).prop⟩
  · push_neg at H
    refine Or.inr ⟨?_⟩
    intro x y hxy
    specialize H (y - x)
    obtain ⟨z, hz⟩ : ∃ z : G, 0 < z ∧ z < y - x := by
      contrapose! H
      refine ⟨by simp [hxy], fun _ ↦ H _⟩
    refine ⟨x + z, ?_, ?_⟩
    · simp [hz.left]
    · simpa [lt_sub_iff_add_lt'] using hz.right
