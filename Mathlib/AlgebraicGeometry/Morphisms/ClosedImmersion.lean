/-
Copyright (c) 2023 Jonas van der Schaaf. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston, Christian Merten, Jonas van der Schaaf
-/
import Mathlib.AlgebraicGeometry.OpenImmersion
import Mathlib.AlgebraicGeometry.Morphisms.QuasiCompact
import Mathlib.CategoryTheory.MorphismProperty.Composition
import Mathlib.RingTheory.LocalProperties
import Mathlib.AlgebraicGeometry.Morphisms.Basic
import Mathlib.Topology.LocalAtTarget
import Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated
import Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties
import Mathlib.RingTheory.RingHom.Surjective

/-!

# Closed immersions of schemes

A morphism of schemes `f : X ‚ü∂ Y` is a closed immersion if the underlying map of topological spaces
is a closed immersion and the induced morphisms of stalks are all surjective.

## Main definitions

* `IsClosedImmersion` : The property of scheme morphisms stating `f : X ‚ü∂ Y` is a closed immersion.

## TODO

* Show closed immersions of affines are induced by surjective ring maps
* Show closed immersions are stable under pullback
* Show closed immersions are precisely the proper monomorphisms
* Define closed immersions of locally ringed spaces, where we also assume that the kernel of `O_X ‚Üí
  f_*O_Y` is locally generated by sections as an `O_X`-module, and relate it to this file. See
  https://stacks.math.columbia.edu/tag/01HJ.

-/

universe v u

open CategoryTheory

namespace AlgebraicGeometry

/-
@[mk_iff]
class IsSurjectiveOnStalks {X Y : Scheme} (f : X ‚ü∂ Y) : Prop where
  out : MorphismProperty.stalkwise (fun f ‚Ü¶ Function.Surjective f) f

lemma isSurjectiveOnStalks_eq_stalkwise_surjective :
    @IsSurjectiveOnStalks = MorphismProperty.stalkwise (fun f ‚Ü¶ Function.Surjective f) := by
  ext 
  exact isSurjectiveOnStalks_iff _
-/

/-- A morphism of schemes `X ‚ü∂ Y` is a closed immersion if the underlying
topological map is a closed embedding and the induced stalk maps are surjective. -/
@[mk_iff]
class IsClosedImmersion {X Y : Scheme} (f : X ‚ü∂ Y) : Prop where
  base_closed : MorphismProperty.topologically ClosedEmbedding f
  surj_on_stalks : MorphismProperty.stalkwise (fun f ‚Ü¶ Function.Surjective f) f

namespace IsClosedImmersion

lemma closedEmbedding {X Y : Scheme} (f : X ‚ü∂ Y)
    [IsClosedImmersion f] : ClosedEmbedding f.1.base :=
  IsClosedImmersion.base_closed

lemma surjective_stalkMap {X Y : Scheme} (f : X ‚ü∂ Y)
    [IsClosedImmersion f] (x : X) : Function.Surjective (PresheafedSpace.stalkMap f.1 x) :=
  IsClosedImmersion.surj_on_stalks x

/-- Isomorphisms are closed immersions. -/
instance {X Y : Scheme} (f : X ‚ü∂ Y) [IsIso f] : IsClosedImmersion f where
  base_closed := Homeomorph.closedEmbedding <| TopCat.homeoOfIso (asIso f.1.base)
  surj_on_stalks := fun _ ‚Ü¶ (ConcreteCategory.bijective_of_isIso _).2

instance : MorphismProperty.IsMultiplicative @IsClosedImmersion where
  id_mem _ := inferInstance
  comp_mem {X Y Z} f g hf hg := by
    refine ‚ü®hg.base_closed.comp hf.base_closed, fun x ‚Ü¶ ?_‚ü©
    erw [PresheafedSpace.stalkMap.comp]
    exact (hf.surj_on_stalks x).comp (hg.surj_on_stalks (f.1.1 x))

/-
instance {X Y : Scheme} (f : X ‚ü∂ Y) [IsIso f] : IsSurjectiveOnStalks f where
  out := fun _ ‚Ü¶ (ConcreteCategory.bijective_of_isIso _).2
-/

/-
instance : MorphismProperty.IsMultiplicative @IsSurjectiveOnStalks where
  id_mem _ := inferInstance
  comp_mem {X Y Z} f g hf hg := by
    constructor
    intro x
    erw [PresheafedSpace.stalkMap.comp]
    exact (hf.out x).comp (hg.out (f.1.1 x))
-/

/-- Composition of closed immersions is a closed immersion. -/
instance comp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsClosedImmersion f]
    [IsClosedImmersion g] : IsClosedImmersion (f ‚â´ g) :=
  MorphismProperty.IsStableUnderComposition.comp_mem f g inferInstance inferInstance

/-
/-- Composition of closed immersions is a closed immersion. -/
instance comp' {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsSurjectiveOnStalks f]
    [IsSurjectiveOnStalks g] : IsSurjectiveOnStalks (f ‚â´ g) :=
  MorphismProperty.IsStableUnderComposition.comp_mem f g inferInstance inferInstance
-/

/-- Composition with an isomorphism preserves closed immersions. -/
lemma respectsIso : MorphismProperty.RespectsIso @IsClosedImmersion := by
  constructor <;> intro X Y Z e f hf <;> infer_instance

/-- Given two commutative rings `R S : CommRingCat` and a surjective morphism
`f : R ‚ü∂ S`, the induced scheme morphism `specObj S ‚ü∂ specObj R` is a
closed immersion. -/
theorem spec_of_surjective {R S : CommRingCat} (f : R ‚ü∂ S) (h : Function.Surjective f) :
    IsClosedImmersion (Spec.map f) where
  base_closed := PrimeSpectrum.closedEmbedding_comap_of_surjective _ _ h
  surj_on_stalks x := by
    dsimp
    erw [‚Üê localRingHom_comp_stalkIso, CommRingCat.coe_comp, CommRingCat.coe_comp]
    apply Function.Surjective.comp (Function.Surjective.comp _ _) _
    ¬∑ exact (ConcreteCategory.bijective_of_isIso (StructureSheaf.stalkIso S x).inv).2
    ¬∑ exact surjective_localRingHom_of_surjective f h x.asIdeal
    ¬∑ let g := (StructureSheaf.stalkIso ((CommRingCat.of R))
        ((PrimeSpectrum.comap (CommRingCat.ofHom f)) x)).hom
      exact (ConcreteCategory.bijective_of_isIso g).2

open Opposite

lemma specMap_Œì_map {X Y : Scheme} [IsAffine X] [IsAffine Y] (f : X ‚ü∂ Y) :
    Spec.map (Scheme.Œì.map f.op) = X.isoSpec.inv ‚â´ f ‚â´ Y.isoSpec.hom := by
  erw [IsIso.eq_inv_comp]
  apply Adjunction.unit_naturality

theorem of_surjective_of_affine {X Y : Scheme} [IsAffine X] [IsAffine Y] (f : X ‚ü∂ Y)
    (h : Function.Surjective (Scheme.Œì.map f.op)) : IsClosedImmersion f := by
  have he : IsClosedImmersion (X.isoSpec.inv ‚â´ f ‚â´ Y.isoSpec.hom) := by
    rw [‚Üê specMap_Œì_map f]
    apply spec_of_surjective
    exact h
  rw [respectsIso.cancel_left_isIso] at he
  rw [respectsIso.cancel_right_isIso] at he
  exact he

/-- For any ideal `I` in a commutative ring `R`, the quotient map `specObj R ‚ü∂ specObj (R ‚ß∏ I)`
is a closed immersion. -/
instance spec_of_quotient_mk {R : CommRingCat.{u}} (I : Ideal R) :
    IsClosedImmersion (Spec.map (CommRingCat.ofHom (Ideal.Quotient.mk I))) :=
  spec_of_surjective _ Ideal.Quotient.mk_surjective

/-- If `f ‚â´ g` is a closed immersion, then `f` is a closed immersion. -/
theorem of_comp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsClosedImmersion g]
    [IsClosedImmersion (f ‚â´ g)] : IsClosedImmersion f where
  base_closed := by
    have h := closedEmbedding (f ‚â´ g)
    rw [Scheme.comp_val_base] at h
    apply closedEmbedding_of_continuous_injective_closed (Scheme.Hom.continuous f)
    ¬∑ exact Function.Injective.of_comp h.inj
    ¬∑ intro Z hZ
      rw [ClosedEmbedding.closed_iff_image_closed (closedEmbedding g),
        ‚Üê Set.image_comp]
      exact ClosedEmbedding.isClosedMap h _ hZ
  surj_on_stalks x := by
    have h := surjective_stalkMap (f ‚â´ g) x
    erw [Scheme.comp_val, PresheafedSpace.stalkMap.comp] at h
    exact Function.Surjective.of_comp h

theorem closedEmbedding_localAtTarget : PropertyIsLocalAtTarget
    (MorphismProperty.topologically ClosedEmbedding) := by
  apply MorphismProperty.topologically_propertyIsLocalAtTarget
  ¬∑ apply MorphismProperty.topologically_respectsIso
    ¬∑ intro X Y _ _ e
      exact Homeomorph.closedEmbedding e
    ¬∑ intro X Y Z _ _ _ f g hf hg
      exact ClosedEmbedding.comp hg hf
  ¬∑ intro X Y _ _ f s hf
    exact ClosedEmbedding.restrictPreimage s hf
  ¬∑ intro X Y _ _ f Œπ U hU hfcont hf
    apply (closedEmbedding_iff_closedEmbedding_of_iSup_eq_top hU hfcont).mpr hf

theorem surjective_respectsIso :
    RingHom.RespectsIso (fun f ‚Ü¶ Function.Surjective f) := by
  apply RingHom.StableUnderComposition.respectsIso
  ¬∑ intro R S T _ _ _ f g hf hg
    simp only [RingHom.coe_comp]
    exact Function.Surjective.comp hg hf
  ¬∑ intro R S _ _ e
    exact EquivLike.surjective e

theorem isSurjectiveOnStalks_localAtTarget : PropertyIsLocalAtTarget
      (MorphismProperty.stalkwise (fun f ‚Ü¶ Function.Surjective f)) := by
  apply stalkwiseIsLocalAtTarget_of_respectsIso
  exact surjective_respectsIso

/-
TODO: can we write a general helper (ideally n-ary) to obtain this?
-> write MorphismProperty.and
-/
/-- Closed immersions are local at the target. -/
theorem closedImmersion_localAtTarget :
    PropertyIsLocalAtTarget @IsClosedImmersion where
  RespectsIso := respectsIso
  restrict f U hf := by
    constructor
    ¬∑ exact closedEmbedding_localAtTarget.restrict f U hf.base_closed
    . exact isSurjectiveOnStalks_localAtTarget.restrict f U hf.surj_on_stalks
  of_openCover f ùí∞ hf := by
    constructor
    ¬∑ exact closedEmbedding_localAtTarget.of_openCover f ùí∞ (fun i ‚Ü¶ (hf i).base_closed)
    ¬∑ exact isSurjectiveOnStalks_localAtTarget.of_openCover f ùí∞ (fun i ‚Ü¶ (hf i).surj_on_stalks)

section Affine

section

variable {X Y : Scheme} (f : X ‚ü∂ Y) (x : X) (s : Scheme.Œì.obj <| op X)

example : X.presheaf.obj (op ‚ä§) := s

variable (t : Scheme.Œì.obj <| op Y)

end

variable (A : Type u) [CommRing A]
variable {X : Scheme.{u}}

open TopologicalSpace

noncomputable
def IsOpenImmersion.ŒìIso {X Y : Scheme.{u}} (f : X ‚ü∂ Y) [IsOpenImmersion f] :
    Scheme.Œì.obj (op X) ‚âÖ Y.presheaf.obj (op (Scheme.Hom.opensRange f)) :=
  Scheme.Œì.mapIso (IsOpenImmersion.isoOfRangeEq
      (Scheme.ŒπOpens (Scheme.Hom.opensRange f)) _ Subtype.range_val).op ‚â™‚â´
    Y.presheaf.mapIso (eqToIso (TopologicalSpace.Opens.openEmbedding_obj_top _).symm).op

lemma IsOpenImmersion.map_ŒìIso_inv
    {X Y : Scheme.{u}} (f : X ‚ü∂ Y) [IsOpenImmersion f] :
  Y.presheaf.map (homOfLE le_top).op ‚â´ (IsOpenImmersion.ŒìIso f).inv = Scheme.Œì.map f.op := by
  conv_rhs => rw [‚Üê IsOpenImmersion.isoOfRangeEq_inv_fac
      (Scheme.ŒπOpens (Scheme.Hom.opensRange f)) _ Subtype.range_val]
  rw [IsOpenImmersion.ŒìIso]
  dsimp
  rw [‚Üê Functor.map_comp_assoc]
  rfl

lemma eq_of_eq_cover {X : Scheme.{u}} (f g : Scheme.Œì.obj (op X)) (ùí∞ : X.OpenCover)
    (h : ‚àÄ i : ùí∞.J, Scheme.Œì.map (ùí∞.map i).op f = Scheme.Œì.map (ùí∞.map i).op g) : f = g := by
  fapply TopCat.Sheaf.eq_of_locally_eq' X.sheaf
    (fun i ‚Ü¶ Scheme.Hom.opensRange (ùí∞.map (ùí∞.f i))) _ (fun _ ‚Ü¶ homOfLE le_top)
  ¬∑ rintro x -; simpa using ‚ü®_, ùí∞.covers x‚ü©
  ¬∑ intro x;
    replace h := h (ùí∞.f x)
    rw [‚Üê IsOpenImmersion.map_ŒìIso_inv] at h
    exact (IsOpenImmersion.ŒìIso (ùí∞.map (ùí∞.f x))).commRingCatIsoToRingEquiv.symm.injective h

lemma zero_of_zero_cover (s : Scheme.Œì.obj (op X)) (ùí∞ : X.OpenCover)
    (h : ‚àÄ i : ùí∞.J, Scheme.Œì.map (ùí∞.map i).op s = 0) : s = 0 := by
  apply eq_of_eq_cover s 0 _
  intro i
  rw [map_zero]
  exact h i

lemma isNilpotent_of_isNilpotent_cover (s : Scheme.Œì.obj (op X)) (ùí∞ : X.OpenCover)
    [Finite ùí∞.J] (h : ‚àÄ i : ùí∞.J, IsNilpotent (Scheme.Œì.map (ùí∞.map i).op s)) : IsNilpotent s := by
  choose fn hfn using h
  have : Fintype ùí∞.J := Fintype.ofFinite ùí∞.J
  /- the maximum of all `fn i` (exists, because `ùí∞.J` is finite) -/
  let N : ‚Ñï := Finset.sup Finset.univ fn
  have hfnleN (i : ùí∞.J) : fn i ‚â§ N := Finset.le_sup (Finset.mem_univ i)
  use N
  apply zero_of_zero_cover
  intro i
  simp only [map_pow]
  exact pow_eq_zero_of_le (hfnleN i) (hfn i)

lemma ŒìToStalk_stalkMap {X Y : Scheme} (f : X ‚ü∂ Y) (x : X) :
    Y.ŒìToStalk (f.val.base x) ‚â´ PresheafedSpace.stalkMap f.val x =
      Scheme.Œì.map f.op ‚â´ X.ŒìToStalk x := by
  dsimp only [LocallyRingedSpace.ŒìToStalk]
  rw [PresheafedSpace.stalkMap_germ']
  simp

noncomputable def _root_.AlgebraicGeometry.LocallyRingedSpace.ResidueField
    (X : LocallyRingedSpace) (x : X) : CommRingCat :=
  CommRingCat.of <| LocalRing.ResidueField (X.stalk x)

noncomputable def _root_.AlgebraicGeometry.LocallyRingedSpace.evaluation (X : LocallyRingedSpace)
    {U : TopologicalSpace.Opens X} (x : U) :
    X.presheaf.obj (op U) ‚ü∂ X.ResidueField x :=
  X.presheaf.germ x ‚â´ LocalRing.residue _

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.evaluation_eq_zero_iff_mem_maximalIdeal
    (X : LocallyRingedSpace) {U : TopologicalSpace.Opens X} (x : U) (f : X.presheaf.obj (op U)) :
    X.evaluation x f = 0 ‚Üî (X.presheaf.germ x) f ‚àà LocalRing.maximalIdeal (X.stalk x) :=
  LocalRing.residue_eq_zero_iff _

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.evaluation_ne_zero_iff_isUnit
    (X : LocallyRingedSpace) {U : TopologicalSpace.Opens X} (x : U) (f : X.presheaf.obj (op U)) :
    X.evaluation x f ‚â† 0 ‚Üî IsUnit ((X.presheaf.germ x) f) :=
  LocalRing.residue_ne_zero_iff_isUnit _

noncomputable def _root_.AlgebraicGeometry.LocallyRingedSpace.Œìevaluation (X : LocallyRingedSpace)
    (x : X) :
    LocallyRingedSpace.Œì.obj (op X) ‚ü∂ X.ResidueField x :=
  X.evaluation ‚ü®x, show x ‚àà ‚ä§ from trivial‚ü©

--lemma _root_.AlgebraicGeometry.LocallyRingedSpace.Œìevaluation_eq_zero_iff_mem_maximalIdeal
--    (X : LocallyRingedSpace) (x : X) (f : LocallyRingedSpace.Œì.obj (op X)) :
--    X.Œìevaluation x f = 0 ‚Üî (X.presheaf.germ x) f ‚àà LocalRing.maximalIdeal (X.stalk x) :=
--  LocalRing.residue_eq_zero_iff _

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.Œìevaluation_ne_zero_iff_isUnit
    (X : LocallyRingedSpace) {U : TopologicalSpace.Opens X} (x : U) (f : X.presheaf.obj (op U)) :
    X.evaluation x f ‚â† 0 ‚Üî IsUnit ((X.presheaf.germ x) f) :=
  LocalRing.residue_ne_zero_iff_isUnit _

noncomputable def _root_.AlgebraicGeometry.LocallyRingedSpace.evaluationMap
    {X Y : LocallyRingedSpace} (f : X ‚ü∂ Y) (x : X) :
    Y.ResidueField (f.val.base x) ‚ü∂ X.ResidueField x :=
  LocalRing.ResidueField.map (LocallyRingedSpace.stalkMap f x)

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.mem_basicOpen (X : LocallyRingedSpace)
    {U : TopologicalSpace.Opens X}
    (f : X.presheaf.obj (op U)) (x : U) :
    x.val ‚àà X.toRingedSpace.basicOpen f ‚Üî X.evaluation x f ‚â† 0 := by
  rw [X.toRingedSpace.mem_basicOpen f x]
  exact (X.evaluation_ne_zero_iff_isUnit x f).symm

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.mem_basicOpenŒì (X : LocallyRingedSpace)
    (f : X.presheaf.obj (op ‚ä§)) (x : X) :
    x ‚àà X.toRingedSpace.basicOpen f ‚Üî X.Œìevaluation x f ‚â† 0 :=
  LocallyRingedSpace.mem_basicOpen X f ‚ü®x, trivial‚ü©

lemma evaluation_evaluationMap {X Y : Scheme} (f : X ‚ü∂ Y) (x : X) :
    Y.Œìevaluation (f.val.base x) ‚â´ LocallyRingedSpace.evaluationMap f x =
      Scheme.Œì.map f.op ‚â´ X.Œìevaluation x := by
  dsimp [LocallyRingedSpace.Œìevaluation, LocallyRingedSpace.evaluation,
    LocallyRingedSpace.evaluationMap]
  rw [Category.assoc]
  ext a
  simp only [comp_apply]
  erw [LocalRing.ResidueField.map_residue, PresheafedSpace.stalkMap_germ'_apply]
  rfl

lemma evaluation_evaluationMap_apply {X Y : Scheme} (f : X ‚ü∂ Y) (x : X) (a : Scheme.Œì.obj (op Y)) :
    LocallyRingedSpace.evaluationMap f x (Y.Œìevaluation (f.val.base x) a) =
      X.Œìevaluation x (Scheme.Œì.map f.op a) := by
  simpa using congrFun (congrArg DFunLike.coe <| evaluation_evaluationMap f x) a

lemma ŒìToStalk_stalkMap_apply {X Y : Scheme} (f : X ‚ü∂ Y) (x : X) (a : Scheme.Œì.obj (op Y)) :
    PresheafedSpace.stalkMap f.val x (Y.ŒìToStalk (f.val.base x) a) =
      X.ŒìToStalk x (Scheme.Œì.map f.op a) := by
  simpa using congrFun (congrArg DFunLike.coe <| ŒìToStalk_stalkMap f x) a

def _root_.AlgebraicGeometry.RingedSpace.zeroLocus {X : RingedSpace}
    (s : Set (X.presheaf.obj (op ‚ä§))) : Set X :=
  ‚ãÇ f ‚àà s, (X.basicOpen f)·∂ú

lemma _root_.AlgebraicGeometry.RingedSpace.zeroLocus_singleton {X : RingedSpace}
    (f : X.presheaf.obj (op ‚ä§)) : X.zeroLocus {f} = (X.basicOpen f).carrier·∂ú := by
  simp [RingedSpace.zeroLocus]

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.mem_zeroLocus_iff' {X : LocallyRingedSpace}
    (s : Set (X.presheaf.obj (op ‚ä§))) (x : X) :
      x ‚àà X.toRingedSpace.zeroLocus s ‚Üî ‚àÄ f ‚àà s, x ‚àâ X.toRingedSpace.basicOpen f := by
  simp [RingedSpace.zeroLocus]
  rfl

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.mem_zeroLocus_iff {X : LocallyRingedSpace}
    (s : Set (X.presheaf.obj (op ‚ä§))) (x : X) :
      x ‚àà X.toRingedSpace.zeroLocus s ‚Üî ‚àÄ f ‚àà s, X.Œìevaluation x f = 0 := by
  simp only [RingedSpace.zeroLocus, Set.mem_iInter, Set.mem_compl_iff, SetLike.mem_coe,
    LocallyRingedSpace.Œì_obj]
  simp only [LocallyRingedSpace.mem_basicOpenŒì, ne_eq, not_not]
  rfl

lemma Scheme.zeroLocus_primeSpectrum_zeroLocus' {X : Scheme} (s : Set (Scheme.Œì.obj (op X))) :
    X.toŒìSpecFun ‚Åª¬π' PrimeSpectrum.zeroLocus s = RingedSpace.zeroLocus s := by
  simp only [RingedSpace.zeroLocus]
  have (i : Scheme.Œì.obj (op X)) (_ : i ‚àà s) : (X.basicOpen i).carrier·∂ú =
        X.toŒìSpecFun ‚Åª¬π' (PrimeSpectrum.basicOpen i).carrier·∂ú := by
    symm
    rw [Set.preimage_compl, X.toŒìSpec_preim_basicOpen_eq i]
    simp
    rfl
  erw [Set.iInter‚ÇÇ_congr this]
  rw [‚Üê Set.preimage_iInter‚ÇÇ]
  simp only [Scheme.Œì_obj, Opens.carrier_eq_coe, PrimeSpectrum.basicOpen_eq_zeroLocus_compl, compl_compl]
  rw [‚Üê PrimeSpectrum.zeroLocus_iUnion‚ÇÇ]
  simp

example [IsAffine X] : X.toŒìSpecFun = X.isoSpec.hom.val.base := rfl

lemma Scheme.zeroLocus_primeSpectrum_zeroLocus {X : Scheme} [IsAffine X] (s : Set (Scheme.Œì.obj (op X))) :
    X.isoSpec.hom.val.base '' RingedSpace.zeroLocus s = PrimeSpectrum.zeroLocus s := by
  rw [‚Üê Scheme.zeroLocus_primeSpectrum_zeroLocus']
  show X.isoSpec.hom.val.base '' (X.isoSpec.hom.val.base ‚Åª¬π' PrimeSpectrum.zeroLocus s) =
    PrimeSpectrum.zeroLocus s
  rw [Set.image_preimage_eq]
  apply Function.Bijective.surjective
  have : IsIso (X.isoSpec.hom.val.base) := inferInstance
  exact ConcreteCategory.bijective_of_isIso (X.isoSpec.hom.val.base)

lemma Scheme.zeroLocus_eq_top_iff {X : Scheme} [IsAffine X] (s : Set (Scheme.Œì.obj (op X))) :
    RingedSpace.zeroLocus s = ‚ä§ ‚Üî s ‚äÜ nilradical (Scheme.Œì.obj (op X)) := by
  rw [‚Üê Scheme.zeroLocus_primeSpectrum_zeroLocus']
  simp only [Functor.op_obj, inducedFunctor_obj, LocallyRingedSpace.forgetToSheafedSpace_obj,
    LocallyRingedSpace.Œì_obj, Set.top_eq_univ, Set.preimage_eq_univ_iff, Scheme.Œì_obj]
  erw [‚Üê PrimeSpectrum.zeroLocus_eq_top_iff]
  have hfsurj : Function.Surjective (X.toŒìSpecFun) := by
    apply Function.Bijective.surjective
    apply ConcreteCategory.bijective_of_isIso X.isoSpec.hom.val.base
  rw [hfsurj.range_eq]
  simp

lemma Scheme.zeroLocus_mem {X : Scheme} (s : Set (Scheme.Œì.obj (op X)))
    (x : X) : x ‚àà RingedSpace.zeroLocus s ‚Üî ‚àÄ f ‚àà s, X.Œìevaluation x f = 0 :=
  LocallyRingedSpace.mem_zeroLocus_iff s x

lemma Scheme.basicOpen_eq_bot_iff {X : Scheme} [IsAffine X] (f : Scheme.Œì.obj (op X)) :
    X.basicOpen f = ‚ä• ‚Üî IsNilpotent f := by
  rw [‚Üê mem_nilradical, ‚Üê Opens.coe_eq_empty, ‚Üê Set.compl_univ_iff]
  erw [‚Üê RingedSpace.zeroLocus_singleton]
  rw [‚Üê Set.top_eq_univ, Scheme.zeroLocus_eq_top_iff]
  simp

lemma Scheme.isNilpotent_iff {X : Scheme} [IsAffine X] (f : Scheme.Œì.obj (op X)) :
    IsNilpotent f ‚Üî ‚àÄ x, X.Œìevaluation x f = 0 := by
  rw [‚Üê Scheme.basicOpen_eq_bot_iff]
  rw [‚Üê Opens.coe_eq_empty]
  rw [Set.eq_empty_iff_forall_not_mem]
  rw [‚Üê not_iff_not]
  simp only [Functor.op_obj, inducedFunctor_obj, LocallyRingedSpace.forgetToSheafedSpace_obj,
    SheafedSpace.forgetToPresheafedSpace_obj, SetLike.mem_coe, not_forall, not_not, LocallyRingedSpace.Œì_obj]
  simp_rw [‚Üê ne_eq]
  constructor
  ¬∑ intro ‚ü®x, hx‚ü©
    use x
    apply (X.mem_basicOpenŒì f x).mp hx
  ¬∑ intro ‚ü®x, hx‚ü©
    use x
    apply (X.mem_basicOpenŒì f x).mpr hx

theorem eq_zeroLocus_of_isClosed (X : Scheme) [IsAffine X] (s : Set X.carrier) (hs : IsClosed s) :
    ‚àÉ I : Ideal (Scheme.Œì.obj (op X)), s = RingedSpace.zeroLocus (I : Set (Scheme.Œì.obj (op X))) := by
  let A : CommRingCat := Scheme.Œì.obj (op X)
  let iso : X ‚âÖ Spec A := Scheme.isoSpec X
  let Z : Set (Spec A) := iso.hom.val.base '' s
  have hZ : IsClosed Z :=
    (TopCat.homeoOfIso (asIso <| iso.hom.val.base)).isClosedMap _ hs
  obtain ‚ü®I, (hI : Z = _)‚ü© := (PrimeSpectrum.isClosed_iff_zeroLocus_ideal _).mp hZ
  use I
  have : Function.Injective (Set.image iso.hom.val.base) := by
    simp only [Set.image_injective]
    exact (ConcreteCategory.bijective_of_isIso iso.hom.val.base).injective
  apply this
  show Z = _
  rw [hI]
  erw [Scheme.zeroLocus_primeSpectrum_zeroLocus]

theorem surjective_of_closedInAffine_of_injective {X Y : Scheme} [IsAffine Y] [CompactSpace X]
    (f : X ‚ü∂ Y) (hfcl : IsClosed (Set.range f.val.base))
    (hfinj : Function.Injective (Scheme.Œì.map f.op)) :
    Function.Surjective f.val.base := by
  let A : CommRingCat := Scheme.Œì.obj (op Y)
  obtain ‚ü®I, hI‚ü© := eq_zeroLocus_of_isClosed Y (Set.range f.val.base) hfcl
  let œÜ : A ‚ü∂ Scheme.Œì.obj (op X) := Scheme.Œì.map f.op
  let ùí∞ : X.OpenCover := X.affineCover.finiteSubcover
  have (i : ùí∞.J) : IsAffine (ùí∞.obj i) :=
    Scheme.isAffine_affineCover X _
  let B (i : ùí∞.J) : CommRingCat := Scheme.Œì.obj (op <| ùí∞.obj i)
  let res (i : ùí∞.J) : Scheme.Œì.obj (op X) ‚ü∂ B i := Scheme.Œì.map (ùí∞.map i).op
  apply Set.range_iff_surjective.mp
  rw [hI]
  apply (Scheme.zeroLocus_eq_top_iff _).mpr
  have h1 (s : A) (hs : s ‚àà I) (i : ùí∞.J) (x : ùí∞.obj i) :
      (ùí∞.obj i).Œìevaluation x ((res i) (œÜ s)) = 0 := by
    let y : Y := f.val.base <| (ùí∞.map i).val.base x
    have hyinrange : y ‚àà Set.range f.val.base :=
      Set.mem_range_self ((ùí∞.map i).val.base x)
    have hys : Y.Œìevaluation y s = 0 := by
      rw [hI, Scheme.zeroLocus_mem] at hyinrange
      exact hyinrange s hs
    let f‚Çì := LocallyRingedSpace.evaluationMap (ùí∞.map i ‚â´ f) x
    have hdiag2 :
        (ùí∞.obj i).Œìevaluation x ((res i) (œÜ s)) = f‚Çì (Y.Œìevaluation y s) := by
      erw [evaluation_evaluationMap_apply]
      rfl
    rw [hdiag2, hys]
    simp
  have h3 (s : A) (hs : s ‚àà I) (i : ùí∞.J) : IsNilpotent ((res i) (œÜ s)) := by
    rw [Scheme.isNilpotent_iff]
    intro x
    apply h1 s hs i x
  intro s hs
  simp only [SetLike.mem_coe, mem_nilradical, ‚Üê IsNilpotent.map_iff hfinj]
  apply isNilpotent_of_isNilpotent_cover _ ùí∞
  exact h3 s hs

noncomputable instance {X : Scheme} (x : X) : Algebra (X.presheaf.obj { unop := ‚ä§ }) (X.presheaf.stalk x) :=
  TopCat.Presheaf.algebra_section_stalk X.presheaf (U := ‚ä§) ‚ü®x, trivial‚ü©

noncomputable instance {X : Scheme} (x : X) : Algebra (X.presheaf.obj { unop := ‚ä§ }) (X.stalk x) :=
  TopCat.Presheaf.algebra_section_stalk X.presheaf (U := ‚ä§) ‚ü®x, trivial‚ü©


noncomputable
def stalkIsoOfIso {X Y : Scheme} (e : X ‚âÖ Y) (x : X) : Y.stalk (e.hom.val.base x) ‚âÖ X.stalk x :=
  letI F := Scheme.forgetToLocallyRingedSpace ‚ãô
      LocallyRingedSpace.forgetToSheafedSpace ‚ãô SheafedSpace.forgetToPresheafedSpace
  PresheafedSpace.stalkMap.stalkIso (F.mapIso e) x

@[simp]
lemma stalkIsoOfIso_hom {X Y : Scheme} (e : X ‚âÖ Y) (x : X) :
    (stalkIsoOfIso e x).hom = X.stalkMap e.hom x :=
  rfl

set_option maxHeartbeats 1000000

lemma fooz {X : Scheme.{u}} [IsAffine X] (a : X.presheaf.obj (op ‚ä§)) :
    (StructureSheaf.toOpen (X.presheaf.obj (op ‚ä§)) ‚ä§
      ‚â´ X.isoSpec.hom.val.c.app { unop := ‚ä§ }) a = a := by
  simp only [Scheme.isoSpec]
  simp only [asIso_hom, TopCat.Presheaf.pushforwardObj_obj, Functor.op_obj, Opens.map_top]
  erw [ŒìSpec.toOpen_unit_app_val_c_app]
  simp
  rfl

lemma barz {X : Scheme.{u}} [IsAffine X] (x : X) (a : X.presheaf.obj (op ‚ä§)) :
    (X.presheaf.germ ‚ü®x, show x ‚àà ‚ä§ from trivial‚ü©) a = (stalkIsoOfIso X.isoSpec x).hom
      ((StructureSheaf.toStalk (X.presheaf.obj (op ‚ä§)) (X.isoSpec.hom.val.base x)) a) := by
  let R := X.presheaf.obj (op ‚ä§)
  rw [stalkIsoOfIso_hom]
  simp [LocallyRingedSpace.stalkMap]
  simp only [StructureSheaf.toStalk]
  show (X.presheaf.germ ‚ü®x, show x ‚àà ‚ä§ from trivial‚ü©) a =
      ((StructureSheaf.toOpen ‚ÜëR ‚ä§ ‚â´ (Spec.structureSheaf ‚ÜëR).presheaf.germ
        ‚ü®X.isoSpec.hom.val.base x, show X.isoSpec.hom.val.base x ‚àà ‚ä§ from trivial‚ü© ‚â´
          PresheafedSpace.stalkMap X.isoSpec.hom.val x)) a
  erw [PresheafedSpace.stalkMap_germ' X.isoSpec.hom.val ‚ä§]
  show (X.presheaf.germ ‚ü®x, show x ‚àà ‚ä§ from trivial‚ü©) a =
    X.presheaf.germ ‚ü®x, show x ‚àà ‚ä§ from trivial‚ü©
      ((StructureSheaf.toOpen ‚ÜëR ‚ä§ ‚â´ X.isoSpec.hom.val.c.app (op ‚ä§)) a)
  rw [fooz]

lemma isLocalizationAtPrime [IsAffine X] (x : X) :
    IsLocalization.AtPrime (R := X.presheaf.obj (op ‚ä§))
      (X.stalk x) (X.isoSpec.hom.val.base x).asIdeal := by
  let R := X.presheaf.obj (op ‚ä§)
  let p : PrimeSpectrum R := X.isoSpec.hom.val.base x
  have islocal := StructureSheaf.IsLocalization.to_stalk R p
  let i := X.isoSpec
  have : (Scheme.Spec.obj (op <| R)).presheaf = (Spec.structureSheaf R).presheaf := rfl
  let is : (Spec.structureSheaf R).presheaf.stalk p ‚âÖ X.stalk x :=
    stalkIsoOfIso i x
  have iff := IsLocalization.isLocalization_iff_of_ringEquiv p.asIdeal.primeCompl
    is.commRingCatIsoToRingEquiv
  have := iff.mp islocal
  show IsLocalization p.asIdeal.primeCompl ‚Üë(X.stalk x)
  convert this
  ext a b
  simp
  let inst1 := (is.commRingCatIsoToRingEquiv.toRingHom.comp
    (algebraMap R ((Spec.structureSheaf ‚ÜëR).presheaf.stalk p))).toAlgebra
  let inst2 := (instAlgebraŒ±CommRingObjOppositeOpensTopologicalSpaceCarrierCommRingCatPresheafOpTopStalk_1 x)
  rw [@Algebra.smul_def _ _ _ _ inst1]
  rw [@Algebra.smul_def (X.presheaf.obj { unop := ‚ä§ }) (X.stalk x) _ _ inst2 a b]
  have : (algebraMap (X.presheaf.obj { unop := ‚ä§ }) (X.stalk x)) a =
      (@algebraMap R (X.stalk x) _ _ (inst1) a) := by
    show (algebraMap ‚Üë(X.presheaf.obj { unop := ‚ä§ }) ‚Üë(X.stalk x)) a =
      (is.commRingCatIsoToRingEquiv.toRingHom.comp (algebraMap ‚ÜëR ‚Üë((Spec.structureSheaf ‚ÜëR).presheaf.stalk p))) a
    simp [is, i]
    erw [TopCat.Presheaf.stalk_open_algebraMap]
    apply barz
  rw [this]

lemma isLocalization [IsAffine X] (x : X) : ‚àÉ (M : Submonoid (X.presheaf.obj (op ‚ä§))),
    IsLocalization M (X.stalk x) := by
  use (X.isoSpec.hom.val.base x).asIdeal.primeCompl
  apply isLocalizationAtPrime

lemma injective_of_isLocalization {R S T} [CommRing R] (M : Submonoid R) [CommRing S] [Algebra R S]
    [IsLocalization M S] [CommRing T] (f : S ‚Üí+* T) :
    Function.Injective f ‚Üî ‚àÄ (x y : R),
      algebraMap R S x = algebraMap R S y ‚Üî f (algebraMap R S x) = f (algebraMap R S y) := by
  rw [‚Üê IsLocalization.lift_of_comp (M := M) f, IsLocalization.lift_injective_iff]
  simp

lemma injective_iff_of_isLocalization' {R S T} [CommRing R] (M : Submonoid R) [CommRing S] [Algebra R S]
    [IsLocalization M S] [CommRing T] (f : S ‚Üí+* T) :
    Function.Injective f ‚Üî ‚àÄ (x : R), algebraMap R S x = 0 ‚Üî f (algebraMap R S x) = 0 := by
  rw [injective_of_isLocalization M]
  constructor
  ¬∑ intro h x
    rw [‚Üê map_zero (algebraMap R S), ‚Üê map_zero f, ‚Üê map_zero (algebraMap R S)]
    exact h x 0
  ¬∑ intro h x y
    rw [‚Üê sub_eq_zero]
    nth_rw 2 [‚Üê sub_eq_zero]
    repeat rw [‚Üê map_sub]
    exact h (x - y)

lemma injective_of_isLocalization' {R S T} [CommRing R] (M : Submonoid R) [CommRing S] [Algebra R S]
    [IsLocalization M S] [CommRing T] (f : S ‚Üí+* T)
    (h : ‚àÄ (x : R), f (algebraMap R S x) = 0 ‚Üí algebraMap R S x = 0) :
    Function.Injective f := by
  rw [injective_iff_of_isLocalization' M]
  exact fun x ‚Ü¶ ‚ü®fun h ‚Ü¶ by rw [h]; simp, h x‚ü©

theorem stalkMap_injective_of {X Y : Scheme} (f : X ‚ü∂ Y) [IsAffine Y] (x : X)
    (h : ‚àÄ g,
      LocallyRingedSpace.stalkMap f x (Y.ŒìToStalk (f.val.base x) g) = 0 ‚Üí Y.ŒìToStalk (f.val.base x) g = 0) :
    Function.Injective (LocallyRingedSpace.stalkMap f x) := by
  obtain ‚ü®M, hM‚ü© := isLocalization (f.val.base x)
  apply injective_of_isLocalization' M
  exact h

lemma ŒìToStalk_eq_zero_of {X : Scheme} (x : X) (f s : Scheme.Œì.obj (op X)) (hx : x ‚àà X.basicOpen s)
    {n : ‚Ñï} (hf : s ^ n * f = 0) : X.ŒìToStalk x f = 0 := by
  rw [Scheme.mem_basicOpen_top] at hx
  replace hx : IsUnit (X.ŒìToStalk x s) := hx
  have hu : IsUnit (X.ŒìToStalk x (s ^ n)) := by
    rw [map_pow]
    exact IsUnit.pow n hx
  rw [‚Üê hu.mul_right_eq_zero, ‚Üê map_mul, hf, map_zero]

lemma pow_mul_eq_zero_of_le {R : Type*} [CommRing R] {a b : R} {m n : ‚Ñï} (hmn : m ‚â§ n)
    (h : a ^ m * b = 0) : a ^ n * b = 0 := by
  have : n = n - m + m := by
    omega
  rw [show n = n - m + m by omega, pow_add, mul_assoc, h]
  simp

lemma res_basicOpen_eq_iff_of_qcqs {X : Scheme} {U : TopologicalSpace.Opens X}
    (hU : IsCompact U.carrier) (hU' : IsQuasiSeparated U.carrier)
    (f g s : X.presheaf.obj (op U))
    (hf : (f |_ X.basicOpen s : (forget CommRingCat).obj _) = (g |_ X.basicOpen s)) :
    ‚àÉ n, s ^ n * f = s ^ n * g := by
  have hloc := is_localization_basicOpen_of_qcqs hU hU' s
  obtain ‚ü®‚ü®_, n, rfl‚ü©, hc‚ü© := hloc.exists_of_eq hf
  use n

lemma Œìres_basicOpen_eq_iff_of_qcqs {X : Scheme} [CompactSpace X] [QuasiSeparatedSpace X]
    (f g s : Scheme.Œì.obj (op X))
    (hf : (f |_ X.basicOpen s : (forget CommRingCat).obj _) = (g |_ X.basicOpen s)) :
    ‚àÉ n, s ^ n * f = s ^ n * g := by
  apply res_basicOpen_eq_iff_of_qcqs
  ¬∑ exact CompactSpace.isCompact_univ
  ¬∑ exact isQuasiSeparated_univ
  ¬∑ exact hf

@[simp]
lemma RingedSpace.res_zero {X : RingedSpace} {U V : TopologicalSpace.Opens X}
    (hUV : U ‚â§ V) : ((0 : X.presheaf.obj (op V)) |_ U : (forget CommRingCat).obj _) = 0 :=
  map_zero _

lemma res_basicOpen_zero_iff_of_qcqs {X : Scheme} {U : TopologicalSpace.Opens X}
    (hU : IsCompact U.carrier) (hU' : IsQuasiSeparated U.carrier)
    (f s : X.presheaf.obj (op U)) (hf : (f |_ X.basicOpen s : (forget CommRingCat).obj _) = 0) :
    ‚àÉ n, s ^ n * f = 0 := by
  have := by
    apply res_basicOpen_eq_iff_of_qcqs hU hU' f 0 s
    simp only [RingedSpace.res_zero]
    exact hf
  simp at this
  assumption

lemma Œìres_basicOpen_zero_iff_of_qcqs {X : Scheme} [CompactSpace X] [QuasiSeparatedSpace X]
    (f s : Scheme.Œì.obj (op X)) (hf : (f |_ X.basicOpen s : (forget CommRingCat).obj _) = 0) :
    ‚àÉ n, s ^ n * f = 0 := by
  apply res_basicOpen_zero_iff_of_qcqs
  ¬∑ exact CompactSpace.isCompact_univ
  ¬∑ exact isQuasiSeparated_univ
  ¬∑ exact hf

section

variable {X Y : Scheme} (f : X ‚ü∂ Y) (U : Opens Y) (s : Scheme.Œì.obj (op Y))

end

lemma pullback_zero_of_zero {X Y : Scheme} (f : X ‚ü∂ Y) (U : Opens Y) (s : Scheme.Œì.obj (op Y))
    (h : (s |_ U : (forget CommRingCat).obj _) = 0) :
    ((Scheme.Œì.map f.op s) |_ f‚Åª¬π·µÅ U : (forget CommRingCat).obj _) = 0 := by
  simp only [Functor.op_obj, inducedFunctor_obj, LocallyRingedSpace.forgetToSheafedSpace_obj,
    SheafedSpace.forgetToPresheafedSpace_obj, Scheme.Œì_obj, Scheme.Œì_map, Quiver.Hom.unop_op]
  let e : U ‚â§ ‚ä§ := le_top
  let i : op ‚ä§ ‚ü∂ op U := (homOfLE e).op
  show (f.app ‚ä§ ‚â´ X.presheaf.map ((Opens.map f.1.base).map i.unop).op) s = 0
  rw [‚Üê Scheme.Hom.naturality, comp_apply]
  show (Scheme.Hom.app f U) (s |_ U) = 0
  rw [h]
  simp

lemma map_le {X Y : Scheme} (f : X ‚ü∂ Y) {U V : Opens Y} (hUV : U ‚â§ V) :
    f‚Åª¬π·µÅ U ‚â§ f‚Åª¬π·µÅ V :=
  leOfHom <| (Opens.map f.val.base).map (homOfLE hUV)

theorem injective_on_stalks {X Y : Scheme} (f : X ‚ü∂ Y) [CompactSpace X] [IsAffine Y]
    (hfopen : IsOpenMap f.val.base)
    (hfinj‚ÇÅ : Function.Injective f.val.base)
    (hfinj‚ÇÇ : Function.Injective (Scheme.Œì.map f.op)) (x : X) :
    Function.Injective (LocallyRingedSpace.stalkMap f x) := by
  let A : CommRingCat := Scheme.Œì.obj (op Y)
  let œÜ : A ‚ü∂ Scheme.Œì.obj (op X) := Scheme.Œì.map f.op
  let ùí∞ : X.OpenCover := X.affineCover.finiteSubcover
  have (i : ùí∞.J) : IsAffine (ùí∞.obj i) := Scheme.isAffine_affineCover X _
  let res (i : ùí∞.J) : Scheme.Œì.obj (op X) ‚ü∂ Scheme.Œì.obj (op <| ùí∞.obj i) :=
    Scheme.Œì.map (ùí∞.map i).op
  apply stalkMap_injective_of
  intro (g : A) h
  erw [ŒìToStalk_stalkMap_apply] at h
  obtain ‚ü®U, _, (hx : x ‚àà U), hg‚ü© :=
    X.toRingedSpace.eq_zero_res_of_eq_zero_germ ‚ä§ (œÜ g) ‚ü®x, trivial‚ü© h
  let y : Y := f.val.base x
  let V : TopologicalSpace.Opens Y := ‚ü®f.val.base '' U.carrier, hfopen U.carrier U.is_open'‚ü©
  have hyv : y ‚àà V := by
    simp only [TopologicalSpace.Opens.carrier_eq_coe, TopologicalSpace.Opens.mem_mk, Set.mem_image,
      SetLike.mem_coe, V]
    use x
  have : TopologicalSpace.Opens.IsBasis (Set.range Y.basicOpen) := isBasis_basicOpen Y
  rw [Opens.isBasis_iff_nbhd] at this
  obtain ‚ü®V', ‚ü®(s : A), rfl‚ü©, hyv', yv'le‚ü© := this hyv
  let W (i : ùí∞.J) : TopologicalSpace.Opens (ùí∞.obj i) := ((ùí∞.obj i).basicOpen ((res i) (œÜ s)))
  let r (i : ùí∞.J) : (forget CommRingCat).obj ((ùí∞.obj i).presheaf.obj (op <| W i)) :=
    (res i) (œÜ g) |_ (W i)
  let r0 (i : ùí∞.J) : (forget CommRingCat).obj ((ùí∞.obj i).presheaf.obj (op <| (ùí∞.map i)‚Åª¬π·µÅ U)) :=
    ((res i) (œÜ g) |_ (ùí∞.map i)‚Åª¬π·µÅ U)
  have h00 (i : ùí∞.J) : r0 i = 0 := by
    dsimp only [r0, res]
    apply pullback_zero_of_zero
    exact hg
  have hwle (i : ùí∞.J) : W i ‚â§ (ùí∞.map i)‚Åª¬π·µÅ U := by
    show ((ùí∞.obj i).toRingedSpace.basicOpen ((ùí∞.map i ‚â´ f).val.c.app (op ‚ä§) s)) ‚â§ _
    erw [‚Üê LocallyRingedSpace.preimage_basicOpen (ùí∞.map i ‚â´ f) s]
    dsimp
    apply map_le
    apply map_le f at yv'le
    dsimp only [V] at yv'le
    trans
    exact yv'le
    apply le_of_eq
    apply Opens.ext
    apply Set.preimage_image_eq
    exact hfinj‚ÇÅ
  have h0 (i : ùí∞.J) : r i = 0 := by
    dsimp [r]
    rw [‚Üê TopCat.Presheaf.restrict_restrict (hwle i)]
    dsimp [r0] at h00
    rw [h00 i]
    rfl
  have h1 (i : ùí∞.J) : ‚àÉ n, (res i) (œÜ (s ^ n * g)) = 0 := by
    obtain ‚ü®n, hn‚ü© := Œìres_basicOpen_zero_iff_of_qcqs ((res i) (œÜ g)) ((res i) (œÜ s)) (h0 i)
    use n
    rwa [map_mul, map_mul, map_pow, map_pow]
  have h2 : ‚àÉ n, ‚àÄ i, (res i) (œÜ (s ^ n * g)) = 0 := by
    choose fn hfn using h1
    have : Fintype ùí∞.J := Fintype.ofFinite ùí∞.J
    /- the maximum of all `fn i` (exists, because `ùí∞.J` is finite) -/
    let N : ‚Ñï := Finset.sup Finset.univ fn
    have hfnleN (i : ùí∞.J) : fn i ‚â§ N := Finset.le_sup (Finset.mem_univ i)
    use N
    intro i
    rw [map_mul, map_pow, map_mul, map_pow]
    simp only [map_mul, map_pow, map_mul, map_pow] at hfn
    apply pow_mul_eq_zero_of_le (hfnleN i) (hfn i)
  obtain ‚ü®n, hn‚ü© := h2
  have h3 : œÜ (s ^ n * g) = 0 :=
    zero_of_zero_cover _ _ hn
  have h4 : s ^ n * g = 0 := by
    rw [RingHom.injective_iff_ker_eq_bot, RingHom.ker_eq_bot_iff_eq_zero] at hfinj‚ÇÇ
    exact hfinj‚ÇÇ _ h3
  exact ŒìToStalk_eq_zero_of y g s hyv' h4

theorem TopCat.isIso_of_bijective_of_isClosedMap {X Y : TopCat} (f : X ‚ü∂ Y)
    (hfbij : Function.Bijective f) (hfcl : IsClosedMap f) : IsIso f := by
  let e : X ‚âÉ‚Çú Y := Homeomorph.homeomorphOfContinuousClosed
    (Equiv.ofBijective f hfbij) f.continuous hfcl
  let i : X ‚âÖ Y := TopCat.isoOfHomeo e
  show IsIso i.hom
  infer_instance

theorem closedImmersion_affine_target_iso {X Y : Scheme} [IsAffine Y]
    (f : X ‚ü∂ Y) [IsClosedImmersion f] (hf : Function.Injective (Scheme.Œì.map f.op)) :
    IsIso f := by
  have : CompactSpace X := (closedEmbedding f).compactSpace
  have : IsIso f.val.base := by
    refine TopCat.isIso_of_bijective_of_isClosedMap _ ‚ü®?_, ?_‚ü© ?_
    ¬∑ exact (closedEmbedding f).inj
    ¬∑ apply surjective_of_closedInAffine_of_injective
      ¬∑ exact (closedEmbedding f).isClosed_range
      ¬∑ exact hf
    ¬∑ exact (closedEmbedding f).isClosedMap
  rw [isIso_iff_stalk_iso]
  constructor
  ¬∑ assumption
  ¬∑ intro x
    apply (ConcreteCategory.isIso_iff_bijective _).mpr
    constructor
    ¬∑ apply injective_on_stalks
      ¬∑ exact (TopCat.homeoOfIso (asIso f.val.base)).isOpenMap
      ¬∑ exact (closedEmbedding f).inj
      ¬∑ exact hf
    ¬∑ exact surjective_stalkMap f x

noncomputable example (A : CommRingCat) : Scheme.Œì.obj (op <| Spec A) ‚ü∂ A :=
  Scheme.SpecŒìIdentity.hom.app A

lemma toSpecŒì_ŒìSpec_adjunction_homEquiv {X : Scheme} {B : CommRingCat} (œÜ : B ‚ü∂ Scheme.Œì.obj (op X)) :
    toSpecŒì B ‚â´ ((ŒìSpec.adjunction.homEquiv X (op B)) œÜ.op).val.c.app (op ‚ä§) = œÜ := by
  rw [AlgebraicGeometry.ŒìSpec.adjunction_homEquiv]
  erw [AlgebraicGeometry.ŒìSpec.locallyRingedSpaceAdjunction_homEquiv_apply']
  show toSpecŒì B ‚â´ (Spec.locallyRingedSpaceMap œÜ).val.c.app (op ‚ä§) ‚â´
    (identityToŒìSpec.app X.toLocallyRingedSpace).val.c.app (op ‚ä§) = œÜ
  rw [‚Üê LocallyRingedSpace.SpecŒìIdentity_inv_app]
  convert_to œÜ ‚â´
    LocallyRingedSpace.SpecŒìIdentity.inv.app (LocallyRingedSpace.Œì.obj { unop := X.toLocallyRingedSpace }) ‚â´
     (identityToŒìSpec.app X.toLocallyRingedSpace).val.c.app (op ‚ä§) = œÜ
  have hfoo : toSpecŒì B ‚â´ StructureSheaf.comap œÜ ‚ä§ ‚ä§ (by trivial) = œÜ ‚â´ toSpecŒì Œì(X, ‚ä§) := by
    erw [Spec_Œì_naturality]
    simp
  ¬∑ simp only [Functor.comp_obj, Functor.rightOp_obj, LocallyRingedSpace.Œì_obj, Spec.toLocallyRingedSpace_obj,
      Spec.locallyRingedSpaceObj_toSheafedSpace, Spec.sheafedSpaceObj_carrier, Functor.id_obj,
      TopCat.Presheaf.pushforwardObj_obj, Functor.op_obj, Opens.map_top, Spec.sheafedSpaceObj_presheaf,
      LocallyRingedSpace.SpecŒìIdentity_inv_app, Scheme.Œì_obj, Spec.locallyRingedSpaceMap_val,
      Spec.sheafedSpaceMap_base, Spec.sheafedSpaceMap_c_app]
    rw [‚Üê Category.assoc]
    rw [‚Üê Category.assoc]
    rw [hfoo]
  ¬∑ rw [ŒìSpec.left_triangle X.toLocallyRingedSpace]
    simp

lemma ŒìSpec_adjunction_homEquiv_app_top {X : Scheme} {B : CommRingCat} (œÜ : B ‚ü∂ Scheme.Œì.obj (op X)) :
    (((ŒìSpec.adjunction.homEquiv X (op B)) œÜ.op).val.c.app (op ‚ä§)) = inv (toSpecŒì B) ‚â´ œÜ := by
  simp_rw [‚Üê toSpecŒì_ŒìSpec_adjunction_homEquiv œÜ]
  simp

set_option maxHeartbeats 500000

lemma specMap_app_top {A B : CommRingCat} (œÜ : A ‚ü∂ B) :
    (Spec.map œÜ).val.c.app (op ‚ä§) = inv (toSpecŒì A) ‚â´ œÜ ‚â´ toSpecŒì B := by
  rw [Spec_Œì_naturality]
  simp
  rfl

lemma specMap_app_top_surjective {A B : CommRingCat} (œÜ : A ‚ü∂ B) (hœÜ : Function.Surjective œÜ) :
    Function.Surjective ((Spec.map œÜ).val.c.app (op ‚ä§)) := by
  rw [specMap_app_top]
  erw [CommRingCat.coe_comp]
  erw [CommRingCat.coe_comp]
  apply Function.Surjective.comp
  ¬∑ apply Function.Surjective.comp
    ¬∑ apply Function.Bijective.surjective
      apply (ConcreteCategory.isIso_iff_bijective _).mp
      infer_instance
    ¬∑ exact hœÜ
  ¬∑ apply Function.Bijective.surjective
    apply (ConcreteCategory.isIso_iff_bijective _).mp
    infer_instance

theorem spec_target_factorization {X : Scheme} {A : CommRingCat} (f : X ‚ü∂ Spec A) :
    ‚àÉ (B : CommRingCat) (g : X ‚ü∂ Spec B) (h : A ‚ü∂ B),
      f = g ‚â´ Spec.map h ‚àß Function.Surjective h ‚àß
        Function.Injective (Scheme.Œì.map g.op) := by
  let œÜ : A ‚ü∂ Scheme.Œì.obj (op X) :=
    (((ŒìSpec.adjunction).homEquiv X (op A)).symm f).unop
  let I : Ideal A := RingHom.ker œÜ
  let B : CommRingCat := CommRingCat.of <| A ‚ß∏ I
  let œÜ' : B ‚ü∂ Scheme.Œì.obj (op X) := RingHom.kerLift œÜ
  have hinj : Function.Injective œÜ' := RingHom.kerLift_injective œÜ
  use B
  let g : X ‚ü∂ Spec B :=
    (ŒìSpec.adjunction).homEquiv X (op B) œÜ'.op
  use g
  let h : A ‚ü∂ B := Ideal.Quotient.mk I
  use h
  have hd : œÜ = h ‚â´ œÜ' := by
    ext a
    simp only [Scheme.Œì_obj, comp_apply]
    symm
    apply RingHom.kerLift_mk
  refine ‚ü®?_, ?_, ?_‚ü©
  ¬∑ apply ((ŒìSpec.adjunction).homEquiv X (op A)).symm.injective
    apply Opposite.unop_injective
    show œÜ = _
    rw [Adjunction.homEquiv_naturality_left_symm]
    rw [Adjunction.homEquiv_counit]
    show œÜ = _ ‚â´ _
    show œÜ = (_ ‚â´ _) ‚â´ _
    dsimp only [g]
    simp only [Scheme.Œì_obj, Functor.rightOp_obj, Scheme.Spec_obj, Functor.id_obj, ŒìSpec.adjunction_counit_app,
      Quiver.Hom.unop_op, Functor.rightOp_map, Scheme.Œì_map, Category.assoc]
    rw [‚Üê Category.assoc]
    erw [‚Üê Spec_Œì_naturality]
    simp
    show œÜ = h ‚â´ toSpecŒì B ‚â´ _
    erw [toSpecŒì_ŒìSpec_adjunction_homEquiv œÜ']
    exact hd
  ¬∑ exact Ideal.Quotient.mk_surjective
  ¬∑ simp only [g]
    simp only [Scheme.Œì_obj, Functor.rightOp_obj, Scheme.Spec_obj, Scheme.Œì_map, Scheme.Hom.app,
      Quiver.Hom.unop_op]
    erw [ŒìSpec_adjunction_homEquiv_app_top]
    erw [CommRingCat.coe_comp]
    apply Function.Injective.comp
    ¬∑ exact hinj
    ¬∑ apply Function.Bijective.injective
      apply (ConcreteCategory.isIso_iff_bijective _).mp
      infer_instance

instance (B : CommRingCat) : IsAffine (Spec B) := isAffine_Spec B

theorem affine_target_factorization {X Y : Scheme} [IsAffine Y] (f : X ‚ü∂ Y) :
    ‚àÉ (Z : Scheme) (g : X ‚ü∂ Z) (h : Z ‚ü∂ Y),
      f = g ‚â´ h ‚àß IsAffine Z ‚àß Function.Surjective (Scheme.Œì.map h.op) ‚àß
        Function.Injective (Scheme.Œì.map g.op) := by
  let isoY := Y.isoSpec
  obtain ‚ü®B, g, h, hcomp, hsurj, hinj‚ü© := spec_target_factorization (f ‚â´ isoY.hom)
  refine ‚ü®Spec B, g, Spec.map h ‚â´ isoY.inv, ?_, ?_, ?_, ?_‚ü©
  ¬∑ rw [‚Üê Category.assoc]
    rw [‚Üê hcomp]
    simp
  ¬∑ infer_instance
  ¬∑ simp
    rw [CommRingCat.coe_comp]
    apply (specMap_app_top_surjective h hsurj).comp
    ¬∑ apply Function.Bijective.surjective
      apply ConcreteCategory.bijective_of_isIso
  ¬∑ exact hinj

theorem closedImmersion_affine_target {X Y : Scheme} [IsAffine Y] (f : X ‚ü∂ Y)
    [IsClosedImmersion f] : IsAffine X ‚àß Function.Surjective (Scheme.Œì.map f.op) := by
  obtain ‚ü®Z, g, h, rfl, hZA, hh, hg‚ü© := affine_target_factorization f
  have : IsClosedImmersion h := of_surjective_of_affine h hh
  have : IsClosedImmersion g := IsClosedImmersion.of_comp g h
  have : IsIso g := closedImmersion_affine_target_iso g hg
  constructor
  ¬∑ apply isAffine_of_isIso g
  ¬∑ simp
    show Function.Surjective (_ ‚àò Scheme.Œì.map h.op)
    apply Function.Surjective.comp
    ¬∑ apply Function.Bijective.surjective
      apply ConcreteCategory.bijective_of_isIso
    ¬∑ exact hh

end Affine

section

end

open Limits

theorem closedImmersion_pullback_fst_of_isAffine {X Y Z : Scheme} [IsAffine X] [IsAffine Y] [IsAffine Z]
    (f : X ‚ü∂ Y) (g : Z ‚ü∂ Y) [IsClosedImmersion g]  :
    IsClosedImmersion (pullback.fst : pullback f g ‚ü∂ X) := by
  have : Function.Surjective (Scheme.Œì.map g.op) :=
    (closedImmersion_affine_target g).right
  apply of_surjective_of_affine
  apply (RingHom.surjective_stableUnderBaseChange).Œì_pullback_fst
  ¬∑ exact RingHom.surjective_respectsIso
  ¬∑ exact (closedImmersion_affine_target g).right

theorem closedImmersion_stableUnderBaseChange :
    MorphismProperty.StableUnderBaseChange @IsClosedImmersion := by
  apply MorphismProperty.stableUnderBaseChange_of_isLocalAtTarget_of_affine
  ¬∑ exact closedImmersion_localAtTarget
  ¬∑ apply MorphismProperty.StableUnderAffineBaseChange.mk
    ¬∑ exact respectsIso
    ¬∑ intro X Y S _ _ f g hg
      have : IsAffine Y := (closedImmersion_affine_target g).left
      exact closedImmersion_pullback_fst_of_isAffine f g

instance {X Y : Scheme} (f : X ‚ü∂ Y) [IsClosedImmersion f] : QuasiCompact f where
  isCompact_preimage _ _ hU' := base_closed.isCompact_preimage hU'

end IsClosedImmersion

end AlgebraicGeometry
