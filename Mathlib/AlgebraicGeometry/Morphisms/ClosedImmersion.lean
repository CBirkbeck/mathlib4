/-
Copyright (c) 2023 Jonas van der Schaaf. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Amelia Livingston, Christian Merten, Jonas van der Schaaf
-/
import Mathlib.AlgebraicGeometry.OpenImmersion
import Mathlib.CategoryTheory.MorphismProperty.Composition
import Mathlib.RingTheory.LocalProperties
import Mathlib.AlgebraicGeometry.Morphisms.Basic
import Mathlib.Topology.LocalAtTarget
import Mathlib.AlgebraicGeometry.Morphisms.QuasiSeparated
import Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties
import Mathlib.RingTheory.RingHom.Surjective

/-!

# Closed immersions of schemes

A morphism of schemes `f : X ‚ü∂ Y` is a closed immersion if the underlying map of topological spaces
is a closed immersion and the induced morphisms of stalks are all surjective.

## Main definitions

* `IsClosedImmersion` : The property of scheme morphisms stating `f : X ‚ü∂ Y` is a closed immersion.

## TODO

* Show closed immersions of affines are induced by surjective ring maps
* Show closed immersions are stable under pullback
* Show closed immersions are precisely the proper monomorphisms
* Define closed immersions of locally ringed spaces, where we also assume that the kernel of `O_X ‚Üí
  f_*O_Y` is locally generated by sections as an `O_X`-module, and relate it to this file. See
  https://stacks.math.columbia.edu/tag/01HJ.

-/

universe v u

open CategoryTheory

namespace AlgebraicGeometry

/-
@[mk_iff]
class IsSurjectiveOnStalks {X Y : Scheme} (f : X ‚ü∂ Y) : Prop where
  out : MorphismProperty.stalkwise (fun f ‚Ü¶ Function.Surjective f) f

lemma isSurjectiveOnStalks_eq_stalkwise_surjective :
    @IsSurjectiveOnStalks = MorphismProperty.stalkwise (fun f ‚Ü¶ Function.Surjective f) := by
  ext 
  exact isSurjectiveOnStalks_iff _
-/

/-- A morphism of schemes `X ‚ü∂ Y` is a closed immersion if the underlying
topological map is a closed embedding and the induced stalk maps are surjective. -/
@[mk_iff]
class IsClosedImmersion {X Y : Scheme} (f : X ‚ü∂ Y) : Prop where
  base_closed : MorphismProperty.topologically ClosedEmbedding f
  surj_on_stalks : MorphismProperty.stalkwise (fun f ‚Ü¶ Function.Surjective f) f

namespace IsClosedImmersion

lemma closedEmbedding {X Y : Scheme} (f : X ‚ü∂ Y)
    [IsClosedImmersion f] : ClosedEmbedding f.1.base :=
  IsClosedImmersion.base_closed

lemma surjective_stalkMap {X Y : Scheme} (f : X ‚ü∂ Y)
    [IsClosedImmersion f] (x : X) : Function.Surjective (PresheafedSpace.stalkMap f.1 x) :=
  IsClosedImmersion.surj_on_stalks x

/-- Isomorphisms are closed immersions. -/
instance {X Y : Scheme} (f : X ‚ü∂ Y) [IsIso f] : IsClosedImmersion f where
  base_closed := Homeomorph.closedEmbedding <| TopCat.homeoOfIso (asIso f.1.base)
  surj_on_stalks := fun _ ‚Ü¶ (ConcreteCategory.bijective_of_isIso _).2

instance : MorphismProperty.IsMultiplicative @IsClosedImmersion where
  id_mem _ := inferInstance
  comp_mem {X Y Z} f g hf hg := by
    refine ‚ü®hg.base_closed.comp hf.base_closed, fun x ‚Ü¶ ?_‚ü©
    erw [PresheafedSpace.stalkMap.comp]
    exact (hf.surj_on_stalks x).comp (hg.surj_on_stalks (f.1.1 x))

/-
instance {X Y : Scheme} (f : X ‚ü∂ Y) [IsIso f] : IsSurjectiveOnStalks f where
  out := fun _ ‚Ü¶ (ConcreteCategory.bijective_of_isIso _).2
-/

/-
instance : MorphismProperty.IsMultiplicative @IsSurjectiveOnStalks where
  id_mem _ := inferInstance
  comp_mem {X Y Z} f g hf hg := by
    constructor
    intro x
    erw [PresheafedSpace.stalkMap.comp]
    exact (hf.out x).comp (hg.out (f.1.1 x))
-/

/-- Composition of closed immersions is a closed immersion. -/
instance comp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsClosedImmersion f]
    [IsClosedImmersion g] : IsClosedImmersion (f ‚â´ g) :=
  MorphismProperty.IsStableUnderComposition.comp_mem f g inferInstance inferInstance

/-
/-- Composition of closed immersions is a closed immersion. -/
instance comp' {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsSurjectiveOnStalks f]
    [IsSurjectiveOnStalks g] : IsSurjectiveOnStalks (f ‚â´ g) :=
  MorphismProperty.IsStableUnderComposition.comp_mem f g inferInstance inferInstance
-/

/-- Composition with an isomorphism preserves closed immersions. -/
lemma respectsIso : MorphismProperty.RespectsIso @IsClosedImmersion := by
  constructor <;> intro X Y Z e f hf <;> infer_instance

/-- Given two commutative rings `R S : CommRingCat` and a surjective morphism
`f : R ‚ü∂ S`, the induced scheme morphism `specObj S ‚ü∂ specObj R` is a
closed immersion. -/
theorem spec_of_surjective {R S : CommRingCat} (f : R ‚ü∂ S) (h : Function.Surjective f) :
    IsClosedImmersion (Scheme.specMap f) where
  base_closed := PrimeSpectrum.closedEmbedding_comap_of_surjective _ _ h
  surj_on_stalks x := by
    dsimp
    erw [‚Üê localRingHom_comp_stalkIso, CommRingCat.coe_comp, CommRingCat.coe_comp]
    apply Function.Surjective.comp (Function.Surjective.comp _ _) _
    ¬∑ exact (ConcreteCategory.bijective_of_isIso (StructureSheaf.stalkIso S x).inv).2
    ¬∑ exact surjective_localRingHom_of_surjective f h x.asIdeal
    ¬∑ let g := (StructureSheaf.stalkIso ((CommRingCat.of R))
        ((PrimeSpectrum.comap (CommRingCat.ofHom f)) x)).hom
      exact (ConcreteCategory.bijective_of_isIso g).2

open Opposite

lemma specMap_Œì_map {X Y : Scheme} [IsAffine X] [IsAffine Y] (f : X ‚ü∂ Y) :
    Scheme.specMap (Scheme.Œì.map f.op) = X.isoSpec.inv ‚â´ f ‚â´ Y.isoSpec.hom := by
  erw [IsIso.eq_inv_comp]
  apply Adjunction.unit_naturality

theorem of_surjective_of_affine {X Y : Scheme} [IsAffine X] [IsAffine Y] (f : X ‚ü∂ Y)
    (h : Function.Surjective (Scheme.Œì.map f.op)) : IsClosedImmersion f := by
  have he : IsClosedImmersion (X.isoSpec.inv ‚â´ f ‚â´ Y.isoSpec.hom) := by
    rw [‚Üê specMap_Œì_map f]
    apply spec_of_surjective
    exact h
  rw [respectsIso.cancel_left_isIso] at he
  rw [respectsIso.cancel_right_isIso] at he
  exact he

/-- For any ideal `I` in a commutative ring `R`, the quotient map `specObj R ‚ü∂ specObj (R ‚ß∏ I)`
is a closed immersion. -/
instance spec_of_quotient_mk {R : CommRingCat.{u}} (I : Ideal R) :
    IsClosedImmersion (Scheme.specMap (CommRingCat.ofHom (Ideal.Quotient.mk I))) :=
  spec_of_surjective _ Ideal.Quotient.mk_surjective

/-- If `f ‚â´ g` is a closed immersion, then `f` is a closed immersion. -/
theorem of_comp {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsClosedImmersion g]
    [IsClosedImmersion (f ‚â´ g)] : IsClosedImmersion f where
  base_closed := by
    have h := closedEmbedding (f ‚â´ g)
    rw [Scheme.comp_val_base] at h
    apply closedEmbedding_of_continuous_injective_closed (Scheme.Hom.continuous f)
    ¬∑ exact Function.Injective.of_comp h.inj
    ¬∑ intro Z hZ
      rw [ClosedEmbedding.closed_iff_image_closed (closedEmbedding g),
        ‚Üê Set.image_comp]
      exact ClosedEmbedding.isClosedMap h _ hZ
  surj_on_stalks x := by
    have h := surjective_stalkMap (f ‚â´ g) x
    erw [Scheme.comp_val, PresheafedSpace.stalkMap.comp] at h
    exact Function.Surjective.of_comp h

theorem closedEmbedding_localAtTarget : PropertyIsLocalAtTarget
    (MorphismProperty.topologically ClosedEmbedding) := by
  apply topologicallyIsLocalAtTargetOfMorphismRestrict
  ¬∑ apply topologicallyRespectsIso
    ¬∑ intro X Y _ _ e
      exact Homeomorph.closedEmbedding e
    ¬∑ intro X Y Z _ _ _ f g hf hg
      exact ClosedEmbedding.comp hg hf
  ¬∑ intro X Y _ _ f s hf
    exact ClosedEmbedding.restrictPreimage s hf
  ¬∑ intro X Y _ _ f Œπ U hU hfcont hf
    apply (closedEmbedding_iff_closedEmbedding_of_iSup_eq_top hU hfcont).mpr hf

theorem surjective_respectsIso :
    RingHom.RespectsIso (fun f ‚Ü¶ Function.Surjective f) := by
  apply RingHom.StableUnderComposition.respectsIso
  ¬∑ intro R S T _ _ _ f g hf hg
    simp only [RingHom.coe_comp]
    exact Function.Surjective.comp hg hf
  ¬∑ intro R S _ _ e
    exact EquivLike.surjective e

theorem isSurjectiveOnStalks_localAtTarget : PropertyIsLocalAtTarget
      (MorphismProperty.stalkwise (fun f ‚Ü¶ Function.Surjective f)) := by
  apply stalkwiseIsLocalAtTarget_of_respectsIso
  exact surjective_respectsIso

/-
TODO: can we write a general helper (ideally n-ary) to obtain this?
-> write MorphismProperty.and
-/
/-- Closed immersions are local at the target. -/
theorem closedImmersion_localAtTarget :
    PropertyIsLocalAtTarget @IsClosedImmersion where
  RespectsIso := respectsIso
  restrict f U hf := by
    constructor
    ¬∑ exact closedEmbedding_localAtTarget.restrict f U hf.base_closed
    . exact isSurjectiveOnStalks_localAtTarget.restrict f U hf.surj_on_stalks
  of_openCover f ùí∞ hf := by
    constructor
    ¬∑ exact closedEmbedding_localAtTarget.of_openCover f ùí∞ (fun i ‚Ü¶ (hf i).base_closed)
    ¬∑ exact isSurjectiveOnStalks_localAtTarget.of_openCover f ùí∞ (fun i ‚Ü¶ (hf i).surj_on_stalks)

section Affine

section

variable {X Y : Scheme} (f : X ‚ü∂ Y) (x : X) (s : Scheme.Œì.obj <| op X)

example : X.presheaf.obj (op ‚ä§) := s

variable (t : Scheme.Œì.obj <| op Y)

end

variable (A : Type u) [CommRing A]
variable {X : Scheme.{u}}

open TopologicalSpace

lemma eq_of_eq_cover (f g : Scheme.Œì.obj (op X)) (ùí∞ : X.OpenCover)
    (h : ‚àÄ i : ùí∞.J, Scheme.Œì.map (ùí∞.map i).op f = Scheme.Œì.map (ùí∞.map i).op g) : f = g := by
  sorry
  --let Œπ : Type _ := sorry
  --let U (i : Œπ) : Opens X := sorry
  --apply TopCat.Sheaf.eq_of_locally_eq' X.sheaf U ‚ä§ (fun i ‚Ü¶ (U i).leTop)
  --¬∑ sorry
  --¬∑ intro i
  --  sorry

lemma zero_of_zero_cover (s : Scheme.Œì.obj (op X)) (ùí∞ : X.OpenCover)
    (h : ‚àÄ i : ùí∞.J, Scheme.Œì.map (ùí∞.map i).op s = 0) : s = 0 := by
  apply eq_of_eq_cover s 0 _
  intro i
  rw [map_zero]
  exact h i

lemma isNilpotent_of_isNilpotent_cover (s : Scheme.Œì.obj (op X)) (ùí∞ : X.OpenCover)
    [Finite ùí∞.J] (h : ‚àÄ i : ùí∞.J, IsNilpotent (Scheme.Œì.map (ùí∞.map i).op s)) : IsNilpotent s := by
  choose fn hfn using h
  have : Fintype ùí∞.J := Fintype.ofFinite ùí∞.J
  /- the maximum of all `fn i` (exists, because `ùí∞.J` is finite) -/
  let N : ‚Ñï := Finset.sup Finset.univ fn
  have hfnleN (i : ùí∞.J) : fn i ‚â§ N := Finset.le_sup (Finset.mem_univ i)
  use N
  apply zero_of_zero_cover
  intro i
  simp only [map_pow]
  exact pow_eq_zero_of_le (hfnleN i) (hfn i)

lemma ŒìToStalk_stalkMap {X Y : Scheme} (f : X ‚ü∂ Y) (x : X) :
    Y.ŒìToStalk (f.val.base x) ‚â´ PresheafedSpace.stalkMap f.val x =
      Scheme.Œì.map f.op ‚â´ X.ŒìToStalk x :=
  sorry

noncomputable def _root_.AlgebraicGeometry.LocallyRingedSpace.ResidueField
    (X : LocallyRingedSpace) (x : X) : CommRingCat :=
  CommRingCat.of <| LocalRing.ResidueField (X.stalk x)

noncomputable def _root_.AlgebraicGeometry.LocallyRingedSpace.evaluation (X : LocallyRingedSpace)
    {U : TopologicalSpace.Opens X} (x : U) :
    X.presheaf.obj (op U) ‚ü∂ X.ResidueField x :=
  X.presheaf.germ x ‚â´ LocalRing.residue _

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.evaluation_eq_zero_iff_mem_maximalIdeal
    (X : LocallyRingedSpace) {U : TopologicalSpace.Opens X} (x : U) (f : X.presheaf.obj (op U)) :
    X.evaluation x f = 0 ‚Üî (X.presheaf.germ x) f ‚àà LocalRing.maximalIdeal (X.stalk x) :=
  LocalRing.residue_eq_zero_iff _

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.evaluation_ne_zero_iff_isUnit
    (X : LocallyRingedSpace) {U : TopologicalSpace.Opens X} (x : U) (f : X.presheaf.obj (op U)) :
    X.evaluation x f ‚â† 0 ‚Üî IsUnit ((X.presheaf.germ x) f) :=
  LocalRing.residue_ne_zero_iff_isUnit _

noncomputable def _root_.AlgebraicGeometry.LocallyRingedSpace.Œìevaluation (X : LocallyRingedSpace)
    (x : X) :
    LocallyRingedSpace.Œì.obj (op X) ‚ü∂ X.ResidueField x :=
  X.evaluation ‚ü®x, show x ‚àà ‚ä§ from trivial‚ü©

--lemma _root_.AlgebraicGeometry.LocallyRingedSpace.Œìevaluation_eq_zero_iff_mem_maximalIdeal
--    (X : LocallyRingedSpace) (x : X) (f : LocallyRingedSpace.Œì.obj (op X)) :
--    X.Œìevaluation x f = 0 ‚Üî (X.presheaf.germ x) f ‚àà LocalRing.maximalIdeal (X.stalk x) :=
--  LocalRing.residue_eq_zero_iff _

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.Œìevaluation_ne_zero_iff_isUnit
    (X : LocallyRingedSpace) {U : TopologicalSpace.Opens X} (x : U) (f : X.presheaf.obj (op U)) :
    X.evaluation x f ‚â† 0 ‚Üî IsUnit ((X.presheaf.germ x) f) :=
  LocalRing.residue_ne_zero_iff_isUnit _

noncomputable def _root_.AlgebraicGeometry.LocallyRingedSpace.evaluationMap
    {X Y : LocallyRingedSpace} (f : X ‚ü∂ Y) (x : X) :
    Y.ResidueField (f.val.base x) ‚ü∂ X.ResidueField x :=
  LocalRing.ResidueField.map (LocallyRingedSpace.stalkMap f x)

lemma _root_.AlgebraicGeometry.LocallyRingedSpace.mem_basicOpen (X : LocallyRingedSpace)
    {U : TopologicalSpace.Opens X}
    (f : X.presheaf.obj (op U)) (x : U) :
    x.val ‚àà X.toRingedSpace.basicOpen f ‚Üî X.evaluation x f ‚â† 0 := by
  rw [X.toRingedSpace.mem_basicOpen f x]
  exact (X.evaluation_ne_zero_iff_isUnit x f).symm

lemma evaluation_evaluationMap {X Y : Scheme} (f : X ‚ü∂ Y) (x : X) :
    Y.Œìevaluation (f.val.base x) ‚â´ LocallyRingedSpace.evaluationMap f x =
      Scheme.Œì.map f.op ‚â´ X.Œìevaluation x :=
  sorry

lemma evaluation_evaluationMap_apply {X Y : Scheme} (f : X ‚ü∂ Y) (x : X) (a : Scheme.Œì.obj (op Y)) :
    LocallyRingedSpace.evaluationMap f x (Y.Œìevaluation (f.val.base x) a) =
      X.Œìevaluation x (Scheme.Œì.map f.op a) :=
  sorry

lemma ŒìToStalk_stalkMap_apply {X Y : Scheme} (f : X ‚ü∂ Y) (x : X) (a : Scheme.Œì.obj (op Y)) :
    PresheafedSpace.stalkMap f.val x (Y.ŒìToStalk (f.val.base x) a) =
      X.ŒìToStalk x (Scheme.Œì.map f.op a) :=
  sorry

def _root_.AlgebraicGeometry.RingedSpace.zeroLocus {X : RingedSpace}
    (s : Set (X.presheaf.obj (op ‚ä§))) : Set X :=
  sInf { (X.basicOpen f : Set X)·∂ú | (f ‚àà s) }

lemma _root_.AlgebraicGeometry.RingedSpace.mem_zeroLocus_iff {X : RingedSpace}
    (s : Set (X.presheaf.obj (op ‚ä§))) : True :=
  sorry

lemma Scheme.zeroLocus_primeSpectrum_zeroLocus {X : Scheme} [IsAffine X] (s : Set (Scheme.Œì.obj (op X))) :
    X.isoSpec.hom.val.base '' RingedSpace.zeroLocus s = PrimeSpectrum.zeroLocus s :=
  sorry

lemma Scheme.zeroLocus_eq_top_iff {X : Scheme} [IsAffine X] (s : Set (Scheme.Œì.obj (op X))) :
    RingedSpace.zeroLocus s = ‚ä§ ‚Üî s ‚äÜ nilradical (Scheme.Œì.obj (op X)) :=
  sorry

lemma Scheme.zeroLocus_mem {X : Scheme} [IsAffine X] (s : Set (Scheme.Œì.obj (op X)))
    (x : X) : x ‚àà RingedSpace.zeroLocus s ‚Üî ‚àÄ f ‚àà s, X.Œìevaluation x f = 0 :=
  sorry

lemma Scheme.isNilpotent_iff {X : Scheme} [IsAffine X] (f : Scheme.Œì.obj (op X)) :
    IsNilpotent f ‚Üî ‚àÄ x, X.Œìevaluation x f = 0 := by
  rw [nilpotent_iff_mem_prime]
  constructor
  ¬∑ intro h x
    sorry
  ¬∑ sorry

theorem eq_zeroLocus_of_isClosed (X : Scheme) [IsAffine X] (s : Set X.carrier) (hs : IsClosed s) :
    ‚àÉ I : Ideal (Scheme.Œì.obj (op X)), s = RingedSpace.zeroLocus (I : Set (Scheme.Œì.obj (op X))) := by
  let A : CommRingCat := Scheme.Œì.obj (op X)
  let iso : X ‚âÖ Scheme.specObj A := Scheme.isoSpec X
  let Z : Set (Scheme.specObj A) := iso.hom.val.base '' s
  have hZ : IsClosed Z :=
    (TopCat.homeoOfIso (asIso <| iso.hom.val.base)).isClosedMap _ hs
  obtain ‚ü®I, (hI : Z = _)‚ü© := (PrimeSpectrum.isClosed_iff_zeroLocus_ideal _).mp hZ
  use I
  have : Function.Injective (Set.image iso.hom.val.base) := by
    simp only [Set.image_injective]
    exact (ConcreteCategory.bijective_of_isIso iso.hom.val.base).injective
  apply this
  show Z = _
  rw [hI]
  erw [Scheme.zeroLocus_primeSpectrum_zeroLocus]

theorem surjective_of_closedInAffine_of_injective {X Y : Scheme} [IsAffine Y] [CompactSpace X]
    (f : X ‚ü∂ Y) (hfcl : IsClosed (Set.range f.val.base))
    (hfinj : Function.Injective (Scheme.Œì.map f.op)) :
    Function.Surjective f.val.base := by
  let A : CommRingCat := Scheme.Œì.obj (op Y)
  obtain ‚ü®I, hI‚ü© := eq_zeroLocus_of_isClosed Y (Set.range f.val.base) hfcl
  let œÜ : A ‚ü∂ Scheme.Œì.obj (op X) := Scheme.Œì.map f.op
  let ùí∞ : X.OpenCover := X.affineCover.finiteSubcover
  have (i : ùí∞.J) : IsAffine (ùí∞.obj i) :=
    Scheme.affineCoverIsAffine X _
  let B (i : ùí∞.J) : CommRingCat := Scheme.Œì.obj (op <| ùí∞.obj i)
  let res (i : ùí∞.J) : Scheme.Œì.obj (op X) ‚ü∂ B i := Scheme.Œì.map (ùí∞.map i).op
  apply Set.range_iff_surjective.mp
  rw [hI]
  apply (Scheme.zeroLocus_eq_top_iff _).mpr
  have h1 (s : A) (hs : s ‚àà I) (i : ùí∞.J) (x : ùí∞.obj i) :
      (ùí∞.obj i).Œìevaluation x ((res i) (œÜ s)) = 0 := by
    let y : Y := f.val.base <| (ùí∞.map i).val.base x
    have hyinrange : y ‚àà Set.range f.val.base :=
      Set.mem_range_self ((ùí∞.map i).val.base x)
    have hys : Y.Œìevaluation y s = 0 := by
      rw [hI, Scheme.zeroLocus_mem] at hyinrange
      exact hyinrange s hs
    let f‚Çì := LocallyRingedSpace.evaluationMap (ùí∞.map i ‚â´ f) x
    have hdiag2 :
        (ùí∞.obj i).Œìevaluation x ((res i) (œÜ s)) = f‚Çì (Y.Œìevaluation y s) := by
      erw [evaluation_evaluationMap_apply]
      rfl
    rw [hdiag2, hys]
    simp
  have h3 (s : A) (hs : s ‚àà I) (i : ùí∞.J) : IsNilpotent ((res i) (œÜ s)) := by
    rw [Scheme.isNilpotent_iff]
    intro x
    apply h1 s hs i x
  intro s hs
  simp only [SetLike.mem_coe, mem_nilradical, ‚Üê IsNilpotent.map_iff hfinj]
  apply isNilpotent_of_isNilpotent_cover _ ùí∞
  exact h3 s hs

theorem stalkMap_injective_of {X Y : Scheme} (f : X ‚ü∂ Y) [IsAffine Y] (x : X)
    (h : ‚àÄ g,
      LocallyRingedSpace.stalkMap f x (Y.ŒìToStalk (f.val.base x) g) = 0 ‚Üí Y.ŒìToStalk (f.val.base x) g = 0) :
    Function.Injective (LocallyRingedSpace.stalkMap f x) := by
  --rw [RingHom.injective_iff_ker_eq_bot, RingHom.ker_eq_bot_iff_eq_zero]
  sorry

lemma ŒìToStalk_eq_zero_of {X : Scheme} (x : X) (f s : Scheme.Œì.obj (op X)) (hx : x ‚àà X.basicOpen s)
    {n : ‚Ñï} (hf : s ^ n * f = 0) : X.ŒìToStalk x f = 0 :=
  sorry

lemma pow_mul_eq_zero_of_le {R : Type*} [CommRing R] {a b : R} {m n : ‚Ñï} (hmn : m ‚â§ n)
    (h : a ^ m * b = 0) : a ^ n * b = 0 :=
  sorry

lemma res_basicOpen_zero_iff_of_qcqs {X : Scheme} {U : TopologicalSpace.Opens X}
    (hU : IsCompact U.carrier) (hU' : IsQuasiSeparated U.carrier)
    (f s : X.presheaf.obj (op U)) (hf : (f |_ X.basicOpen s : (forget CommRingCat).obj _) = 0) :
    ‚àÉ n, s ^ n * f = 0 := by
  have := is_localization_basicOpen_of_qcqs hU hU' s
  sorry

lemma Œìres_basicOpen_zero_iff_of_qcqs {X : Scheme} [CompactSpace X] [QuasiSeparatedSpace X]
    (f s : Scheme.Œì.obj (op X)) (hf : (f |_ X.basicOpen s : (forget CommRingCat).obj _) = 0) :
    ‚àÉ n, s ^ n * f = 0 := by
  sorry

section

variable {X Y : Scheme} (f : X ‚ü∂ Y) (U : Opens Y) (s : Scheme.Œì.obj (op Y))

end

lemma pullback_zero_of_zero {X Y : Scheme} (f : X ‚ü∂ Y) (U : Opens Y) (s : Scheme.Œì.obj (op Y))
    (h : (s |_ U : (forget CommRingCat).obj _) = 0) :
    ((Scheme.Œì.map f.op s) |_ f‚Åª¬π·µÅ U : (forget CommRingCat).obj _) = 0 :=
  sorry

lemma map_le {X Y : Scheme} (f : X ‚ü∂ Y) {U V : Opens Y} (hUV : U ‚â§ V) :
    f‚Åª¬π·µÅ U ‚â§ f‚Åª¬π·µÅ V :=
  sorry

theorem injective_on_stalks {X Y : Scheme} (f : X ‚ü∂ Y) [CompactSpace X] [IsAffine Y]
    (hfopen : IsOpenMap f.val.base)
    (hfinj‚ÇÅ : Function.Injective f.val.base)
    (hfinj‚ÇÇ : Function.Injective (Scheme.Œì.map f.op)) (x : X) :
    Function.Injective (LocallyRingedSpace.stalkMap f x) := by
  let A : CommRingCat := Scheme.Œì.obj (op Y)
  let œÜ : A ‚ü∂ Scheme.Œì.obj (op X) := Scheme.Œì.map f.op
  let ùí∞ : X.OpenCover := X.affineCover.finiteSubcover
  have (i : ùí∞.J) : IsAffine (ùí∞.obj i) := Scheme.affineCoverIsAffine X _
  let res (i : ùí∞.J) : Scheme.Œì.obj (op X) ‚ü∂ Scheme.Œì.obj (op <| ùí∞.obj i) :=
    Scheme.Œì.map (ùí∞.map i).op
  apply stalkMap_injective_of
  intro (g : A) h
  erw [ŒìToStalk_stalkMap_apply] at h
  obtain ‚ü®U, _, (hx : x ‚àà U), hg‚ü© :=
    X.toRingedSpace.eq_zero_res_of_eq_zero_germ ‚ä§ (œÜ g) ‚ü®x, trivial‚ü© h
  let y : Y := f.val.base x
  let V : TopologicalSpace.Opens Y := ‚ü®f.val.base '' U.carrier, hfopen U.carrier U.is_open'‚ü©
  have hyv : y ‚àà V := by
    simp only [TopologicalSpace.Opens.carrier_eq_coe, TopologicalSpace.Opens.mem_mk, Set.mem_image,
      SetLike.mem_coe, V]
    use x
  have : TopologicalSpace.Opens.IsBasis (Set.range Y.basicOpen) := isBasis_basicOpen Y
  rw [Opens.isBasis_iff_nbhd] at this
  obtain ‚ü®V', ‚ü®(s : A), rfl‚ü©, hyv', yv'le‚ü© := this hyv
  let W (i : ùí∞.J) : TopologicalSpace.Opens (ùí∞.obj i) := ((ùí∞.obj i).basicOpen ((res i) (œÜ s)))
  let r (i : ùí∞.J) : (forget CommRingCat).obj ((ùí∞.obj i).presheaf.obj (op <| W i)) :=
    (res i) (œÜ g) |_ (W i)
  let r0 (i : ùí∞.J) : (forget CommRingCat).obj ((ùí∞.obj i).presheaf.obj (op <| (ùí∞.map i)‚Åª¬π·µÅ U)) :=
    ((res i) (œÜ g) |_ (ùí∞.map i)‚Åª¬π·µÅ U)
  have h00 (i : ùí∞.J) : r0 i = 0 := by
    dsimp only [r0, res]
    apply pullback_zero_of_zero
    exact hg
  have hwle (i : ùí∞.J) : W i ‚â§ (ùí∞.map i)‚Åª¬π·µÅ U := by
    show ((ùí∞.obj i).toRingedSpace.basicOpen ((ùí∞.map i ‚â´ f).val.c.app (op ‚ä§) s)) ‚â§ _
    erw [‚Üê LocallyRingedSpace.preimage_basicOpen (ùí∞.map i ‚â´ f) s]
    dsimp
    apply map_le
    apply map_le f at yv'le
    dsimp only [V] at yv'le
    trans
    exact yv'le
    apply le_of_eq
    apply Opens.ext
    apply Set.preimage_image_eq
    exact hfinj‚ÇÅ
  have h0 (i : ùí∞.J) : r i = 0 := by
    dsimp [r]
    rw [‚Üê TopCat.Presheaf.restrict_restrict (hwle i)]
    dsimp [r0] at h00
    rw [h00 i]
    rfl
  have h1 (i : ùí∞.J) : ‚àÉ n, (res i) (œÜ (s ^ n * g)) = 0 := by
    obtain ‚ü®n, hn‚ü© := Œìres_basicOpen_zero_iff_of_qcqs ((res i) (œÜ g)) ((res i) (œÜ s)) (h0 i)
    use n
    simpa
  have h2 : ‚àÉ n, ‚àÄ i, (res i) (œÜ (s ^ n * g)) = 0 := by
    choose fn hfn using h1
    have : Fintype ùí∞.J := Fintype.ofFinite ùí∞.J
    /- the maximum of all `fn i` (exists, because `ùí∞.J` is finite) -/
    let N : ‚Ñï := Finset.sup Finset.univ fn
    have hfnleN (i : ùí∞.J) : fn i ‚â§ N := Finset.le_sup (Finset.mem_univ i)
    use N
    intro i
    rw [map_mul, map_pow, map_mul, map_pow]
    simp only [map_mul, map_pow, map_mul, map_pow] at hfn
    apply pow_mul_eq_zero_of_le (hfnleN i) (hfn i)
  obtain ‚ü®n, hn‚ü© := h2
  have h3 : œÜ (s ^ n * g) = 0 :=
    zero_of_zero_cover _ _ hn
  have h4 : s ^ n * g = 0 := by
    rw [RingHom.injective_iff_ker_eq_bot, RingHom.ker_eq_bot_iff_eq_zero] at hfinj‚ÇÇ
    exact hfinj‚ÇÇ _ h3
  exact ŒìToStalk_eq_zero_of y g s hyv' h4

theorem TopCat.isIso_of_bijective_of_isClosedMap {X Y : TopCat} (f : X ‚ü∂ Y)
    (hfbij : Function.Bijective f) (hfcl : IsClosedMap f) : IsIso f := by
  let e : X ‚âÉ‚Çú Y := sorry
  sorry

theorem closedImmersion_affine_target_iso {X Y : Scheme} [IsAffine Y]
    (f : X ‚ü∂ Y) [IsClosedImmersion f] (hf : Function.Injective (Scheme.Œì.map f.op)) :
    IsIso f := by
  have : CompactSpace X := (closedEmbedding f).compactSpace
  have : IsIso f.val.base := by
    refine TopCat.isIso_of_bijective_of_isClosedMap _ ‚ü®?_, ?_‚ü© ?_
    ¬∑ exact (closedEmbedding f).inj
    ¬∑ apply surjective_of_closedInAffine_of_injective
      ¬∑ exact (closedEmbedding f).isClosed_range
      ¬∑ exact hf
    ¬∑ exact (closedEmbedding f).isClosedMap
  rw [isIso_iff_stalk_iso]
  constructor
  ¬∑ assumption
  ¬∑ intro x
    apply (ConcreteCategory.isIso_iff_bijective _).mpr
    constructor
    ¬∑ apply injective_on_stalks
      ¬∑ exact (TopCat.homeoOfIso (asIso f.val.base)).isOpenMap
      ¬∑ exact (closedEmbedding f).inj
      ¬∑ exact hf
    ¬∑ exact surjective_stalkMap f x

noncomputable example (A : CommRingCat) : Scheme.Œì.obj (op <| Scheme.specObj A) ‚ü∂ A :=
  SpecŒìIdentity.hom.app A

lemma toSpecŒì_ŒìSpec_adjunction_homEquiv {X : Scheme} {B : CommRingCat} (œÜ : B ‚ü∂ Scheme.Œì.obj (op X)) :
    toSpecŒì B ‚â´
      ((ŒìSpec.adjunction.homEquiv X (op B)) œÜ.op).val.c.app (op ‚ä§) = œÜ :=
  sorry

lemma ŒìSpec_adjunction_homEquiv_app_top {X : Scheme} {B : CommRingCat} (œÜ : B ‚ü∂ Scheme.Œì.obj (op X)) :
    (((ŒìSpec.adjunction.homEquiv X (op B)) œÜ.op).val.c.app (op ‚ä§)) = inv (toSpecŒì B) ‚â´ œÜ := by
  simp_rw [‚Üê toSpecŒì_ŒìSpec_adjunction_homEquiv œÜ]
  simp

set_option maxHeartbeats 500000

lemma specMap_app_top {A B : CommRingCat} (œÜ : A ‚ü∂ B) :
    (Scheme.specMap œÜ).val.c.app (op ‚ä§) = inv (toSpecŒì A) ‚â´ œÜ ‚â´ toSpecŒì B :=
  sorry

lemma specMap_app_top_surjective {A B : CommRingCat} (œÜ : A ‚ü∂ B) (hœÜ : Function.Surjective œÜ) :
    Function.Surjective ((Scheme.specMap œÜ).val.c.app (op ‚ä§)) := by
  rw [specMap_app_top]
  erw [CommRingCat.coe_comp]
  erw [CommRingCat.coe_comp]
  apply Function.Surjective.comp
  ¬∑ apply Function.Surjective.comp
    ¬∑ apply Function.Bijective.surjective
      apply (ConcreteCategory.isIso_iff_bijective _).mp
      infer_instance
    ¬∑ exact hœÜ
  ¬∑ apply Function.Bijective.surjective
    apply (ConcreteCategory.isIso_iff_bijective _).mp
    infer_instance

theorem spec_target_factorization {X : Scheme} {A : CommRingCat} (f : X ‚ü∂ Scheme.specObj A) :
    ‚àÉ (B : CommRingCat) (g : X ‚ü∂ Scheme.specObj B) (h : A ‚ü∂ B),
      f = g ‚â´ Scheme.specMap h ‚àß Function.Surjective h ‚àß
        Function.Injective (Scheme.Œì.map g.op) := by
  let œÜ : A ‚ü∂ Scheme.Œì.obj (op X) :=
    (((ŒìSpec.adjunction).homEquiv X (op A)).symm f).unop
  let I : Ideal A := RingHom.ker œÜ
  let B : CommRingCat := CommRingCat.of <| A ‚ß∏ I
  let œÜ' : B ‚ü∂ Scheme.Œì.obj (op X) := RingHom.kerLift œÜ
  have hinj : Function.Injective œÜ' := RingHom.kerLift_injective œÜ
  use B
  let g : X ‚ü∂ Scheme.specObj B :=
    (ŒìSpec.adjunction).homEquiv X (op B) œÜ'.op
  use g
  let h : A ‚ü∂ B := Ideal.Quotient.mk I
  use h
  have hd : œÜ = h ‚â´ œÜ' := by
    ext a
    simp
    symm
    apply RingHom.kerLift_mk
  refine ‚ü®?_, ?_, ?_‚ü©
  ¬∑ apply ((ŒìSpec.adjunction).homEquiv X (op A)).symm.injective
    apply Opposite.unop_injective
    show œÜ = _
    rw [Adjunction.homEquiv_naturality_left_symm]
    rw [Adjunction.homEquiv_counit]
    show œÜ = _ ‚â´ _
    show œÜ = (_ ‚â´ _) ‚â´ _
    dsimp only [g]
    simp
    rw [ŒìSpec.locallyRingedSpaceAdjunction_counit]
    simp
    rw [‚Üê Category.assoc]
    erw [‚Üê Spec_Œì_naturality]
    simp
    show œÜ = h ‚â´ toSpecŒì B ‚â´ _
    erw [toSpecŒì_ŒìSpec_adjunction_homEquiv œÜ']
    exact hd
  ¬∑ exact Ideal.Quotient.mk_surjective
  ¬∑ simp only [g]
    simp
    erw [ŒìSpec_adjunction_homEquiv_app_top]
    erw [CommRingCat.coe_comp]
    apply Function.Injective.comp
    ¬∑ exact hinj
    ¬∑ apply Function.Bijective.injective
      apply (ConcreteCategory.isIso_iff_bijective _).mp
      infer_instance

instance (B : CommRingCat) : IsAffine (Scheme.specObj B) := SpecIsAffine (op B)

theorem affine_target_factorization {X Y : Scheme} [IsAffine Y] (f : X ‚ü∂ Y) :
    ‚àÉ (Z : Scheme) (g : X ‚ü∂ Z) (h : Z ‚ü∂ Y),
      f = g ‚â´ h ‚àß IsAffine Z ‚àß Function.Surjective (Scheme.Œì.map h.op) ‚àß
        Function.Injective (Scheme.Œì.map g.op) := by
  let isoY := Y.isoSpec
  obtain ‚ü®B, g, h, hcomp, hsurj, hinj‚ü© := spec_target_factorization (f ‚â´ isoY.hom)
  refine ‚ü®Scheme.specObj B, g, Scheme.specMap h ‚â´ isoY.inv, ?_, ?_, ?_, ?_‚ü©
  ¬∑ rw [‚Üê Category.assoc]
    rw [‚Üê hcomp]
    simp
  ¬∑ infer_instance
  ¬∑ simp
    rw [CommRingCat.coe_comp]
    apply (specMap_app_top_surjective h hsurj).comp
    ¬∑ apply Function.Bijective.surjective
      apply ConcreteCategory.bijective_of_isIso
  ¬∑ exact hinj

theorem closedImmersion_affine_target {X Y : Scheme} [IsAffine Y] (f : X ‚ü∂ Y)
    [IsClosedImmersion f] : IsAffine X ‚àß Function.Surjective (Scheme.Œì.map f.op) := by
  obtain ‚ü®Z, g, h, rfl, hZA, hh, hg‚ü© := affine_target_factorization f
  have : IsClosedImmersion h := of_surjective_of_affine h hh
  have : IsClosedImmersion g := IsClosedImmersion.of_comp g h
  have : IsIso g := closedImmersion_affine_target_iso g hg
  constructor
  ¬∑ apply isAffineOfIso g
  ¬∑ simp
    show Function.Surjective (_ ‚àò Scheme.Œì.map h.op)
    apply Function.Surjective.comp
    ¬∑ apply Function.Bijective.surjective
      apply ConcreteCategory.bijective_of_isIso
    ¬∑ exact hh

end Affine

section

end

open Limits

theorem closedImmersion_pullback_fst_of_isAffine {X Y Z : Scheme} [IsAffine X] [IsAffine Y] [IsAffine Z]
    (f : X ‚ü∂ Y) (g : Z ‚ü∂ Y) [IsClosedImmersion g]  :
    IsClosedImmersion (pullback.fst : pullback f g ‚ü∂ X) := by
  have : Function.Surjective (Scheme.Œì.map g.op) :=
    (closedImmersion_affine_target g).right
  apply of_surjective_of_affine
  apply (RingHom.surjective_stableUnderBaseChange).Œì_pullback_fst
  ¬∑ exact RingHom.surjective_respectsIso
  ¬∑ exact (closedImmersion_affine_target g).right

theorem closedImmersion_stableUnderBaseChange :
    MorphismProperty.StableUnderBaseChange @IsClosedImmersion := by
  apply MorphismProperty.stableUnderBaseChange_of_isLocalAtTarget_of_affine
  ¬∑ exact closedImmersion_localAtTarget
  ¬∑ apply MorphismProperty.StableUnderAffineBaseChange.mk
    ¬∑ exact respectsIso
    ¬∑ intro X Y S _ _ f g hg
      have : IsAffine Y := (closedImmersion_affine_target g).left
      exact closedImmersion_pullback_fst_of_isAffine f g

end IsClosedImmersion

end AlgebraicGeometry
