/-
Copyright (c) 2020 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison
-/
import Mathlib.AlgebraicGeometry.PresheafedSpace
import Mathlib.Topology.Category.TopCat.Limits.Basic
import Mathlib.Topology.Sheaves.Limits

#align_import algebraic_geometry.presheafed_space.has_colimits from "leanprover-community/mathlib"@"178a32653e369dce2da68dc6b2694e385d484ef1"

/-!
# `PresheafedSpace C` has colimits.

If `C` has limits, then the category `PresheafedSpace C` has colimits,
and the forgetful functor to `TopCat` preserves these colimits.

When restricted to a diagram where the underlying continuous maps are open embeddings,
this says that we can glue presheaved spaces.

Given a diagram `F : J ‚•§ PresheafedSpace C`,
we first build the colimit of the underlying topological spaces,
as `colimit (F ‚ãô PresheafedSpace.forget C)`. Call that colimit space `X`.

Our strategy is to push each of the presheaves `F.obj j`
forward along the continuous map `colimit.Œπ (F ‚ãô PresheafedSpace.forget C) j` to `X`.
Since pushforward is functorial, we obtain a diagram `J ‚•§ (presheaf C X)·µí·µñ`
of presheaves on a single space `X`.
(Note that the arrows now point the other direction,
because this is the way `PresheafedSpace C` is set up.)

The limit of this diagram then constitutes the colimit presheaf.
-/


noncomputable section

universe v' u' v u

open CategoryTheory Opposite CategoryTheory.Category CategoryTheory.Functor CategoryTheory.Limits
  TopCat TopCat.Presheaf TopologicalSpace

variable {J : Type u'} [Category.{v'} J] {C : Type u} [Category.{v} C]

namespace AlgebraicGeometry

namespace PresheafedSpace

attribute [local simp] eqToHom_map

-- Porting note: we used to have:
-- local attribute [tidy] tactic.auto_cases_opens
-- We would replace this by:
-- attribute [local aesop safe cases (rule_sets [CategoryTheory])] Opens
-- although it doesn't appear to help in this file, in any case.

@[simp]
theorem map_id_c_app (F : J ‚•§ PresheafedSpace.{_, _, v} C) (j) (U) :
    (F.map (ùüô j)).c.app (op U) =
      (Pushforward.id (F.obj j).presheaf).inv.app (op U) ‚â´
        (pushforwardEq (by simp) (F.obj j).presheaf).hom.app
                           -- üéâ no goals
          (op U) := by
  cases U
  -- ‚ä¢ NatTrans.app (F.map (ùüô j)).c (op { carrier := carrier‚úù, is_open' := is_open' ‚Ä¶
  simp [PresheafedSpace.congr_app (F.map_id j)]
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.map_id_c_app AlgebraicGeometry.PresheafedSpace.map_id_c_app

@[simp]
theorem map_comp_c_app (F : J ‚•§ PresheafedSpace.{_, _, v} C) {j‚ÇÅ j‚ÇÇ j‚ÇÉ}
    (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (g : j‚ÇÇ ‚ü∂ j‚ÇÉ) (U) :
    (F.map (f ‚â´ g)).c.app (op U) =
      (F.map g).c.app (op U) ‚â´
        (pushforwardMap (F.map g).base (F.map f).c).app (op U) ‚â´
          (Pushforward.comp (F.obj j‚ÇÅ).presheaf (F.map f).base (F.map g).base).inv.app (op U) ‚â´
            (pushforwardEq (by rw [F.map_comp]; rfl) _).hom.app
                               -- ‚ä¢ (F.map f).base ‚â´ (F.map g).base = (F.map f ‚â´ F.map g).base
                                                -- üéâ no goals
              _ := by
  cases U
  -- ‚ä¢ NatTrans.app (F.map (f ‚â´ g)).c (op { carrier := carrier‚úù, is_open' := is_ope ‚Ä¶
  simp [PresheafedSpace.congr_app (F.map_comp f g)]
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.map_comp_c_app AlgebraicGeometry.PresheafedSpace.map_comp_c_app

-- See note [dsimp, simp]
/-- Given a diagram of `PresheafedSpace C`s, its colimit is computed by pushing the sheaves onto
the colimit of the underlying spaces, and taking componentwise limit.
This is the componentwise diagram for an open set `U` of the colimit of the underlying spaces.
-/
@[simps]
def componentwiseDiagram (F : J ‚•§ PresheafedSpace.{_, _, v} C) [HasColimit F]
    (U : Opens (Limits.colimit F).carrier) : J·µí·µñ ‚•§ C where
  obj j := (F.obj (unop j)).presheaf.obj (op ((Opens.map (colimit.Œπ F (unop j)).base).obj U))
  map {j k} f := (F.map f.unop).c.app _ ‚â´
    (F.obj (unop k)).presheaf.map (eqToHom (by rw [‚Üê colimit.w F f.unop, comp_base]; rfl))
                                               -- ‚ä¢ (Opens.map (F.map f.unop).base).op.obj (op ((Opens.map (colimit.Œπ F j.unop). ‚Ä¶
                                                                                     -- üéâ no goals
  map_comp {i j k} f g := by
    dsimp
    -- ‚ä¢ NatTrans.app (F.map (g.unop ‚â´ f.unop)).c (op ((Opens.map (colimit.Œπ F i.unop ‚Ä¶
    simp_rw [map_comp_c_app]
    -- ‚ä¢ (NatTrans.app (F.map f.unop).c (op ((Opens.map (colimit.Œπ F i.unop).base).ob ‚Ä¶
    simp only [op_obj, unop_op, eqToHom_op, id_eq, id_comp, assoc, eqToHom_trans]
    -- ‚ä¢ NatTrans.app (F.map f.unop).c (op ((Opens.map (colimit.Œπ F i.unop).base).obj ‚Ä¶
    congr 1
    -- ‚ä¢ NatTrans.app (pushforwardMap (F.map f.unop).base (F.map g.unop).c) (op ((Ope ‚Ä¶
    rw [TopCat.Presheaf.Pushforward.comp_inv_app, TopCat.Presheaf.pushforwardEq_hom_app,
      CategoryTheory.NatTrans.naturality_assoc, TopCat.Presheaf.pushforwardMap_app]
    -- ‚ä¢ NatTrans.app (F.map (ùüô x.unop)).c (op ((Opens.map (colimit.Œπ F x.unop).base) ‚Ä¶
    congr 1
    -- ‚ä¢ ùüô (((F.map f.unop).base _* ((F.map g.unop).base _* (F.obj k.unop).presheaf)) ‚Ä¶
    simp
    -- üéâ no goals
    -- ‚ä¢ (F.obj x.unop).presheaf.map (ùüô (op { carrier := ((Opens.map (colimit.Œπ F x.u ‚Ä¶
  map_id x := by
    -- üéâ no goals
    dsimp
    simp [map_id_c_app, pushforwardObj_obj, op_obj, unop_op, pushforwardEq_hom_app, eqToHom_op,
      id_eq, eqToHom_map, assoc, eqToHom_trans, eqToHom_refl, comp_id,
      TopCat.Presheaf.Pushforward.id_inv_app']
    rw [TopCat.Presheaf.Pushforward.id_inv_app']
    simp only [Opens.carrier_eq_coe, Opens.mk_coe, map_id]
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.componentwise_diagram AlgebraicGeometry.PresheafedSpace.componentwiseDiagram

variable [HasColimitsOfShape J TopCat.{v}]

/-- Given a diagram of presheafed spaces,
we can push all the presheaves forward to the colimit `X` of the underlying topological spaces,
obtaining a diagram in `(Presheaf C X)·µí·µñ`.
-/
@[simps]
def pushforwardDiagramToColimit (F : J ‚•§ PresheafedSpace.{_, _, v} C) :
    J ‚•§ (Presheaf C (colimit (F ‚ãô PresheafedSpace.forget C)))·µí·µñ where
  obj j := op (colimit.Œπ (F ‚ãô PresheafedSpace.forget C) j _* (F.obj j).presheaf)
  map {j j'} f :=
    (pushforwardMap (colimit.Œπ (F ‚ãô PresheafedSpace.forget C) j') (F.map f).c ‚â´
        (Pushforward.comp (F.obj j).presheaf ((F ‚ãô PresheafedSpace.forget C).map f)
              (colimit.Œπ (F ‚ãô PresheafedSpace.forget C) j')).inv ‚â´
          (pushforwardEq (colimit.w (F ‚ãô PresheafedSpace.forget C) f) (F.obj j).presheaf).hom).op
  map_id j := by
    apply (opEquiv _ _).injective
    -- ‚ä¢ ‚Üë(opEquiv ({ obj := fun j => op (colimit.Œπ (F ‚ãô forget C) j _* (F.obj j).pre ‚Ä¶
    refine NatTrans.ext _ _ (funext fun U => ?_)
    -- ‚ä¢ NatTrans.app (‚Üë(opEquiv ({ obj := fun j => op (colimit.Œπ (F ‚ãô forget C) j _* ‚Ä¶
    induction U with
    | h U =>
      rcases U with ‚ü®U, hU‚ü©
      dsimp [comp_obj, forget_obj, Functor.comp_map, forget_map, op_comp, unop_op,
        pushforwardObj_obj, op_obj, Opens.map_obj, opEquiv, Equiv.coe_fn_mk, unop_comp,
        Quiver.Hom.unop_op, unop_id]
      -- Porting note : some `simp` lemmas are not picked up
      rw [NatTrans.comp_app, pushforwardMap_app, NatTrans.id_app]
      simp only [op_obj, unop_op, Opens.map_obj, map_id_c_app, Opens.map_id_obj',
        map_id, pushforwardEq_hom_app, eqToHom_op, id_eq, eqToHom_map, id_comp,
        TopCat.Presheaf.Pushforward.id_inv_app']
      rw [NatTrans.comp_app, Pushforward.comp_inv_app, id_comp]
      dsimp
      simp
  map_comp {j‚ÇÅ j‚ÇÇ j‚ÇÉ} f g := by
    apply (opEquiv _ _).injective
    -- ‚ä¢ ‚Üë(opEquiv ({ obj := fun j => op (colimit.Œπ (F ‚ãô forget C) j _* (F.obj j).pre ‚Ä¶
    refine NatTrans.ext _ _ (funext fun U => ?_)
    -- ‚ä¢ NatTrans.app (‚Üë(opEquiv ({ obj := fun j => op (colimit.Œπ (F ‚ãô forget C) j _* ‚Ä¶
    dsimp only [comp_obj, forget_obj, Functor.comp_map, forget_map, op_comp, unop_op,
      pushforwardObj_obj, op_obj, opEquiv, Equiv.coe_fn_mk, unop_comp, Quiver.Hom.unop_op]
    -- Porting note : some `simp` lemmas are not picked up
    rw [NatTrans.comp_app, pushforwardMap_app, NatTrans.comp_app, Pushforward.comp_inv_app,
      id_comp, pushforwardEq_hom_app, NatTrans.comp_app, NatTrans.comp_app, NatTrans.comp_app,
      pushforwardMap_app, Pushforward.comp_inv_app, id_comp, pushforwardEq_hom_app,
      NatTrans.comp_app, NatTrans.comp_app, pushforwardEq_hom_app, Pushforward.comp_inv_app,
      id_comp, pushforwardMap_app]
    simp only [pushforwardObj_obj, op_obj, unop_op, map_comp_c_app, pushforwardMap_app,
      Opens.map_comp_obj, Pushforward.comp_inv_app, pushforwardEq_hom_app, eqToHom_op, id_eq,
      eqToHom_map, id_comp, assoc, eqToHom_trans]
    dsimp
    -- ‚ä¢ NatTrans.app (F.map g).c (op ((Opens.map (colimit.Œπ (F ‚ãô forget C) j‚ÇÉ)).obj  ‚Ä¶
    congr 1
    -- ‚ä¢ NatTrans.app (F.map f).c (op ((Opens.map (F.map g).base).obj ((Opens.map (co ‚Ä¶
    -- The key fact is `(F.map f).c.congr`,
    -- which allows us in rewrite in the argument of `(F.map f).c.app`.
    rw [@NatTrans.congr (Œ± := (F.map f).c)
      (op ((Opens.map (F.map g).base).obj ((Opens.map (colimit.Œπ (F ‚ãô forget C) j‚ÇÉ)).obj U.unop)))
      (op ((Opens.map (colimit.Œπ (F ‚ãô PresheafedSpace.forget C) j‚ÇÇ)).obj (unop U)))
      _]
    swap
    -- ‚ä¢ op ((Opens.map (F.map g).base).obj ((Opens.map (colimit.Œπ (F ‚ãô forget C) j‚ÇÉ) ‚Ä¶
    -- Now we show the open sets are equal.
    ¬∑ apply unop_injective
      -- ‚ä¢ (op ((Opens.map (F.map g).base).obj ((Opens.map (colimit.Œπ (F ‚ãô forget C) j‚ÇÉ ‚Ä¶
      rw [‚Üê Opens.map_comp_obj]
      -- ‚ä¢ (op ((Opens.map ((F.map g).base ‚â´ colimit.Œπ (F ‚ãô forget C) j‚ÇÉ)).obj U.unop)) ‚Ä¶
      congr
      -- ‚ä¢ (F.map g).base ‚â´ colimit.Œπ (F ‚ãô forget C) j‚ÇÉ = colimit.Œπ (F ‚ãô forget C) j‚ÇÇ
      exact colimit.w (F ‚ãô PresheafedSpace.forget C) g
      -- üéâ no goals
    -- Finally, the original goal is now easy:
    simp
    -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.pushforward_diagram_to_colimit AlgebraicGeometry.PresheafedSpace.pushforwardDiagramToColimit

variable [‚àÄ X : TopCat.{v}, HasLimitsOfShape J·µí·µñ (X.Presheaf C)]

/-- Auxiliary definition for `AlgebraicGeometry.PresheafedSpace.instHasColimits`.
-/
def colimit (F : J ‚•§ PresheafedSpace.{_, _, v} C) : PresheafedSpace C where
  carrier := Limits.colimit (F ‚ãô PresheafedSpace.forget C)
  presheaf := limit (pushforwardDiagramToColimit F).leftOp
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.colimit AlgebraicGeometry.PresheafedSpace.colimit

@[simp]
theorem colimit_carrier (F : J ‚•§ PresheafedSpace.{_, _, v} C) :
    (colimit F).carrier = Limits.colimit (F ‚ãô PresheafedSpace.forget C) :=
  rfl
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.colimit_carrier AlgebraicGeometry.PresheafedSpace.colimit_carrier

@[simp]
theorem colimit_presheaf (F : J ‚•§ PresheafedSpace.{_, _, v} C) :
    (colimit F).presheaf = limit (pushforwardDiagramToColimit F).leftOp :=
  rfl
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.colimit_presheaf AlgebraicGeometry.PresheafedSpace.colimit_presheaf

/-- Auxiliary definition for `AlgebraicGeometry.PresheafedSpace.instHasColimits`.
-/
@[simps]
def colimitCocone (F : J ‚•§ PresheafedSpace.{_, _, v} C) : Cocone F where
  pt := colimit F
  Œπ :=
    { app := fun j =>
        { base := colimit.Œπ (F ‚ãô PresheafedSpace.forget C) j
          c := limit.œÄ _ (op j) }
      naturality := fun {j j'} f => by
        ext1
        -- ‚ä¢ (F.map f ‚â´ (fun j => { base := colimit.Œπ (F ‚ãô forget C) j, c := limit.œÄ (pus ‚Ä¶
        ¬∑ ext x
          -- ‚ä¢ ‚Üë(F.map f ‚â´ (fun j => { base := colimit.Œπ (F ‚ãô forget C) j, c := limit.œÄ (pu ‚Ä¶
          exact colimit.w_apply (F ‚ãô PresheafedSpace.forget C) f x
          -- üéâ no goals
        ¬∑ ext ‚ü®U, hU‚ü©
          -- ‚ä¢ NatTrans.app ((F.map f ‚â´ (fun j => { base := colimit.Œπ (F ‚ãô forget C) j, c : ‚Ä¶
          dsimp
          -- ‚ä¢ NatTrans.app ((F.map f ‚â´ { base := colimit.Œπ (F ‚ãô forget C) j', c := limit.œÄ ‚Ä¶
          rw [PresheafedSpace.id_c_app, map_id]
          -- ‚ä¢ NatTrans.app ((F.map f ‚â´ { base := colimit.Œπ (F ‚ãô forget C) j', c := limit.œÄ ‚Ä¶
          erw [id_comp]
          -- ‚ä¢ NatTrans.app ((F.map f ‚â´ { base := colimit.Œπ (F ‚ãô forget C) j', c := limit.œÄ ‚Ä¶
          rw [NatTrans.comp_app, PresheafedSpace.comp_c_app, whiskerRight_app, eqToHom_app,
            ‚Üê congr_arg NatTrans.app (limit.w (pushforwardDiagramToColimit F).leftOp f.op),
            NatTrans.comp_app, Functor.leftOp_map, pushforwardDiagramToColimit_map]
          dsimp
          -- ‚ä¢ (NatTrans.app (limit.œÄ (pushforwardDiagramToColimit F).leftOp (op j')) (op { ‚Ä¶
          rw [NatTrans.comp_app, NatTrans.comp_app, pushforwardEq_hom_app, id.def, eqToHom_op,
            Pushforward.comp_inv_app, id_comp, pushforwardMap_app, ‚Üêassoc]
          congr 1 }
          -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.colimit_cocone AlgebraicGeometry.PresheafedSpace.colimitCocone

variable [HasLimitsOfShape J·µí·µñ C]

namespace ColimitCoconeIsColimit

/-- Auxiliary definition for `AlgebraicGeometry.PresheafedSpace.colimitCoconeIsColimit`.
-/
def descCApp (F : J ‚•§ PresheafedSpace.{_, _, v} C) (s : Cocone F) (U : (Opens s.pt.carrier)·µí·µñ) :
    s.pt.presheaf.obj U ‚ü∂
      (colimit.desc (F ‚ãô PresheafedSpace.forget C) ((PresheafedSpace.forget C).mapCocone s) _*
            limit (pushforwardDiagramToColimit F).leftOp).obj
        U := by
  refine'
    limit.lift _
        { pt := s.pt.presheaf.obj U
          œÄ :=
            { app := fun j => _
              naturality := fun j j' f => _ } } ‚â´
      (limitObjIsoLimitCompEvaluation _ _).inv
  -- We still need to construct the `app` and `naturality'` fields omitted above.
  ¬∑ refine' (s.Œπ.app (unop j)).c.app U ‚â´ (F.obj (unop j)).presheaf.map (eqToHom _)
    -- ‚ä¢ (Opens.map (NatTrans.app s.Œπ j.unop).base).op.obj U = (Opens.map (colimit.Œπ  ‚Ä¶
    dsimp
    -- ‚ä¢ op ((Opens.map (NatTrans.app s.Œπ j.unop).base).obj U.unop) = op ((Opens.map  ‚Ä¶
    rw [‚Üê Opens.map_comp_obj]
    -- ‚ä¢ op ((Opens.map (NatTrans.app s.Œπ j.unop).base).obj U.unop) = op ((Opens.map  ‚Ä¶
    simp
    -- üéâ no goals
  ¬∑ dsimp
    -- ‚ä¢ ùüô (s.pt.presheaf.obj U) ‚â´ NatTrans.app (NatTrans.app s.Œπ j'.unop).c U ‚â´ (F.o ‚Ä¶
    rw [PresheafedSpace.congr_app (s.w f.unop).symm U]
    -- ‚ä¢ ùüô (s.pt.presheaf.obj U) ‚â´ (NatTrans.app (F.map f.unop ‚â´ NatTrans.app s.Œπ j.u ‚Ä¶
    have w :=
      Functor.congr_obj
        (congr_arg Opens.map (colimit.Œπ_desc ((PresheafedSpace.forget C).mapCocone s) (unop j)))
        (unop U)
    simp only [Opens.map_comp_obj_unop] at w
    -- ‚ä¢ ùüô (s.pt.presheaf.obj U) ‚â´ (NatTrans.app (F.map f.unop ‚â´ NatTrans.app s.Œπ j.u ‚Ä¶
    replace w := congr_arg op w
    -- ‚ä¢ ùüô (s.pt.presheaf.obj U) ‚â´ (NatTrans.app (F.map f.unop ‚â´ NatTrans.app s.Œπ j.u ‚Ä¶
    have w' := NatTrans.congr (F.map f.unop).c w
    -- ‚ä¢ ùüô (s.pt.presheaf.obj U) ‚â´ (NatTrans.app (F.map f.unop ‚â´ NatTrans.app s.Œπ j.u ‚Ä¶
    rw [w']
    -- ‚ä¢ ùüô (s.pt.presheaf.obj U) ‚â´ (NatTrans.app (F.map f.unop ‚â´ NatTrans.app s.Œπ j.u ‚Ä¶
    simp
    -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.colimit_cocone_is_colimit.desc_c_app AlgebraicGeometry.PresheafedSpace.ColimitCoconeIsColimit.descCApp

theorem desc_c_naturality (F : J ‚•§ PresheafedSpace.{_, _, v} C) (s : Cocone F)
    {U V : (Opens s.pt.carrier)·µí·µñ} (i : U ‚ü∂ V) :
    s.pt.presheaf.map i ‚â´ descCApp F s V =
      descCApp F s U ‚â´
        (colimit.desc (F ‚ãô forget C) ((forget C).mapCocone s) _* (colimitCocone F).pt.presheaf).map
          i := by
  dsimp [descCApp]
  -- ‚ä¢ s.pt.presheaf.map i ‚â´ limit.lift ((pushforwardDiagramToColimit F).leftOp ‚ãô ( ‚Ä¶
  refine limit_obj_ext (fun j => ?_)
  -- ‚ä¢ (s.pt.presheaf.map i ‚â´ limit.lift ((pushforwardDiagramToColimit F).leftOp ‚ãô  ‚Ä¶
  simp only [limit.lift_œÄ, NatTrans.naturality, limit.lift_œÄ_assoc, eqToHom_map, assoc,
    pushforwardObj_map, NatTrans.naturality_assoc, op_map,
    limitObjIsoLimitCompEvaluation_inv_œÄ_app_assoc,
    limitObjIsoLimitCompEvaluation_inv_œÄ_app]
  dsimp
  -- ‚ä¢ NatTrans.app (NatTrans.app s.Œπ j.unop).c U ‚â´ (F.obj j.unop).presheaf.map ((O ‚Ä¶
  have w :=
    Functor.congr_hom
      (congr_arg Opens.map (colimit.Œπ_desc ((PresheafedSpace.forget C).mapCocone s) (unop j)))
      i.unop
  simp only [Opens.map_comp_map] at w
  -- ‚ä¢ NatTrans.app (NatTrans.app s.Œπ j.unop).c U ‚â´ (F.obj j.unop).presheaf.map ((O ‚Ä¶
  replace w := congr_arg Quiver.Hom.op w
  -- ‚ä¢ NatTrans.app (NatTrans.app s.Œπ j.unop).c U ‚â´ (F.obj j.unop).presheaf.map ((O ‚Ä¶
  rw [w]
  -- ‚ä¢ NatTrans.app (NatTrans.app s.Œπ j.unop).c U ‚â´ (F.obj j.unop).presheaf.map ((O ‚Ä¶
  simp
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.colimit_cocone_is_colimit.desc_c_naturality AlgebraicGeometry.PresheafedSpace.ColimitCoconeIsColimit.desc_c_naturality

/-- Auxiliary definition for `AlgebraicGeometry.PresheafedSpace.colimitCoconeIsColimit`.
-/
def desc (F : J ‚•§ PresheafedSpace.{_, _, v} C) (s : Cocone F) : colimit F ‚ü∂ s.pt where
  base := colimit.desc (F ‚ãô PresheafedSpace.forget C) ((PresheafedSpace.forget C).mapCocone s)
  c :=
    { app := fun U => descCApp F s U
      naturality := fun _ _ i => desc_c_naturality F s i }
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.colimit_cocone_is_colimit.desc AlgebraicGeometry.PresheafedSpace.ColimitCoconeIsColimit.desc

theorem desc_fac (F : J ‚•§ PresheafedSpace.{_, _, v} C) (s : Cocone F) (j : J) :
    (colimitCocone F).Œπ.app j ‚â´ desc F s = s.Œπ.app j := by
  ext U
  -- ‚ä¢ ‚Üë(NatTrans.app (colimitCocone F).Œπ j ‚â´ desc F s).base U = ‚Üë(NatTrans.app s.Œπ ‚Ä¶
  ¬∑ simp [desc]
    -- üéâ no goals
  ¬∑ -- Porting note : the original proof is just `ext; dsimp [desc, descCApp]; simpa`,
    -- but this has to be expanded a bit
    rw [NatTrans.comp_app, PresheafedSpace.comp_c_app, whiskerRight_app]
    -- ‚ä¢ (NatTrans.app (desc F s).c (op U) ‚â´ NatTrans.app (NatTrans.app (colimitCocon ‚Ä¶
    dsimp [desc, descCApp]
    -- ‚ä¢ ((limit.lift ((pushforwardDiagramToColimit F).leftOp ‚ãô (evaluation (Opens ‚Üë( ‚Ä¶
    simp only [eqToHom_app, op_obj, Opens.map_comp_obj, eqToHom_map, Functor.leftOp, assoc]
    -- ‚ä¢ limit.lift (CategoryTheory.Functor.mk { obj := fun X => ((pushforwardDiagram ‚Ä¶
    rw [limitObjIsoLimitCompEvaluation_inv_œÄ_app_assoc]
    -- ‚ä¢ limit.lift (CategoryTheory.Functor.mk { obj := fun X => ((pushforwardDiagram ‚Ä¶
    simp
    -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.colimit_cocone_is_colimit.desc_fac AlgebraicGeometry.PresheafedSpace.ColimitCoconeIsColimit.desc_fac

end ColimitCoconeIsColimit

open ColimitCoconeIsColimit

/-- Auxiliary definition for `AlgebraicGeometry.PresheafedSpace.instHasColimits`.
-/
def colimitCoconeIsColimit (F : J ‚•§ PresheafedSpace.{_, _, v} C) :
    IsColimit (colimitCocone F) where
  desc s := desc F s
  fac s := desc_fac F s
  uniq s m w := by
    -- We need to use the identity on the continuous maps twice, so we prepare that first:
    have t :
      m.base =
        colimit.desc (F ‚ãô PresheafedSpace.forget C) ((PresheafedSpace.forget C).mapCocone s) := by
      dsimp
      ext j
      rw [colimit.Œπ_desc, mapCocone_Œπ_app, ‚Üê w j]
      simp
    ext : 1
    -- ‚ä¢ m.base = ((fun s => desc F s) s).base
    ¬∑ exact t
      -- üéâ no goals
    ¬∑ refine NatTrans.ext _ _ (funext fun U => limit_obj_ext fun j => ?_)
      -- ‚ä¢ NatTrans.app (m.c ‚â´ whiskerRight (eqToHom (_ : (Opens.map m.base).op = (Open ‚Ä¶
      dsimp only [colimitCocone_pt, colimit_carrier, leftOp_obj, pushforwardDiagramToColimit_obj,
        comp_obj, forget_obj, unop_op, op_obj, desc, colimit_presheaf, descCApp, mapCocone_pt,
        pushforwardObj_obj, const_obj_obj, id_eq, evaluation_obj_obj, Eq.ndrec, eq_mpr_eq_cast]
      rw [NatTrans.comp_app, whiskerRight_app]
      -- ‚ä¢ (NatTrans.app m.c U ‚â´ (limit (pushforwardDiagramToColimit F).leftOp).map (Na ‚Ä¶
      simp only [pushforwardObj_obj, op_obj, comp_obj, eqToHom_app, eqToHom_map, assoc,
        limitObjIsoLimitCompEvaluation_inv_œÄ_app, limit.lift_œÄ]
      rw [PresheafedSpace.congr_app (w (unop j)).symm U]
      -- ‚ä¢ NatTrans.app m.c U ‚â´ eqToHom (_ : (limit (pushforwardDiagramToColimit F).lef ‚Ä¶
      dsimp
      -- ‚ä¢ NatTrans.app m.c U ‚â´ eqToHom (_ : (limit (pushforwardDiagramToColimit F).lef ‚Ä¶
      have w := congr_arg op (Functor.congr_obj (congr_arg Opens.map t) (unop U))
      -- ‚ä¢ NatTrans.app m.c U ‚â´ eqToHom (_ : (limit (pushforwardDiagramToColimit F).lef ‚Ä¶
      rw [NatTrans.congr (limit.œÄ (pushforwardDiagramToColimit F).leftOp j) w]
      -- ‚ä¢ NatTrans.app m.c U ‚â´ eqToHom (_ : (limit (pushforwardDiagramToColimit F).lef ‚Ä¶
      simp
      -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.colimit_cocone_is_colimit AlgebraicGeometry.PresheafedSpace.colimitCoconeIsColimit

instance : HasColimitsOfShape J (PresheafedSpace.{_, _, v} C) where
  has_colimit F := ‚ü®colimitCocone F, colimitCoconeIsColimit F‚ü©

instance : PreservesColimitsOfShape J (PresheafedSpace.forget.{u, v, v} C) :=
  ‚ü®fun {F} => preservesColimitOfPreservesColimitCocone (colimitCoconeIsColimit F) <| by
    apply IsColimit.ofIsoColimit (colimit.isColimit _)
    -- ‚ä¢ colimit.cocone (F ‚ãô forget C) ‚âÖ (forget C).mapCocone (colimitCocone F)
    fapply Cocones.ext
    -- ‚ä¢ (colimit.cocone (F ‚ãô forget C)).pt ‚âÖ ((forget C).mapCocone (colimitCocone F) ‚Ä¶
    ¬∑ rfl
      -- üéâ no goals
    ¬∑ intro j
      -- ‚ä¢ NatTrans.app (colimit.cocone (F ‚ãô forget C)).Œπ j ‚â´ (Iso.refl (colimit.cocone ‚Ä¶
      simp‚ü©
      -- üéâ no goals

/-- When `C` has limits, the category of presheaved spaces with values in `C` itself has colimits.
-/
instance instHasColimits [HasLimits C] : HasColimits (PresheafedSpace.{_, _, v} C) :=
  ‚ü®fun {_ _} => ‚ü®fun {F} => ‚ü®colimitCocone F, colimitCoconeIsColimit F‚ü©‚ü©‚ü©

/-- The underlying topological space of a colimit of presheaved spaces is
the colimit of the underlying topological spaces.
-/
instance forgetPreservesColimits [HasLimits C] : PreservesColimits (PresheafedSpace.forget C) where
  preservesColimitsOfShape {J ùí•} :=
    { preservesColimit := fun {F} =>
        preservesColimitOfPreservesColimitCocone (colimitCoconeIsColimit F)
          (by apply IsColimit.ofIsoColimit (colimit.isColimit _)
              -- ‚ä¢ colimit.cocone (F ‚ãô forget C) ‚âÖ (forget C).mapCocone (colimitCocone F)
              fapply Cocones.ext
              -- ‚ä¢ (colimit.cocone (F ‚ãô forget C)).pt ‚âÖ ((forget C).mapCocone (colimitCocone F) ‚Ä¶
              ¬∑ rfl
                -- üéâ no goals
              ¬∑ intro j
                -- ‚ä¢ NatTrans.app (colimit.cocone (F ‚ãô forget C)).Œπ j ‚â´ (Iso.refl (colimit.cocone ‚Ä¶
                simp) }
                -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.forget_preserves_colimits AlgebraicGeometry.PresheafedSpace.forgetPreservesColimits

/-- The components of the colimit of a diagram of `PresheafedSpace C` is obtained
via taking componentwise limits.
-/
def colimitPresheafObjIsoComponentwiseLimit (F : J ‚•§ PresheafedSpace.{_, _, v} C) [HasColimit F]
    (U : Opens (Limits.colimit F).carrier) :
    (Limits.colimit F).presheaf.obj (op U) ‚âÖ limit (componentwiseDiagram F U) := by
  refine'
    ((sheafIsoOfIso (colimit.isoColimitCocone ‚ü®_, colimitCoconeIsColimit F‚ü©).symm).app
          (op U)).trans
      _
  refine' (limitObjIsoLimitCompEvaluation _ _).trans (Limits.lim.mapIso _)
  -- ‚ä¢ (pushforwardDiagramToColimit F).leftOp ‚ãô (evaluation (Opens ‚Üë‚Üë{ cocone := co ‚Ä¶
  fapply NatIso.ofComponents
  -- ‚ä¢ (X : J·µí·µñ) ‚Üí ((pushforwardDiagramToColimit F).leftOp ‚ãô (evaluation (Opens ‚Üë‚Üë{ ‚Ä¶
  ¬∑ intro X
    -- ‚ä¢ ((pushforwardDiagramToColimit F).leftOp ‚ãô (evaluation (Opens ‚Üë‚Üë{ cocone := c ‚Ä¶
    refine' (F.obj (unop X)).presheaf.mapIso (eqToIso _)
    -- ‚ä¢ (Opens.map (colimit.Œπ (F ‚ãô forget C) X.unop)).op.obj ((Opens.map (colimit.is ‚Ä¶
    simp only [Functor.op_obj, unop_op, op_inj_iff, Opens.map_coe, SetLike.ext'_iff,
      Set.preimage_preimage]
    refine congr_arg (Set.preimage . U.1) (funext fun x => ?_)
    -- ‚ä¢ ‚Üë(colimit.isoColimitCocone { cocone := colimitCocone F, isColimit := colimit ‚Ä¶
    erw [‚Üêcomp_app]
    -- ‚ä¢ ‚Üë(colimit.Œπ (F ‚ãô forget C) X.unop ‚â´ (colimit.isoColimitCocone { cocone := co ‚Ä¶
    congr
    -- ‚ä¢ colimit.Œπ (F ‚ãô forget C) X.unop ‚â´ (colimit.isoColimitCocone { cocone := coli ‚Ä¶
    exact Œπ_preservesColimitsIso_inv (forget C) F (unop X)
    -- üéâ no goals
  ¬∑ intro X Y f
    -- ‚ä¢ ((pushforwardDiagramToColimit F).leftOp ‚ãô (evaluation (Opens ‚Üë‚Üë{ cocone := c ‚Ä¶
    change ((F.map f.unop).c.app _ ‚â´ _ ‚â´ _) ‚â´ (F.obj (unop Y)).presheaf.map _ = _ ‚â´ _
    -- ‚ä¢ (NatTrans.app (F.map f.unop).c ((Opens.map (colimit.Œπ (F ‚ãô forget C) X.unop) ‚Ä¶
    rw [TopCat.Presheaf.Pushforward.comp_inv_app]
    -- ‚ä¢ (NatTrans.app (F.map f.unop).c ((Opens.map (colimit.Œπ (F ‚ãô forget C) X.unop) ‚Ä¶
    erw [Category.id_comp]
    -- ‚ä¢ (NatTrans.app (F.map f.unop).c ((Opens.map (colimit.Œπ (F ‚ãô forget C) X.unop) ‚Ä¶
    rw [Category.assoc]
    -- ‚ä¢ NatTrans.app (F.map f.unop).c ((Opens.map (colimit.Œπ (F ‚ãô forget C) X.unop)) ‚Ä¶
    erw [‚Üê (F.obj (unop Y)).presheaf.map_comp, (F.map f.unop).c.naturality_assoc,
      ‚Üê(F.obj (unop Y)).presheaf.map_comp]
    rfl
    -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.colimit_presheaf_obj_iso_componentwise_limit AlgebraicGeometry.PresheafedSpace.colimitPresheafObjIsoComponentwiseLimit

@[simp]
theorem colimitPresheafObjIsoComponentwiseLimit_inv_Œπ_app (F : J ‚•§ PresheafedSpace.{_, _, v} C)
    (U : Opens (Limits.colimit F).carrier) (j : J) :
    (colimitPresheafObjIsoComponentwiseLimit F U).inv ‚â´ (colimit.Œπ F j).c.app (op U) =
      limit.œÄ _ (op j) := by
  delta colimitPresheafObjIsoComponentwiseLimit
  -- ‚ä¢ ((sheafIsoOfIso (colimit.isoColimitCocone { cocone := colimitCocone F, isCol ‚Ä¶
  rw [Iso.trans_inv, Iso.trans_inv, Iso.app_inv, sheafIsoOfIso_inv, pushforwardToOfIso_app,
    congr_app (Iso.symm_inv _)]
  dsimp
  -- ‚ä¢ ((limMap (NatIso.ofComponents fun X => (F.obj X.unop).presheaf.mapIso (eqToI ‚Ä¶
  rw [map_id, comp_id, assoc, assoc, assoc, NatTrans.naturality]
  -- ‚ä¢ limMap (NatIso.ofComponents fun X => (F.obj X.unop).presheaf.mapIso (eqToIso ‚Ä¶
  erw [‚Üê comp_c_app_assoc]
  -- ‚ä¢ limMap (NatIso.ofComponents fun X => (F.obj X.unop).presheaf.mapIso (eqToIso ‚Ä¶
  rw [congr_app (colimit.isoColimitCocone_Œπ_hom _ _), assoc]
  -- ‚ä¢ limMap (NatIso.ofComponents fun X => (F.obj X.unop).presheaf.mapIso (eqToIso ‚Ä¶
  erw [limitObjIsoLimitCompEvaluation_inv_œÄ_app_assoc, limMap_œÄ_assoc]
  -- ‚ä¢ limit.œÄ (componentwiseDiagram F U) (op j) ‚â´ NatTrans.app (NatIso.ofComponent ‚Ä¶
  -- Porting note : `convert` doesn't work due to meta variable, so change to a `suffices` block
  set f := _
  -- ‚ä¢ limit.œÄ (componentwiseDiagram F U) (op j) ‚â´ NatTrans.app (NatIso.ofComponent ‚Ä¶
  change _ ‚â´ f = _
  -- ‚ä¢ limit.œÄ (componentwiseDiagram F U) (op j) ‚â´ f = limit.œÄ (componentwiseDiagra ‚Ä¶
  suffices f_eq : f = ùüô _ by rw [f_eq, comp_id]
  -- ‚ä¢ f = ùüô ((componentwiseDiagram F U).obj (op j))
  erw [‚Üê (F.obj j).presheaf.map_id]
  -- ‚ä¢ f = (F.obj j).presheaf.map (ùüô (op ((Opens.map (colimit.Œπ F (op j).unop).base ‚Ä¶
  change (F.obj j).presheaf.map _ ‚â´ _ = _
  -- ‚ä¢ (F.obj j).presheaf.map (eqToIso (_ : (Opens.map (colimit.Œπ (F ‚ãô forget C) (o ‚Ä¶
  erw [‚Üê (F.obj j).presheaf.map_comp, ‚Üê (F.obj j).presheaf.map_comp]
  -- ‚ä¢ (F.obj j).presheaf.map ((eqToIso (_ : (Opens.map (colimit.Œπ (F ‚ãô forget C) ( ‚Ä¶
  congr 1
  -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.colimit_presheaf_obj_iso_componentwise_limit_inv_Œπ_app AlgebraicGeometry.PresheafedSpace.colimitPresheafObjIsoComponentwiseLimit_inv_Œπ_app

@[simp]
theorem colimitPresheafObjIsoComponentwiseLimit_hom_œÄ (F : J ‚•§ PresheafedSpace.{_, _, v} C)
    (U : Opens (Limits.colimit F).carrier) (j : J) :
    (colimitPresheafObjIsoComponentwiseLimit F U).hom ‚â´ limit.œÄ _ (op j) =
      (colimit.Œπ F j).c.app (op U) :=
  by rw [‚Üê Iso.eq_inv_comp, colimitPresheafObjIsoComponentwiseLimit_inv_Œπ_app]
     -- üéâ no goals
set_option linter.uppercaseLean3 false in
#align algebraic_geometry.PresheafedSpace.colimit_presheaf_obj_iso_componentwise_limit_hom_œÄ AlgebraicGeometry.PresheafedSpace.colimitPresheafObjIsoComponentwiseLimit_hom_œÄ

end PresheafedSpace

end AlgebraicGeometry
