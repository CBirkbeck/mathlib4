
import Lean.Elab.Term
universe w v v‚ÇÅ v‚ÇÇ v‚ÇÉ u u‚ÇÅ u‚ÇÇ u‚ÇÉ

open Lean

elab "Sort*" : term => do
  let u ‚Üê Lean.Meta.mkFreshLevelMVar
  Elab.Term.levelMVarToParam (.sort u)

/-- The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable
`> 0` for each variable in the sequence. -/
elab "Type*" : term => do
  let u ‚Üê Lean.Meta.mkFreshLevelMVar
  Elab.Term.levelMVarToParam (.sort (.succ u))
section FunctionStuff

def Function.Injective (f : Œ± ‚Üí Œ≤) : Prop :=
  ‚àÄ ‚¶Éa‚ÇÅ a‚ÇÇ‚¶Ñ, f a‚ÇÅ = f a‚ÇÇ ‚Üí a‚ÇÅ = a‚ÇÇ

end FunctionStuff

section FunLikeStuff

class DFunLike (F : Sort*) (Œ± : outParam (Sort*)) (Œ≤ : outParam <| Œ± ‚Üí Sort*) where
  /-- The coercion from `F` to a function. -/
  coe : F ‚Üí ‚àÄ a : Œ±, Œ≤ a
  /-- The coercion to functions must be injective. -/
  coe_injective' : Function.Injective coe

abbrev FunLike F Œ± Œ≤ := DFunLike F Œ± fun _ => Œ≤

variable (F Œ± : Sort*) (Œ≤ : Œ± ‚Üí Sort*)

variable {F Œ± Œ≤} [i : DFunLike F Œ± Œ≤]

instance (priority := 100) hasCoeToFun : CoeFun F (fun _ ‚Ü¶ ‚àÄ a : Œ±, Œ≤ a) where
  coe := @DFunLike.coe _ _ Œ≤ _ -- need to make explicit to beta reduce for non-dependent functions

end FunLikeStuff

section OrderStuff

class Preorder (Œ± : Type u) extends LE Œ±, LT Œ± where
  le_refl : ‚àÄ a : Œ±, a ‚â§ a
  le_trans : ‚àÄ a b c : Œ±, a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c
  lt := fun a b => a ‚â§ b ‚àß ¬¨b ‚â§ a
  lt_iff_le_not_le : ‚àÄ a b : Œ±, a < b ‚Üî a ‚â§ b ‚àß ¬¨b ‚â§ a := by intros; rfl

end OrderStuff

section CategoryStuff

class Quiver (V : Type u) where
  /-- The type of edges/arrows/morphisms between a given source and target. -/
  Hom : V ‚Üí V ‚Üí Sort v

infixr:10 " ‚ü∂ " => Quiver.Hom

namespace CategoryTheory

class CategoryStruct (obj : Type u) extends Quiver.{v + 1} obj : Type max u (v + 1) where
  /-- The identity morphism on an object. -/
  id : ‚àÄ X : obj, Hom X X
  /-- Composition of morphisms in a category, written `f ‚â´ g`. -/
  comp : ‚àÄ {X Y Z : obj}, (X ‚ü∂ Y) ‚Üí (Y ‚ü∂ Z) ‚Üí (X ‚ü∂ Z)

-- macro (name := aesop_cat) "aesop_cat" c:Aesop.tactic_clause* : tactic =>
-- `(tactic|
--   aesop $c* (config := { introsTransparency? := some .default, terminal := true })
--             (simp_config := { decide := true, zetaDelta := true })
--             (rule_sets := [$(Lean.mkIdent `CategoryTheory):ident]))

/-- Notation for the identity morphism in a category. -/
scoped notation "ùüô" => CategoryStruct.id  -- type as \b1

/-- Notation for composition of morphisms in a category. -/
scoped infixr:80 " ‚â´ " => CategoryStruct.comp -- type as \gg

class Category (obj : Type u) extends CategoryStruct.{v} obj : Type max u (v + 1) where
  /-- Identity morphisms are left identities for composition. -/
  id_comp : ‚àÄ {X Y : obj} (f : X ‚ü∂ Y), ùüô X ‚â´ f = f -- := by aesop_cat
  /-- Identity morphisms are right identities for composition. -/
  comp_id : ‚àÄ {X Y : obj} (f : X ‚ü∂ Y), f ‚â´ ùüô Y = f -- := by aesop_cat
  /-- Composition in a category is associative. -/
  assoc : ‚àÄ {W X Y Z : obj} (f : W ‚ü∂ X) (g : X ‚ü∂ Y) (h : Y ‚ü∂ Z), (f ‚â´ g) ‚â´ h = f ‚â´ g ‚â´ h -- := by aesop_cat

end CategoryTheory

end CategoryStuff

section OppositeStuff

structure Opposite (Œ± : Sort u) :=
  op ::
  /-- The canonical map `Œ±·µí·µñ ‚Üí Œ±`. -/
  unop : Œ±

notation:max -- Use a high right binding power (like that of postfix ‚Åª¬π) so that, for example,
-- `Presheaf C·µí·µñ` parses as `Presheaf (C·µí·µñ)` and not `(Presheaf C)·µí·µñ`.
Œ± "·µí·µñ" => Opposite Œ±

open Opposite

section Quiver

variable {C : Type u‚ÇÅ}

variable [Quiver.{v‚ÇÅ} C]

/-- `V·µí·µñ` reverses the direction of all arrows of `V`. -/
instance Quiver.opposite {V} [Quiver V] : Quiver V·µí·µñ :=
  ‚ü®fun a b => (unop b ‚ü∂ unop a)·µí·µñ‚ü©

def Quiver.Hom.op {V : Type u} [Quiver V] {X Y : V} (f : X ‚ü∂ Y) : op Y ‚ü∂ op X := ‚ü®f‚ü©

def Quiver.Hom.unop {V : Type u} [Quiver V] {X Y : V·µí·µñ} (f : X ‚ü∂ Y) : unop Y ‚ü∂ unop X := Opposite.unop f

theorem Quiver.Hom.op_inj {X Y : C} :
    Function.Injective (Quiver.Hom.op : (X ‚ü∂ Y) ‚Üí (Opposite.op Y ‚ü∂ Opposite.op X)) := fun _ _ H =>
  congrArg Quiver.Hom.unop H

end Quiver

namespace CategoryTheory

variable [Category.{v‚ÇÅ} C]

instance Category.opposite : Category.{v‚ÇÅ} C·µí·µñ where
  comp f g := (g.unop ‚â´ f.unop).op
  id X := (ùüô (unop X)).op
  id_comp := by sorry
  comp_id := by sorry
  assoc := by sorry

end CategoryTheory

end OppositeStuff

open CategoryTheory

section IsoStuff

variable {C : Type u} [Category.{v} C] {X Y Z : C}

/-- `IsIso` typeclass expressing that a morphism is invertible. -/
class IsIso (f : X ‚ü∂ Y) : Prop where
  /-- The existence of an inverse morphism. -/
  out : ‚àÉ inv : Y ‚ü∂ X, f ‚â´ inv = ùüô X ‚àß inv ‚â´ f = ùüô Y

structure Iso {C : Type u} [Category.{v} C] (X Y : C) where
  /-- The forward direction of an isomorphism. -/
  hom : X ‚ü∂ Y
  /-- The backwards direction of an isomorphism. -/
  inv : Y ‚ü∂ X
  /-- Composition of the two directions of an isomorphism is the identity on the source. -/
  hom_inv_id : hom ‚â´ inv = ùüô X -- := by aesop_cat
  /-- Composition of the two directions of an isomorphism in reverse order
  is the identity on the target. -/
  inv_hom_id : inv ‚â´ hom = ùüô Y -- := by aesop_cat

infixr:10 " ‚âÖ " => Iso -- type as \cong or \iso

noncomputable def inv (f : X ‚ü∂ Y) [I : IsIso f] : Y ‚ü∂ X :=
  Classical.choose I.1

theorem hom_inv_id (f : X ‚ü∂ Y) [I : IsIso f] : f ‚â´ inv f = ùüô X :=
  (Classical.choose_spec I.1).left

theorem inv_hom_id (f : X ‚ü∂ Y) [I : IsIso f] : inv f ‚â´ f = ùüô Y :=
  (Classical.choose_spec I.1).right

open Iso in
noncomputable def asIso (f : X ‚ü∂ Y) [IsIso f] : X ‚âÖ Y :=
  ‚ü®f, inv f, hom_inv_id f, inv_hom_id f‚ü©

def Iso.symm (I : X ‚âÖ Y) : Y ‚âÖ X where
  hom := I.inv
  inv := I.hom
  hom_inv_id := I.inv_hom_id
  inv_hom_id := I.hom_inv_id

instance IsIso.of_iso (f : X ‚âÖ Y) : IsIso f.hom := ‚ü®‚ü®f.inv, by sorry‚ü©‚ü©
-- instance IsIso.of_iso (f : X ‚âÖ Y) : IsIso f.hom := ‚ü®‚ü®f.inv, by simp‚ü©‚ü©

instance IsIso.of_iso_inv (f : X ‚âÖ Y) : IsIso f.inv := IsIso.of_iso f.symm

end IsoStuff

section FunctorStuff

structure Prefunctor (V : Type u‚ÇÅ) [Quiver.{v‚ÇÅ} V] (W : Type u‚ÇÇ) [Quiver.{v‚ÇÇ} W] where
  /-- The action of a (pre)functor on vertices/objects. -/
  obj : V ‚Üí W
  /-- The action of a (pre)functor on edges/arrows/morphisms. -/
  map : ‚àÄ {X Y : V}, (X ‚ü∂ Y) ‚Üí (obj X ‚ü∂ obj Y)

namespace CategoryTheory

structure Functor (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [Category.{v‚ÇÇ} D]
    extends Prefunctor C D : Type max v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ where
  /-- A functor preserves identity morphisms. -/
  map_id : ‚àÄ X : C, map (ùüô X) = ùüô (obj X) -- := by aesop_cat
  /-- A functor preserves composition. -/
  map_comp : ‚àÄ {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), map (f ‚â´ g) = map f ‚â´ map g -- := by aesop_cat

infixr:26 " ‚•§ " => Functor -- type as \func
-- scoped [CategoryTheory] infixr:26 " ‚•§ " => Functor -- type as \func

variable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D]
  {E : Type u‚ÇÉ} [Category.{v‚ÇÉ} E]

protected def Functor.id : C ‚•§ C where
  obj X := X
  map f := f
  map_id := by sorry
  map_comp := by sorry

/-- Notation for the identity functor on a category. -/
notation "ùü≠" => Functor.id -- Type this as `\sb1`
-- scoped [CategoryTheory] notation "ùü≠" => Functor.id -- Type this as `\sb1`

def comp (F : C ‚•§ D) (G : D ‚•§ E) : C ‚•§ E where
  obj X := G.obj (F.obj X)
  map f := G.map (F.map f)
  map_comp := sorry -- by intros; dsimp; rw [F.map_comp, G.map_comp]
  map_id := sorry

infixr:80 " ‚ãô " => Functor.comp
-- scoped [CategoryTheory] infixr:80 " ‚ãô " => Functor.comp

abbrev LargeCategory (C : Type (u + 1)) : Type (u + 1) := Category.{u} C

instance types : LargeCategory (Type u)
    where
  Hom a b := a ‚Üí b
  id a := id
  comp f g := g ‚àò f
  comp_id := by sorry
  id_comp := by sorry
  assoc := by sorry

abbrev SmallCategory (C : Type u) : Type (u + 1) := Category.{u} C

open Preorder in
instance (priority := 100) smallCategory (Œ± : Type u) [Preorder Œ±] : SmallCategory Œ± where
  Hom U V := ULift (PLift (U ‚â§ V))
  id X := ‚ü®‚ü®le_refl X‚ü©‚ü©
  comp f g := ‚ü®‚ü®le_trans _ _ _ f.down.down g.down.down‚ü©‚ü©
  id_comp := by sorry
  comp_id := by sorry
  assoc := by sorry

end CategoryTheory

namespace CategoryTheory.Functor

open Opposite

variable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C]
variable {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D]

protected def op (F : C ‚•§ D) : C·µí·µñ ‚•§ D·µí·µñ where
  obj X := op (F.obj (unop X))
  map f := (F.map f.unop).op
  map_id := by sorry
  map_comp := by sorry

protected def rightOp (F : C·µí·µñ ‚•§ D) : C ‚•§ D·µí·µñ where
  obj X := op (F.obj (op X))
  map f := (F.map f.op).op
  map_id := by sorry
  map_comp := by sorry

end CategoryTheory.Functor

variable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C]
variable {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D]

class CategoryTheory.Functor.Faithful (F : C ‚•§ D) : Prop where
  /-- `F.map` is injective for each `X Y : C`. -/
  map_injective : ‚àÄ {X Y : C}, Function.Injective (F.map : (X ‚ü∂ Y) ‚Üí (F.obj X ‚ü∂ F.obj Y)) -- := by aesop_cat

end FunctorStuff

section NatTransStuff

variable {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D]

namespace CategoryTheory

structure NatTrans (F G : C ‚•§ D) : Type max u‚ÇÅ v‚ÇÇ where
  /-- The component of a natural transformation. -/
  app : ‚àÄ X : C, F.obj X ‚ü∂ G.obj X
  /-- The naturality square for a given morphism. -/
  naturality : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y), F.map f ‚â´ app Y = app X ‚â´ G.map f -- := by aesop_cat

end CategoryTheory

namespace NatTrans

protected def id (F : C ‚•§ D) : NatTrans F F where
  app X := ùüô (F.obj X)
  naturality := by sorry

end NatTrans

namespace CategoryTheory.Functor

variable {F G H I : C ‚•§ D}

/-- `vcomp Œ± Œ≤` is the vertical compositions of natural transformations. -/
def vcomp (Œ± : NatTrans F G) (Œ≤ : NatTrans G H) : NatTrans F H where
  app X := Œ±.app X ‚â´ Œ≤.app X
  naturality := sorry

end CategoryTheory.Functor

open NatTrans Category CategoryTheory.Functor

instance Functor.category : Category.{max u‚ÇÅ v‚ÇÇ} (C ‚•§ D) where
  Hom F G := NatTrans F G
  id F := NatTrans.id F
  comp Œ± Œ≤ := vcomp Œ± Œ≤
  id_comp := by sorry
  comp_id := by sorry
  assoc := by sorry

namespace NatTrans

open Opposite

variable {F G H : C ‚•§ D}

protected def op (Œ± : F ‚ü∂ G) : G.op ‚ü∂ F.op where
  app X := (Œ±.app (unop X)).op
  naturality X Y f := sorry -- Quiver.Hom.unop_inj (by simp)


end NatTrans

namespace CategoryTheory.NatIso

variable {C : Type u‚ÇÅ} {D : Type u‚ÇÇ} [Category.{v‚ÇÅ} C] [Category.{v‚ÇÇ} D]
variable {F G : C ‚•§ D}

protected def op (Œ± : F ‚âÖ G) : G.op ‚âÖ F.op where
  hom := NatTrans.op Œ±.hom
  inv := NatTrans.op Œ±.inv
  hom_inv_id := sorry -- by ext; dsimp; rw [‚Üê op_comp]; rw [Œ±.inv_hom_id_app]; rfl
  inv_hom_id := sorry -- by ext; dsimp; rw [‚Üê op_comp]; rw [Œ±.hom_inv_id_app]; rfl

def ofComponents (app : ‚àÄ X : C, F.obj X ‚âÖ G.obj X)
    (naturality : ‚àÄ {X Y : C} (f : X ‚ü∂ Y),
      F.map f ‚â´ (app Y).hom = (app X).hom ‚â´ G.map f) : -- := by aesop_cat) :
    F ‚âÖ G where
  hom :=
    { app := fun X => (app X).hom
      naturality := sorry}
  inv :=
    { app := fun X => (app X).inv,
      naturality := fun X Y f => by sorry }
        -- have h := congrArg (fun f => (app X).inv ‚â´ f ‚â´ (app Y).inv) (naturality f).symm
        -- simp only [Iso.inv_hom_id_assoc, Iso.hom_inv_id, assoc, comp_id, cancel_mono] at h
        -- exact h }
  hom_inv_id := sorry
  inv_hom_id := sorry

end CategoryTheory.NatIso

end NatTransStuff

section SetStuff

def Set (Œ± : Type u) := Œ± ‚Üí Prop

def setOf {Œ± : Type u} (p : Œ± ‚Üí Prop) : Set Œ± := p

namespace Set

protected def Mem (a : Œ±) (s : Set Œ±) : Prop :=
  s a

open Lean in
syntax extBinder := binderIdent ((" : " term) <|> binderPred)?
syntax "{" extBinder " | " term "}" : term

macro_rules
  | `({ $x:ident | $p }) => `(setOf fun $x:ident ‚Ü¶ $p)
  | `({ $x:ident : $t | $p }) => `(setOf fun $x:ident : $t ‚Ü¶ $p)
  | `({ $x:ident $b:binderPred | $p }) =>
    `(setOf fun $x:ident ‚Ü¶ satisfies_binder_pred% $x $b ‚àß $p)

instance : Membership Œ± (Set Œ±) :=
  ‚ü®Set.Mem‚ü©

def univ : Set Œ± := {_a | True}

protected def inter (s‚ÇÅ s‚ÇÇ : Set Œ±) : Set Œ± := {a | a ‚àà s‚ÇÅ ‚àß a ‚àà s‚ÇÇ}

instance : Inter (Set Œ±) := ‚ü®Set.inter‚ü©

class SupSet (Œ± : Type u) where
  sSup : Set Œ± ‚Üí Œ±

instance : SupSet (Set Œ±) :=
  ‚ü®fun s => { a | ‚àÉ t ‚àà s, a ‚àà t }‚ü©

open SupSet in
def sUnion (S : Set (Set Œ±)) : Set Œ± :=
  sSup S

/-- Notation for `Set.sUnion`. Union of a set of sets. -/
prefix:110 "‚ãÉ‚ÇÄ " => sUnion

def preimage (f : Œ± ‚Üí Œ≤) (s : Set Œ≤) : Set Œ± := {x | f x ‚àà s}

/-- `f ‚Åª¬π' t` denotes the preimage of `t : Set Œ≤` under the function `f : Œ± ‚Üí Œ≤`. -/
infixl:80 " ‚Åª¬π' " => preimage

end Set

section OrderStuff

class PartialOrder (Œ± : Type u) extends Preorder Œ± where
  le_antisymm : ‚àÄ a b : Œ±, a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b

variable {Œ± : Type u} [Preorder Œ±]

theorem le_refl : ‚àÄ a : Œ±, a ‚â§ a :=
  Preorder.le_refl

theorem le_rfl {a : Œ±} : a ‚â§ a :=
  le_refl a

theorem le_trans : ‚àÄ {a b c : Œ±}, a ‚â§ b ‚Üí b ‚â§ c ‚Üí a ‚â§ c :=
  Preorder.le_trans _ _ _

theorem lt_iff_le_not_le : ‚àÄ {a b : Œ±}, a < b ‚Üî a ‚â§ b ‚àß ¬¨b ‚â§ a :=
  Preorder.lt_iff_le_not_le _ _

variable {Œ± : Type u} [PartialOrder Œ±] in
theorem le_antisymm : ‚àÄ {a b : Œ±}, a ‚â§ b ‚Üí b ‚â§ a ‚Üí a = b :=
  PartialOrder.le_antisymm _ _

abbrev Preorder.lift {Œ± Œ≤} [Preorder Œ≤] (f : Œ± ‚Üí Œ≤) : Preorder Œ± where
  le x y := f x ‚â§ f y
  le_refl _ := le_rfl
  le_trans _ _ _ := _root_.le_trans
  lt x y := f x < f y
  lt_iff_le_not_le _ _ := _root_.lt_iff_le_not_le

abbrev PartialOrder.lift {Œ± Œ≤} [PartialOrder Œ≤] (f : Œ± ‚Üí Œ≤) (inj : Function.Injective f) : PartialOrder Œ± :=
  { Preorder.lift f with le_antisymm := fun _ _ h‚ÇÅ h‚ÇÇ ‚Ü¶ inj sorry }
  -- { Preorder.lift f with le_antisymm := fun _ _ h‚ÇÅ h‚ÇÇ ‚Ü¶ inj (le_antisymm h‚ÇÅ h‚ÇÇ) }

end OrderStuff

end SetStuff

section SetLikeStuff

class SetLike (A : Type*) (B : outParam <| Type*) where
  /-- The coercion from a term of a `SetLike` to its corresponding `Set`. -/
  protected coe : A ‚Üí Set B
  /-- The coercion from a term of a `SetLike` to its corresponding `Set` is injective. -/
  protected coe_injective' : Function.Injective coe

attribute [coe] SetLike.coe

namespace SetLike

variable {A : Type*} {B : Type*} [i : SetLike A B]

instance : CoeTC A (Set B) where coe := SetLike.coe

instance (priority := 100) instMembership : Membership B A :=
  ‚ü®fun x p => x ‚àà (p : Set B)‚ü©

instance (priority := 100) : CoeSort A (Type _) :=
  ‚ü®fun p => { x : B // x ‚àà p }‚ü©

theorem coe_injective : Function.Injective (SetLike.coe : A ‚Üí Set B) := fun _ _ h =>
  SetLike.coe_injective' h

instance (priority := 100) instPartialOrder : PartialOrder A :=
  { PartialOrder.lift (SetLike.coe : A ‚Üí Set B) coe_injective with
    le := fun H K => ‚àÄ ‚¶Éx‚¶Ñ, x ‚àà H ‚Üí x ‚àà K }

end SetLike

end SetLikeStuff

section ConcreteCategoryStuff

class ConcreteCategory (C : Type u) [Category.{v} C] where
  /-- We have a functor to Type -/
  protected forget : C ‚•§ Type w
  /-- That functor is faithful -/
  [forget_faithful : forget.Faithful]

attribute [reducible] ConcreteCategory.forget
attribute [instance] ConcreteCategory.forget_faithful

/-- The forgetful functor from a concrete category to `Type u`. -/
abbrev forget (C : Type u) [Category.{v} C] [ConcreteCategory.{w} C] : C ‚•§ Type w :=
  ConcreteCategory.forget

-- this is reducible because we want `forget (Type u)` to unfold to `ùü≠ _`
@[instance] abbrev ConcreteCategory.types : ConcreteCategory.{u, u, u+1} (Type u) where
  forget := ùü≠ _

def ConcreteCategory.hasCoeToSort (C : Type u) [Category.{v} C] [ConcreteCategory.{w} C] :
    CoeSort C (Type w) where
  coe := fun X => (forget C).obj X

attribute [local instance] ConcreteCategory.hasCoeToSort

variable {C : Type u} [Category.{v} C] [ConcreteCategory.{w} C]

abbrev ConcreteCategory.instFunLike {X Y : C} : FunLike (X ‚ü∂ Y) X Y where
  coe f := (forget C).map f
  coe_injective' _ _ h := (forget C).map_injective h

attribute [local instance] ConcreteCategory.instFunLike

end ConcreteCategoryStuff

section TopologicalSpaceStuff

open Set

/-- A topology on `X`. -/
class TopologicalSpace (X : Type u) where
  /-- A predicate saying that a set is an open set. Use `IsOpen` in the root namespace instead. -/
  protected IsOpen : Set X ‚Üí Prop
  /-- The set representing the whole space is an open set.
  Use `isOpen_univ` in the root namespace instead. -/
  protected isOpen_univ : IsOpen univ
  /-- The intersection of two open sets is an open set. Use `IsOpen.inter` instead. -/
  protected isOpen_inter : ‚àÄ s t, IsOpen s ‚Üí IsOpen t ‚Üí IsOpen (s ‚à© t)
  /-- The union of a family of open sets is an open set.
  Use `isOpen_sUnion` in the root namespace instead. -/
  protected isOpen_sUnion : ‚àÄ s, (‚àÄ t ‚àà s, IsOpen t) ‚Üí IsOpen (‚ãÉ‚ÇÄ s)

variable [TopologicalSpace X]

def IsOpen : Set X ‚Üí Prop := TopologicalSpace.IsOpen

variable (Œ± : Type u) [TopologicalSpace Œ±]

structure Opens where
  /-- The underlying set of a bundled `TopologicalSpace.Opens` object. -/
  carrier : Set Œ±
  /-- The `TopologicalSpace.Opens.carrier _` is an open set. -/
  is_open' : IsOpen carrier

variable {X : Type u} {Y : Type v}

variable [TopologicalSpace X] [TopologicalSpace Y] {s t : Set X}

instance : SetLike (Opens X) X where
  coe := Opens.carrier
  coe_injective' := fun ‚ü®_, _‚ü© ‚ü®_, _‚ü© _ => by congr

structure Continuous (f : X ‚Üí Y) : Prop where
  /-- The preimage of an open set under a continuous function is an open set. Use `IsOpen.preimage`
  instead. -/
  isOpen_preimage : ‚àÄ s, IsOpen s ‚Üí IsOpen (f ‚Åª¬π' s)

structure ContinuousMap (Œ± : Type u‚ÇÅ) (Œ≤ : Type u‚ÇÇ) [TopologicalSpace Œ±] [TopologicalSpace Œ≤] where
  /-- The function `Œ± ‚Üí Œ≤` -/
  protected toFun : Œ± ‚Üí Œ≤
  /-- Proposition that `toFun` is continuous -/
  protected continuous_toFun : Continuous toFun -- := by continuity

notation "C(" Œ± ", " Œ≤ ")" => ContinuousMap Œ± Œ≤

variable {Œ± Œ≤ Œ≥ : Type u} [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [TopologicalSpace Œ≥]

instance funLike : FunLike C(Œ±, Œ≤) Œ± Œ≤ where
  coe := ContinuousMap.toFun
  coe_injective' f g h := by cases f; cases g; congr

namespace ContinuousMap

protected def id : C(Œ±, Œ±) where
  toFun := id
  continuous_toFun := sorry

def comp (f : C(Œ≤, Œ≥)) (g : C(Œ±, Œ≤)) : C(Œ±, Œ≥) where
  toFun := f ‚àò g
  continuous_toFun := sorry

theorem coe_injective : @Function.Injective C(Œ±, Œ≤) (Œ± ‚Üí Œ≤) DFunLike.coe := fun f g h => by
  cases f; cases g; congr

end ContinuousMap

end TopologicalSpaceStuff

section BundledStuff

structure Bundled (c : Type u ‚Üí Type v) : Type max (u + 1) v where
  /-- The underlying type of the bundled type -/
  Œ± : Type u
  /-- The corresponding instance of the bundled type class -/
  str : c Œ± := by infer_instance

variable {c : Type u ‚Üí Type u} (hom : ‚àÄ ‚¶ÉŒ± Œ≤ : Type u‚¶Ñ (_ : c Œ±) (_ : c Œ≤), Type u)

instance Bundled.coeSort : CoeSort (Bundled c) (Type u) :=
  ‚ü®Bundled.Œ±‚ü©

structure BundledHom where
  /-- the underlying map of a bundled morphism -/
  toFun : ‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), hom IŒ± IŒ≤ ‚Üí Œ± ‚Üí Œ≤
  /-- the identity as a bundled morphism -/
  id : ‚àÄ {Œ± : Type u} (I : c Œ±), hom I I
  /-- composition of bundled morphisms -/
  comp : ‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥), hom IŒ≤ IŒ≥ ‚Üí hom IŒ± IŒ≤ ‚Üí hom IŒ± IŒ≥
  /-- a bundled morphism is determined by the underlying map -/
  hom_ext : ‚àÄ {Œ± Œ≤ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤), Function.Injective (toFun IŒ± IŒ≤) -- := by aesop_cat
  /-- compatibility with identities -/
  id_toFun : ‚àÄ {Œ± : Type u} (I : c Œ±), toFun I I (id I) = _root_.id -- := by aesop_cat
  /-- compatibility with the composition -/
  comp_toFun :
    ‚àÄ {Œ± Œ≤ Œ≥ : Type u} (IŒ± : c Œ±) (IŒ≤ : c Œ≤) (IŒ≥ : c Œ≥) (f : hom IŒ± IŒ≤) (g : hom IŒ≤ IŒ≥),
      toFun IŒ± IŒ≥ (comp IŒ± IŒ≤ IŒ≥ g f) = toFun IŒ≤ IŒ≥ g ‚àò toFun IŒ± IŒ≤ f -- := by aesop_cat

attribute [class] BundledHom

variable [ùíû : BundledHom hom]

set_option synthInstance.checkSynthOrder false in
instance CategoryTheory.BundledHom.category : Category (Bundled c) where
  Hom := fun X Y => hom X.str Y.str
  id := fun X => BundledHom.id ùíû (Œ± := X) X.str
  comp := fun {X Y Z} f g => BundledHom.comp ùíû (Œ± := X) (Œ≤ := Y) (Œ≥ := Z) X.str Y.str Z.str g f
  comp_id _ := sorry --by apply ùíû.hom_ext; simp
  assoc _ _ _ := sorry -- by apply ùíû.hom_ext; aesop_cat
  id_comp _ := sorry -- by apply ùíû.hom_ext; simp

instance CategoryTheory.BundledHom.concreteCategory : ConcreteCategory.{u} (Bundled c) where
  forget :=
    { obj := fun X => X
      map := @fun X Y f => ùíû.toFun X.str Y.str f
      map_id := fun X => ùíû.id_toFun X.str
      map_comp := fun f g => by dsimp; erw [ùíû.comp_toFun];rfl }
  forget_faithful := { map_injective := by (intros; apply ùíû.hom_ext) }

def TopCat : Type (u + 1) :=
  Bundled TopologicalSpace

instance bundledHom : BundledHom @ContinuousMap :=
  ‚ü®@ContinuousMap.toFun, @ContinuousMap.id, @ContinuousMap.comp, @ContinuousMap.coe_injective,
    fun _ => rfl, fun _ _ _ _ _ => rfl‚ü©

deriving instance LargeCategory for TopCat

instance concreteCategory : ConcreteCategory TopCat := by
  dsimp [TopCat]
  infer_instance

instance instCoeSortTopCatType : CoeSort TopCat (Type*) :=
  Bundled.coeSort

instance topologicalSpaceUnbundled (x : TopCat) : TopologicalSpace x :=
  x.str

end BundledStuff

section LocallyRingedSpaceStuff

variable (C : Type u) [Category.{v} C]

def TopCat.Presheaf (X : TopCat.{w}) : Type max u v w :=
  (Opens X)·µí·µñ ‚•§ C

structure PresheafedSpace where
  carrier : TopCat
  protected presheaf : carrier.Presheaf C

structure SheafedSpace extends PresheafedSpace C where
  /-- A sheafed space is presheafed space which happens to be sheaf. -/
  IsSheaf : presheaf.IsSheaf

structure LocallyRingedSpace extends SheafedSpace CommRingCat.{u} where
  /-- Stalks of a locally ringed space are local rings. -/
  localRing : ‚àÄ x, LocalRing (presheaf.stalk x)

def Œì : LocallyRingedSpace.{u}·µí·µñ ‚•§ CommRingCat.{u} :=
  forgetToSheafedSpace.op ‚ãô SheafedSpace.Œì

def SpecŒìIdentity : Spec.toLocallyRingedSpace.rightOp ‚ãô Œì ‚âÖ ùü≠ _ :=
  Iso.symm <| NatIso.ofComponents.{u,u,u+1,u+1} (fun R =>
    -- Porting note: In Lean3, this `IsIso` is synthesized automatically
    letI : IsIso (toSpecŒì R) := sorry -- StructureSheaf.isIso_to_global _
    asIso (toSpecŒì R)) fun {X Y} f => sorry -- by convert Spec_Œì_naturality (R := X) (S := Y) f

def locallyRingedSpaceAdjunction : Œì.rightOp ‚ä£ Spec.toLocallyRingedSpace.{u} :=
  Adjunction.mkOfUnitCounit
    { unit := identityToŒìSpec
      counit := (NatIso.op SpecŒìIdentity).inv
      left_triangle := by
        ext X; erw [Category.id_comp]
        exact congr_arg Quiver.Hom.op (left_triangle X)
      right_triangle := by
        ext R : 2
        -- Porting note: a little bit hand holding
        change identityToŒìSpec.app _ ‚â´ ùüô _ ‚â´ Spec.toLocallyRingedSpace.map _ =
          ùüô _
        simp_rw [Category.id_comp, show (NatIso.op SpecŒìIdentity).inv.app R =
          (SpecŒìIdentity.inv.app R.unop).op from rfl]
        exact right_triangle R.unop
        }


end LocallyRingedSpaceStuff

section BadStuff

instance isIso_locallyRingedSpaceAdjunction_counit :
      IsIso locallyRingedSpaceAdjunction.counit :=
  IsIso.of_iso_inv (NatIso.op SpecŒìIdentity)

end BadStuff

